// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LicenseManagerLinuxSubscriptionsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// A filter object that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct Filter: Swift.Equatable {
        /// The type of name to filter by.
        public var name: Swift.String?
        /// An operator for filtering results.
        public var `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator?
        /// One or more values for the name to filter by.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            `operator`: LicenseManagerLinuxSubscriptionsClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension GetServiceSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/GetServiceSettings"
    }
}

public struct GetServiceSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetServiceSettingsInputBody: Swift.Equatable {
}

extension GetServiceSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.homeRegions = output.homeRegions
            self.linuxSubscriptionsDiscovery = output.linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = output.linuxSubscriptionsDiscoverySettings
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.homeRegions = nil
            self.linuxSubscriptionsDiscovery = nil
            self.linuxSubscriptionsDiscoverySettings = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetServiceSettingsOutput: Swift.Equatable {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// Lists the settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String:Swift.String]?

    public init(
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String:Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetServiceSettingsOutputBody: Swift.Equatable {
    let linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    let linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    let status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    let statusMessage: [Swift.String:Swift.String]?
    let homeRegions: [Swift.String]?
}

extension GetServiceSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegions = "HomeRegions"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxSubscriptionsDiscoveryDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery.self, forKey: .linuxSubscriptionsDiscovery)
        linuxSubscriptionsDiscovery = linuxSubscriptionsDiscoveryDecoded
        let linuxSubscriptionsDiscoverySettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.self, forKey: .linuxSubscriptionsDiscoverySettings)
        linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .statusMessage)
        var statusMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let statusMessageContainer = statusMessageContainer {
            statusMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in statusMessageContainer {
                if let string0 = string0 {
                    statusMessageDecoded0?[key0] = string0
                }
            }
        }
        statusMessage = statusMessageDecoded0
        let homeRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .homeRegions)
        var homeRegionsDecoded0:[Swift.String]? = nil
        if let homeRegionsContainer = homeRegionsContainer {
            homeRegionsDecoded0 = [Swift.String]()
            for string0 in homeRegionsContainer {
                if let string0 = string0 {
                    homeRegionsDecoded0?.append(string0)
                }
            }
        }
        homeRegions = homeRegionsDecoded0
    }
}

enum GetServiceSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID = "AccountID"
        case amiId = "AmiId"
        case instanceID = "InstanceID"
        case instanceType = "InstanceType"
        case lastUpdatedTime = "LastUpdatedTime"
        case productCode = "ProductCode"
        case region = "Region"
        case status = "Status"
        case subscriptionName = "SubscriptionName"
        case usageOperation = "UsageOperation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let instanceID = self.instanceID {
            try encodeContainer.encode(instanceID, forKey: .instanceID)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let productCode = productCode {
            var productCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productCode)
            for string0 in productCode {
                try productCodeContainer.encode(string0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let usageOperation = self.usageOperation {
            try encodeContainer.encode(usageOperation, forKey: .usageOperation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let instanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceID)
        instanceID = instanceIDDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let usageOperationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
        let productCodeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .productCode)
        var productCodeDecoded0:[Swift.String]? = nil
        if let productCodeContainer = productCodeContainer {
            productCodeDecoded0 = [Swift.String]()
            for string0 in productCodeContainer {
                if let string0 = string0 {
                    productCodeDecoded0?.append(string0)
                }
            }
        }
        productCode = productCodeDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Details discovered information about a running instance using Linux subscriptions.
    public struct Instance: Swift.Equatable {
        /// The account ID which owns the instance.
        public var accountID: Swift.String?
        /// The AMI ID used to launch the instance.
        public var amiId: Swift.String?
        /// The instance ID of the resource.
        public var instanceID: Swift.String?
        /// The instance type of the resource.
        public var instanceType: Swift.String?
        /// The time in which the last discovery updated the instance details.
        public var lastUpdatedTime: Swift.String?
        /// The product code for the instance. For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide .
        public var productCode: [Swift.String]?
        /// The Region the instance is running in.
        public var region: Swift.String?
        /// The status of the instance.
        public var status: Swift.String?
        /// The name of the subscription being used by the instance.
        public var subscriptionName: Swift.String?
        /// The usage operation of the instance. For more information, see For more information, see [Usage operation values](https://docs.aws.amazon.com/license-manager/latest/userguide/linux-subscriptions-usage-operation.html) in the License Manager User Guide.
        public var usageOperation: Swift.String?

        public init(
            accountID: Swift.String? = nil,
            amiId: Swift.String? = nil,
            instanceID: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            productCode: [Swift.String]? = nil,
            region: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            usageOperation: Swift.String? = nil
        )
        {
            self.accountID = accountID
            self.amiId = amiId
            self.instanceID = instanceID
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.productCode = productCode
            self.region = region
            self.status = status
            self.subscriptionName = subscriptionName
            self.usageOperation = usageOperation
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum LinuxSubscriptionsDiscovery: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Disabled LinuxSubscriptionsDiscovery
        case disabled
        /// Enabled LinuxSubscriptionsDiscovery
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LinuxSubscriptionsDiscovery] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LinuxSubscriptionsDiscovery(rawValue: rawValue) ?? LinuxSubscriptionsDiscovery.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationIntegration = "OrganizationIntegration"
        case sourceRegions = "SourceRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationIntegration = self.organizationIntegration {
            try encodeContainer.encode(organizationIntegration.rawValue, forKey: .organizationIntegration)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for string0 in sourceRegions {
                try sourceRegionsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[Swift.String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [Swift.String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let organizationIntegrationDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration.self, forKey: .organizationIntegration)
        organizationIntegration = organizationIntegrationDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// Lists the settings defined for discovering Linux subscriptions.
    public struct LinuxSubscriptionsDiscoverySettings: Swift.Equatable {
        /// Details if you have enabled resource discovery across your accounts in Organizations.
        /// This member is required.
        public var organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration?
        /// The Regions in which to discover data for Linux subscriptions.
        /// This member is required.
        public var sourceRegions: [Swift.String]?

        public init(
            organizationIntegration: LicenseManagerLinuxSubscriptionsClientTypes.OrganizationIntegration? = nil,
            sourceRegions: [Swift.String]? = nil
        )
        {
            self.organizationIntegration = organizationIntegration
            self.sourceRegions = sourceRegions
        }
    }

}

extension ListLinuxSubscriptionInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLinuxSubscriptionInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/ListLinuxSubscriptionInstances"
    }
}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionInstancesInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of AmiID with an optional operator to see subscriptions that match, partially match, or don't match a certain Amazon Machine Image (AMI) ID. The valid names for this filter are:
    ///
    /// * AmiID
    ///
    /// * InstanceID
    ///
    /// * AccountID
    ///
    /// * Status
    ///
    /// * Region
    ///
    /// * UsageOperation
    ///
    /// * ProductCode
    ///
    /// * InstanceType
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLinuxSubscriptionInstancesInputBody: Swift.Equatable {
    let filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLinuxSubscriptionInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLinuxSubscriptionInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListLinuxSubscriptionInstancesOutput: Swift.Equatable {
    /// An array that contains instance objects.
    public var instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListLinuxSubscriptionInstancesOutputBody: Swift.Equatable {
    let instances: [LicenseManagerLinuxSubscriptionsClientTypes.Instance]?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Instance?].self, forKey: .instances)
        var instancesDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Instance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Instance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLinuxSubscriptionInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLinuxSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLinuxSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/ListLinuxSubscriptions"
    }
}

/// NextToken length limit is half of ddb accepted limit. Increase this limit if parameters in request increases.
public struct ListLinuxSubscriptionsInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify. For example, you can filter by the name of Subscription with an optional operator to see subscriptions that match, partially match, or don't match a certain subscription's name. The valid names for this filter are:
    ///
    /// * Subscription
    ///
    ///
    /// The valid Operators for this filter are:
    ///
    /// * contains
    ///
    /// * equals
    ///
    /// * Notequal
    public var filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLinuxSubscriptionsInputBody: Swift.Equatable {
    let filters: [LicenseManagerLinuxSubscriptionsClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLinuxSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLinuxSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

public struct ListLinuxSubscriptionsOutput: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// An array that contains subscription objects.
    public var subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListLinuxSubscriptionsOutputBody: Swift.Equatable {
    let subscriptions: [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]?
    let nextToken: Swift.String?
}

extension ListLinuxSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([LicenseManagerLinuxSubscriptionsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[LicenseManagerLinuxSubscriptionsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [LicenseManagerLinuxSubscriptionsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLinuxSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Contains operator
        case contains
        /// Equal operator
        case equal
        /// Not equal operator
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .contains,
                .equal,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum OrganizationIntegration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Disabled OrganizationIntegration
        case disabled
        /// Enabled OrganizationIntegration
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationIntegration] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationIntegration(rawValue: rawValue) ?? OrganizationIntegration.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Completed status
        case completed
        /// Failed status
        case failed
        /// InProgress status
        case inprogress
        /// Successful status
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCount = "InstanceCount"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
    }
}

extension LicenseManagerLinuxSubscriptionsClientTypes {
    /// An object which details a discovered Linux subscription.
    public struct Subscription: Swift.Equatable {
        /// The total amount of running instances using this subscription.
        public var instanceCount: Swift.Int?
        /// The name of the subscription.
        public var name: Swift.String?
        /// The type of subscription. The type can be subscription-included with Amazon EC2, Bring Your Own Subscription model (BYOS), or from the Amazon Web Services Marketplace. Certain subscriptions may use licensing from the Amazon Web Services Marketplace as well as OS licensing from Amazon EC2 or BYOS.
        public var type: Swift.String?

        public init(
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateServiceSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUpdate = "AllowUpdate"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowUpdate = self.allowUpdate {
            try encodeContainer.encode(allowUpdate, forKey: .allowUpdate)
        }
        if let linuxSubscriptionsDiscovery = self.linuxSubscriptionsDiscovery {
            try encodeContainer.encode(linuxSubscriptionsDiscovery.rawValue, forKey: .linuxSubscriptionsDiscovery)
        }
        if let linuxSubscriptionsDiscoverySettings = self.linuxSubscriptionsDiscoverySettings {
            try encodeContainer.encode(linuxSubscriptionsDiscoverySettings, forKey: .linuxSubscriptionsDiscoverySettings)
        }
    }
}

extension UpdateServiceSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/subscription/UpdateServiceSettings"
    }
}

public struct UpdateServiceSettingsInput: Swift.Equatable {
    /// Describes if updates are allowed to the service settings for Linux subscriptions. If you allow updates, you can aggregate Linux subscription data in more than one home Region.
    public var allowUpdate: Swift.Bool?
    /// Describes if the discovery of Linux subscriptions is enabled.
    /// This member is required.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    /// This member is required.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?

    public init(
        allowUpdate: Swift.Bool? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil
    )
    {
        self.allowUpdate = allowUpdate
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
    }
}

struct UpdateServiceSettingsInputBody: Swift.Equatable {
    let linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    let linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    let allowUpdate: Swift.Bool?
}

extension UpdateServiceSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowUpdate = "AllowUpdate"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxSubscriptionsDiscoveryDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery.self, forKey: .linuxSubscriptionsDiscovery)
        linuxSubscriptionsDiscovery = linuxSubscriptionsDiscoveryDecoded
        let linuxSubscriptionsDiscoverySettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.self, forKey: .linuxSubscriptionsDiscoverySettings)
        linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettingsDecoded
        let allowUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowUpdate)
        allowUpdate = allowUpdateDecoded
    }
}

extension UpdateServiceSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.homeRegions = output.homeRegions
            self.linuxSubscriptionsDiscovery = output.linuxSubscriptionsDiscovery
            self.linuxSubscriptionsDiscoverySettings = output.linuxSubscriptionsDiscoverySettings
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.homeRegions = nil
            self.linuxSubscriptionsDiscovery = nil
            self.linuxSubscriptionsDiscoverySettings = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct UpdateServiceSettingsOutput: Swift.Equatable {
    /// The Region in which License Manager displays the aggregated data for Linux subscriptions.
    public var homeRegions: [Swift.String]?
    /// Lists if discovery has been enabled for Linux subscriptions.
    public var linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    /// The settings defined for Linux subscriptions discovery. The settings include if Organizations integration has been enabled, and which Regions data will be aggregated from.
    public var linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    /// Indicates the status of Linux subscriptions settings being applied.
    public var status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    /// A message which details the Linux subscriptions service settings current status.
    public var statusMessage: [Swift.String:Swift.String]?

    public init(
        homeRegions: [Swift.String]? = nil,
        linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery? = nil,
        linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings? = nil,
        status: LicenseManagerLinuxSubscriptionsClientTypes.Status? = nil,
        statusMessage: [Swift.String:Swift.String]? = nil
    )
    {
        self.homeRegions = homeRegions
        self.linuxSubscriptionsDiscovery = linuxSubscriptionsDiscovery
        self.linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettings
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct UpdateServiceSettingsOutputBody: Swift.Equatable {
    let linuxSubscriptionsDiscovery: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery?
    let linuxSubscriptionsDiscoverySettings: LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings?
    let status: LicenseManagerLinuxSubscriptionsClientTypes.Status?
    let statusMessage: [Swift.String:Swift.String]?
    let homeRegions: [Swift.String]?
}

extension UpdateServiceSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegions = "HomeRegions"
        case linuxSubscriptionsDiscovery = "LinuxSubscriptionsDiscovery"
        case linuxSubscriptionsDiscoverySettings = "LinuxSubscriptionsDiscoverySettings"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxSubscriptionsDiscoveryDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscovery.self, forKey: .linuxSubscriptionsDiscovery)
        linuxSubscriptionsDiscovery = linuxSubscriptionsDiscoveryDecoded
        let linuxSubscriptionsDiscoverySettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.LinuxSubscriptionsDiscoverySettings.self, forKey: .linuxSubscriptionsDiscoverySettings)
        linuxSubscriptionsDiscoverySettings = linuxSubscriptionsDiscoverySettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerLinuxSubscriptionsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .statusMessage)
        var statusMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let statusMessageContainer = statusMessageContainer {
            statusMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in statusMessageContainer {
                if let string0 = string0 {
                    statusMessageDecoded0?[key0] = string0
                }
            }
        }
        statusMessage = statusMessageDecoded0
        let homeRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .homeRegions)
        var homeRegionsDecoded0:[Swift.String]? = nil
        if let homeRegionsContainer = homeRegionsContainer {
            homeRegionsDecoded0 = [Swift.String]()
            for string0 in homeRegionsContainer {
                if let string0 = string0 {
                    homeRegionsDecoded0?.append(string0)
                }
            }
        }
        homeRegions = homeRegionsDecoded0
    }
}

enum UpdateServiceSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
