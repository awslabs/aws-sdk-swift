//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension MediaStoreClientTypes {

    public enum MethodName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case `get`
        case head
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [MethodName] {
            return [
                .delete,
                .get,
                .head,
                .put
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaStoreClientTypes {

    public enum ContainerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerStatus] {
            return [
                .active,
                .creating,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaStoreClientTypes {

    /// This section describes operations that you can perform on an AWS Elemental MediaStore container.
    public struct Container: Swift.Sendable {
        /// The state of access logging on the container. This value is false by default, indicating that AWS Elemental MediaStore does not send access logs to Amazon CloudWatch Logs. When you enable access logging on the container, MediaStore changes this value to true, indicating that the service delivers access logs for objects stored in that container to CloudWatch Logs.
        public var accessLoggingEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the container. The ARN has the following format: arn:aws:::container/ For example: arn:aws:mediastore:us-west-2:111122223333:container/movies
        public var arn: Swift.String?
        /// Unix timestamp.
        public var creationTime: Foundation.Date?
        /// The DNS endpoint of the container. Use the endpoint to identify the specific container when sending requests to the data plane. The service assigns this value when the container is created. Once the value has been assigned, it does not change.
        public var endpoint: Swift.String?
        /// The name of the container.
        public var name: Swift.String?
        /// The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When the endpoint is available, the status changes to ACTIVE.
        public var status: MediaStoreClientTypes.ContainerStatus?

        public init(
            accessLoggingEnabled: Swift.Bool? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            endpoint: Swift.String? = nil,
            name: Swift.String? = nil,
            status: MediaStoreClientTypes.ContainerStatus? = nil
        )
        {
            self.accessLoggingEnabled = accessLoggingEnabled
            self.arn = arn
            self.creationTime = creationTime
            self.endpoint = endpoint
            self.name = name
            self.status = status
        }
    }
}

/// The container that you specified in the request already exists or is being updated.
public struct ContainerInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContainerInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MediaStoreClientTypes {

    public enum ContainerLevelMetrics: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerLevelMetrics] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The container that you specified in the request does not exist.
public struct ContainerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContainerNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MediaStoreClientTypes {

    /// A rule for a CORS policy. You can add up to 100 rules to a CORS policy. If more than one rule applies, the service uses the first applicable rule listed.
    public struct CorsRule: Swift.Sendable {
        /// Specifies which headers are allowed in a preflight OPTIONS request through the Access-Control-Request-Headers header. Each header name that is specified in Access-Control-Request-Headers must have a corresponding entry in the rule. Only the headers that were requested are sent back. This element can contain only one wildcard character (*).
        /// This member is required.
        public var allowedHeaders: [Swift.String]?
        /// Identifies an HTTP method that the origin that is specified in the rule is allowed to execute. Each CORS rule must contain at least one AllowedMethods and one AllowedOrigins element.
        public var allowedMethods: [MediaStoreClientTypes.MethodName]?
        /// One or more response headers that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). Each CORS rule must have at least one AllowedOrigins element. The string value can include only one wildcard character (*), for example, http://*.example.com. Additionally, you can specify only one wildcard character to allow cross-origin access for all origins.
        /// This member is required.
        public var allowedOrigins: [Swift.String]?
        /// One or more headers in the response that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). This element is optional for each rule.
        public var exposeHeaders: [Swift.String]?
        /// The time in seconds that your browser caches the preflight response for the specified resource. A CORS rule can have only one MaxAgeSeconds element.
        public var maxAgeSeconds: Swift.Int

        public init(
            allowedHeaders: [Swift.String]? = nil,
            allowedMethods: [MediaStoreClientTypes.MethodName]? = nil,
            allowedOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAgeSeconds: Swift.Int = 0
        )
        {
            self.allowedHeaders = allowedHeaders
            self.allowedMethods = allowedMethods
            self.allowedOrigins = allowedOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAgeSeconds = maxAgeSeconds
        }
    }
}

/// The CORS policy that you specified in the request does not exist.
public struct CorsPolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CorsPolicyNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A service limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MediaStoreClientTypes {

    /// A collection of tags associated with a container. Each tag consists of a key:value pair, which can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see [Tagging Resources in MediaStore](https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html).
    public struct Tag: Swift.Sendable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateContainerInput: Swift.Sendable {
    /// The name for the container. The name must be from 1 to 255 characters. Container names must be unique to your AWS account within a specific region. As an example, you could create a container named movies in every region, as long as you don’t have an existing container with that name.
    /// This member is required.
    public var containerName: Swift.String?
    /// An array of key:value pairs that you define. These values can be anything that you want. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see [Tagging Resources in MediaStore](https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html).
    public var tags: [MediaStoreClientTypes.Tag]?

    public init(
        containerName: Swift.String? = nil,
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.containerName = containerName
        self.tags = tags
    }
}

public struct CreateContainerOutput: Swift.Sendable {
    /// ContainerARN: The Amazon Resource Name (ARN) of the newly created container. The ARN has the following format: arn:aws:::container/. For example: arn:aws:mediastore:us-west-2:111122223333:container/movies ContainerName: The container name as specified in the request. CreationTime: Unix time stamp. Status: The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When an endpoint is available, the status changes to ACTIVE. The return value does not include the container's endpoint. To make downstream requests, you must obtain this value by using [DescribeContainer] or [ListContainers].
    /// This member is required.
    public var container: MediaStoreClientTypes.Container?

    public init(
        container: MediaStoreClientTypes.Container? = nil
    )
    {
        self.container = container
    }
}

public struct DeleteContainerInput: Swift.Sendable {
    /// The name of the container to delete.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct DeleteContainerOutput: Swift.Sendable {

    public init() { }
}

/// The policy that you specified in the request does not exist.
public struct PolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteContainerPolicyInput: Swift.Sendable {
    /// The name of the container that holds the policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct DeleteContainerPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCorsPolicyInput: Swift.Sendable {
    /// The name of the container to remove the policy from.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct DeleteCorsPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLifecyclePolicyInput: Swift.Sendable {
    /// The name of the container that holds the object lifecycle policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMetricPolicyInput: Swift.Sendable {
    /// The name of the container that is associated with the metric policy that you want to delete.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct DeleteMetricPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeContainerInput: Swift.Sendable {
    /// The name of the container to query.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct DescribeContainerOutput: Swift.Sendable {
    /// The name of the queried container.
    public var container: MediaStoreClientTypes.Container?

    public init(
        container: MediaStoreClientTypes.Container? = nil
    )
    {
        self.container = container
    }
}

public struct GetContainerPolicyInput: Swift.Sendable {
    /// The name of the container.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct GetContainerPolicyOutput: Swift.Sendable {
    /// The contents of the access policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

public struct GetCorsPolicyInput: Swift.Sendable {
    /// The name of the container that the policy is assigned to.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct GetCorsPolicyOutput: Swift.Sendable {
    /// The CORS policy assigned to the container.
    /// This member is required.
    public var corsPolicy: [MediaStoreClientTypes.CorsRule]?

    public init(
        corsPolicy: [MediaStoreClientTypes.CorsRule]? = nil
    )
    {
        self.corsPolicy = corsPolicy
    }
}

public struct GetLifecyclePolicyInput: Swift.Sendable {
    /// The name of the container that the object lifecycle policy is assigned to.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct GetLifecyclePolicyOutput: Swift.Sendable {
    /// The object lifecycle policy that is assigned to the container.
    /// This member is required.
    public var lifecyclePolicy: Swift.String?

    public init(
        lifecyclePolicy: Swift.String? = nil
    )
    {
        self.lifecyclePolicy = lifecyclePolicy
    }
}

public struct GetMetricPolicyInput: Swift.Sendable {
    /// The name of the container that is associated with the metric policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

extension MediaStoreClientTypes {

    /// A setting that enables metrics at the object level. Each rule contains an object group and an object group name. If the policy includes the MetricPolicyRules parameter, you must include at least one rule. Each metric policy can include up to five rules by default. You can also [request a quota increase](https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas) to allow up to 300 rules per policy.
    public struct MetricPolicyRule: Swift.Sendable {
        /// A path or file name that defines which objects to include in the group. Wildcards (*) are acceptable.
        /// This member is required.
        public var objectGroup: Swift.String?
        /// A name that allows you to refer to the object group.
        /// This member is required.
        public var objectGroupName: Swift.String?

        public init(
            objectGroup: Swift.String? = nil,
            objectGroupName: Swift.String? = nil
        )
        {
            self.objectGroup = objectGroup
            self.objectGroupName = objectGroupName
        }
    }
}

extension MediaStoreClientTypes {

    /// The metric policy that is associated with the container. A metric policy allows AWS Elemental MediaStore to send metrics to Amazon CloudWatch. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include rules to define groups of objects that you want MediaStore to send object-level metrics for. To view examples of how to construct a metric policy for your use case, see [Example Metric Policies](https://docs.aws.amazon.com/mediastore/latest/ug/policies-metric-examples.html).
    public struct MetricPolicy: Swift.Sendable {
        /// A setting to enable or disable metrics at the container level.
        /// This member is required.
        public var containerLevelMetrics: MediaStoreClientTypes.ContainerLevelMetrics?
        /// A parameter that holds an array of rules that enable metrics at the object level. This parameter is optional, but if you choose to include it, you must also include at least one rule. By default, you can include up to five rules. You can also [request a quota increase](https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas) to allow up to 300 rules per policy.
        public var metricPolicyRules: [MediaStoreClientTypes.MetricPolicyRule]?

        public init(
            containerLevelMetrics: MediaStoreClientTypes.ContainerLevelMetrics? = nil,
            metricPolicyRules: [MediaStoreClientTypes.MetricPolicyRule]? = nil
        )
        {
            self.containerLevelMetrics = containerLevelMetrics
            self.metricPolicyRules = metricPolicyRules
        }
    }
}

public struct GetMetricPolicyOutput: Swift.Sendable {
    /// The metric policy that is associated with the specific container.
    /// This member is required.
    public var metricPolicy: MediaStoreClientTypes.MetricPolicy?

    public init(
        metricPolicy: MediaStoreClientTypes.MetricPolicy? = nil
    )
    {
        self.metricPolicy = metricPolicy
    }
}

public struct ListContainersInput: Swift.Sendable {
    /// Enter the maximum number of containers in the response. Use from 1 to 255 characters.
    public var maxResults: Swift.Int?
    /// Only if you used MaxResults in the first command, enter the token (which was included in the previous response) to obtain the next set of containers. This token is included in a response only if there actually are more containers to list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListContainersOutput: Swift.Sendable {
    /// The names of the containers.
    /// This member is required.
    public var containers: [MediaStoreClientTypes.Container]?
    /// NextToken is the token to use in the next call to ListContainers. This token is returned only if you included the MaxResults tag in the original command, and only if there are still containers to return.
    public var nextToken: Swift.String?

    public init(
        containers: [MediaStoreClientTypes.Container]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.containers = containers
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// An array of key:value pairs that are assigned to the container.
    public var tags: [MediaStoreClientTypes.Tag]?

    public init(
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutContainerPolicyInput: Swift.Sendable {
    /// The name of the container.
    /// This member is required.
    public var containerName: Swift.String?
    /// The contents of the policy, which includes the following:
    ///
    /// * One Version tag
    ///
    /// * One Statement tag that contains the standard tags for the policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        containerName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerName = containerName
        self.policy = policy
    }
}

public struct PutContainerPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutCorsPolicyInput: Swift.Sendable {
    /// The name of the container that you want to assign the CORS policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The CORS policy to apply to the container.
    /// This member is required.
    public var corsPolicy: [MediaStoreClientTypes.CorsRule]?

    public init(
        containerName: Swift.String? = nil,
        corsPolicy: [MediaStoreClientTypes.CorsRule]? = nil
    )
    {
        self.containerName = containerName
        self.corsPolicy = corsPolicy
    }
}

public struct PutCorsPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutLifecyclePolicyInput: Swift.Sendable {
    /// The name of the container that you want to assign the object lifecycle policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The object lifecycle policy to apply to the container.
    /// This member is required.
    public var lifecyclePolicy: Swift.String?

    public init(
        containerName: Swift.String? = nil,
        lifecyclePolicy: Swift.String? = nil
    )
    {
        self.containerName = containerName
        self.lifecyclePolicy = lifecyclePolicy
    }
}

public struct PutLifecyclePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutMetricPolicyInput: Swift.Sendable {
    /// The name of the container that you want to add the metric policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The metric policy that you want to associate with the container. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include up to five rules to define groups of objects that you want MediaStore to send object-level metrics for. If you include rules in the policy, construct each rule with both of the following:
    ///
    /// * An object group that defines which objects to include in the group. The definition can be a path or a file name, but it can't have more than 900 characters. Valid characters are: a-z, A-Z, 0-9, _ (underscore), = (equal), : (colon), . (period), - (hyphen), ~ (tilde), / (forward slash), and * (asterisk). Wildcards (*) are acceptable.
    ///
    /// * An object group name that allows you to refer to the object group. The name can't have more than 30 characters. Valid characters are: a-z, A-Z, 0-9, and _ (underscore).
    /// This member is required.
    public var metricPolicy: MediaStoreClientTypes.MetricPolicy?

    public init(
        containerName: Swift.String? = nil,
        metricPolicy: MediaStoreClientTypes.MetricPolicy? = nil
    )
    {
        self.containerName = containerName
        self.metricPolicy = metricPolicy
    }
}

public struct PutMetricPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct StartAccessLoggingInput: Swift.Sendable {
    /// The name of the container that you want to start access logging on.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct StartAccessLoggingOutput: Swift.Sendable {

    public init() { }
}

public struct StopAccessLoggingInput: Swift.Sendable {
    /// The name of the container that you want to stop access logging on.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

public struct StopAccessLoggingOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?
    /// An array of key:value pairs that you want to add to the container. You need to specify only the tags that you want to add or update. For example, suppose a container already has two tags (customer:CompanyA and priority:High). You want to change the priority tag and also add a third tag (type:Contract). For TagResource, you specify the following tags: priority:Medium, type:Contract. The result is that your container has three tags: customer:CompanyA, priority:Medium, and type:Contract.
    /// This member is required.
    public var tags: [MediaStoreClientTypes.Tag]?

    public init(
        resource: Swift.String? = nil,
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?
    /// A comma-separated list of keys for tags that you want to remove from the container. For example, if your container has two tags (customer:CompanyA and priority:High) and you want to remove one of the tags (priority:High), you specify the key for the tag that you want to remove (priority).
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateContainerInput {

    static func urlPathProvider(_ value: CreateContainerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteContainerInput {

    static func urlPathProvider(_ value: DeleteContainerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteContainerPolicyInput {

    static func urlPathProvider(_ value: DeleteContainerPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCorsPolicyInput {

    static func urlPathProvider(_ value: DeleteCorsPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLifecyclePolicyInput {

    static func urlPathProvider(_ value: DeleteLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMetricPolicyInput {

    static func urlPathProvider(_ value: DeleteMetricPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeContainerInput {

    static func urlPathProvider(_ value: DescribeContainerInput) -> Swift.String? {
        return "/"
    }
}

extension GetContainerPolicyInput {

    static func urlPathProvider(_ value: GetContainerPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetCorsPolicyInput {

    static func urlPathProvider(_ value: GetCorsPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetLifecyclePolicyInput {

    static func urlPathProvider(_ value: GetLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetMetricPolicyInput {

    static func urlPathProvider(_ value: GetMetricPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListContainersInput {

    static func urlPathProvider(_ value: ListContainersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutContainerPolicyInput {

    static func urlPathProvider(_ value: PutContainerPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutCorsPolicyInput {

    static func urlPathProvider(_ value: PutCorsPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutLifecyclePolicyInput {

    static func urlPathProvider(_ value: PutLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutMetricPolicyInput {

    static func urlPathProvider(_ value: PutMetricPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension StartAccessLoggingInput {

    static func urlPathProvider(_ value: StartAccessLoggingInput) -> Swift.String? {
        return "/"
    }
}

extension StopAccessLoggingInput {

    static func urlPathProvider(_ value: StopAccessLoggingInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateContainerInput {

    static func write(value: CreateContainerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MediaStoreClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteContainerInput {

    static func write(value: DeleteContainerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension DeleteContainerPolicyInput {

    static func write(value: DeleteContainerPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension DeleteCorsPolicyInput {

    static func write(value: DeleteCorsPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension DeleteLifecyclePolicyInput {

    static func write(value: DeleteLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension DeleteMetricPolicyInput {

    static func write(value: DeleteMetricPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension DescribeContainerInput {

    static func write(value: DescribeContainerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension GetContainerPolicyInput {

    static func write(value: GetContainerPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension GetCorsPolicyInput {

    static func write(value: GetCorsPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension GetLifecyclePolicyInput {

    static func write(value: GetLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension GetMetricPolicyInput {

    static func write(value: GetMetricPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension ListContainersInput {

    static func write(value: ListContainersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resource"].write(value.resource)
    }
}

extension PutContainerPolicyInput {

    static func write(value: PutContainerPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["Policy"].write(value.policy)
    }
}

extension PutCorsPolicyInput {

    static func write(value: PutCorsPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["CorsPolicy"].writeList(value.corsPolicy, memberWritingClosure: MediaStoreClientTypes.CorsRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutLifecyclePolicyInput {

    static func write(value: PutLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["LifecyclePolicy"].write(value.lifecyclePolicy)
    }
}

extension PutMetricPolicyInput {

    static func write(value: PutMetricPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["MetricPolicy"].write(value.metricPolicy, with: MediaStoreClientTypes.MetricPolicy.write(value:to:))
    }
}

extension StartAccessLoggingInput {

    static func write(value: StartAccessLoggingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension StopAccessLoggingInput {

    static func write(value: StopAccessLoggingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resource"].write(value.resource)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MediaStoreClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resource"].write(value.resource)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateContainerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContainerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContainerOutput()
        value.container = try reader["Container"].readIfPresent(with: MediaStoreClientTypes.Container.read(from:))
        return value
    }
}

extension DeleteContainerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContainerOutput {
        return DeleteContainerOutput()
    }
}

extension DeleteContainerPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContainerPolicyOutput {
        return DeleteContainerPolicyOutput()
    }
}

extension DeleteCorsPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCorsPolicyOutput {
        return DeleteCorsPolicyOutput()
    }
}

extension DeleteLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLifecyclePolicyOutput {
        return DeleteLifecyclePolicyOutput()
    }
}

extension DeleteMetricPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMetricPolicyOutput {
        return DeleteMetricPolicyOutput()
    }
}

extension DescribeContainerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContainerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContainerOutput()
        value.container = try reader["Container"].readIfPresent(with: MediaStoreClientTypes.Container.read(from:))
        return value
    }
}

extension GetContainerPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContainerPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContainerPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent() ?? ""
        return value
    }
}

extension GetCorsPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCorsPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCorsPolicyOutput()
        value.corsPolicy = try reader["CorsPolicy"].readListIfPresent(memberReadingClosure: MediaStoreClientTypes.CorsRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLifecyclePolicyOutput()
        value.lifecyclePolicy = try reader["LifecyclePolicy"].readIfPresent() ?? ""
        return value
    }
}

extension GetMetricPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetricPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetricPolicyOutput()
        value.metricPolicy = try reader["MetricPolicy"].readIfPresent(with: MediaStoreClientTypes.MetricPolicy.read(from:))
        return value
    }
}

extension ListContainersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContainersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContainersOutput()
        value.containers = try reader["Containers"].readListIfPresent(memberReadingClosure: MediaStoreClientTypes.Container.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: MediaStoreClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutContainerPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutContainerPolicyOutput {
        return PutContainerPolicyOutput()
    }
}

extension PutCorsPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutCorsPolicyOutput {
        return PutCorsPolicyOutput()
    }
}

extension PutLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutLifecyclePolicyOutput {
        return PutLifecyclePolicyOutput()
    }
}

extension PutMetricPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMetricPolicyOutput {
        return PutMetricPolicyOutput()
    }
}

extension StartAccessLoggingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAccessLoggingOutput {
        return StartAccessLoggingOutput()
    }
}

extension StopAccessLoggingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAccessLoggingOutput {
        return StopAccessLoggingOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateContainerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContainerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContainerPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "PolicyNotFoundException": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCorsPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "CorsPolicyNotFoundException": return try CorsPolicyNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "PolicyNotFoundException": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMetricPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "PolicyNotFoundException": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContainerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContainerPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "PolicyNotFoundException": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCorsPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "CorsPolicyNotFoundException": return try CorsPolicyNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "PolicyNotFoundException": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetricPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "PolicyNotFoundException": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContainersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutContainerPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutCorsPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMetricPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAccessLoggingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAccessLoggingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ContainerInUseException": return try ContainerInUseException.makeError(baseError: baseError)
            case "ContainerNotFoundException": return try ContainerNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContainerInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ContainerInUseException {
        let reader = baseError.errorBodyReader
        var value = ContainerInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerError {
        let reader = baseError.errorBodyReader
        var value = InternalServerError()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContainerNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ContainerNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ContainerNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PolicyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = PolicyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CorsPolicyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CorsPolicyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = CorsPolicyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MediaStoreClientTypes.Container {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaStoreClientTypes.Container {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaStoreClientTypes.Container()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["ARN"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.accessLoggingEnabled = try reader["AccessLoggingEnabled"].readIfPresent()
        return value
    }
}

extension MediaStoreClientTypes.CorsRule {

    static func write(value: MediaStoreClientTypes.CorsRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedHeaders"].writeList(value.allowedHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowedMethods"].writeList(value.allowedMethods, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaStoreClientTypes.MethodName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowedOrigins"].writeList(value.allowedOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExposeHeaders"].writeList(value.exposeHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxAgeSeconds"].write(value.maxAgeSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaStoreClientTypes.CorsRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaStoreClientTypes.CorsRule()
        value.allowedOrigins = try reader["AllowedOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.allowedMethods = try reader["AllowedMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaStoreClientTypes.MethodName>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedHeaders = try reader["AllowedHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.maxAgeSeconds = try reader["MaxAgeSeconds"].readIfPresent() ?? 0
        value.exposeHeaders = try reader["ExposeHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaStoreClientTypes.MetricPolicy {

    static func write(value: MediaStoreClientTypes.MetricPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerLevelMetrics"].write(value.containerLevelMetrics)
        try writer["MetricPolicyRules"].writeList(value.metricPolicyRules, memberWritingClosure: MediaStoreClientTypes.MetricPolicyRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaStoreClientTypes.MetricPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaStoreClientTypes.MetricPolicy()
        value.containerLevelMetrics = try reader["ContainerLevelMetrics"].readIfPresent() ?? .sdkUnknown("")
        value.metricPolicyRules = try reader["MetricPolicyRules"].readListIfPresent(memberReadingClosure: MediaStoreClientTypes.MetricPolicyRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaStoreClientTypes.MetricPolicyRule {

    static func write(value: MediaStoreClientTypes.MetricPolicyRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectGroup"].write(value.objectGroup)
        try writer["ObjectGroupName"].write(value.objectGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaStoreClientTypes.MetricPolicyRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaStoreClientTypes.MetricPolicyRule()
        value.objectGroup = try reader["ObjectGroup"].readIfPresent() ?? ""
        value.objectGroupName = try reader["ObjectGroupName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaStoreClientTypes.Tag {

    static func write(value: MediaStoreClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaStoreClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaStoreClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

public enum MediaStoreClientTypes {}
