// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaStoreClientTypes.Container: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case accessLoggingEnabled = "AccessLoggingEnabled"
        case creationTime = "CreationTime"
        case endpoint = "Endpoint"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let accessLoggingEnabled = self.accessLoggingEnabled {
            try encodeContainer.encode(accessLoggingEnabled, forKey: .accessLoggingEnabled)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.ContainerStatus.self, forKey: .status)
        status = statusDecoded
        let accessLoggingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessLoggingEnabled)
        accessLoggingEnabled = accessLoggingEnabledDecoded
    }
}

extension MediaStoreClientTypes {
    /// This section describes operations that you can perform on an AWS Elemental MediaStore container.
    public struct Container: Swift.Equatable {
        /// The state of access logging on the container. This value is false by default, indicating that AWS Elemental MediaStore does not send access logs to Amazon CloudWatch Logs. When you enable access logging on the container, MediaStore changes this value to true, indicating that the service delivers access logs for objects stored in that container to CloudWatch Logs.
        public var accessLoggingEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the container. The ARN has the following format: arn:aws:::container/ For example: arn:aws:mediastore:us-west-2:111122223333:container/movies
        public var arn: Swift.String?
        /// Unix timestamp.
        public var creationTime: ClientRuntime.Date?
        /// The DNS endpoint of the container. Use the endpoint to identify the specific container when sending requests to the data plane. The service assigns this value when the container is created. Once the value has been assigned, it does not change.
        public var endpoint: Swift.String?
        /// The name of the container.
        public var name: Swift.String?
        /// The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When the endpoint is available, the status changes to ACTIVE.
        public var status: MediaStoreClientTypes.ContainerStatus?

        public init(
            accessLoggingEnabled: Swift.Bool? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endpoint: Swift.String? = nil,
            name: Swift.String? = nil,
            status: MediaStoreClientTypes.ContainerStatus? = nil
        )
        {
            self.accessLoggingEnabled = accessLoggingEnabled
            self.arn = arn
            self.creationTime = creationTime
            self.endpoint = endpoint
            self.name = name
            self.status = status
        }
    }

}

extension ContainerInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ContainerInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The container that you specified in the request already exists or is being updated.
public struct ContainerInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContainerInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContainerInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContainerInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreClientTypes {
    public enum ContainerLevelMetrics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerLevelMetrics] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerLevelMetrics(rawValue: rawValue) ?? ContainerLevelMetrics.sdkUnknown(rawValue)
        }
    }
}

extension ContainerNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ContainerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The container that you specified in the request does not exist.
public struct ContainerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContainerNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContainerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContainerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreClientTypes {
    public enum ContainerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerStatus(rawValue: rawValue) ?? ContainerStatus.sdkUnknown(rawValue)
        }
    }
}

extension CorsPolicyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CorsPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The CORS policy that you specified in the request does not exist.
public struct CorsPolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CorsPolicyNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CorsPolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CorsPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreClientTypes.CorsRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedHeaders = "AllowedHeaders"
        case allowedMethods = "AllowedMethods"
        case allowedOrigins = "AllowedOrigins"
        case exposeHeaders = "ExposeHeaders"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedHeaders = allowedHeaders {
            var allowedHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedHeaders)
            for header0 in allowedHeaders {
                try allowedHeadersContainer.encode(header0)
            }
        }
        if let allowedMethods = allowedMethods {
            var allowedMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedMethods)
            for methodname0 in allowedMethods {
                try allowedMethodsContainer.encode(methodname0.rawValue)
            }
        }
        if let allowedOrigins = allowedOrigins {
            var allowedOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOrigins)
            for origin0 in allowedOrigins {
                try allowedOriginsContainer.encode(origin0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for header0 in exposeHeaders {
                try exposeHeadersContainer.encode(header0)
            }
        }
        if maxAgeSeconds != 0 {
            try encodeContainer.encode(maxAgeSeconds, forKey: .maxAgeSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedOrigins)
        var allowedOriginsDecoded0:[Swift.String]? = nil
        if let allowedOriginsContainer = allowedOriginsContainer {
            allowedOriginsDecoded0 = [Swift.String]()
            for string0 in allowedOriginsContainer {
                if let string0 = string0 {
                    allowedOriginsDecoded0?.append(string0)
                }
            }
        }
        allowedOrigins = allowedOriginsDecoded0
        let allowedMethodsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.MethodName?].self, forKey: .allowedMethods)
        var allowedMethodsDecoded0:[MediaStoreClientTypes.MethodName]? = nil
        if let allowedMethodsContainer = allowedMethodsContainer {
            allowedMethodsDecoded0 = [MediaStoreClientTypes.MethodName]()
            for enum0 in allowedMethodsContainer {
                if let enum0 = enum0 {
                    allowedMethodsDecoded0?.append(enum0)
                }
            }
        }
        allowedMethods = allowedMethodsDecoded0
        let allowedHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedHeaders)
        var allowedHeadersDecoded0:[Swift.String]? = nil
        if let allowedHeadersContainer = allowedHeadersContainer {
            allowedHeadersDecoded0 = [Swift.String]()
            for string0 in allowedHeadersContainer {
                if let string0 = string0 {
                    allowedHeadersDecoded0?.append(string0)
                }
            }
        }
        allowedHeaders = allowedHeadersDecoded0
        let maxAgeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAgeSeconds) ?? 0
        maxAgeSeconds = maxAgeSecondsDecoded
        let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[Swift.String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [Swift.String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
    }
}

extension MediaStoreClientTypes {
    /// A rule for a CORS policy. You can add up to 100 rules to a CORS policy. If more than one rule applies, the service uses the first applicable rule listed.
    public struct CorsRule: Swift.Equatable {
        /// Specifies which headers are allowed in a preflight OPTIONS request through the Access-Control-Request-Headers header. Each header name that is specified in Access-Control-Request-Headers must have a corresponding entry in the rule. Only the headers that were requested are sent back. This element can contain only one wildcard character (*).
        /// This member is required.
        public var allowedHeaders: [Swift.String]?
        /// Identifies an HTTP method that the origin that is specified in the rule is allowed to execute. Each CORS rule must contain at least one AllowedMethods and one AllowedOrigins element.
        public var allowedMethods: [MediaStoreClientTypes.MethodName]?
        /// One or more response headers that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). Each CORS rule must have at least one AllowedOrigins element. The string value can include only one wildcard character (*), for example, http://*.example.com. Additionally, you can specify only one wildcard character to allow cross-origin access for all origins.
        /// This member is required.
        public var allowedOrigins: [Swift.String]?
        /// One or more headers in the response that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). This element is optional for each rule.
        public var exposeHeaders: [Swift.String]?
        /// The time in seconds that your browser caches the preflight response for the specified resource. A CORS rule can have only one MaxAgeSeconds element.
        public var maxAgeSeconds: Swift.Int

        public init(
            allowedHeaders: [Swift.String]? = nil,
            allowedMethods: [MediaStoreClientTypes.MethodName]? = nil,
            allowedOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAgeSeconds: Swift.Int = 0
        )
        {
            self.allowedHeaders = allowedHeaders
            self.allowedMethods = allowedMethods
            self.allowedOrigins = allowedOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAgeSeconds = maxAgeSeconds
        }
    }

}

extension CreateContainerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateContainerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContainerInput: Swift.Equatable {
    /// The name for the container. The name must be from 1 to 255 characters. Container names must be unique to your AWS account within a specific region. As an example, you could create a container named movies in every region, as long as you donâ€™t have an existing container with that name.
    /// This member is required.
    public var containerName: Swift.String?
    /// An array of key:value pairs that you define. These values can be anything that you want. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see [Tagging Resources in MediaStore](https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html).
    public var tags: [MediaStoreClientTypes.Tag]?

    public init(
        containerName: Swift.String? = nil,
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.containerName = containerName
        self.tags = tags
    }
}

struct CreateContainerInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let tags: [MediaStoreClientTypes.Tag]?
}

extension CreateContainerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MediaStoreClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MediaStoreClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContainerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContainerOutputBody = try responseDecoder.decode(responseBody: data)
            self.container = output.container
        } else {
            self.container = nil
        }
    }
}

public struct CreateContainerOutput: Swift.Equatable {
    /// ContainerARN: The Amazon Resource Name (ARN) of the newly created container. The ARN has the following format: arn:aws:::container/. For example: arn:aws:mediastore:us-west-2:111122223333:container/movies ContainerName: The container name as specified in the request. CreationTime: Unix time stamp. Status: The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When an endpoint is available, the status changes to ACTIVE. The return value does not include the container's endpoint. To make downstream requests, you must obtain this value by using [DescribeContainer] or [ListContainers].
    /// This member is required.
    public var container: MediaStoreClientTypes.Container?

    public init(
        container: MediaStoreClientTypes.Container? = nil
    )
    {
        self.container = container
    }
}

struct CreateContainerOutputBody: Swift.Equatable {
    let container: MediaStoreClientTypes.Container?
}

extension CreateContainerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case container = "Container"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.Container.self, forKey: .container)
        container = containerDecoded
    }
}

enum CreateContainerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContainerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteContainerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContainerInput: Swift.Equatable {
    /// The name of the container to delete.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteContainerInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteContainerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteContainerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContainerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContainerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContainerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteContainerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContainerPolicyInput: Swift.Equatable {
    /// The name of the container that holds the policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteContainerPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteContainerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteContainerPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContainerPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContainerPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFoundException": return try await PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCorsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteCorsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCorsPolicyInput: Swift.Equatable {
    /// The name of the container to remove the policy from.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteCorsPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteCorsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteCorsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCorsPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCorsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CorsPolicyNotFoundException": return try await CorsPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The name of the container that holds the object lifecycle policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFoundException": return try await PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMetricPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteMetricPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMetricPolicyInput: Swift.Equatable {
    /// The name of the container that is associated with the metric policy that you want to delete.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteMetricPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteMetricPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteMetricPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMetricPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMetricPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFoundException": return try await PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeContainerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DescribeContainerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeContainerInput: Swift.Equatable {
    /// The name of the container to query.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DescribeContainerInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DescribeContainerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DescribeContainerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContainerOutputBody = try responseDecoder.decode(responseBody: data)
            self.container = output.container
        } else {
            self.container = nil
        }
    }
}

public struct DescribeContainerOutput: Swift.Equatable {
    /// The name of the queried container.
    public var container: MediaStoreClientTypes.Container?

    public init(
        container: MediaStoreClientTypes.Container? = nil
    )
    {
        self.container = container
    }
}

struct DescribeContainerOutputBody: Swift.Equatable {
    let container: MediaStoreClientTypes.Container?
}

extension DescribeContainerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case container = "Container"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.Container.self, forKey: .container)
        container = containerDecoded
    }
}

enum DescribeContainerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContainerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetContainerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContainerPolicyInput: Swift.Equatable {
    /// The name of the container.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetContainerPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetContainerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetContainerPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContainerPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetContainerPolicyOutput: Swift.Equatable {
    /// The contents of the access policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetContainerPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetContainerPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetContainerPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFoundException": return try await PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCorsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetCorsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCorsPolicyInput: Swift.Equatable {
    /// The name of the container that the policy is assigned to.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetCorsPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetCorsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetCorsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCorsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.corsPolicy = output.corsPolicy
        } else {
            self.corsPolicy = nil
        }
    }
}

public struct GetCorsPolicyOutput: Swift.Equatable {
    /// The CORS policy assigned to the container.
    /// This member is required.
    public var corsPolicy: [MediaStoreClientTypes.CorsRule]?

    public init(
        corsPolicy: [MediaStoreClientTypes.CorsRule]? = nil
    )
    {
        self.corsPolicy = corsPolicy
    }
}

struct GetCorsPolicyOutputBody: Swift.Equatable {
    let corsPolicy: [MediaStoreClientTypes.CorsRule]?
}

extension GetCorsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case corsPolicy = "CorsPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let corsPolicyContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.CorsRule?].self, forKey: .corsPolicy)
        var corsPolicyDecoded0:[MediaStoreClientTypes.CorsRule]? = nil
        if let corsPolicyContainer = corsPolicyContainer {
            corsPolicyDecoded0 = [MediaStoreClientTypes.CorsRule]()
            for structure0 in corsPolicyContainer {
                if let structure0 = structure0 {
                    corsPolicyDecoded0?.append(structure0)
                }
            }
        }
        corsPolicy = corsPolicyDecoded0
    }
}

enum GetCorsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CorsPolicyNotFoundException": return try await CorsPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// The name of the container that the object lifecycle policy is assigned to.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicy = output.lifecyclePolicy
        } else {
            self.lifecyclePolicy = nil
        }
    }
}

public struct GetLifecyclePolicyOutput: Swift.Equatable {
    /// The object lifecycle policy that is assigned to the container.
    /// This member is required.
    public var lifecyclePolicy: Swift.String?

    public init(
        lifecyclePolicy: Swift.String? = nil
    )
    {
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct GetLifecyclePolicyOutputBody: Swift.Equatable {
    let lifecyclePolicy: Swift.String?
}

extension GetLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

enum GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFoundException": return try await PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMetricPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetMetricPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMetricPolicyInput: Swift.Equatable {
    /// The name of the container that is associated with the metric policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetMetricPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetMetricPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetMetricPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMetricPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricPolicy = output.metricPolicy
        } else {
            self.metricPolicy = nil
        }
    }
}

public struct GetMetricPolicyOutput: Swift.Equatable {
    /// The metric policy that is associated with the specific container.
    /// This member is required.
    public var metricPolicy: MediaStoreClientTypes.MetricPolicy?

    public init(
        metricPolicy: MediaStoreClientTypes.MetricPolicy? = nil
    )
    {
        self.metricPolicy = metricPolicy
    }
}

struct GetMetricPolicyOutputBody: Swift.Equatable {
    let metricPolicy: MediaStoreClientTypes.MetricPolicy?
}

extension GetMetricPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricPolicy = "MetricPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricPolicyDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.MetricPolicy.self, forKey: .metricPolicy)
        metricPolicy = metricPolicyDecoded
    }
}

enum GetMetricPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFoundException": return try await PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListContainersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListContainersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListContainersInput: Swift.Equatable {
    /// Enter the maximum number of containers in the response. Use from 1 to 255 characters.
    public var maxResults: Swift.Int?
    /// Only if you used MaxResults in the first command, enter the token (which was included in the previous response) to obtain the next set of containers. This token is included in a response only if there actually are more containers to list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContainersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListContainersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContainersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContainersOutputBody = try responseDecoder.decode(responseBody: data)
            self.containers = output.containers
            self.nextToken = output.nextToken
        } else {
            self.containers = nil
            self.nextToken = nil
        }
    }
}

public struct ListContainersOutput: Swift.Equatable {
    /// The names of the containers.
    /// This member is required.
    public var containers: [MediaStoreClientTypes.Container]?
    /// NextToken is the token to use in the next call to ListContainers. This token is returned only if you included the MaxResults tag in the original command, and only if there are still containers to return.
    public var nextToken: Swift.String?

    public init(
        containers: [MediaStoreClientTypes.Container]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.containers = containers
        self.nextToken = nextToken
    }
}

struct ListContainersOutputBody: Swift.Equatable {
    let containers: [MediaStoreClientTypes.Container]?
    let nextToken: Swift.String?
}

extension ListContainersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containers = "Containers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containersContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[MediaStoreClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [MediaStoreClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContainersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resource: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// An array of key:value pairs that are assigned to the container.
    public var tags: [MediaStoreClientTypes.Tag]?

    public init(
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [MediaStoreClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MediaStoreClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MediaStoreClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaStoreClientTypes {
    public enum MethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [MethodName] {
            return [
                .delete,
                .get,
                .head,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MethodName(rawValue: rawValue) ?? MethodName.sdkUnknown(rawValue)
        }
    }
}

extension MediaStoreClientTypes.MetricPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerLevelMetrics = "ContainerLevelMetrics"
        case metricPolicyRules = "MetricPolicyRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerLevelMetrics = self.containerLevelMetrics {
            try encodeContainer.encode(containerLevelMetrics.rawValue, forKey: .containerLevelMetrics)
        }
        if let metricPolicyRules = metricPolicyRules {
            var metricPolicyRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricPolicyRules)
            for metricpolicyrule0 in metricPolicyRules {
                try metricPolicyRulesContainer.encode(metricpolicyrule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerLevelMetricsDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.ContainerLevelMetrics.self, forKey: .containerLevelMetrics)
        containerLevelMetrics = containerLevelMetricsDecoded
        let metricPolicyRulesContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.MetricPolicyRule?].self, forKey: .metricPolicyRules)
        var metricPolicyRulesDecoded0:[MediaStoreClientTypes.MetricPolicyRule]? = nil
        if let metricPolicyRulesContainer = metricPolicyRulesContainer {
            metricPolicyRulesDecoded0 = [MediaStoreClientTypes.MetricPolicyRule]()
            for structure0 in metricPolicyRulesContainer {
                if let structure0 = structure0 {
                    metricPolicyRulesDecoded0?.append(structure0)
                }
            }
        }
        metricPolicyRules = metricPolicyRulesDecoded0
    }
}

extension MediaStoreClientTypes {
    /// The metric policy that is associated with the container. A metric policy allows AWS Elemental MediaStore to send metrics to Amazon CloudWatch. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include rules to define groups of objects that you want MediaStore to send object-level metrics for. To view examples of how to construct a metric policy for your use case, see [Example Metric Policies](https://docs.aws.amazon.com/mediastore/latest/ug/policies-metric-examples.html).
    public struct MetricPolicy: Swift.Equatable {
        /// A setting to enable or disable metrics at the container level.
        /// This member is required.
        public var containerLevelMetrics: MediaStoreClientTypes.ContainerLevelMetrics?
        /// A parameter that holds an array of rules that enable metrics at the object level. This parameter is optional, but if you choose to include it, you must also include at least one rule. By default, you can include up to five rules. You can also [request a quota increase](https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas) to allow up to 300 rules per policy.
        public var metricPolicyRules: [MediaStoreClientTypes.MetricPolicyRule]?

        public init(
            containerLevelMetrics: MediaStoreClientTypes.ContainerLevelMetrics? = nil,
            metricPolicyRules: [MediaStoreClientTypes.MetricPolicyRule]? = nil
        )
        {
            self.containerLevelMetrics = containerLevelMetrics
            self.metricPolicyRules = metricPolicyRules
        }
    }

}

extension MediaStoreClientTypes.MetricPolicyRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectGroup = "ObjectGroup"
        case objectGroupName = "ObjectGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectGroup = self.objectGroup {
            try encodeContainer.encode(objectGroup, forKey: .objectGroup)
        }
        if let objectGroupName = self.objectGroupName {
            try encodeContainer.encode(objectGroupName, forKey: .objectGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectGroup)
        objectGroup = objectGroupDecoded
        let objectGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectGroupName)
        objectGroupName = objectGroupNameDecoded
    }
}

extension MediaStoreClientTypes {
    /// A setting that enables metrics at the object level. Each rule contains an object group and an object group name. If the policy includes the MetricPolicyRules parameter, you must include at least one rule. Each metric policy can include up to five rules by default. You can also [request a quota increase](https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas) to allow up to 300 rules per policy.
    public struct MetricPolicyRule: Swift.Equatable {
        /// A path or file name that defines which objects to include in the group. Wildcards (*) are acceptable.
        /// This member is required.
        public var objectGroup: Swift.String?
        /// A name that allows you to refer to the object group.
        /// This member is required.
        public var objectGroupName: Swift.String?

        public init(
            objectGroup: Swift.String? = nil,
            objectGroupName: Swift.String? = nil
        )
        {
            self.objectGroup = objectGroup
            self.objectGroupName = objectGroupName
        }
    }

}

extension PolicyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The policy that you specified in the request does not exist.
public struct PolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutContainerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutContainerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutContainerPolicyInput: Swift.Equatable {
    /// The name of the container.
    /// This member is required.
    public var containerName: Swift.String?
    /// The contents of the policy, which includes the following:
    ///
    /// * One Version tag
    ///
    /// * One Statement tag that contains the standard tags for the policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        containerName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerName = containerName
        self.policy = policy
    }
}

struct PutContainerPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let policy: Swift.String?
}

extension PutContainerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutContainerPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutContainerPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutCorsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case corsPolicy = "CorsPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let corsPolicy = corsPolicy {
            var corsPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .corsPolicy)
            for corsrule0 in corsPolicy {
                try corsPolicyContainer.encode(corsrule0)
            }
        }
    }
}

extension PutCorsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutCorsPolicyInput: Swift.Equatable {
    /// The name of the container that you want to assign the CORS policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The CORS policy to apply to the container.
    /// This member is required.
    public var corsPolicy: [MediaStoreClientTypes.CorsRule]?

    public init(
        containerName: Swift.String? = nil,
        corsPolicy: [MediaStoreClientTypes.CorsRule]? = nil
    )
    {
        self.containerName = containerName
        self.corsPolicy = corsPolicy
    }
}

struct PutCorsPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let corsPolicy: [MediaStoreClientTypes.CorsRule]?
}

extension PutCorsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case corsPolicy = "CorsPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let corsPolicyContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.CorsRule?].self, forKey: .corsPolicy)
        var corsPolicyDecoded0:[MediaStoreClientTypes.CorsRule]? = nil
        if let corsPolicyContainer = corsPolicyContainer {
            corsPolicyDecoded0 = [MediaStoreClientTypes.CorsRule]()
            for structure0 in corsPolicyContainer {
                if let structure0 = structure0 {
                    corsPolicyDecoded0?.append(structure0)
                }
            }
        }
        corsPolicy = corsPolicyDecoded0
    }
}

extension PutCorsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutCorsPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutCorsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let lifecyclePolicy = self.lifecyclePolicy {
            try encodeContainer.encode(lifecyclePolicy, forKey: .lifecyclePolicy)
        }
    }
}

extension PutLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutLifecyclePolicyInput: Swift.Equatable {
    /// The name of the container that you want to assign the object lifecycle policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The object lifecycle policy to apply to the container.
    /// This member is required.
    public var lifecyclePolicy: Swift.String?

    public init(
        containerName: Swift.String? = nil,
        lifecyclePolicy: Swift.String? = nil
    )
    {
        self.containerName = containerName
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct PutLifecyclePolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let lifecyclePolicy: Swift.String?
}

extension PutLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

extension PutLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutLifecyclePolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutMetricPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case metricPolicy = "MetricPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let metricPolicy = self.metricPolicy {
            try encodeContainer.encode(metricPolicy, forKey: .metricPolicy)
        }
    }
}

extension PutMetricPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMetricPolicyInput: Swift.Equatable {
    /// The name of the container that you want to add the metric policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The metric policy that you want to associate with the container. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include up to five rules to define groups of objects that you want MediaStore to send object-level metrics for. If you include rules in the policy, construct each rule with both of the following:
    ///
    /// * An object group that defines which objects to include in the group. The definition can be a path or a file name, but it can't have more than 900 characters. Valid characters are: a-z, A-Z, 0-9, _ (underscore), = (equal), : (colon), . (period), - (hyphen), ~ (tilde), / (forward slash), and * (asterisk). Wildcards (*) are acceptable.
    ///
    /// * An object group name that allows you to refer to the object group. The name can't have more than 30 characters. Valid characters are: a-z, A-Z, 0-9, and _ (underscore).
    /// This member is required.
    public var metricPolicy: MediaStoreClientTypes.MetricPolicy?

    public init(
        containerName: Swift.String? = nil,
        metricPolicy: MediaStoreClientTypes.MetricPolicy? = nil
    )
    {
        self.containerName = containerName
        self.metricPolicy = metricPolicy
    }
}

struct PutMetricPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let metricPolicy: MediaStoreClientTypes.MetricPolicy?
}

extension PutMetricPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case metricPolicy = "MetricPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let metricPolicyDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.MetricPolicy.self, forKey: .metricPolicy)
        metricPolicy = metricPolicyDecoded
    }
}

extension PutMetricPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutMetricPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutMetricPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartAccessLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension StartAccessLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAccessLoggingInput: Swift.Equatable {
    /// The name of the container that you want to start access logging on.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct StartAccessLoggingInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension StartAccessLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension StartAccessLoggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartAccessLoggingOutput: Swift.Equatable {

    public init() { }
}

enum StartAccessLoggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopAccessLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension StopAccessLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopAccessLoggingInput: Swift.Equatable {
    /// The name of the container that you want to stop access logging on.
    /// This member is required.
    public var containerName: Swift.String?

    public init(
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct StopAccessLoggingInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension StopAccessLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension StopAccessLoggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopAccessLoggingOutput: Swift.Equatable {

    public init() { }
}

enum StopAccessLoggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaStoreClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MediaStoreClientTypes {
    /// A collection of tags associated with a container. Each tag consists of a key:value pair, which can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see [Tagging Resources in MediaStore](https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html).
    public struct Tag: Swift.Equatable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?
    /// An array of key:value pairs that you want to add to the container. You need to specify only the tags that you want to add or update. For example, suppose a container already has two tags (customer:CompanyA and priority:High). You want to change the priority tag and also add a third tag (type:Contract). For TagResource, you specify the following tags: priority:Medium, type:Contract. The result is that your container has three tags: customer:CompanyA, priority:Medium, and type:Contract.
    /// This member is required.
    public var tags: [MediaStoreClientTypes.Tag]?

    public init(
        resource: Swift.String? = nil,
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resource: Swift.String?
    let tags: [MediaStoreClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MediaStoreClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MediaStoreClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?
    /// A comma-separated list of keys for tags that you want to remove from the container. For example, if your container has two tags (customer:CompanyA and priority:High) and you want to remove one of the tags (priority:High), you specify the key for the tag that you want to remove (priority).
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resource: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ContainerInUseException": return try await ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ContainerNotFoundException": return try await ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
