//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

public struct DeleteChallengeOutput {

    public init() { }
}

public struct DeleteConnectorOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

/// You can receive this error if you attempt to perform an operation and you don't have the required permissions. This can be caused by insufficient permissions in policies attached to your Amazon Web Services Identity and Access Management (IAM) principal. It can also happen because of restrictions in place from an Amazon Web Services Organizations service control policy (SCP) that affects your Amazon Web Services account.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request is malformed or contains an error such as an invalid parameter value or a missing required parameter.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PcaConnectorScepClientTypes {
    /// For Connector for SCEP for general-purpose. An object containing information about the specified connector's SCEP challenge passwords.
    public struct Challenge {
        /// The Amazon Resource Name (ARN) of the challenge.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the connector.
        public var connectorArn: Swift.String?
        /// The date and time that the challenge was created.
        public var createdAt: Foundation.Date?
        /// The SCEP challenge password, in UUID format.
        public var password: Swift.String?
        /// The date and time that the challenge was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            connectorArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            password: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.connectorArn = connectorArn
            self.createdAt = createdAt
            self.password = password
            self.updatedAt = updatedAt
        }
    }

}

extension PcaConnectorScepClientTypes.Challenge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Challenge(arn: \(Swift.String(describing: arn)), connectorArn: \(Swift.String(describing: connectorArn)), createdAt: \(Swift.String(describing: createdAt)), updatedAt: \(Swift.String(describing: updatedAt)), password: \"CONTENT_REDACTED\")"}
}

extension PcaConnectorScepClientTypes {
    /// Contains details about the connector's challenge.
    public struct ChallengeMetadata {
        /// The Amazon Resource Name (ARN) of the challenge.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the connector.
        public var connectorArn: Swift.String?
        /// The date and time that the connector was created.
        public var createdAt: Foundation.Date?
        /// The date and time that the connector was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            connectorArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.connectorArn = connectorArn
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }
    }

}

extension PcaConnectorScepClientTypes {
    /// Details about the specified challenge, returned by the [GetChallengeMetadata](https://docs.aws.amazon.com/C4SCEP_API/pca-connector-scep/latest/APIReference/API_GetChallengeMetadata.html) action.
    public struct ChallengeMetadataSummary {
        /// The Amazon Resource Name (ARN) of the challenge.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the connector.
        public var connectorArn: Swift.String?
        /// The date and time that the challenge was created.
        public var createdAt: Foundation.Date?
        /// The date and time that the challenge was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            connectorArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.connectorArn = connectorArn
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }
    }

}

/// This request can't be completed for one of the following reasons because the requested resource was being concurrently modified by another request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the Amazon Web Services resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type, which can be either Connector or Challenge.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request processing has failed because of an unknown error, exception or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation tried to access a nonexistent resource. The resource might be incorrectly specified, or it might have a status other than ACTIVE.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the Amazon Web Services resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type, which can be either Connector or Challenge.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota identifier.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource type, which can be either Connector or Challenge.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Identifies the originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PcaConnectorScepClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case caCertValidityTooShort
        case invalidCaUsageMode
        case invalidConnectorType
        case invalidState
        case noClientToken
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .caCertValidityTooShort,
                .invalidCaUsageMode,
                .invalidConnectorType,
                .invalidState,
                .noClientToken,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .caCertValidityTooShort: return "CA_CERT_VALIDITY_TOO_SHORT"
            case .invalidCaUsageMode: return "INVALID_CA_USAGE_MODE"
            case .invalidConnectorType: return "INVALID_CONNECTOR_TYPE"
            case .invalidState: return "INVALID_STATE"
            case .noClientToken: return "NO_CLIENT_TOKEN"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An input validation error occurred. For example, invalid characters in a name tag, or an invalid pagination token.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation error, if available. The service doesn't return a reason for every validation exception.
        public internal(set) var reason: PcaConnectorScepClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PcaConnectorScepClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CreateChallengeInput {
    /// Custom string that can be used to distinguish between calls to the [CreateChallenge](https://docs.aws.amazon.com/C4SCEP_API/pca-connector-scep/latest/APIReference/API_CreateChallenge.html) action. Client tokens for CreateChallenge time out after five minutes. Therefore, if you call CreateChallenge multiple times with the same client token within five minutes, Connector for SCEP recognizes that you are requesting only one challenge and will only respond with one. If you change the client token for each call, Connector for SCEP recognizes that you are requesting multiple challenge passwords.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the connector that you want to create a challenge for.
    /// This member is required.
    public var connectorArn: Swift.String?
    /// The key-value pairs to associate with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        connectorArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.connectorArn = connectorArn
        self.tags = tags
    }
}

public struct CreateChallengeOutput {
    /// Returns the challenge details for the specified connector.
    public var challenge: PcaConnectorScepClientTypes.Challenge?

    public init(
        challenge: PcaConnectorScepClientTypes.Challenge? = nil
    )
    {
        self.challenge = challenge
    }
}

public struct DeleteChallengeInput {
    /// The Amazon Resource Name (ARN) of the challenge password to delete.
    /// This member is required.
    public var challengeArn: Swift.String?

    public init(
        challengeArn: Swift.String? = nil
    )
    {
        self.challengeArn = challengeArn
    }
}

public struct GetChallengeMetadataInput {
    /// The Amazon Resource Name (ARN) of the challenge.
    /// This member is required.
    public var challengeArn: Swift.String?

    public init(
        challengeArn: Swift.String? = nil
    )
    {
        self.challengeArn = challengeArn
    }
}

public struct GetChallengeMetadataOutput {
    /// The metadata for the challenge.
    public var challengeMetadata: PcaConnectorScepClientTypes.ChallengeMetadata?

    public init(
        challengeMetadata: PcaConnectorScepClientTypes.ChallengeMetadata? = nil
    )
    {
        self.challengeMetadata = challengeMetadata
    }
}

public struct GetChallengePasswordInput {
    /// The Amazon Resource Name (ARN) of the challenge.
    /// This member is required.
    public var challengeArn: Swift.String?

    public init(
        challengeArn: Swift.String? = nil
    )
    {
        self.challengeArn = challengeArn
    }
}

public struct GetChallengePasswordOutput {
    /// The SCEP challenge password.
    public var password: Swift.String?

    public init(
        password: Swift.String? = nil
    )
    {
        self.password = password
    }
}

extension GetChallengePasswordOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChallengePasswordOutput(password: \"CONTENT_REDACTED\")"}
}

public struct ListChallengeMetadataInput {
    /// The Amazon Resource Name (ARN) of the connector.
    /// This member is required.
    public var connectorArn: Swift.String?
    /// The maximum number of objects that you want Connector for SCEP to return for this request. If more objects are available, in the response, Connector for SCEP provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Connector for SCEP returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        connectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListChallengeMetadataOutput {
    /// The challenge metadata for the challenges belonging to your Amazon Web Services account.
    public var challenges: [PcaConnectorScepClientTypes.ChallengeMetadataSummary]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Connector for SCEP returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        challenges: [PcaConnectorScepClientTypes.ChallengeMetadataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.challenges = challenges
        self.nextToken = nextToken
    }
}

extension PcaConnectorScepClientTypes {
    /// Contains configuration details for use with Microsoft Intune. For information about using Connector for SCEP for Microsoft Intune, see [Using Connector for SCEP for Microsoft Intune](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlconnector-for-scep-intune.html). When you use Connector for SCEP for Microsoft Intune, certain functionalities are enabled by accessing Microsoft Intune through the Microsoft API. Your use of the Connector for SCEP and accompanying Amazon Web Services services doesn't remove your need to have a valid license for your use of the Microsoft Intune service. You should also review the [Microsoft Intune® App Protection Policies](https://learn.microsoft.com/en-us/mem/intune/apps/app-protection-policy).
    public struct IntuneConfiguration {
        /// The directory (tenant) ID from your Microsoft Entra ID app registration.
        /// This member is required.
        public var azureApplicationId: Swift.String?
        /// The primary domain from your Microsoft Entra ID app registration.
        /// This member is required.
        public var domain: Swift.String?

        public init(
            azureApplicationId: Swift.String? = nil,
            domain: Swift.String? = nil
        )
        {
            self.azureApplicationId = azureApplicationId
            self.domain = domain
        }
    }

}

extension PcaConnectorScepClientTypes {
    /// If you don't supply a value, by default Connector for SCEP creates a connector for general-purpose use. A general-purpose connector is designed to work with clients or endpoints that support the SCEP protocol, except Connector for SCEP for Microsoft Intune. For information about considerations and limitations with using Connector for SCEP, see [Considerations and Limitations](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlc4scep-considerations-limitations.html). If you provide an IntuneConfiguration, Connector for SCEP creates a connector for use with Microsoft Intune, and you manage the challenge passwords using Microsoft Intune. For more information, see [Using Connector for SCEP for Microsoft Intune](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlconnector-for-scep-intune.html).
    public enum MobileDeviceManagement {
        /// Configuration settings for use with Microsoft Intune. For information about using Connector for SCEP for Microsoft Intune, see [Using Connector for SCEP for Microsoft Intune](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlconnector-for-scep-intune.html).
        case intune(PcaConnectorScepClientTypes.IntuneConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension PcaConnectorScepClientTypes {
    /// Contains OpenID Connect (OIDC) parameters for use with Microsoft Intune. For more information about using Connector for SCEP for Microsoft Intune, see [Using Connector for SCEP for Microsoft Intune](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlconnector-for-scep-intune.html).
    public struct OpenIdConfiguration {
        /// The audience value to copy into your Microsoft Entra app registration's OIDC.
        public var audience: Swift.String?
        /// The issuer value to copy into your Microsoft Entra app registration's OIDC.
        public var issuer: Swift.String?
        /// The subject value to copy into your Microsoft Entra app registration's OIDC.
        public var subject: Swift.String?

        public init(
            audience: Swift.String? = nil,
            issuer: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.audience = audience
            self.issuer = issuer
            self.subject = subject
        }
    }

}

extension PcaConnectorScepClientTypes {

    public enum ConnectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PcaConnectorScepClientTypes {

    public enum ConnectorStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalFailure
        case privatecaAccessDenied
        case privatecaInvalidState
        case privatecaResourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorStatusReason] {
            return [
                .internalFailure,
                .privatecaAccessDenied,
                .privatecaInvalidState,
                .privatecaResourceNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .privatecaAccessDenied: return "PRIVATECA_ACCESS_DENIED"
            case .privatecaInvalidState: return "PRIVATECA_INVALID_STATE"
            case .privatecaResourceNotFound: return "PRIVATECA_RESOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PcaConnectorScepClientTypes {

    public enum ConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case generalPurpose
        case intune
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorType] {
            return [
                .generalPurpose,
                .intune
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .generalPurpose: return "GENERAL_PURPOSE"
            case .intune: return "INTUNE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PcaConnectorScepClientTypes {
    /// Connector for SCEP is a service that links Amazon Web Services Private Certificate Authority to your SCEP-enabled devices. The connector brokers the exchange of certificates from Amazon Web Services Private CA to your SCEP-enabled devices and mobile device management systems. The connector is a complex type that contains the connector's configuration settings.
    public struct Connector {
        /// The Amazon Resource Name (ARN) of the connector.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate authority associated with the connector.
        public var certificateAuthorityArn: Swift.String?
        /// The date and time that the connector was created.
        public var createdAt: Foundation.Date?
        /// The connector's HTTPS public SCEP URL.
        public var endpoint: Swift.String?
        /// Contains settings relevant to the mobile device management system that you chose for the connector. If you didn't configure MobileDeviceManagement, then the connector is for general-purpose use and this object is empty.
        public var mobileDeviceManagement: PcaConnectorScepClientTypes.MobileDeviceManagement?
        /// Contains OpenID Connect (OIDC) parameters for use with Connector for SCEP for Microsoft Intune. For more information about using Connector for SCEP for Microsoft Intune, see [Using Connector for SCEP for Microsoft Intune](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlconnector-for-scep-intune.html).
        public var openIdConfiguration: PcaConnectorScepClientTypes.OpenIdConfiguration?
        /// The connector's status.
        public var status: PcaConnectorScepClientTypes.ConnectorStatus?
        /// Information about why connector creation failed, if status is FAILED.
        public var statusReason: PcaConnectorScepClientTypes.ConnectorStatusReason?
        /// The connector type.
        public var type: PcaConnectorScepClientTypes.ConnectorType?
        /// The date and time that the connector was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            certificateAuthorityArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            endpoint: Swift.String? = nil,
            mobileDeviceManagement: PcaConnectorScepClientTypes.MobileDeviceManagement? = nil,
            openIdConfiguration: PcaConnectorScepClientTypes.OpenIdConfiguration? = nil,
            status: PcaConnectorScepClientTypes.ConnectorStatus? = nil,
            statusReason: PcaConnectorScepClientTypes.ConnectorStatusReason? = nil,
            type: PcaConnectorScepClientTypes.ConnectorType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.endpoint = endpoint
            self.mobileDeviceManagement = mobileDeviceManagement
            self.openIdConfiguration = openIdConfiguration
            self.status = status
            self.statusReason = statusReason
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension PcaConnectorScepClientTypes {
    /// Lists the Amazon Web Services Private CA SCEP connectors belonging to your Amazon Web Services account.
    public struct ConnectorSummary {
        /// The Amazon Resource Name (ARN) of the connector.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the connector's associated certificate authority.
        public var certificateAuthorityArn: Swift.String?
        /// The date and time that the challenge was created.
        public var createdAt: Foundation.Date?
        /// The connector's HTTPS public SCEP URL.
        public var endpoint: Swift.String?
        /// Contains settings relevant to the mobile device management system that you chose for the connector. If you didn't configure MobileDeviceManagement, then the connector is for general-purpose use and this object is empty.
        public var mobileDeviceManagement: PcaConnectorScepClientTypes.MobileDeviceManagement?
        /// Contains OpenID Connect (OIDC) parameters for use with Microsoft Intune.
        public var openIdConfiguration: PcaConnectorScepClientTypes.OpenIdConfiguration?
        /// The connector's status. Status can be creating, active, deleting, or failed.
        public var status: PcaConnectorScepClientTypes.ConnectorStatus?
        /// Information about why connector creation failed, if status is FAILED.
        public var statusReason: PcaConnectorScepClientTypes.ConnectorStatusReason?
        /// The connector type.
        public var type: PcaConnectorScepClientTypes.ConnectorType?
        /// The date and time that the challenge was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            certificateAuthorityArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            endpoint: Swift.String? = nil,
            mobileDeviceManagement: PcaConnectorScepClientTypes.MobileDeviceManagement? = nil,
            openIdConfiguration: PcaConnectorScepClientTypes.OpenIdConfiguration? = nil,
            status: PcaConnectorScepClientTypes.ConnectorStatus? = nil,
            statusReason: PcaConnectorScepClientTypes.ConnectorStatusReason? = nil,
            type: PcaConnectorScepClientTypes.ConnectorType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.endpoint = endpoint
            self.mobileDeviceManagement = mobileDeviceManagement
            self.openIdConfiguration = openIdConfiguration
            self.status = status
            self.statusReason = statusReason
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

public struct CreateConnectorInput {
    /// The Amazon Resource Name (ARN) of the Amazon Web Services Private Certificate Authority certificate authority to use with this connector. Due to security vulnerabilities present in the SCEP protocol, we recommend using a private CA that's dedicated for use with the connector. To retrieve the private CAs associated with your account, you can call [ListCertificateAuthorities](https://docs.aws.amazon.com/privateca/latest/APIReference/API_ListCertificateAuthorities.html) using the Amazon Web Services Private CA API.
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// Custom string that can be used to distinguish between calls to the [CreateChallenge](https://docs.aws.amazon.com/C4SCEP_API/pca-connector-scep/latest/APIReference/API_CreateChallenge.html) action. Client tokens for CreateChallenge time out after five minutes. Therefore, if you call CreateChallenge multiple times with the same client token within five minutes, Connector for SCEP recognizes that you are requesting only one challenge and will only respond with one. If you change the client token for each call, Connector for SCEP recognizes that you are requesting multiple challenge passwords.
    public var clientToken: Swift.String?
    /// If you don't supply a value, by default Connector for SCEP creates a connector for general-purpose use. A general-purpose connector is designed to work with clients or endpoints that support the SCEP protocol, except Connector for SCEP for Microsoft Intune. With connectors for general-purpose use, you manage SCEP challenge passwords using Connector for SCEP. For information about considerations and limitations with using Connector for SCEP, see [Considerations and Limitations](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlc4scep-considerations-limitations.html). If you provide an IntuneConfiguration, Connector for SCEP creates a connector for use with Microsoft Intune, and you manage the challenge passwords using Microsoft Intune. For more information, see [Using Connector for SCEP for Microsoft Intune](https://docs.aws.amazon.com/privateca/latest/userguide/scep-connector.htmlconnector-for-scep-intune.html).
    public var mobileDeviceManagement: PcaConnectorScepClientTypes.MobileDeviceManagement?
    /// The key-value pairs to associate with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        certificateAuthorityArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        mobileDeviceManagement: PcaConnectorScepClientTypes.MobileDeviceManagement? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.clientToken = clientToken
        self.mobileDeviceManagement = mobileDeviceManagement
        self.tags = tags
    }
}

public struct CreateConnectorOutput {
    /// Returns the Amazon Resource Name (ARN) of the connector.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

public struct DeleteConnectorInput {
    /// The Amazon Resource Name (ARN) of the connector to delete.
    /// This member is required.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

public struct GetConnectorInput {
    /// The Amazon Resource Name (ARN) of the connector.
    /// This member is required.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

public struct GetConnectorOutput {
    /// The properties of the connector.
    public var connector: PcaConnectorScepClientTypes.Connector?

    public init(
        connector: PcaConnectorScepClientTypes.Connector? = nil
    )
    {
        self.connector = connector
    }
}

public struct ListConnectorsInput {
    /// The maximum number of objects that you want Connector for SCEP to return for this request. If more objects are available, in the response, Connector for SCEP provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Connector for SCEP returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorsOutput {
    /// The connectors belonging to your Amazon Web Services account.
    public var connectors: [PcaConnectorScepClientTypes.ConnectorSummary]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Connector for SCEP returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        connectors: [PcaConnectorScepClientTypes.ConnectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value pairs to associate with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies a list of tag keys that you want to remove from the specified resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension CreateChallengeInput {

    static func urlPathProvider(_ value: CreateChallengeInput) -> Swift.String? {
        return "/challenges"
    }
}

extension CreateConnectorInput {

    static func urlPathProvider(_ value: CreateConnectorInput) -> Swift.String? {
        return "/connectors"
    }
}

extension DeleteChallengeInput {

    static func urlPathProvider(_ value: DeleteChallengeInput) -> Swift.String? {
        guard let challengeArn = value.challengeArn else {
            return nil
        }
        return "/challenges/\(challengeArn.urlPercentEncoding())"
    }
}

extension DeleteConnectorInput {

    static func urlPathProvider(_ value: DeleteConnectorInput) -> Swift.String? {
        guard let connectorArn = value.connectorArn else {
            return nil
        }
        return "/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

extension GetChallengeMetadataInput {

    static func urlPathProvider(_ value: GetChallengeMetadataInput) -> Swift.String? {
        guard let challengeArn = value.challengeArn else {
            return nil
        }
        return "/challengeMetadata/\(challengeArn.urlPercentEncoding())"
    }
}

extension GetChallengePasswordInput {

    static func urlPathProvider(_ value: GetChallengePasswordInput) -> Swift.String? {
        guard let challengeArn = value.challengeArn else {
            return nil
        }
        return "/challengePasswords/\(challengeArn.urlPercentEncoding())"
    }
}

extension GetConnectorInput {

    static func urlPathProvider(_ value: GetConnectorInput) -> Swift.String? {
        guard let connectorArn = value.connectorArn else {
            return nil
        }
        return "/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

extension ListChallengeMetadataInput {

    static func urlPathProvider(_ value: ListChallengeMetadataInput) -> Swift.String? {
        return "/challengeMetadata"
    }
}

extension ListChallengeMetadataInput {

    static func queryItemProvider(_ value: ListChallengeMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let connectorArn = value.connectorArn else {
            let message = "Creating a URL Query Item failed. connectorArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let connectorArnQueryItem = Smithy.URIQueryItem(name: "ConnectorArn".urlPercentEncoding(), value: Swift.String(connectorArn).urlPercentEncoding())
        items.append(connectorArnQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/connectors"
    }
}

extension ListConnectorsInput {

    static func queryItemProvider(_ value: ListConnectorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CreateChallengeInput {

    static func write(value: CreateChallengeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectorArn"].write(value.connectorArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConnectorInput {

    static func write(value: CreateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArn"].write(value.certificateAuthorityArn)
        try writer["ClientToken"].write(value.clientToken)
        try writer["MobileDeviceManagement"].write(value.mobileDeviceManagement, with: PcaConnectorScepClientTypes.MobileDeviceManagement.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateChallengeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChallengeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChallengeOutput()
        value.challenge = try reader["Challenge"].readIfPresent(with: PcaConnectorScepClientTypes.Challenge.read(from:))
        return value
    }
}

extension CreateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorOutput()
        value.connectorArn = try reader["ConnectorArn"].readIfPresent()
        return value
    }
}

extension DeleteChallengeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChallengeOutput {
        return DeleteChallengeOutput()
    }
}

extension DeleteConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorOutput {
        return DeleteConnectorOutput()
    }
}

extension GetChallengeMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChallengeMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChallengeMetadataOutput()
        value.challengeMetadata = try reader["ChallengeMetadata"].readIfPresent(with: PcaConnectorScepClientTypes.ChallengeMetadata.read(from:))
        return value
    }
}

extension GetChallengePasswordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChallengePasswordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChallengePasswordOutput()
        value.password = try reader["Password"].readIfPresent()
        return value
    }
}

extension GetConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorOutput()
        value.connector = try reader["Connector"].readIfPresent(with: PcaConnectorScepClientTypes.Connector.read(from:))
        return value
    }
}

extension ListChallengeMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChallengeMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChallengeMetadataOutput()
        value.challenges = try reader["Challenges"].readListIfPresent(memberReadingClosure: PcaConnectorScepClientTypes.ChallengeMetadataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorsOutput()
        value.connectors = try reader["Connectors"].readListIfPresent(memberReadingClosure: PcaConnectorScepClientTypes.ConnectorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateChallengeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChallengeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChallengeMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChallengePasswordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChallengeMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PcaConnectorScepClientTypes.Challenge {

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.Challenge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.Challenge()
        value.arn = try reader["Arn"].readIfPresent()
        value.connectorArn = try reader["ConnectorArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.password = try reader["Password"].readIfPresent()
        return value
    }
}

extension PcaConnectorScepClientTypes.ChallengeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.ChallengeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.ChallengeMetadata()
        value.arn = try reader["Arn"].readIfPresent()
        value.connectorArn = try reader["ConnectorArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PcaConnectorScepClientTypes.Connector {

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.Connector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.Connector()
        value.arn = try reader["Arn"].readIfPresent()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.mobileDeviceManagement = try reader["MobileDeviceManagement"].readIfPresent(with: PcaConnectorScepClientTypes.MobileDeviceManagement.read(from:))
        value.openIdConfiguration = try reader["OpenIdConfiguration"].readIfPresent(with: PcaConnectorScepClientTypes.OpenIdConfiguration.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PcaConnectorScepClientTypes.OpenIdConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.OpenIdConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.OpenIdConfiguration()
        value.issuer = try reader["Issuer"].readIfPresent()
        value.subject = try reader["Subject"].readIfPresent()
        value.audience = try reader["Audience"].readIfPresent()
        return value
    }
}

extension PcaConnectorScepClientTypes.MobileDeviceManagement {

    static func write(value: PcaConnectorScepClientTypes.MobileDeviceManagement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .intune(intune):
                try writer["Intune"].write(intune, with: PcaConnectorScepClientTypes.IntuneConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.MobileDeviceManagement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Intune":
                return .intune(try reader["Intune"].read(with: PcaConnectorScepClientTypes.IntuneConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PcaConnectorScepClientTypes.IntuneConfiguration {

    static func write(value: PcaConnectorScepClientTypes.IntuneConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AzureApplicationId"].write(value.azureApplicationId)
        try writer["Domain"].write(value.domain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.IntuneConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.IntuneConfiguration()
        value.azureApplicationId = try reader["AzureApplicationId"].readIfPresent() ?? ""
        value.domain = try reader["Domain"].readIfPresent() ?? ""
        return value
    }
}

extension PcaConnectorScepClientTypes.ChallengeMetadataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.ChallengeMetadataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.ChallengeMetadataSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.connectorArn = try reader["ConnectorArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PcaConnectorScepClientTypes.ConnectorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PcaConnectorScepClientTypes.ConnectorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PcaConnectorScepClientTypes.ConnectorSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.mobileDeviceManagement = try reader["MobileDeviceManagement"].readIfPresent(with: PcaConnectorScepClientTypes.MobileDeviceManagement.read(from:))
        value.openIdConfiguration = try reader["OpenIdConfiguration"].readIfPresent(with: PcaConnectorScepClientTypes.OpenIdConfiguration.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

public enum PcaConnectorScepClientTypes {}
