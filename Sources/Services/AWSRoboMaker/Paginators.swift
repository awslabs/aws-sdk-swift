// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RoboMakerClient {
    /// Paginate over `[ListDeploymentJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDeploymentJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentJobsOutputResponse`
    public func listDeploymentJobsPaginated(input: ListDeploymentJobsInput) -> ClientRuntime.PaginatorSequence<ListDeploymentJobsInput, ListDeploymentJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentJobsInput, ListDeploymentJobsOutputResponse>(input: input, inputKey: \ListDeploymentJobsInput.nextToken, outputKey: \ListDeploymentJobsOutputResponse.nextToken, paginationFunction: self.listDeploymentJobs(input:))
    }
}

extension ListDeploymentJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentJobsInput {
        return ListDeploymentJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDeploymentJobsInput, Output == ListDeploymentJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDeploymentJobsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.DeploymentJob]`
    /// - Returns: `[RoboMakerClientTypes.DeploymentJob]`
    public func deploymentJobs() async throws -> [RoboMakerClientTypes.DeploymentJob] {
        return try await self.asyncCompactMap { item in item.deploymentJobs }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListFleetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFleetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFleetsOutputResponse`
    public func listFleetsPaginated(input: ListFleetsInput) -> ClientRuntime.PaginatorSequence<ListFleetsInput, ListFleetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFleetsInput, ListFleetsOutputResponse>(input: input, inputKey: \ListFleetsInput.nextToken, outputKey: \ListFleetsOutputResponse.nextToken, paginationFunction: self.listFleets(input:))
    }
}

extension ListFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFleetsInput {
        return ListFleetsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFleetsInput, Output == ListFleetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFleetsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.Fleet]`
    /// - Returns: `[RoboMakerClientTypes.Fleet]`
    public func fleetDetails() async throws -> [RoboMakerClientTypes.Fleet] {
        return try await self.asyncCompactMap { item in item.fleetDetails }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListRobotApplicationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRobotApplicationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRobotApplicationsOutputResponse`
    public func listRobotApplicationsPaginated(input: ListRobotApplicationsInput) -> ClientRuntime.PaginatorSequence<ListRobotApplicationsInput, ListRobotApplicationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRobotApplicationsInput, ListRobotApplicationsOutputResponse>(input: input, inputKey: \ListRobotApplicationsInput.nextToken, outputKey: \ListRobotApplicationsOutputResponse.nextToken, paginationFunction: self.listRobotApplications(input:))
    }
}

extension ListRobotApplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRobotApplicationsInput {
        return ListRobotApplicationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            versionQualifier: self.versionQualifier
        )}
}

extension PaginatorSequence where Input == ListRobotApplicationsInput, Output == ListRobotApplicationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRobotApplicationsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.RobotApplicationSummary]`
    /// - Returns: `[RoboMakerClientTypes.RobotApplicationSummary]`
    public func robotApplicationSummaries() async throws -> [RoboMakerClientTypes.RobotApplicationSummary] {
        return try await self.asyncCompactMap { item in item.robotApplicationSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListRobotsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRobotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRobotsOutputResponse`
    public func listRobotsPaginated(input: ListRobotsInput) -> ClientRuntime.PaginatorSequence<ListRobotsInput, ListRobotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRobotsInput, ListRobotsOutputResponse>(input: input, inputKey: \ListRobotsInput.nextToken, outputKey: \ListRobotsOutputResponse.nextToken, paginationFunction: self.listRobots(input:))
    }
}

extension ListRobotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRobotsInput {
        return ListRobotsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRobotsInput, Output == ListRobotsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRobotsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.Robot]`
    /// - Returns: `[RoboMakerClientTypes.Robot]`
    public func robots() async throws -> [RoboMakerClientTypes.Robot] {
        return try await self.asyncCompactMap { item in item.robots }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListSimulationApplicationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSimulationApplicationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSimulationApplicationsOutputResponse`
    public func listSimulationApplicationsPaginated(input: ListSimulationApplicationsInput) -> ClientRuntime.PaginatorSequence<ListSimulationApplicationsInput, ListSimulationApplicationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSimulationApplicationsInput, ListSimulationApplicationsOutputResponse>(input: input, inputKey: \ListSimulationApplicationsInput.nextToken, outputKey: \ListSimulationApplicationsOutputResponse.nextToken, paginationFunction: self.listSimulationApplications(input:))
    }
}

extension ListSimulationApplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSimulationApplicationsInput {
        return ListSimulationApplicationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            versionQualifier: self.versionQualifier
        )}
}

extension PaginatorSequence where Input == ListSimulationApplicationsInput, Output == ListSimulationApplicationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSimulationApplicationsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.SimulationApplicationSummary]`
    /// - Returns: `[RoboMakerClientTypes.SimulationApplicationSummary]`
    public func simulationApplicationSummaries() async throws -> [RoboMakerClientTypes.SimulationApplicationSummary] {
        return try await self.asyncCompactMap { item in item.simulationApplicationSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListSimulationJobBatchesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSimulationJobBatchesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSimulationJobBatchesOutputResponse`
    public func listSimulationJobBatchesPaginated(input: ListSimulationJobBatchesInput) -> ClientRuntime.PaginatorSequence<ListSimulationJobBatchesInput, ListSimulationJobBatchesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSimulationJobBatchesInput, ListSimulationJobBatchesOutputResponse>(input: input, inputKey: \ListSimulationJobBatchesInput.nextToken, outputKey: \ListSimulationJobBatchesOutputResponse.nextToken, paginationFunction: self.listSimulationJobBatches(input:))
    }
}

extension ListSimulationJobBatchesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSimulationJobBatchesInput {
        return ListSimulationJobBatchesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSimulationJobBatchesInput, Output == ListSimulationJobBatchesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSimulationJobBatchesPaginated`
    /// to access the nested member `[RoboMakerClientTypes.SimulationJobBatchSummary]`
    /// - Returns: `[RoboMakerClientTypes.SimulationJobBatchSummary]`
    public func simulationJobBatchSummaries() async throws -> [RoboMakerClientTypes.SimulationJobBatchSummary] {
        return try await self.asyncCompactMap { item in item.simulationJobBatchSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListSimulationJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSimulationJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSimulationJobsOutputResponse`
    public func listSimulationJobsPaginated(input: ListSimulationJobsInput) -> ClientRuntime.PaginatorSequence<ListSimulationJobsInput, ListSimulationJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSimulationJobsInput, ListSimulationJobsOutputResponse>(input: input, inputKey: \ListSimulationJobsInput.nextToken, outputKey: \ListSimulationJobsOutputResponse.nextToken, paginationFunction: self.listSimulationJobs(input:))
    }
}

extension ListSimulationJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSimulationJobsInput {
        return ListSimulationJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSimulationJobsInput, Output == ListSimulationJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSimulationJobsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.SimulationJobSummary]`
    /// - Returns: `[RoboMakerClientTypes.SimulationJobSummary]`
    public func simulationJobSummaries() async throws -> [RoboMakerClientTypes.SimulationJobSummary] {
        return try await self.asyncCompactMap { item in item.simulationJobSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListWorldExportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorldExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorldExportJobsOutputResponse`
    public func listWorldExportJobsPaginated(input: ListWorldExportJobsInput) -> ClientRuntime.PaginatorSequence<ListWorldExportJobsInput, ListWorldExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorldExportJobsInput, ListWorldExportJobsOutputResponse>(input: input, inputKey: \ListWorldExportJobsInput.nextToken, outputKey: \ListWorldExportJobsOutputResponse.nextToken, paginationFunction: self.listWorldExportJobs(input:))
    }
}

extension ListWorldExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorldExportJobsInput {
        return ListWorldExportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListWorldExportJobsInput, Output == ListWorldExportJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listWorldExportJobsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.WorldExportJobSummary]`
    /// - Returns: `[RoboMakerClientTypes.WorldExportJobSummary]`
    public func worldExportJobSummaries() async throws -> [RoboMakerClientTypes.WorldExportJobSummary] {
        return try await self.asyncCompactMap { item in item.worldExportJobSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListWorldGenerationJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorldGenerationJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorldGenerationJobsOutputResponse`
    public func listWorldGenerationJobsPaginated(input: ListWorldGenerationJobsInput) -> ClientRuntime.PaginatorSequence<ListWorldGenerationJobsInput, ListWorldGenerationJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorldGenerationJobsInput, ListWorldGenerationJobsOutputResponse>(input: input, inputKey: \ListWorldGenerationJobsInput.nextToken, outputKey: \ListWorldGenerationJobsOutputResponse.nextToken, paginationFunction: self.listWorldGenerationJobs(input:))
    }
}

extension ListWorldGenerationJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorldGenerationJobsInput {
        return ListWorldGenerationJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListWorldGenerationJobsInput, Output == ListWorldGenerationJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listWorldGenerationJobsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.WorldGenerationJobSummary]`
    /// - Returns: `[RoboMakerClientTypes.WorldGenerationJobSummary]`
    public func worldGenerationJobSummaries() async throws -> [RoboMakerClientTypes.WorldGenerationJobSummary] {
        return try await self.asyncCompactMap { item in item.worldGenerationJobSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListWorldsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorldsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorldsOutputResponse`
    public func listWorldsPaginated(input: ListWorldsInput) -> ClientRuntime.PaginatorSequence<ListWorldsInput, ListWorldsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorldsInput, ListWorldsOutputResponse>(input: input, inputKey: \ListWorldsInput.nextToken, outputKey: \ListWorldsOutputResponse.nextToken, paginationFunction: self.listWorlds(input:))
    }
}

extension ListWorldsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorldsInput {
        return ListWorldsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListWorldsInput, Output == ListWorldsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listWorldsPaginated`
    /// to access the nested member `[RoboMakerClientTypes.WorldSummary]`
    /// - Returns: `[RoboMakerClientTypes.WorldSummary]`
    public func worldSummaries() async throws -> [RoboMakerClientTypes.WorldSummary] {
        return try await self.asyncCompactMap { item in item.worldSummaries }
    }
}
extension RoboMakerClient {
    /// Paginate over `[ListWorldTemplatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorldTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorldTemplatesOutputResponse`
    public func listWorldTemplatesPaginated(input: ListWorldTemplatesInput) -> ClientRuntime.PaginatorSequence<ListWorldTemplatesInput, ListWorldTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorldTemplatesInput, ListWorldTemplatesOutputResponse>(input: input, inputKey: \ListWorldTemplatesInput.nextToken, outputKey: \ListWorldTemplatesOutputResponse.nextToken, paginationFunction: self.listWorldTemplates(input:))
    }
}

extension ListWorldTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorldTemplatesInput {
        return ListWorldTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListWorldTemplatesInput, Output == ListWorldTemplatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listWorldTemplatesPaginated`
    /// to access the nested member `[RoboMakerClientTypes.TemplateSummary]`
    /// - Returns: `[RoboMakerClientTypes.TemplateSummary]`
    public func templateSummaries() async throws -> [RoboMakerClientTypes.TemplateSummary] {
        return try await self.asyncCompactMap { item in item.templateSummaries }
    }
}
