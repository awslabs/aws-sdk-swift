//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension RoboMakerClientTypes {

    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arm64
        case armhf
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .armhf,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .armhf: return "ARMHF"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// AWS RoboMaker experienced a service issue. Try your call again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A parameter specified in a request is not valid, is unsupported, or cannot be used. The returned message provides an explanation of the error value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// AWS RoboMaker is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchDeleteWorldsInput {
    /// A list of Amazon Resource Names (arns) that correspond to worlds to delete.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init(
        worlds: [Swift.String]? = nil
    )
    {
        self.worlds = worlds
    }
}

public struct BatchDeleteWorldsOutput {
    /// A list of unprocessed worlds associated with the call. These worlds were not deleted.
    public var unprocessedWorlds: [Swift.String]?

    public init(
        unprocessedWorlds: [Swift.String]? = nil
    )
    {
        self.unprocessedWorlds = unprocessedWorlds
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchDescribeSimulationJobInput {
    /// A list of Amazon Resource Names (ARNs) of simulation jobs to describe.
    /// This member is required.
    public var jobs: [Swift.String]?

    public init(
        jobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
    }
}

extension RoboMakerClientTypes {

    public enum ComputeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cpu
        case gpuAndCpu
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeType] {
            return [
                .cpu,
                .gpuAndCpu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cpu: return "CPU"
            case .gpuAndCpu: return "GPU_AND_CPU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job
    public struct ComputeResponse {
        /// Compute type response information for the simulation job.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public var gpuUnitLimit: Swift.Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init(
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            gpuUnitLimit: Swift.Int? = nil,
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about S3 keys.
    public struct S3KeyOutput {
        /// The etag for the object.
        public var etag: Swift.String?
        /// The S3 key.
        public var s3Key: Swift.String?

        public init(
            etag: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.etag = etag
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes {

    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archive
        case file
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .archive,
                .file,
                .prefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archive: return "Archive"
            case .file: return "File"
            case .prefix: return "Prefix"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSource {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public var destination: Swift.String?
        /// The name of the data source.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        public var s3Keys: [RoboMakerClientTypes.S3KeyOutput]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public var type: RoboMakerClientTypes.DataSourceType?

        public init(
            destination: Swift.String? = nil,
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [RoboMakerClientTypes.S3KeyOutput]? = nil,
            type: RoboMakerClientTypes.DataSourceType? = nil
        )
        {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }
    }

}

extension RoboMakerClientTypes {

    public enum FailureBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `continue`
        case fail
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureBehavior] {
            return [
                .continue,
                .fail
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continue: return "Continue"
            case .fail: return "Fail"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {

    public enum SimulationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badpermissionscloudwatchlogs
        case badpermissionsrobotapplication
        case badpermissionss3object
        case badpermissionss3output
        case badpermissionssimulationapplication
        case badpermissionsusercredentials
        case batchcanceled
        case batchtimedout
        case enilimitexceeded
        case internalserviceerror
        case invalidbundlerobotapplication
        case invalidbundlesimulationapplication
        case invalidinput
        case invalids3resource
        case limitexceeded
        case mismatchedetag
        case requestthrottled
        case resourcenotfound
        case robotapplicationcrash
        case robotapplicationhealthcheckfailure
        case robotapplicationversionmismatchedetag
        case simulationapplicationcrash
        case simulationapplicationhealthcheckfailure
        case simulationapplicationversionmismatchedetag
        case subnetiplimitexceeded
        case throttlingerror
        case uploadcontentmismatcherror
        case wrongregionrobotapplication
        case wrongregions3bucket
        case wrongregions3output
        case wrongregionsimulationapplication
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobErrorCode] {
            return [
                .badpermissionscloudwatchlogs,
                .badpermissionsrobotapplication,
                .badpermissionss3object,
                .badpermissionss3output,
                .badpermissionssimulationapplication,
                .badpermissionsusercredentials,
                .batchcanceled,
                .batchtimedout,
                .enilimitexceeded,
                .internalserviceerror,
                .invalidbundlerobotapplication,
                .invalidbundlesimulationapplication,
                .invalidinput,
                .invalids3resource,
                .limitexceeded,
                .mismatchedetag,
                .requestthrottled,
                .resourcenotfound,
                .robotapplicationcrash,
                .robotapplicationhealthcheckfailure,
                .robotapplicationversionmismatchedetag,
                .simulationapplicationcrash,
                .simulationapplicationhealthcheckfailure,
                .simulationapplicationversionmismatchedetag,
                .subnetiplimitexceeded,
                .throttlingerror,
                .uploadcontentmismatcherror,
                .wrongregionrobotapplication,
                .wrongregions3bucket,
                .wrongregions3output,
                .wrongregionsimulationapplication
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badpermissionscloudwatchlogs: return "BadPermissionsCloudwatchLogs"
            case .badpermissionsrobotapplication: return "BadPermissionsRobotApplication"
            case .badpermissionss3object: return "BadPermissionsS3Object"
            case .badpermissionss3output: return "BadPermissionsS3Output"
            case .badpermissionssimulationapplication: return "BadPermissionsSimulationApplication"
            case .badpermissionsusercredentials: return "BadPermissionsUserCredentials"
            case .batchcanceled: return "BatchCanceled"
            case .batchtimedout: return "BatchTimedOut"
            case .enilimitexceeded: return "ENILimitExceeded"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidbundlerobotapplication: return "InvalidBundleRobotApplication"
            case .invalidbundlesimulationapplication: return "InvalidBundleSimulationApplication"
            case .invalidinput: return "InvalidInput"
            case .invalids3resource: return "InvalidS3Resource"
            case .limitexceeded: return "LimitExceeded"
            case .mismatchedetag: return "MismatchedEtag"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotapplicationcrash: return "RobotApplicationCrash"
            case .robotapplicationhealthcheckfailure: return "RobotApplicationHealthCheckFailure"
            case .robotapplicationversionmismatchedetag: return "RobotApplicationVersionMismatchedEtag"
            case .simulationapplicationcrash: return "SimulationApplicationCrash"
            case .simulationapplicationhealthcheckfailure: return "SimulationApplicationHealthCheckFailure"
            case .simulationapplicationversionmismatchedetag: return "SimulationApplicationVersionMismatchedEtag"
            case .subnetiplimitexceeded: return "SubnetIpLimitExceeded"
            case .throttlingerror: return "ThrottlingError"
            case .uploadcontentmismatcherror: return "UploadContentMismatchError"
            case .wrongregionrobotapplication: return "WrongRegionRobotApplication"
            case .wrongregions3bucket: return "WrongRegionS3Bucket"
            case .wrongregions3output: return "WrongRegionS3Output"
            case .wrongregionsimulationapplication: return "WrongRegionSimulationApplication"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// The logging configuration.
    public struct LoggingConfig {
        /// A boolean indicating whether to record all ROS topics. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var recordAllRosTopics: Swift.Bool?

        public init(
            recordAllRosTopics: Swift.Bool? = nil
        )
        {
            self.recordAllRosTopics = recordAllRosTopics
        }
    }

}

extension RoboMakerClientTypes {
    /// Describes a network interface.
    public struct NetworkInterface {
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The IPv4 public address of the network interface.
        public var publicIpAddress: Swift.String?

        public init(
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }
    }

}

extension RoboMakerClientTypes {
    /// The output location.
    public struct OutputLocation {
        /// The S3 bucket for output.
        public var s3Bucket: Swift.String?
        /// The S3 folder in the s3Bucket where output files will be placed.
        public var s3Prefix: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension RoboMakerClientTypes {
    /// An object representing a port mapping.
    public struct PortMapping {
        /// The port number on the application.
        /// This member is required.
        public var applicationPort: Swift.Int?
        /// A Boolean indicating whether to enable this port mapping on public IP.
        public var enableOnPublicIp: Swift.Bool
        /// The port number on the simulation job instance to use as a remote connection point.
        /// This member is required.
        public var jobPort: Swift.Int?

        public init(
            applicationPort: Swift.Int? = nil,
            enableOnPublicIp: Swift.Bool = false,
            jobPort: Swift.Int? = nil
        )
        {
            self.applicationPort = applicationPort
            self.enableOnPublicIp = enableOnPublicIp
            self.jobPort = jobPort
        }
    }

}

extension RoboMakerClientTypes {
    /// Configuration information for port forwarding.
    public struct PortForwardingConfig {
        /// The port mappings for the configuration.
        public var portMappings: [RoboMakerClientTypes.PortMapping]?

        public init(
            portMappings: [RoboMakerClientTypes.PortMapping]? = nil
        )
        {
            self.portMappings = portMappings
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a launch configuration.
    public struct LaunchConfig {
        /// If you've specified General as the value for your RobotSoftwareSuite, you can use this field to specify a list of commands for your container image. If you've specified SimulationRuntime as the value for your SimulationSoftwareSuite, you can use this field to specify a list of commands for your container image.
        public var command: [Swift.String]?
        /// The environment variables for the application launch.
        public var environmentVariables: [Swift.String: Swift.String]?
        /// The launch file name.
        public var launchFile: Swift.String?
        /// The package name.
        public var packageName: Swift.String?
        /// The port forwarding configuration.
        public var portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig?
        /// Boolean indicating whether a streaming session will be configured for the application. If True, AWS RoboMaker will configure a connection so you can interact with your application as it is running in the simulation. You must configure and launch the component. It must have a graphical user interface.
        public var streamUI: Swift.Bool

        public init(
            command: [Swift.String]? = nil,
            environmentVariables: [Swift.String: Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig? = nil,
            streamUI: Swift.Bool = false
        )
        {
            self.command = command
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.portForwardingConfig = portForwardingConfig
            self.streamUI = streamUI
        }
    }

}

extension RoboMakerClientTypes {

    public enum ExitBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case restart
        case sdkUnknown(Swift.String)

        public static var allCases: [ExitBehavior] {
            return [
                .fail,
                .restart
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .restart: return "RESTART"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about a tool. Tools are used in a simulation job.
    public struct Tool {
        /// Command-line arguments for the tool. It must include the tool executable name.
        /// This member is required.
        public var command: Swift.String?
        /// Exit behavior determines what happens when your tool quits running. RESTART will cause your tool to be restarted. FAIL will cause your job to exit. The default is RESTART.
        public var exitBehavior: RoboMakerClientTypes.ExitBehavior?
        /// The name of the tool.
        /// This member is required.
        public var name: Swift.String?
        /// Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default is False.
        public var streamOutputToCloudWatch: Swift.Bool?
        /// Boolean indicating whether a streaming session will be configured for the tool. If True, AWS RoboMaker will configure a connection so you can interact with the tool as it is running in the simulation. It must have a graphical user interface. The default is False.
        public var streamUI: Swift.Bool?

        public init(
            command: Swift.String? = nil,
            exitBehavior: RoboMakerClientTypes.ExitBehavior? = nil,
            name: Swift.String? = nil,
            streamOutputToCloudWatch: Swift.Bool? = nil,
            streamUI: Swift.Bool? = nil
        )
        {
            self.command = command
            self.exitBehavior = exitBehavior
            self.name = name
            self.streamOutputToCloudWatch = streamOutputToCloudWatch
            self.streamUI = streamUI
        }
    }

}

extension RoboMakerClientTypes {

    public enum UploadBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case uploadOnTerminate
        case uploadRollingAutoRemove
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadBehavior] {
            return [
                .uploadOnTerminate,
                .uploadRollingAutoRemove
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .uploadOnTerminate: return "UPLOAD_ON_TERMINATE"
            case .uploadRollingAutoRemove: return "UPLOAD_ROLLING_AUTO_REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Provides upload configuration information. Files are uploaded from the simulation job to a location you specify.
    public struct UploadConfiguration {
        /// A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the simulation output location to determine the final path. For example, if your simulation output location is s3://my-bucket and your upload configuration name is robot-test, your files will be uploaded to s3://my-bucket///robot-test.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the path of the file(s) to upload. Standard Unix glob matching rules are accepted, with the addition of ** as a super asterisk. For example, specifying /var/log/**.log causes all .log files in the /var/log directory tree to be collected. For more examples, see [Glob Library](https://github.com/gobwas/glob).
        /// This member is required.
        public var path: Swift.String?
        /// Specifies when to upload the files: UPLOAD_ON_TERMINATE Matching files are uploaded once the simulation enters the TERMINATING state. Matching files are not uploaded until all of your code (including tools) have stopped. If there is a problem uploading a file, the upload is retried. If problems persist, no further upload attempts will be made. UPLOAD_ROLLING_AUTO_REMOVE Matching files are uploaded as they are created. They are deleted after they are uploaded. The specified path is checked every 5 seconds. A final check is made when all of your code (including tools) have stopped.
        /// This member is required.
        public var uploadBehavior: RoboMakerClientTypes.UploadBehavior?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            uploadBehavior: RoboMakerClientTypes.UploadBehavior? = nil
        )
        {
            self.name = name
            self.path = path
            self.uploadBehavior = uploadBehavior
        }
    }

}

extension RoboMakerClientTypes {
    /// Application configuration information for a robot.
    public struct RobotApplicationConfig {
        /// The application information for the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the robot application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the robot application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the robot application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// The upload configurations for the robot application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default robot application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultUploadConfigurations: Swift.Bool?

        public init(
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
        }
    }

}

extension RoboMakerClientTypes {
    /// Configuration information for a world.
    public struct WorldConfig {
        /// The world generated by Simulation WorldForge.
        public var world: Swift.String?

        public init(
            world: Swift.String? = nil
        )
        {
            self.world = world
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a simulation application configuration.
    public struct SimulationApplicationConfig {
        /// The application information for the simulation application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the simulation application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the simulation application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the simulation application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// Information about upload configurations for the simulation application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default simulation application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultUploadConfigurations: Swift.Bool?
        /// A list of world configurations.
        public var worldConfigs: [RoboMakerClientTypes.WorldConfig]?

        public init(
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil,
            worldConfigs: [RoboMakerClientTypes.WorldConfig]? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
            self.worldConfigs = worldConfigs
        }
    }

}

extension RoboMakerClientTypes {

    public enum SimulationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case pending
        case preparing
        case restarting
        case running
        case runningfailed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .pending,
                .preparing,
                .restarting,
                .running,
                .runningfailed,
                .terminated,
                .terminating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .restarting: return "Restarting"
            case .running: return "Running"
            case .runningfailed: return "RunningFailed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// VPC configuration associated with your simulation job.
    public struct VPCConfigResponse {
        /// A boolean indicating if a public IP was assigned.
        public var assignPublicIp: Swift.Bool
        /// A list of security group IDs associated with the simulation job.
        public var securityGroups: [Swift.String]?
        /// A list of subnet IDs associated with the simulation job.
        public var subnets: [Swift.String]?
        /// The VPC ID associated with your simulation job.
        public var vpcId: Swift.String?

        public init(
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a simulation job.
    public struct SimulationJob {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// A unique identifier for this SimulationJob request.
        public var clientRequestToken: Swift.String?
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.ComputeResponse?
        /// The data sources for the simulation job.
        public var dataSources: [RoboMakerClientTypes.DataSource]?
        /// The failure behavior the simulation job. Continue Leaves the host running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The failure code of the simulation job if it failed.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The reason why the simulation job failed.
        public var failureReason: Swift.String?
        /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public var iamRole: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job was last started.
        public var lastStartedAt: Foundation.Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        public var maxJobDurationInSeconds: Swift.Int
        /// The name of the simulation job.
        public var name: Swift.String?
        /// Information about a network interface.
        public var networkInterface: RoboMakerClientTypes.NetworkInterface?
        /// Location for output files generated by the simulation job.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// A list of robot applications.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// A list of simulation applications.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public var simulationTimeMillis: Swift.Int
        /// Status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the simulation job.
        public var tags: [Swift.String: Swift.String]?
        /// VPC configuration information.
        public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

        public init(
            arn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            compute: RoboMakerClientTypes.ComputeResponse? = nil,
            dataSources: [RoboMakerClientTypes.DataSource]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            lastStartedAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            name: Swift.String? = nil,
            networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            simulationTimeMillis: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
        )
        {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.name = name
            self.networkInterface = networkInterface
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }
    }

}

public struct BatchDescribeSimulationJobOutput {
    /// A list of simulation jobs.
    public var jobs: [RoboMakerClientTypes.SimulationJob]?
    /// A list of unprocessed simulation job Amazon Resource Names (ARNs).
    public var unprocessedJobs: [Swift.String]?

    public init(
        jobs: [RoboMakerClientTypes.SimulationJob]? = nil,
        unprocessedJobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
        self.unprocessedJobs = unprocessedJobs
    }
}

extension RoboMakerClientTypes {
    /// Information about the batch policy.
    public struct BatchPolicy {
        /// The number of active simulation jobs create as part of the batch that can be in an active state at the same time. Active states include: Pending,Preparing, Running, Restarting, RunningFailed and Terminating. All other states are terminal states.
        public var maxConcurrency: Swift.Int?
        /// The amount of time, in seconds, to wait for the batch to complete. If a batch times out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), they will be moved to the failed list and the batch status will be Failed. If the pending requests were failing for any other reason, the failed pending requests will be moved to the failed list and the batch status will be TimedOut.
        public var timeoutInSeconds: Swift.Int?

        public init(
            maxConcurrency: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.maxConcurrency = maxConcurrency
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CancelDeploymentJobInput {
    /// The deployment job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CancelDeploymentJobOutput {

    public init() { }
}

public struct CancelSimulationJobInput {
    /// The simulation job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

public struct CancelSimulationJobOutput {

    public init() { }
}

public struct CancelSimulationJobBatchInput {
    /// The id of the batch to cancel.
    /// This member is required.
    public var batch: Swift.String?

    public init(
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

public struct CancelSimulationJobBatchOutput {

    public init() { }
}

public struct CancelWorldExportJobInput {
    /// The Amazon Resource Name (arn) of the world export job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

public struct CancelWorldExportJobOutput {

    public init() { }
}

public struct CancelWorldGenerationJobInput {
    /// The Amazon Resource Name (arn) of the world generator job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

public struct CancelWorldGenerationJobOutput {

    public init() { }
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job.
    public struct Compute {
        /// Compute type information for the simulation job.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public var gpuUnitLimit: Swift.Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init(
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            gpuUnitLimit: Swift.Int? = nil,
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

/// The failure percentage threshold percentage was met.
public struct ConcurrentDeploymentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentDeploymentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request uses the same client token as a previous, but non-identical request. Do not reuse a client token with different requests, unless the requests are identical.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for a deployment launch.
    public struct DeploymentLaunchConfig {
        /// An array of key/value pairs specifying environment variables for the robot application
        public var environmentVariables: [Swift.String: Swift.String]?
        /// The launch file name.
        /// This member is required.
        public var launchFile: Swift.String?
        /// The package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The deployment post-launch file. This file will be executed after the launch file.
        public var postLaunchFile: Swift.String?
        /// The deployment pre-launch file. This file will be executed prior to the launch file.
        public var preLaunchFile: Swift.String?

        public init(
            environmentVariables: [Swift.String: Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            postLaunchFile: Swift.String? = nil,
            preLaunchFile: Swift.String? = nil
        )
        {
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.postLaunchFile = postLaunchFile
            self.preLaunchFile = preLaunchFile
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a deployment application configuration.
    public struct DeploymentApplicationConfig {
        /// The Amazon Resource Name (ARN) of the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.String?
        /// The launch configuration.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig?

        public init(
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about an S3 object.
    public struct S3Object {
        /// The bucket containing the object.
        /// This member is required.
        public var bucket: Swift.String?
        /// The etag of the object.
        public var etag: Swift.String?
        /// The key of the object.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a deployment configuration.
    public struct DeploymentConfig {
        /// The percentage of robots receiving the deployment at the same time.
        public var concurrentDeploymentPercentage: Swift.Int?
        /// The download condition file.
        public var downloadConditionFile: RoboMakerClientTypes.S3Object?
        /// The percentage of deployments that need to fail before stopping deployment.
        public var failureThresholdPercentage: Swift.Int?
        /// The amount of time, in seconds, to wait for deployment to a single robot to complete. Choose a time between 1 minute and 7 days. The default is 5 hours.
        public var robotDeploymentTimeoutInSeconds: Swift.Int?

        public init(
            concurrentDeploymentPercentage: Swift.Int? = nil,
            downloadConditionFile: RoboMakerClientTypes.S3Object? = nil,
            failureThresholdPercentage: Swift.Int? = nil,
            robotDeploymentTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.concurrentDeploymentPercentage = concurrentDeploymentPercentage
            self.downloadConditionFile = downloadConditionFile
            self.failureThresholdPercentage = failureThresholdPercentage
            self.robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds
        }
    }

}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateDeploymentJobInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The deployment application configuration.
    /// This member is required.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The requested deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The Amazon Resource Name (ARN) of the fleet to deploy.
    /// This member is required.
    public var fleet: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the deployment job.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        fleet: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.fleet = fleet
        self.tags = tags
    }
}

extension RoboMakerClientTypes {

    public enum DeploymentJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badlambdaassociated
        case badpermissionerror
        case deploymentfleetdoesnotexist
        case downloadconditionfailed
        case environmentsetuperror
        case etagmismatch
        case extractingbundlefailure
        case failurethresholdbreached
        case fleetdeploymenttimeout
        case greengrassdeploymentfailed
        case greengrassgroupversiondoesnotexist
        case internalservererror
        case invalidgreengrassgroup
        case lambdadeleted
        case missingrobotapplicationarchitecture
        case missingrobotarchitecture
        case missingrobotdeploymentresource
        case postlaunchfilefailure
        case prelaunchfilefailure
        case resourcenotfound
        case robotagentconnectiontimeout
        case robotapplicationdoesnotexist
        case robotdeploymentaborted
        case robotdeploymentnoresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentJobErrorCode] {
            return [
                .badlambdaassociated,
                .badpermissionerror,
                .deploymentfleetdoesnotexist,
                .downloadconditionfailed,
                .environmentsetuperror,
                .etagmismatch,
                .extractingbundlefailure,
                .failurethresholdbreached,
                .fleetdeploymenttimeout,
                .greengrassdeploymentfailed,
                .greengrassgroupversiondoesnotexist,
                .internalservererror,
                .invalidgreengrassgroup,
                .lambdadeleted,
                .missingrobotapplicationarchitecture,
                .missingrobotarchitecture,
                .missingrobotdeploymentresource,
                .postlaunchfilefailure,
                .prelaunchfilefailure,
                .resourcenotfound,
                .robotagentconnectiontimeout,
                .robotapplicationdoesnotexist,
                .robotdeploymentaborted,
                .robotdeploymentnoresponse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badlambdaassociated: return "BadLambdaAssociated"
            case .badpermissionerror: return "BadPermissionError"
            case .deploymentfleetdoesnotexist: return "DeploymentFleetDoesNotExist"
            case .downloadconditionfailed: return "DownloadConditionFailed"
            case .environmentsetuperror: return "EnvironmentSetupError"
            case .etagmismatch: return "EtagMismatch"
            case .extractingbundlefailure: return "ExtractingBundleFailure"
            case .failurethresholdbreached: return "FailureThresholdBreached"
            case .fleetdeploymenttimeout: return "FleetDeploymentTimeout"
            case .greengrassdeploymentfailed: return "GreengrassDeploymentFailed"
            case .greengrassgroupversiondoesnotexist: return "GreengrassGroupVersionDoesNotExist"
            case .internalservererror: return "InternalServerError"
            case .invalidgreengrassgroup: return "InvalidGreengrassGroup"
            case .lambdadeleted: return "LambdaDeleted"
            case .missingrobotapplicationarchitecture: return "MissingRobotApplicationArchitecture"
            case .missingrobotarchitecture: return "MissingRobotArchitecture"
            case .missingrobotdeploymentresource: return "MissingRobotDeploymentResource"
            case .postlaunchfilefailure: return "PostLaunchFileFailure"
            case .prelaunchfilefailure: return "PreLaunchFileFailure"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotagentconnectiontimeout: return "RobotAgentConnectionTimeout"
            case .robotapplicationdoesnotexist: return "RobotApplicationDoesNotExist"
            case .robotdeploymentaborted: return "RobotDeploymentAborted"
            case .robotdeploymentnoresponse: return "RobotDeploymentNoResponse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {

    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inprogress
        case pending
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .canceled,
                .failed,
                .inprogress,
                .pending,
                .preparing,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateDeploymentJobOutput {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: Foundation.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code of the simulation job if it failed: BadPermissionError AWS Greengrass requires a service-level role permission to access other services. The role must include the [AWSGreengrassResourceAccessRolePolicy] managed policy(https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSGreengrassResourceAccessRolePolicy$jsonEditor). ExtractingBundleFailure The robot application could not be extracted from the bundle. FailureThresholdBreached The percentage of robots that could not be updated exceeded the percentage set for the deployment. GreengrassDeploymentFailed The robot application could not be deployed to the robot. GreengrassGroupVersionDoesNotExist The AWS Greengrass group or version associated with a robot is missing. InternalServerError An internal error has occurred. Retry your request, but if the problem persists, contact us with details. MissingRobotApplicationArchitecture The robot application does not have a source that matches the architecture of the robot. MissingRobotDeploymentResource One or more of the resources specified for the robot application are missing. For example, does the robot application have the correct launch package and launch file? PostLaunchFileFailure The post-launch script failed. PreLaunchFileFailure The pre-launch script failed. ResourceNotFound One or more deployment resources are missing. For example, do robot application source bundles still exist? RobotDeploymentNoResponse There is no response from the robot. It might not be powered on or connected to the internet.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason of the deployment job if it failed.
    public var failureReason: Swift.String?
    /// The target fleet for the deployment job.
    public var fleet: Swift.String?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the deployment job.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
        self.tags = tags
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateFleetInput {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the fleet.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateFleetOutput {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: Foundation.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// The list of all tags added to the fleet.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateRobotInput {
    /// The target architecture of the robot.
    /// This member is required.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Greengrass group id.
    /// This member is required.
    public var greengrassGroupId: Swift.String?
    /// The name for the robot.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the robot.
    public var tags: [Swift.String: Swift.String]?

    public init(
        architecture: RoboMakerClientTypes.Architecture? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateRobotOutput {
    /// The target architecture of the robot.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the Greengrass group associated with the robot.
    public var greengrassGroupId: Swift.String?
    /// The name of the robot.
    public var name: Swift.String?
    /// The list of all tags added to the robot.
    public var tags: [Swift.String: Swift.String]?

    public init(
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

extension RoboMakerClientTypes {
    /// The object that contains the Docker image URI for either your robot or simulation applications.
    public struct Environment {
        /// The Docker image URI for either your robot or simulation applications.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension RoboMakerClientTypes {

    public enum RobotSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case general
        case ros
        case ros2
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteType] {
            return [
                .general,
                .ros,
                .ros2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .general: return "General"
            case .ros: return "ROS"
            case .ros2: return "ROS2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {

    public enum RobotSoftwareSuiteVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dashing
        case foxy
        case kinetic
        case melodic
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteVersionType] {
            return [
                .dashing,
                .foxy,
                .kinetic,
                .melodic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dashing: return "Dashing"
            case .foxy: return "Foxy"
            case .kinetic: return "Kinetic"
            case .melodic: return "Melodic"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot software suite (ROS distribution).
    public struct RobotSoftwareSuite {
        /// The name of the robot software suite (ROS distribution).
        public var name: RoboMakerClientTypes.RobotSoftwareSuiteType?
        /// The version of the robot software suite (ROS distribution).
        public var version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType?

        public init(
            name: RoboMakerClientTypes.RobotSoftwareSuiteType? = nil,
            version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a source configuration.
    public struct SourceConfig {
        /// The target processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init(
            architecture: RoboMakerClientTypes.Architecture? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

public struct CreateRobotApplicationInput {
    /// The object that contains that URI of the Docker image that you use for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the robot application.
    /// This member is required.
    public var name: Swift.String?
    /// The robot software suite (ROS distribuition) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the robot application.
    public var tags: [Swift.String: Swift.String]?

    public init(
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

extension RoboMakerClientTypes {
    /// Information about a source.
    public struct Source {
        /// The taget processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// A hash of the object specified by s3Bucket and s3Key.
        public var etag: Swift.String?
        /// The s3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init(
            architecture: RoboMakerClientTypes.Architecture? = nil,
            etag: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.etag = etag
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

public struct CreateRobotApplicationOutput {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// An object that contains the Docker image URI used to a create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the robot application.
    public var tags: [Swift.String: Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

public struct CreateRobotApplicationVersionInput {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the robot application. If you provide a value and it matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 identifier for the zip file bundle that you use for your robot application.
    public var s3Etags: [Swift.String]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

public struct CreateRobotApplicationVersionOutput {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

extension RoboMakerClientTypes {

    public enum RenderingEngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ogre
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderingEngineType] {
            return [
                .ogre
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ogre: return "OGRE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about a rendering engine.
    public struct RenderingEngine {
        /// The name of the rendering engine.
        public var name: RoboMakerClientTypes.RenderingEngineType?
        /// The version of the rendering engine.
        public var version: Swift.String?

        public init(
            name: RoboMakerClientTypes.RenderingEngineType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {

    public enum SimulationSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gazebo
        case rosbagplay
        case simulationruntime
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationSoftwareSuiteType] {
            return [
                .gazebo,
                .rosbagplay,
                .simulationruntime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gazebo: return "Gazebo"
            case .rosbagplay: return "RosbagPlay"
            case .simulationruntime: return "SimulationRuntime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation software suite.
    public struct SimulationSoftwareSuite {
        /// The name of the simulation software suite.
        public var name: RoboMakerClientTypes.SimulationSoftwareSuiteType?
        /// The version of the simulation software suite.
        public var version: Swift.String?

        public init(
            name: RoboMakerClientTypes.SimulationSoftwareSuiteType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

public struct CreateSimulationApplicationInput {
    /// The object that contains the Docker image URI used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the simulation application.
    /// This member is required.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The robot software suite (ROS distribution) used by the simulation application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation application.
    public var tags: [Swift.String: Swift.String]?

    public init(
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

public struct CreateSimulationApplicationOutput {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI that you used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the simulation application.
    public var tags: [Swift.String: Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

public struct CreateSimulationApplicationVersionInput {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the simulation application. If you provide a value and it matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// The SHA256 digest used to identify the Docker image URI used to created the simulation application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 eTag identifier for the zip file bundle that you use to create the simulation application.
    public var s3Etags: [Swift.String]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

public struct CreateSimulationApplicationVersionOutput {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision ID of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

/// The request has failed due to a temporary failure of the server.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSourceConfig {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public var destination: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Keys: [Swift.String]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public var type: RoboMakerClientTypes.DataSourceType?

        public init(
            destination: Swift.String? = nil,
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil,
            type: RoboMakerClientTypes.DataSourceType? = nil
        )
        {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }
    }

}

extension RoboMakerClientTypes {
    /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and two subnet IDs.
    public struct VPCConfig {
        /// A boolean indicating whether to assign a public IP address.
        public var assignPublicIp: Swift.Bool
        /// A list of one or more security groups IDs in your VPC.
        public var securityGroups: [Swift.String]?
        /// A list of one or more subnet IDs in your VPC.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

public struct CreateSimulationJobInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.Compute?
    /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name. There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
    public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    /// The failure behavior the simulation job. Continue Leaves the instance running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When maxJobDurationInSeconds is reached, the simulation job will status will transition to Completed.
    /// This member is required.
    public var maxJobDurationInSeconds: Swift.Int?
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application to use in the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application to use in the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation job.
    public var tags: [Swift.String: Swift.String]?
    /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.
    public var vpcConfig: RoboMakerClientTypes.VPCConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.Compute? = nil,
        dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        iamRole: Swift.String? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int? = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.iamRole = iamRole
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

public struct CreateSimulationJobOutput {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// the failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// The IAM role that allows the simulation job to call the AWS APIs that are specified in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last started.
    public var lastStartedAt: Foundation.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds.
    public var maxJobDurationInSeconds: Swift.Int
    /// Simulation job output files location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application used by the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application used by the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the simulation job.
    public var tags: [Swift.String: Swift.String]?
    /// Information about the vpc configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job request.
    public struct SimulationJobRequest {
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.Compute?
        /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name. There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
        public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
        /// The failure behavior the simulation job. Continue Leaves the host running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public var iamRole: Swift.String?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        /// This member is required.
        public var maxJobDurationInSeconds: Swift.Int
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The robot applications to use in the simulation job.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// The simulation applications to use in the simulation job.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation job request.
        public var tags: [Swift.String: Swift.String]?
        /// A Boolean indicating whether to use default applications in the simulation job. Default applications include Gazebo, rqt, rviz and terminal access.
        public var useDefaultApplications: Swift.Bool?
        /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and two subnet IDs.
        public var vpcConfig: RoboMakerClientTypes.VPCConfig?

        public init(
            compute: RoboMakerClientTypes.Compute? = nil,
            dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            iamRole: Swift.String? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            useDefaultApplications: Swift.Bool? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
        )
        {
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.iamRole = iamRole
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.tags = tags
            self.useDefaultApplications = useDefaultApplications
            self.vpcConfig = vpcConfig
        }
    }

}

public struct CreateWorldExportJobInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The output location.
    /// This member is required.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String: Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to export.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.tags = tags
        self.worlds = worlds
    }
}

extension RoboMakerClientTypes {

    public enum WorldExportJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdenied
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobErrorCode] {
            return [
                .accessdenied,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {

    public enum WorldExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorldExportJobOutput {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: Foundation.Date?
    /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid. AllWorldGenerationFailed All of the worlds in the world generation job failed. This can happen if your worldCount is greater than 50 or less than 1. For more information about troubleshooting WorldForge, see [Troubleshooting Simulation WorldForge](https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting-worldforge.html).
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
    }
}

extension RoboMakerClientTypes {
    /// The number of worlds that will be created. You can configure the number of unique floorplans and the number of unique interiors for each floor plan. For example, if you want 1 world with 20 unique interiors, you set floorplanCount = 1 and interiorCountPerFloorplan = 20. This will result in 20 worlds (floorplanCount * interiorCountPerFloorplan). If you set floorplanCount = 4 and interiorCountPerFloorplan = 5, there will be 20 worlds with 5 unique floor plans.
    public struct WorldCount {
        /// The number of unique floorplans.
        public var floorplanCount: Swift.Int?
        /// The number of unique interiors per floorplan.
        public var interiorCountPerFloorplan: Swift.Int?

        public init(
            floorplanCount: Swift.Int? = nil,
            interiorCountPerFloorplan: Swift.Int? = nil
        )
        {
            self.floorplanCount = floorplanCount
            self.interiorCountPerFloorplan = interiorCountPerFloorplan
        }
    }

}

public struct CreateWorldGenerationJobInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world generator job.
    public var tags: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (arn) of the world template describing the worlds you want to create.
    /// This member is required.
    public var template: Swift.String?
    /// Information about the world count.
    /// This member is required.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String: Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

extension RoboMakerClientTypes {

    public enum WorldGenerationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allworldgenerationfailed
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobErrorCode] {
            return [
                .allworldgenerationfailed,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allworldgenerationfailed: return "AllWorldGenerationFailed"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {

    public enum WorldGenerationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case partialfailed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .partialfailed,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .partialfailed: return "PartialFailed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorldGenerationJobOutput {
    /// The Amazon Resource Name (ARN) of the world generator job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generator job was created.
    public var createdAt: Foundation.Date?
    /// The failure code of the world generator job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The status of the world generator job. Pending The world generator job request is pending. Running The world generator job is running. Completed The world generator job completed. Failed The world generator job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generator job was cancelled. Canceling The world generator job is being cancelled.
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generator job.
    public var tags: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

extension RoboMakerClientTypes {
    /// Information about a template location.
    public struct TemplateLocation {
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

public struct CreateWorldTemplateInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String: Swift.String]?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

public struct CreateWorldTemplateOutput {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: Foundation.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteFleetInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init(
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteFleetOutput {

    public init() { }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteRobotInput {
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteRobotOutput {

    public init() { }
}

public struct DeleteRobotApplicationInput {
    /// The Amazon Resource Name (ARN) of the the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to delete.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

public struct DeleteRobotApplicationOutput {

    public init() { }
}

public struct DeleteSimulationApplicationInput {
    /// The application information for the simulation application to delete.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to delete.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

public struct DeleteSimulationApplicationOutput {

    public init() { }
}

public struct DeleteWorldTemplateInput {
    /// The Amazon Resource Name (arn) of the world template you want to delete.
    /// This member is required.
    public var template: Swift.String?

    public init(
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

public struct DeleteWorldTemplateOutput {

    public init() { }
}

extension RoboMakerClientTypes {
    /// Information about a deployment job.
    public struct DeploymentJob {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment job was created.
        public var createdAt: Foundation.Date?
        /// The deployment application configuration.
        public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
        /// The deployment configuration.
        public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
        /// The deployment job failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the deployment job failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleet: Swift.String?
        /// The status of the deployment job.
        public var status: RoboMakerClientTypes.DeploymentStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
            deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            fleet: Swift.String? = nil,
            status: RoboMakerClientTypes.DeploymentStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
        }
    }

}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeregisterRobotInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeregisterRobotOutput {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeDeploymentJobInput {
    /// The Amazon Resource Name (ARN) of the deployment job.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

extension RoboMakerClientTypes {

    public enum RobotDeploymentStep: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case downloadingextractingstep
        case executingdownloadcondition
        case finishedstep
        case launchingstep
        case postlaunchstep
        case prelaunchstep
        case validatingstep
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotDeploymentStep] {
            return [
                .downloadingextractingstep,
                .executingdownloadcondition,
                .finishedstep,
                .launchingstep,
                .postlaunchstep,
                .prelaunchstep,
                .validatingstep
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .downloadingextractingstep: return "DownloadingExtracting"
            case .executingdownloadcondition: return "ExecutingDownloadCondition"
            case .finishedstep: return "Finished"
            case .launchingstep: return "Launching"
            case .postlaunchstep: return "ExecutingPostLaunch"
            case .prelaunchstep: return "ExecutingPreLaunch"
            case .validatingstep: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about the progress of a deployment job.
    public struct ProgressDetail {
        /// The current progress status. Validating Validating the deployment. DownloadingExtracting Downloading and extracting the bundle on the robot. ExecutingPreLaunch Executing pre-launch script(s) if provided. Launching Launching the robot application. ExecutingPostLaunch Executing post-launch script(s) if provided. Finished Deployment is complete.
        public var currentProgress: RoboMakerClientTypes.RobotDeploymentStep?
        /// Estimated amount of time in seconds remaining in the step. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public var estimatedTimeRemainingSeconds: Swift.Int?
        /// Precentage of the step that is done. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public var percentDone: Swift.Float?
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var targetResource: Swift.String?

        public init(
            currentProgress: RoboMakerClientTypes.RobotDeploymentStep? = nil,
            estimatedTimeRemainingSeconds: Swift.Int? = nil,
            percentDone: Swift.Float? = nil,
            targetResource: Swift.String? = nil
        )
        {
            self.currentProgress = currentProgress
            self.estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds
            self.percentDone = percentDone
            self.targetResource = targetResource
        }
    }

}

extension RoboMakerClientTypes {

    public enum RobotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deploying
        case failed
        case insync
        case noresponse
        case pendingnewdeployment
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotStatus] {
            return [
                .available,
                .deploying,
                .failed,
                .insync,
                .noresponse,
                .pendingnewdeployment,
                .registered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .deploying: return "Deploying"
            case .failed: return "Failed"
            case .insync: return "InSync"
            case .noresponse: return "NoResponse"
            case .pendingnewdeployment: return "PendingNewDeployment"
            case .registered: return "Registered"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot deployment.
    public struct RobotDeployment {
        /// The robot deployment Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment finished.
        public var deploymentFinishTime: Foundation.Date?
        /// The time, in milliseconds since the epoch, when the deployment was started.
        public var deploymentStartTime: Foundation.Date?
        /// The robot deployment failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the robot deployment failed.
        public var failureReason: Swift.String?
        /// Information about how the deployment is progressing.
        public var progressDetail: RoboMakerClientTypes.ProgressDetail?
        /// The status of the robot deployment.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init(
            arn: Swift.String? = nil,
            deploymentFinishTime: Foundation.Date? = nil,
            deploymentStartTime: Foundation.Date? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            progressDetail: RoboMakerClientTypes.ProgressDetail? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.arn = arn
            self.deploymentFinishTime = deploymentFinishTime
            self.deploymentStartTime = deploymentStartTime
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.progressDetail = progressDetail
            self.status = status
        }
    }

}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeDeploymentJobOutput {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment job was created.
    public var createdAt: Foundation.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The deployment job failure code.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// A short description of the reason why the deployment job failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// A list of robot deployment summaries.
    public var robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the specified deployment job.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.robotDeploymentSummary = robotDeploymentSummary
        self.status = status
        self.tags = tags
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeFleetInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init(
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot.
    public struct Robot {
        /// The architecture of the robot.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The Greengrass group associated with the robot.
        public var greenGrassGroupId: Swift.String?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The time of the last deployment.
        public var lastDeploymentTime: Foundation.Date?
        /// The name of the robot.
        public var name: Swift.String?
        /// The status of the robot.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init(
            architecture: RoboMakerClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            fleetArn: Swift.String? = nil,
            greenGrassGroupId: Swift.String? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.fleetArn = fleetArn
            self.greenGrassGroupId = greenGrassGroupId
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.status = status
        }
    }

}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeFleetOutput {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The status of the last deployment.
    public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    /// The time of the last deployment.
    public var lastDeploymentTime: Foundation.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// A list of robots.
    public var robots: [RoboMakerClientTypes.Robot]?
    /// The list of all tags added to the specified fleet.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
        lastDeploymentTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentStatus = lastDeploymentStatus
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.robots = robots
        self.tags = tags
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeRobotInput {
    /// The Amazon Resource Name (ARN) of the robot to be described.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeRobotOutput {
    /// The target architecture of the robot application.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?
    /// The Greengrass group id.
    public var greengrassGroupId: Swift.String?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The time of the last deployment job.
    public var lastDeploymentTime: Foundation.Date?
    /// The name of the robot.
    public var name: Swift.String?
    /// The status of the fleet.
    public var status: RoboMakerClientTypes.RobotStatus?
    /// The list of all tags added to the specified robot.
    public var tags: [Swift.String: Swift.String]?

    public init(
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        fleetArn: Swift.String? = nil,
        greengrassGroupId: Swift.String? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        status: RoboMakerClientTypes.RobotStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.fleetArn = fleetArn
        self.greengrassGroupId = greengrassGroupId
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

public struct DescribeRobotApplicationInput {
    /// The Amazon Resource Name (ARN) of the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to describe.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

public struct DescribeRobotApplicationOutput {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified robot application.
    public var tags: [Swift.String: Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

public struct DescribeSimulationApplicationInput {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to describe.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

public struct DescribeSimulationApplicationOutput {
    /// The Amazon Resource Name (ARN) of the robot simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your simulation application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified simulation application.
    public var tags: [Swift.String: Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

public struct DescribeSimulationJobInput {
    /// The Amazon Resource Name (ARN) of the simulation job to be described.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

public struct DescribeSimulationJobOutput {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// The failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// Details about why the simulation job failed. For more information about troubleshooting, see [Troubleshooting](https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting.html).
    public var failureReason: Swift.String?
    /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last started.
    public var lastStartedAt: Foundation.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum job duration in seconds. The value must be 8 days (691,200 seconds) or less.
    public var maxJobDurationInSeconds: Swift.Int
    /// The name of the simulation job.
    public var name: Swift.String?
    /// The network interface information for the simulation job.
    public var networkInterface: RoboMakerClientTypes.NetworkInterface?
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A list of robot applications.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// A list of simulation applications.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the specified simulation job.
    public var tags: [Swift.String: Swift.String]?
    /// The VPC configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        name: Swift.String? = nil,
        networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.name = name
        self.networkInterface = networkInterface
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

public struct DescribeSimulationJobBatchInput {
    /// The id of the batch to describe.
    /// This member is required.
    public var batch: Swift.String?

    public init(
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation job.
    public struct SimulationJobSummary {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// The compute type for the simulation job summary.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// The names of the data sources.
        public var dataSourceNames: [Swift.String]?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the simulation job.
        public var name: Swift.String?
        /// A list of simulation job robot application names.
        public var robotApplicationNames: [Swift.String]?
        /// A list of simulation job simulation application names.
        public var simulationApplicationNames: [Swift.String]?
        /// The status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?

        public init(
            arn: Swift.String? = nil,
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            dataSourceNames: [Swift.String]? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            robotApplicationNames: [Swift.String]? = nil,
            simulationApplicationNames: [Swift.String]? = nil,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil
        )
        {
            self.arn = arn
            self.computeType = computeType
            self.dataSourceNames = dataSourceNames
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotApplicationNames = robotApplicationNames
            self.simulationApplicationNames = simulationApplicationNames
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a failed create simulation job request.
    public struct FailedCreateSimulationJobRequest {
        /// The time, in milliseconds since the epoch, when the simulation job batch failed.
        public var failedAt: Foundation.Date?
        /// The failure code.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The failure reason of the simulation job request.
        public var failureReason: Swift.String?
        /// The simulation job request.
        public var request: RoboMakerClientTypes.SimulationJobRequest?

        public init(
            failedAt: Foundation.Date? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            request: RoboMakerClientTypes.SimulationJobRequest? = nil
        )
        {
            self.failedAt = failedAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.request = request
        }
    }

}

extension RoboMakerClientTypes {

    public enum SimulationJobBatchErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalserviceerror
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchErrorCode] {
            return [
                .internalserviceerror
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalserviceerror: return "InternalServiceError"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RoboMakerClientTypes {

    public enum SimulationJobBatchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case completing
        case failed
        case inprogress
        case pending
        case timedout
        case timingout
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .completing,
                .failed,
                .inprogress,
                .pending,
                .timedout,
                .timingout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .timedout: return "TimedOut"
            case .timingout: return "TimingOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeSimulationJobBatchOutput {
    /// The Amazon Resource Name (ARN) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was created.
    public var createdAt: Foundation.Date?
    /// A list of created simulation job summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed create simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code of the simulation job batch.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the simulation job batch.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

public struct DescribeWorldInput {
    /// The Amazon Resource Name (arn) of the world you want to describe.
    /// This member is required.
    public var world: Swift.String?

    public init(
        world: Swift.String? = nil
    )
    {
        self.world = world
    }
}

public struct DescribeWorldOutput {
    /// The Amazon Resource Name (arn) of the world.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world was created.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (arn) of the world generation job that generated the world.
    public var generationJob: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world.
    public var tags: [Swift.String: Swift.String]?
    /// The world template.
    public var template: Swift.String?
    /// Returns the JSON formatted string that describes the contents of your world.
    public var worldDescriptionBody: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        generationJob: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        template: Swift.String? = nil,
        worldDescriptionBody: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.generationJob = generationJob
        self.tags = tags
        self.template = template
        self.worldDescriptionBody = worldDescriptionBody
    }
}

public struct DescribeWorldExportJobInput {
    /// The Amazon Resource Name (arn) of the world export job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

public struct DescribeWorldExportJobOutput {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: Foundation.Date?
    /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The reason why the world export job failed.
    public var failureReason: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode and failureReason for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String: Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to be exported.
    public var worlds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
        self.worlds = worlds
    }
}

public struct DescribeWorldGenerationJobInput {
    /// The Amazon Resource Name (arn) of the world generation job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

extension RoboMakerClientTypes {
    /// Information about a failed world.
    public struct WorldFailure {
        /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
        public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
        /// The number of failed worlds.
        public var failureCount: Swift.Int
        /// The sample reason why the world failed. World errors are aggregated. A sample is used as the sampleFailureReason.
        public var sampleFailureReason: Swift.String?

        public init(
            failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
            failureCount: Swift.Int = 0,
            sampleFailureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureCount = failureCount
            self.sampleFailureReason = sampleFailureReason
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about worlds that failed.
    public struct FailureSummary {
        /// The worlds that failed.
        public var failures: [RoboMakerClientTypes.WorldFailure]?
        /// The total number of failures.
        public var totalFailureCount: Swift.Int

        public init(
            failures: [RoboMakerClientTypes.WorldFailure]? = nil,
            totalFailureCount: Swift.Int = 0
        )
        {
            self.failures = failures
            self.totalFailureCount = totalFailureCount
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about worlds that finished.
    public struct FinishedWorldsSummary {
        /// Information about worlds that failed.
        public var failureSummary: RoboMakerClientTypes.FailureSummary?
        /// The total number of finished worlds.
        public var finishedCount: Swift.Int
        /// A list of worlds that succeeded.
        public var succeededWorlds: [Swift.String]?

        public init(
            failureSummary: RoboMakerClientTypes.FailureSummary? = nil,
            finishedCount: Swift.Int = 0,
            succeededWorlds: [Swift.String]? = nil
        )
        {
            self.failureSummary = failureSummary
            self.finishedCount = finishedCount
            self.succeededWorlds = succeededWorlds
        }
    }

}

public struct DescribeWorldGenerationJobOutput {
    /// The Amazon Resource Name (ARN) of the world generation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generation job was created.
    public var createdAt: Foundation.Date?
    /// The failure code of the world generation job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The reason why the world generation job failed.
    public var failureReason: Swift.String?
    /// Summary information about finished worlds.
    public var finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    /// The status of the world generation job: Pending The world generation job request is pending. Running The world generation job is running. Completed The world generation job completed. Failed The world generation job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generation job was cancelled. Canceling The world generation job is being cancelled.
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generation job.
    public var tags: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.finishedWorldsSummary = finishedWorldsSummary
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

public struct DescribeWorldTemplateInput {
    /// The Amazon Resource Name (arn) of the world template you want to describe.
    /// This member is required.
    public var template: Swift.String?

    public init(
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

public struct DescribeWorldTemplateOutput {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: Foundation.Date?
    /// The time, in milliseconds since the epoch, when the world template was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String: Swift.String]?
    /// The version of the world template that you're using.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.tags = tags
        self.version = version
    }
}

extension RoboMakerClientTypes {
    /// Information about a filter.
    public struct Filter {
        /// The name of the filter.
        public var name: Swift.String?
        /// A list of values.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RoboMakerClientTypes {
    /// Information about a fleet.
    public struct Fleet {
        /// The Amazon Resource Name (ARN) of the fleet.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The status of the last fleet deployment.
        public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
        /// The time of the last deployment.
        public var lastDeploymentTime: Foundation.Date?
        /// The name of the fleet.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
            lastDeploymentTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentStatus = lastDeploymentStatus
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
        }
    }

}

public struct GetWorldTemplateBodyInput {
    /// The Amazon Resource Name (arn) of the world generator job.
    public var generationJob: Swift.String?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?

    public init(
        generationJob: Swift.String? = nil,
        template: Swift.String? = nil
    )
    {
        self.generationJob = generationJob
        self.template = template
    }
}

public struct GetWorldTemplateBodyOutput {
    /// The world template body.
    public var templateBody: Swift.String?

    public init(
        templateBody: Swift.String? = nil
    )
    {
        self.templateBody = templateBody
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListDeploymentJobsInput {
    /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status InProgress or the status Pending.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListDeploymentJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListDeploymentJobs request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListDeploymentJobs returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListDeploymentJobsOutput {
    /// A list of deployment jobs that meet the criteria of the request.
    public var deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        deploymentJobs: [RoboMakerClientTypes.DeploymentJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentJobs = deploymentJobs
        self.nextToken = nextToken
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListFleetsInput {
    /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListFleets only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFleets request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListFleets returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListFleetsOutput {
    /// A list of fleet details meeting the request criteria.
    public var fleetDetails: [RoboMakerClientTypes.Fleet]?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        fleetDetails: [RoboMakerClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetDetails = fleetDetails
        self.nextToken = nextToken
    }
}

public struct ListRobotApplicationsInput {
    /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobotApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobotApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListRobotApplications returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the robot application.
    public var versionQualifier: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a robot application.
    public struct RobotApplicationSummary {
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the robot application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// The version of the robot application.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.version = version
        }
    }

}

public struct ListRobotApplicationsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robot application summaries that meet the criteria of the request.
    public var robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.robotApplicationSummaries = robotApplicationSummaries
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListRobotsInput {
    /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Registered or the status Available.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobots only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobots request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListRobots returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListRobotsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robots that meet the criteria of the request.
    public var robots: [RoboMakerClientTypes.Robot]?

    public init(
        nextToken: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil
    )
    {
        self.nextToken = nextToken
        self.robots = robots
    }
}

public struct ListSimulationApplicationsInput {
    /// Optional list of filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListSimulationApplications returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the simulation application.
    public var versionQualifier: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation application.
    public struct SimulationApplicationSummary {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the simulation application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// Information about a simulation software suite.
        public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
        /// The version of the simulation application.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.version = version
        }
    }

}

public struct ListSimulationApplicationsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation application summaries that meet the criteria of the request.
    public var simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationApplicationSummaries = simulationApplicationSummaries
    }
}

public struct ListSimulationJobBatchesInput {
    /// Optional filters to limit results.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobBatches only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobBatches request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job batch.
    public struct SimulationJobBatchSummary {
        /// The Amazon Resource Name (ARN) of the batch.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was created.
        public var createdAt: Foundation.Date?
        /// The number of created simulation job requests.
        public var createdRequestCount: Swift.Int
        /// The number of failed simulation job requests.
        public var failedRequestCount: Swift.Int
        /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The number of pending simulation job requests.
        public var pendingRequestCount: Swift.Int
        /// The status of the simulation job batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
        public var status: RoboMakerClientTypes.SimulationJobBatchStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdRequestCount: Swift.Int = 0,
            failedRequestCount: Swift.Int = 0,
            lastUpdatedAt: Foundation.Date? = nil,
            pendingRequestCount: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdRequestCount = createdRequestCount
            self.failedRequestCount = failedRequestCount
            self.lastUpdatedAt = lastUpdatedAt
            self.pendingRequestCount = pendingRequestCount
            self.status = status
        }
    }

}

public struct ListSimulationJobBatchesOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job batch summaries.
    public var simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?

    public init(
        nextToken: Swift.String? = nil,
        simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobBatchSummaries = simulationJobBatchSummaries
    }
}

public struct ListSimulationJobsInput {
    /// Optional filters to limit results. The filter names status and simulationApplicationName and robotApplicationName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Preparing or the status Running.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobs request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListSimulationJobs returns up to 1000 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSimulationJobsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job summaries that meet the criteria of the request.
    /// This member is required.
    public var simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobSummaries = simulationJobSummaries
    }
}

public struct ListTagsForResourceInput {
    /// The AWS RoboMaker Amazon Resource Name (ARN) with tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The list of all tags added to the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWorldExportJobsInput {
    /// Optional filters to limit results. You can use generationJobId and templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldExportJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldExportJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldExportJobs returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RoboMakerClientTypes {
    /// Information about a world export job.
    public struct WorldExportJobSummary {
        /// The Amazon Resource Name (ARN) of the world export job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public var createdAt: Foundation.Date?
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
        public var status: RoboMakerClientTypes.WorldExportJobStatus?
        /// A list of worlds.
        public var worlds: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
            worlds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.outputLocation = outputLocation
            self.status = status
            self.worlds = worlds
        }
    }

}

public struct ListWorldExportJobsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world export jobs.
    /// This member is required.
    public var worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldExportJobSummaries = worldExportJobSummaries
    }
}

public struct ListWorldGenerationJobsInput {
    /// Optional filters to limit results. You can use status and templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldGeneratorJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldGeneratorJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldGeneratorJobs returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGenerationJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RoboMakerClientTypes {
    /// Information about a world generator job.
    public struct WorldGenerationJobSummary {
        /// The Amazon Resource Name (ARN) of the world generator job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world generator job was created.
        public var createdAt: Foundation.Date?
        /// The number of worlds that failed.
        public var failedWorldCount: Swift.Int
        /// The status of the world generator job: Pending The world generator job request is pending. Running The world generator job is running. Completed The world generator job completed. Failed The world generator job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generator job was cancelled. Canceling The world generator job is being cancelled.
        public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
        /// The number of worlds that were generated.
        public var succeededWorldCount: Swift.Int
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?
        /// Information about the world count.
        public var worldCount: RoboMakerClientTypes.WorldCount?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            failedWorldCount: Swift.Int = 0,
            status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
            succeededWorldCount: Swift.Int = 0,
            template: Swift.String? = nil,
            worldCount: RoboMakerClientTypes.WorldCount? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.failedWorldCount = failedWorldCount
            self.status = status
            self.succeededWorldCount = succeededWorldCount
            self.template = template
            self.worldCount = worldCount
        }
    }

}

public struct ListWorldGenerationJobsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGeneratorJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world generator jobs.
    /// This member is required.
    public var worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldGenerationJobSummaries = worldGenerationJobSummaries
    }
}

public struct ListWorldsInput {
    /// Optional filters to limit results. You can use status.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorlds only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorlds request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorlds returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RoboMakerClientTypes {
    /// Information about a world.
    public struct WorldSummary {
        /// The Amazon Resource Name (ARN) of the world.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (arn) of the world generation job.
        public var generationJob: Swift.String?
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            generationJob: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.generationJob = generationJob
            self.template = template
        }
    }

}

public struct ListWorldsOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for worlds.
    public var worldSummaries: [RoboMakerClientTypes.WorldSummary]?

    public init(
        nextToken: Swift.String? = nil,
        worldSummaries: [RoboMakerClientTypes.WorldSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldSummaries = worldSummaries
    }
}

public struct ListWorldTemplatesInput {
    /// When this parameter is used, ListWorldTemplates only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldTemplates request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldTemplates returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a template.
    public struct TemplateSummary {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the template was created.
        public var createdAt: Foundation.Date?
        /// The time, in milliseconds since the epoch, when the template was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the template.
        public var name: Swift.String?
        /// The version of the template that you're using.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.version = version
        }
    }

}

public struct ListWorldTemplatesOutput {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for templates.
    public var templateSummaries: [RoboMakerClientTypes.TemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateSummaries: [RoboMakerClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummaries = templateSummaries
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct RegisterRobotInput {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct RegisterRobotOutput {
    /// The Amazon Resource Name (ARN) of the fleet that the robot will join.
    public var fleet: Swift.String?
    /// Information about the robot registration.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

public struct RestartSimulationJobInput {
    /// The Amazon Resource Name (ARN) of the simulation job.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

public struct RestartSimulationJobOutput {

    public init() { }
}

public struct StartSimulationJobBatchInput {
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// A list of simulation job requests to create in the batch.
    /// This member is required.
    public var createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// A map that contains tag keys and tag values that are attached to the deployment job batch.
    public var tags: [Swift.String: Swift.String]?

    public init(
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createSimulationJobRequests = createSimulationJobRequests
        self.tags = tags
    }
}

public struct StartSimulationJobBatchOutput {
    /// The Amazon Resource Name (arn) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was created.
    public var createdAt: Foundation.Date?
    /// A list of created simulation job request summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code if the simulation job batch failed.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the simulation job batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the deployment job batch.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct SyncDeploymentJobInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The target fleet for the synchronization.
    /// This member is required.
    public var fleet: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        fleet: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fleet = fleet
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct SyncDeploymentJobOutput {
    /// The Amazon Resource Name (ARN) of the synchronization request.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: Foundation.Date?
    /// Information about the deployment application configurations.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// Information about the deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code if the job fails: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason if the job fails.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The status of the synchronization job.
    public var status: RoboMakerClientTypes.DeploymentStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are tagging.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that will be unattached from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateRobotApplicationInput {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The robot software suite (ROS distribution) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
    }
}

public struct UpdateRobotApplicationOutput {
    /// The Amazon Resource Name (ARN) of the updated robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

public struct UpdateSimulationApplicationInput {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// Information about the robot software suite (ROS distribution).
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
    }
}

public struct UpdateSimulationApplicationOutput {
    /// The Amazon Resource Name (ARN) of the updated simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

public struct UpdateWorldTemplateInput {
    /// The name of the template.
    public var name: Swift.String?
    /// The Amazon Resource Name (arn) of the world template to update.
    /// This member is required.
    public var template: Swift.String?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init(
        name: Swift.String? = nil,
        template: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.name = name
        self.template = template
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

public struct UpdateWorldTemplateOutput {
    /// The Amazon Resource Name (arn) of the world template.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: Foundation.Date?
    /// The time, in milliseconds since the epoch, when the world template was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the world template.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

extension BatchDeleteWorldsInput {

    static func urlPathProvider(_ value: BatchDeleteWorldsInput) -> Swift.String? {
        return "/batchDeleteWorlds"
    }
}

extension BatchDescribeSimulationJobInput {

    static func urlPathProvider(_ value: BatchDescribeSimulationJobInput) -> Swift.String? {
        return "/batchDescribeSimulationJob"
    }
}

extension CancelDeploymentJobInput {

    static func urlPathProvider(_ value: CancelDeploymentJobInput) -> Swift.String? {
        return "/cancelDeploymentJob"
    }
}

extension CancelSimulationJobInput {

    static func urlPathProvider(_ value: CancelSimulationJobInput) -> Swift.String? {
        return "/cancelSimulationJob"
    }
}

extension CancelSimulationJobBatchInput {

    static func urlPathProvider(_ value: CancelSimulationJobBatchInput) -> Swift.String? {
        return "/cancelSimulationJobBatch"
    }
}

extension CancelWorldExportJobInput {

    static func urlPathProvider(_ value: CancelWorldExportJobInput) -> Swift.String? {
        return "/cancelWorldExportJob"
    }
}

extension CancelWorldGenerationJobInput {

    static func urlPathProvider(_ value: CancelWorldGenerationJobInput) -> Swift.String? {
        return "/cancelWorldGenerationJob"
    }
}

extension CreateDeploymentJobInput {

    static func urlPathProvider(_ value: CreateDeploymentJobInput) -> Swift.String? {
        return "/createDeploymentJob"
    }
}

extension CreateFleetInput {

    static func urlPathProvider(_ value: CreateFleetInput) -> Swift.String? {
        return "/createFleet"
    }
}

extension CreateRobotInput {

    static func urlPathProvider(_ value: CreateRobotInput) -> Swift.String? {
        return "/createRobot"
    }
}

extension CreateRobotApplicationInput {

    static func urlPathProvider(_ value: CreateRobotApplicationInput) -> Swift.String? {
        return "/createRobotApplication"
    }
}

extension CreateRobotApplicationVersionInput {

    static func urlPathProvider(_ value: CreateRobotApplicationVersionInput) -> Swift.String? {
        return "/createRobotApplicationVersion"
    }
}

extension CreateSimulationApplicationInput {

    static func urlPathProvider(_ value: CreateSimulationApplicationInput) -> Swift.String? {
        return "/createSimulationApplication"
    }
}

extension CreateSimulationApplicationVersionInput {

    static func urlPathProvider(_ value: CreateSimulationApplicationVersionInput) -> Swift.String? {
        return "/createSimulationApplicationVersion"
    }
}

extension CreateSimulationJobInput {

    static func urlPathProvider(_ value: CreateSimulationJobInput) -> Swift.String? {
        return "/createSimulationJob"
    }
}

extension CreateWorldExportJobInput {

    static func urlPathProvider(_ value: CreateWorldExportJobInput) -> Swift.String? {
        return "/createWorldExportJob"
    }
}

extension CreateWorldGenerationJobInput {

    static func urlPathProvider(_ value: CreateWorldGenerationJobInput) -> Swift.String? {
        return "/createWorldGenerationJob"
    }
}

extension CreateWorldTemplateInput {

    static func urlPathProvider(_ value: CreateWorldTemplateInput) -> Swift.String? {
        return "/createWorldTemplate"
    }
}

extension DeleteFleetInput {

    static func urlPathProvider(_ value: DeleteFleetInput) -> Swift.String? {
        return "/deleteFleet"
    }
}

extension DeleteRobotInput {

    static func urlPathProvider(_ value: DeleteRobotInput) -> Swift.String? {
        return "/deleteRobot"
    }
}

extension DeleteRobotApplicationInput {

    static func urlPathProvider(_ value: DeleteRobotApplicationInput) -> Swift.String? {
        return "/deleteRobotApplication"
    }
}

extension DeleteSimulationApplicationInput {

    static func urlPathProvider(_ value: DeleteSimulationApplicationInput) -> Swift.String? {
        return "/deleteSimulationApplication"
    }
}

extension DeleteWorldTemplateInput {

    static func urlPathProvider(_ value: DeleteWorldTemplateInput) -> Swift.String? {
        return "/deleteWorldTemplate"
    }
}

extension DeregisterRobotInput {

    static func urlPathProvider(_ value: DeregisterRobotInput) -> Swift.String? {
        return "/deregisterRobot"
    }
}

extension DescribeDeploymentJobInput {

    static func urlPathProvider(_ value: DescribeDeploymentJobInput) -> Swift.String? {
        return "/describeDeploymentJob"
    }
}

extension DescribeFleetInput {

    static func urlPathProvider(_ value: DescribeFleetInput) -> Swift.String? {
        return "/describeFleet"
    }
}

extension DescribeRobotInput {

    static func urlPathProvider(_ value: DescribeRobotInput) -> Swift.String? {
        return "/describeRobot"
    }
}

extension DescribeRobotApplicationInput {

    static func urlPathProvider(_ value: DescribeRobotApplicationInput) -> Swift.String? {
        return "/describeRobotApplication"
    }
}

extension DescribeSimulationApplicationInput {

    static func urlPathProvider(_ value: DescribeSimulationApplicationInput) -> Swift.String? {
        return "/describeSimulationApplication"
    }
}

extension DescribeSimulationJobInput {

    static func urlPathProvider(_ value: DescribeSimulationJobInput) -> Swift.String? {
        return "/describeSimulationJob"
    }
}

extension DescribeSimulationJobBatchInput {

    static func urlPathProvider(_ value: DescribeSimulationJobBatchInput) -> Swift.String? {
        return "/describeSimulationJobBatch"
    }
}

extension DescribeWorldInput {

    static func urlPathProvider(_ value: DescribeWorldInput) -> Swift.String? {
        return "/describeWorld"
    }
}

extension DescribeWorldExportJobInput {

    static func urlPathProvider(_ value: DescribeWorldExportJobInput) -> Swift.String? {
        return "/describeWorldExportJob"
    }
}

extension DescribeWorldGenerationJobInput {

    static func urlPathProvider(_ value: DescribeWorldGenerationJobInput) -> Swift.String? {
        return "/describeWorldGenerationJob"
    }
}

extension DescribeWorldTemplateInput {

    static func urlPathProvider(_ value: DescribeWorldTemplateInput) -> Swift.String? {
        return "/describeWorldTemplate"
    }
}

extension GetWorldTemplateBodyInput {

    static func urlPathProvider(_ value: GetWorldTemplateBodyInput) -> Swift.String? {
        return "/getWorldTemplateBody"
    }
}

extension ListDeploymentJobsInput {

    static func urlPathProvider(_ value: ListDeploymentJobsInput) -> Swift.String? {
        return "/listDeploymentJobs"
    }
}

extension ListFleetsInput {

    static func urlPathProvider(_ value: ListFleetsInput) -> Swift.String? {
        return "/listFleets"
    }
}

extension ListRobotApplicationsInput {

    static func urlPathProvider(_ value: ListRobotApplicationsInput) -> Swift.String? {
        return "/listRobotApplications"
    }
}

extension ListRobotsInput {

    static func urlPathProvider(_ value: ListRobotsInput) -> Swift.String? {
        return "/listRobots"
    }
}

extension ListSimulationApplicationsInput {

    static func urlPathProvider(_ value: ListSimulationApplicationsInput) -> Swift.String? {
        return "/listSimulationApplications"
    }
}

extension ListSimulationJobBatchesInput {

    static func urlPathProvider(_ value: ListSimulationJobBatchesInput) -> Swift.String? {
        return "/listSimulationJobBatches"
    }
}

extension ListSimulationJobsInput {

    static func urlPathProvider(_ value: ListSimulationJobsInput) -> Swift.String? {
        return "/listSimulationJobs"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWorldExportJobsInput {

    static func urlPathProvider(_ value: ListWorldExportJobsInput) -> Swift.String? {
        return "/listWorldExportJobs"
    }
}

extension ListWorldGenerationJobsInput {

    static func urlPathProvider(_ value: ListWorldGenerationJobsInput) -> Swift.String? {
        return "/listWorldGenerationJobs"
    }
}

extension ListWorldsInput {

    static func urlPathProvider(_ value: ListWorldsInput) -> Swift.String? {
        return "/listWorlds"
    }
}

extension ListWorldTemplatesInput {

    static func urlPathProvider(_ value: ListWorldTemplatesInput) -> Swift.String? {
        return "/listWorldTemplates"
    }
}

extension RegisterRobotInput {

    static func urlPathProvider(_ value: RegisterRobotInput) -> Swift.String? {
        return "/registerRobot"
    }
}

extension RestartSimulationJobInput {

    static func urlPathProvider(_ value: RestartSimulationJobInput) -> Swift.String? {
        return "/restartSimulationJob"
    }
}

extension StartSimulationJobBatchInput {

    static func urlPathProvider(_ value: StartSimulationJobBatchInput) -> Swift.String? {
        return "/startSimulationJobBatch"
    }
}

extension SyncDeploymentJobInput {

    static func urlPathProvider(_ value: SyncDeploymentJobInput) -> Swift.String? {
        return "/syncDeploymentJob"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateRobotApplicationInput {

    static func urlPathProvider(_ value: UpdateRobotApplicationInput) -> Swift.String? {
        return "/updateRobotApplication"
    }
}

extension UpdateSimulationApplicationInput {

    static func urlPathProvider(_ value: UpdateSimulationApplicationInput) -> Swift.String? {
        return "/updateSimulationApplication"
    }
}

extension UpdateWorldTemplateInput {

    static func urlPathProvider(_ value: UpdateWorldTemplateInput) -> Swift.String? {
        return "/updateWorldTemplate"
    }
}

extension BatchDeleteWorldsInput {

    static func write(value: BatchDeleteWorldsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["worlds"].writeList(value.worlds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDescribeSimulationJobInput {

    static func write(value: BatchDescribeSimulationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobs"].writeList(value.jobs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelDeploymentJobInput {

    static func write(value: CancelDeploymentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension CancelSimulationJobInput {

    static func write(value: CancelSimulationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension CancelSimulationJobBatchInput {

    static func write(value: CancelSimulationJobBatchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batch"].write(value.batch)
    }
}

extension CancelWorldExportJobInput {

    static func write(value: CancelWorldExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension CancelWorldGenerationJobInput {

    static func write(value: CancelWorldGenerationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension CreateDeploymentJobInput {

    static func write(value: CreateDeploymentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["deploymentApplicationConfigs"].writeList(value.deploymentApplicationConfigs, memberWritingClosure: RoboMakerClientTypes.DeploymentApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deploymentConfig"].write(value.deploymentConfig, with: RoboMakerClientTypes.DeploymentConfig.write(value:to:))
        try writer["fleet"].write(value.fleet)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFleetInput {

    static func write(value: CreateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRobotInput {

    static func write(value: CreateRobotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["architecture"].write(value.architecture)
        try writer["greengrassGroupId"].write(value.greengrassGroupId)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRobotApplicationInput {

    static func write(value: CreateRobotApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environment"].write(value.environment, with: RoboMakerClientTypes.Environment.write(value:to:))
        try writer["name"].write(value.name)
        try writer["robotSoftwareSuite"].write(value.robotSoftwareSuite, with: RoboMakerClientTypes.RobotSoftwareSuite.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: RoboMakerClientTypes.SourceConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRobotApplicationVersionInput {

    static func write(value: CreateRobotApplicationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["currentRevisionId"].write(value.currentRevisionId)
        try writer["imageDigest"].write(value.imageDigest)
        try writer["s3Etags"].writeList(value.s3Etags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSimulationApplicationInput {

    static func write(value: CreateSimulationApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environment"].write(value.environment, with: RoboMakerClientTypes.Environment.write(value:to:))
        try writer["name"].write(value.name)
        try writer["renderingEngine"].write(value.renderingEngine, with: RoboMakerClientTypes.RenderingEngine.write(value:to:))
        try writer["robotSoftwareSuite"].write(value.robotSoftwareSuite, with: RoboMakerClientTypes.RobotSoftwareSuite.write(value:to:))
        try writer["simulationSoftwareSuite"].write(value.simulationSoftwareSuite, with: RoboMakerClientTypes.SimulationSoftwareSuite.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: RoboMakerClientTypes.SourceConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSimulationApplicationVersionInput {

    static func write(value: CreateSimulationApplicationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["currentRevisionId"].write(value.currentRevisionId)
        try writer["imageDigest"].write(value.imageDigest)
        try writer["s3Etags"].writeList(value.s3Etags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSimulationJobInput {

    static func write(value: CreateSimulationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["compute"].write(value.compute, with: RoboMakerClientTypes.Compute.write(value:to:))
        try writer["dataSources"].writeList(value.dataSources, memberWritingClosure: RoboMakerClientTypes.DataSourceConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["failureBehavior"].write(value.failureBehavior)
        try writer["iamRole"].write(value.iamRole)
        try writer["loggingConfig"].write(value.loggingConfig, with: RoboMakerClientTypes.LoggingConfig.write(value:to:))
        try writer["maxJobDurationInSeconds"].write(value.maxJobDurationInSeconds)
        try writer["outputLocation"].write(value.outputLocation, with: RoboMakerClientTypes.OutputLocation.write(value:to:))
        try writer["robotApplications"].writeList(value.robotApplications, memberWritingClosure: RoboMakerClientTypes.RobotApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["simulationApplications"].writeList(value.simulationApplications, memberWritingClosure: RoboMakerClientTypes.SimulationApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcConfig"].write(value.vpcConfig, with: RoboMakerClientTypes.VPCConfig.write(value:to:))
    }
}

extension CreateWorldExportJobInput {

    static func write(value: CreateWorldExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["iamRole"].write(value.iamRole)
        try writer["outputLocation"].write(value.outputLocation, with: RoboMakerClientTypes.OutputLocation.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["worlds"].writeList(value.worlds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWorldGenerationJobInput {

    static func write(value: CreateWorldGenerationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["template"].write(value.template)
        try writer["worldCount"].write(value.worldCount, with: RoboMakerClientTypes.WorldCount.write(value:to:))
        try writer["worldTags"].writeMap(value.worldTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateWorldTemplateInput {

    static func write(value: CreateWorldTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateBody"].write(value.templateBody)
        try writer["templateLocation"].write(value.templateLocation, with: RoboMakerClientTypes.TemplateLocation.write(value:to:))
    }
}

extension DeleteFleetInput {

    static func write(value: DeleteFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleet"].write(value.fleet)
    }
}

extension DeleteRobotInput {

    static func write(value: DeleteRobotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["robot"].write(value.robot)
    }
}

extension DeleteRobotApplicationInput {

    static func write(value: DeleteRobotApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
    }
}

extension DeleteSimulationApplicationInput {

    static func write(value: DeleteSimulationApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
    }
}

extension DeleteWorldTemplateInput {

    static func write(value: DeleteWorldTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["template"].write(value.template)
    }
}

extension DeregisterRobotInput {

    static func write(value: DeregisterRobotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleet"].write(value.fleet)
        try writer["robot"].write(value.robot)
    }
}

extension DescribeDeploymentJobInput {

    static func write(value: DescribeDeploymentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension DescribeFleetInput {

    static func write(value: DescribeFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleet"].write(value.fleet)
    }
}

extension DescribeRobotInput {

    static func write(value: DescribeRobotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["robot"].write(value.robot)
    }
}

extension DescribeRobotApplicationInput {

    static func write(value: DescribeRobotApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
    }
}

extension DescribeSimulationApplicationInput {

    static func write(value: DescribeSimulationApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
    }
}

extension DescribeSimulationJobInput {

    static func write(value: DescribeSimulationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension DescribeSimulationJobBatchInput {

    static func write(value: DescribeSimulationJobBatchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batch"].write(value.batch)
    }
}

extension DescribeWorldInput {

    static func write(value: DescribeWorldInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["world"].write(value.world)
    }
}

extension DescribeWorldExportJobInput {

    static func write(value: DescribeWorldExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension DescribeWorldGenerationJobInput {

    static func write(value: DescribeWorldGenerationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension DescribeWorldTemplateInput {

    static func write(value: DescribeWorldTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["template"].write(value.template)
    }
}

extension GetWorldTemplateBodyInput {

    static func write(value: GetWorldTemplateBodyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationJob"].write(value.generationJob)
        try writer["template"].write(value.template)
    }
}

extension ListDeploymentJobsInput {

    static func write(value: ListDeploymentJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFleetsInput {

    static func write(value: ListFleetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRobotApplicationsInput {

    static func write(value: ListRobotApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["versionQualifier"].write(value.versionQualifier)
    }
}

extension ListRobotsInput {

    static func write(value: ListRobotsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSimulationApplicationsInput {

    static func write(value: ListSimulationApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["versionQualifier"].write(value.versionQualifier)
    }
}

extension ListSimulationJobBatchesInput {

    static func write(value: ListSimulationJobBatchesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSimulationJobsInput {

    static func write(value: ListSimulationJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorldExportJobsInput {

    static func write(value: ListWorldExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorldGenerationJobsInput {

    static func write(value: ListWorldGenerationJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorldsInput {

    static func write(value: ListWorldsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: RoboMakerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorldTemplatesInput {

    static func write(value: ListWorldTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension RegisterRobotInput {

    static func write(value: RegisterRobotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleet"].write(value.fleet)
        try writer["robot"].write(value.robot)
    }
}

extension RestartSimulationJobInput {

    static func write(value: RestartSimulationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["job"].write(value.job)
    }
}

extension StartSimulationJobBatchInput {

    static func write(value: StartSimulationJobBatchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchPolicy"].write(value.batchPolicy, with: RoboMakerClientTypes.BatchPolicy.write(value:to:))
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["createSimulationJobRequests"].writeList(value.createSimulationJobRequests, memberWritingClosure: RoboMakerClientTypes.SimulationJobRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension SyncDeploymentJobInput {

    static func write(value: SyncDeploymentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["fleet"].write(value.fleet)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateRobotApplicationInput {

    static func write(value: UpdateRobotApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["currentRevisionId"].write(value.currentRevisionId)
        try writer["environment"].write(value.environment, with: RoboMakerClientTypes.Environment.write(value:to:))
        try writer["robotSoftwareSuite"].write(value.robotSoftwareSuite, with: RoboMakerClientTypes.RobotSoftwareSuite.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: RoboMakerClientTypes.SourceConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateSimulationApplicationInput {

    static func write(value: UpdateSimulationApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["currentRevisionId"].write(value.currentRevisionId)
        try writer["environment"].write(value.environment, with: RoboMakerClientTypes.Environment.write(value:to:))
        try writer["renderingEngine"].write(value.renderingEngine, with: RoboMakerClientTypes.RenderingEngine.write(value:to:))
        try writer["robotSoftwareSuite"].write(value.robotSoftwareSuite, with: RoboMakerClientTypes.RobotSoftwareSuite.write(value:to:))
        try writer["simulationSoftwareSuite"].write(value.simulationSoftwareSuite, with: RoboMakerClientTypes.SimulationSoftwareSuite.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: RoboMakerClientTypes.SourceConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWorldTemplateInput {

    static func write(value: UpdateWorldTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["template"].write(value.template)
        try writer["templateBody"].write(value.templateBody)
        try writer["templateLocation"].write(value.templateLocation, with: RoboMakerClientTypes.TemplateLocation.write(value:to:))
    }
}

extension BatchDeleteWorldsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteWorldsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteWorldsOutput()
        value.unprocessedWorlds = try reader["unprocessedWorlds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDescribeSimulationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDescribeSimulationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDescribeSimulationJobOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedJobs = try reader["unprocessedJobs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelDeploymentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDeploymentJobOutput {
        return CancelDeploymentJobOutput()
    }
}

extension CancelSimulationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSimulationJobOutput {
        return CancelSimulationJobOutput()
    }
}

extension CancelSimulationJobBatchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSimulationJobBatchOutput {
        return CancelSimulationJobBatchOutput()
    }
}

extension CancelWorldExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelWorldExportJobOutput {
        return CancelWorldExportJobOutput()
    }
}

extension CancelWorldGenerationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelWorldGenerationJobOutput {
        return CancelWorldGenerationJobOutput()
    }
}

extension CreateDeploymentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentApplicationConfigs = try reader["deploymentApplicationConfigs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DeploymentApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deploymentConfig = try reader["deploymentConfig"].readIfPresent(with: RoboMakerClientTypes.DeploymentConfig.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.fleet = try reader["fleet"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateRobotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRobotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRobotOutput()
        value.architecture = try reader["architecture"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.greengrassGroupId = try reader["greengrassGroupId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateRobotApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRobotApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRobotApplicationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension CreateRobotApplicationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRobotApplicationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRobotApplicationVersionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension CreateSimulationApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSimulationApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSimulationApplicationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.renderingEngine = try reader["renderingEngine"].readIfPresent(with: RoboMakerClientTypes.RenderingEngine.read(from:))
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.simulationSoftwareSuite = try reader["simulationSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.SimulationSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension CreateSimulationApplicationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSimulationApplicationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSimulationApplicationVersionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.renderingEngine = try reader["renderingEngine"].readIfPresent(with: RoboMakerClientTypes.RenderingEngine.read(from:))
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.simulationSoftwareSuite = try reader["simulationSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.SimulationSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension CreateSimulationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSimulationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSimulationJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.compute = try reader["compute"].readIfPresent(with: RoboMakerClientTypes.ComputeResponse.read(from:))
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureBehavior = try reader["failureBehavior"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.lastStartedAt = try reader["lastStartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: RoboMakerClientTypes.LoggingConfig.read(from:))
        value.maxJobDurationInSeconds = try reader["maxJobDurationInSeconds"].readIfPresent() ?? 0
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        value.robotApplications = try reader["robotApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.RobotApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.simulationApplications = try reader["simulationApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.simulationTimeMillis = try reader["simulationTimeMillis"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: RoboMakerClientTypes.VPCConfigResponse.read(from:))
        return value
    }
}

extension CreateWorldExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorldExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorldExportJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateWorldGenerationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorldGenerationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorldGenerationJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.template = try reader["template"].readIfPresent()
        value.worldCount = try reader["worldCount"].readIfPresent(with: RoboMakerClientTypes.WorldCount.read(from:))
        value.worldTags = try reader["worldTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateWorldTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorldTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorldTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DeleteFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetOutput {
        return DeleteFleetOutput()
    }
}

extension DeleteRobotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRobotOutput {
        return DeleteRobotOutput()
    }
}

extension DeleteRobotApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRobotApplicationOutput {
        return DeleteRobotApplicationOutput()
    }
}

extension DeleteSimulationApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSimulationApplicationOutput {
        return DeleteSimulationApplicationOutput()
    }
}

extension DeleteWorldTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorldTemplateOutput {
        return DeleteWorldTemplateOutput()
    }
}

extension DeregisterRobotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterRobotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterRobotOutput()
        value.fleet = try reader["fleet"].readIfPresent()
        value.robot = try reader["robot"].readIfPresent()
        return value
    }
}

extension DescribeDeploymentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeploymentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeploymentJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentApplicationConfigs = try reader["deploymentApplicationConfigs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DeploymentApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deploymentConfig = try reader["deploymentConfig"].readIfPresent(with: RoboMakerClientTypes.DeploymentConfig.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.fleet = try reader["fleet"].readIfPresent()
        value.robotDeploymentSummary = try reader["robotDeploymentSummary"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.RobotDeployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastDeploymentJob = try reader["lastDeploymentJob"].readIfPresent()
        value.lastDeploymentStatus = try reader["lastDeploymentStatus"].readIfPresent()
        value.lastDeploymentTime = try reader["lastDeploymentTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.robots = try reader["robots"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Robot.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeRobotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRobotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRobotOutput()
        value.architecture = try reader["architecture"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fleetArn = try reader["fleetArn"].readIfPresent()
        value.greengrassGroupId = try reader["greengrassGroupId"].readIfPresent()
        value.lastDeploymentJob = try reader["lastDeploymentJob"].readIfPresent()
        value.lastDeploymentTime = try reader["lastDeploymentTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeRobotApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRobotApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRobotApplicationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.imageDigest = try reader["imageDigest"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension DescribeSimulationApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSimulationApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSimulationApplicationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.imageDigest = try reader["imageDigest"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.renderingEngine = try reader["renderingEngine"].readIfPresent(with: RoboMakerClientTypes.RenderingEngine.read(from:))
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.simulationSoftwareSuite = try reader["simulationSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.SimulationSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension DescribeSimulationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSimulationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSimulationJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.compute = try reader["compute"].readIfPresent(with: RoboMakerClientTypes.ComputeResponse.read(from:))
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureBehavior = try reader["failureBehavior"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.lastStartedAt = try reader["lastStartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: RoboMakerClientTypes.LoggingConfig.read(from:))
        value.maxJobDurationInSeconds = try reader["maxJobDurationInSeconds"].readIfPresent() ?? 0
        value.name = try reader["name"].readIfPresent()
        value.networkInterface = try reader["networkInterface"].readIfPresent(with: RoboMakerClientTypes.NetworkInterface.read(from:))
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        value.robotApplications = try reader["robotApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.RobotApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.simulationApplications = try reader["simulationApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.simulationTimeMillis = try reader["simulationTimeMillis"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: RoboMakerClientTypes.VPCConfigResponse.read(from:))
        return value
    }
}

extension DescribeSimulationJobBatchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSimulationJobBatchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSimulationJobBatchOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.batchPolicy = try reader["batchPolicy"].readIfPresent(with: RoboMakerClientTypes.BatchPolicy.read(from:))
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdRequests = try reader["createdRequests"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedRequests = try reader["failedRequests"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.FailedCreateSimulationJobRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pendingRequests = try reader["pendingRequests"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJobRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeWorldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorldOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.generationJob = try reader["generationJob"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.template = try reader["template"].readIfPresent()
        value.worldDescriptionBody = try reader["worldDescriptionBody"].readIfPresent()
        return value
    }
}

extension DescribeWorldExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorldExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorldExportJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.worlds = try reader["worlds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorldGenerationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorldGenerationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorldGenerationJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.finishedWorldsSummary = try reader["finishedWorldsSummary"].readIfPresent(with: RoboMakerClientTypes.FinishedWorldsSummary.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.template = try reader["template"].readIfPresent()
        value.worldCount = try reader["worldCount"].readIfPresent(with: RoboMakerClientTypes.WorldCount.read(from:))
        value.worldTags = try reader["worldTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeWorldTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorldTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorldTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension GetWorldTemplateBodyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorldTemplateBodyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorldTemplateBodyOutput()
        value.templateBody = try reader["templateBody"].readIfPresent()
        return value
    }
}

extension ListDeploymentJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeploymentJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentJobsOutput()
        value.deploymentJobs = try reader["deploymentJobs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DeploymentJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFleetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFleetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetsOutput()
        value.fleetDetails = try reader["fleetDetails"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Fleet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRobotApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRobotApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRobotApplicationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.robotApplicationSummaries = try reader["robotApplicationSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.RobotApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRobotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRobotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRobotsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.robots = try reader["robots"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Robot.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSimulationApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSimulationApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSimulationApplicationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.simulationApplicationSummaries = try reader["simulationApplicationSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSimulationJobBatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSimulationJobBatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSimulationJobBatchesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.simulationJobBatchSummaries = try reader["simulationJobBatchSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJobBatchSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSimulationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSimulationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSimulationJobsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.simulationJobSummaries = try reader["simulationJobSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorldExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorldExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorldExportJobsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.worldExportJobSummaries = try reader["worldExportJobSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.WorldExportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorldGenerationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorldGenerationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorldGenerationJobsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.worldGenerationJobSummaries = try reader["worldGenerationJobSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.WorldGenerationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorldsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorldsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorldsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.worldSummaries = try reader["worldSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.WorldSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorldTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorldTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorldTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.templateSummaries = try reader["templateSummaries"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.TemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RegisterRobotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterRobotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterRobotOutput()
        value.fleet = try reader["fleet"].readIfPresent()
        value.robot = try reader["robot"].readIfPresent()
        return value
    }
}

extension RestartSimulationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestartSimulationJobOutput {
        return RestartSimulationJobOutput()
    }
}

extension StartSimulationJobBatchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSimulationJobBatchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSimulationJobBatchOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.batchPolicy = try reader["batchPolicy"].readIfPresent(with: RoboMakerClientTypes.BatchPolicy.read(from:))
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdRequests = try reader["createdRequests"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedRequests = try reader["failedRequests"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.FailedCreateSimulationJobRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.pendingRequests = try reader["pendingRequests"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationJobRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SyncDeploymentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SyncDeploymentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SyncDeploymentJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentApplicationConfigs = try reader["deploymentApplicationConfigs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DeploymentApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deploymentConfig = try reader["deploymentConfig"].readIfPresent(with: RoboMakerClientTypes.DeploymentConfig.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.fleet = try reader["fleet"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateRobotApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRobotApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRobotApplicationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension UpdateSimulationApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSimulationApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSimulationApplicationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.environment = try reader["environment"].readIfPresent(with: RoboMakerClientTypes.Environment.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.renderingEngine = try reader["renderingEngine"].readIfPresent(with: RoboMakerClientTypes.RenderingEngine.read(from:))
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.simulationSoftwareSuite = try reader["simulationSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.SimulationSoftwareSuite.read(from:))
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Source.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension UpdateWorldTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorldTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorldTemplateOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

enum BatchDeleteWorldsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDescribeSimulationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDeploymentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelSimulationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelSimulationJobBatchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelWorldExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelWorldGenerationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentDeploymentException": return try ConcurrentDeploymentException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRobotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRobotApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRobotApplicationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSimulationApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSimulationApplicationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSimulationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorldExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorldGenerationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorldTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRobotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRobotApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSimulationApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorldTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterRobotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeploymentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRobotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRobotApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSimulationApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSimulationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSimulationJobBatchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorldExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorldGenerationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorldTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorldTemplateBodyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeploymentJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFleetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRobotApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRobotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSimulationApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSimulationJobBatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSimulationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorldExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorldGenerationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorldsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorldTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterRobotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestartSimulationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSimulationJobBatchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SyncDeploymentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentDeploymentException": return try ConcurrentDeploymentException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRobotApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSimulationApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorldTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotentParameterMismatchException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IdempotentParameterMismatchException {
        let reader = baseError.errorBodyReader
        var value = IdempotentParameterMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentDeploymentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentDeploymentException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentDeploymentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RoboMakerClientTypes.SimulationJob {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationJob()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lastStartedAt = try reader["lastStartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureBehavior = try reader["failureBehavior"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: RoboMakerClientTypes.LoggingConfig.read(from:))
        value.maxJobDurationInSeconds = try reader["maxJobDurationInSeconds"].readIfPresent() ?? 0
        value.simulationTimeMillis = try reader["simulationTimeMillis"].readIfPresent() ?? 0
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.robotApplications = try reader["robotApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.RobotApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.simulationApplications = try reader["simulationApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: RoboMakerClientTypes.VPCConfigResponse.read(from:))
        value.networkInterface = try reader["networkInterface"].readIfPresent(with: RoboMakerClientTypes.NetworkInterface.read(from:))
        value.compute = try reader["compute"].readIfPresent(with: RoboMakerClientTypes.ComputeResponse.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.ComputeResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.ComputeResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.ComputeResponse()
        value.simulationUnitLimit = try reader["simulationUnitLimit"].readIfPresent()
        value.computeType = try reader["computeType"].readIfPresent()
        value.gpuUnitLimit = try reader["gpuUnitLimit"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.NetworkInterface()
        value.networkInterfaceId = try reader["networkInterfaceId"].readIfPresent()
        value.privateIpAddress = try reader["privateIpAddress"].readIfPresent()
        value.publicIpAddress = try reader["publicIpAddress"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.VPCConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.VPCConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.VPCConfigResponse()
        value.subnets = try reader["subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.assignPublicIp = try reader["assignPublicIp"].readIfPresent() ?? false
        return value
    }
}

extension RoboMakerClientTypes.DataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.DataSource()
        value.name = try reader["name"].readIfPresent()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3Keys = try reader["s3Keys"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.S3KeyOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.S3KeyOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.S3KeyOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.S3KeyOutput()
        value.s3Key = try reader["s3Key"].readIfPresent()
        value.etag = try reader["etag"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.SimulationApplicationConfig {

    static func write(value: RoboMakerClientTypes.SimulationApplicationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
        try writer["launchConfig"].write(value.launchConfig, with: RoboMakerClientTypes.LaunchConfig.write(value:to:))
        try writer["tools"].writeList(value.tools, memberWritingClosure: RoboMakerClientTypes.Tool.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["uploadConfigurations"].writeList(value.uploadConfigurations, memberWritingClosure: RoboMakerClientTypes.UploadConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["useDefaultTools"].write(value.useDefaultTools)
        try writer["useDefaultUploadConfigurations"].write(value.useDefaultUploadConfigurations)
        try writer["worldConfigs"].writeList(value.worldConfigs, memberWritingClosure: RoboMakerClientTypes.WorldConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationApplicationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationApplicationConfig()
        value.application = try reader["application"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent()
        value.launchConfig = try reader["launchConfig"].readIfPresent(with: RoboMakerClientTypes.LaunchConfig.read(from:))
        value.uploadConfigurations = try reader["uploadConfigurations"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.UploadConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.worldConfigs = try reader["worldConfigs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.WorldConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.useDefaultUploadConfigurations = try reader["useDefaultUploadConfigurations"].readIfPresent()
        value.tools = try reader["tools"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Tool.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.useDefaultTools = try reader["useDefaultTools"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.Tool {

    static func write(value: RoboMakerClientTypes.Tool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["command"].write(value.command)
        try writer["exitBehavior"].write(value.exitBehavior)
        try writer["name"].write(value.name)
        try writer["streamOutputToCloudWatch"].write(value.streamOutputToCloudWatch)
        try writer["streamUI"].write(value.streamUI)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.Tool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.Tool()
        value.streamUI = try reader["streamUI"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.command = try reader["command"].readIfPresent() ?? ""
        value.streamOutputToCloudWatch = try reader["streamOutputToCloudWatch"].readIfPresent()
        value.exitBehavior = try reader["exitBehavior"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.WorldConfig {

    static func write(value: RoboMakerClientTypes.WorldConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["world"].write(value.world)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.WorldConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.WorldConfig()
        value.world = try reader["world"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.UploadConfiguration {

    static func write(value: RoboMakerClientTypes.UploadConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["path"].write(value.path)
        try writer["uploadBehavior"].write(value.uploadBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.UploadConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.UploadConfiguration()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.path = try reader["path"].readIfPresent() ?? ""
        value.uploadBehavior = try reader["uploadBehavior"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RoboMakerClientTypes.LaunchConfig {

    static func write(value: RoboMakerClientTypes.LaunchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["command"].writeList(value.command, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["launchFile"].write(value.launchFile)
        try writer["packageName"].write(value.packageName)
        try writer["portForwardingConfig"].write(value.portForwardingConfig, with: RoboMakerClientTypes.PortForwardingConfig.write(value:to:))
        try writer["streamUI"].write(value.streamUI)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.LaunchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.LaunchConfig()
        value.packageName = try reader["packageName"].readIfPresent()
        value.launchFile = try reader["launchFile"].readIfPresent()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.portForwardingConfig = try reader["portForwardingConfig"].readIfPresent(with: RoboMakerClientTypes.PortForwardingConfig.read(from:))
        value.streamUI = try reader["streamUI"].readIfPresent() ?? false
        value.command = try reader["command"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RoboMakerClientTypes.PortForwardingConfig {

    static func write(value: RoboMakerClientTypes.PortForwardingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["portMappings"].writeList(value.portMappings, memberWritingClosure: RoboMakerClientTypes.PortMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.PortForwardingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.PortForwardingConfig()
        value.portMappings = try reader["portMappings"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.PortMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RoboMakerClientTypes.PortMapping {

    static func write(value: RoboMakerClientTypes.PortMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationPort"].write(value.applicationPort)
        try writer["enableOnPublicIp"].write(value.enableOnPublicIp)
        try writer["jobPort"].write(value.jobPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.PortMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.PortMapping()
        value.jobPort = try reader["jobPort"].readIfPresent() ?? 0
        value.applicationPort = try reader["applicationPort"].readIfPresent() ?? 0
        value.enableOnPublicIp = try reader["enableOnPublicIp"].readIfPresent() ?? false
        return value
    }
}

extension RoboMakerClientTypes.RobotApplicationConfig {

    static func write(value: RoboMakerClientTypes.RobotApplicationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
        try writer["launchConfig"].write(value.launchConfig, with: RoboMakerClientTypes.LaunchConfig.write(value:to:))
        try writer["tools"].writeList(value.tools, memberWritingClosure: RoboMakerClientTypes.Tool.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["uploadConfigurations"].writeList(value.uploadConfigurations, memberWritingClosure: RoboMakerClientTypes.UploadConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["useDefaultTools"].write(value.useDefaultTools)
        try writer["useDefaultUploadConfigurations"].write(value.useDefaultUploadConfigurations)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.RobotApplicationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.RobotApplicationConfig()
        value.application = try reader["application"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent()
        value.launchConfig = try reader["launchConfig"].readIfPresent(with: RoboMakerClientTypes.LaunchConfig.read(from:))
        value.uploadConfigurations = try reader["uploadConfigurations"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.UploadConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.useDefaultUploadConfigurations = try reader["useDefaultUploadConfigurations"].readIfPresent()
        value.tools = try reader["tools"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.Tool.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.useDefaultTools = try reader["useDefaultTools"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.LoggingConfig {

    static func write(value: RoboMakerClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recordAllRosTopics"].write(value.recordAllRosTopics)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.LoggingConfig()
        value.recordAllRosTopics = try reader["recordAllRosTopics"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.OutputLocation {

    static func write(value: RoboMakerClientTypes.OutputLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3Prefix"].write(value.s3Prefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.OutputLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.OutputLocation()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3Prefix = try reader["s3Prefix"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.DeploymentApplicationConfig {

    static func write(value: RoboMakerClientTypes.DeploymentApplicationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["application"].write(value.application)
        try writer["applicationVersion"].write(value.applicationVersion)
        try writer["launchConfig"].write(value.launchConfig, with: RoboMakerClientTypes.DeploymentLaunchConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.DeploymentApplicationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.DeploymentApplicationConfig()
        value.application = try reader["application"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? ""
        value.launchConfig = try reader["launchConfig"].readIfPresent(with: RoboMakerClientTypes.DeploymentLaunchConfig.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.DeploymentLaunchConfig {

    static func write(value: RoboMakerClientTypes.DeploymentLaunchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["launchFile"].write(value.launchFile)
        try writer["packageName"].write(value.packageName)
        try writer["postLaunchFile"].write(value.postLaunchFile)
        try writer["preLaunchFile"].write(value.preLaunchFile)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.DeploymentLaunchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.DeploymentLaunchConfig()
        value.packageName = try reader["packageName"].readIfPresent() ?? ""
        value.preLaunchFile = try reader["preLaunchFile"].readIfPresent()
        value.launchFile = try reader["launchFile"].readIfPresent() ?? ""
        value.postLaunchFile = try reader["postLaunchFile"].readIfPresent()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RoboMakerClientTypes.DeploymentConfig {

    static func write(value: RoboMakerClientTypes.DeploymentConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["concurrentDeploymentPercentage"].write(value.concurrentDeploymentPercentage)
        try writer["downloadConditionFile"].write(value.downloadConditionFile, with: RoboMakerClientTypes.S3Object.write(value:to:))
        try writer["failureThresholdPercentage"].write(value.failureThresholdPercentage)
        try writer["robotDeploymentTimeoutInSeconds"].write(value.robotDeploymentTimeoutInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.DeploymentConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.DeploymentConfig()
        value.concurrentDeploymentPercentage = try reader["concurrentDeploymentPercentage"].readIfPresent()
        value.failureThresholdPercentage = try reader["failureThresholdPercentage"].readIfPresent()
        value.robotDeploymentTimeoutInSeconds = try reader["robotDeploymentTimeoutInSeconds"].readIfPresent()
        value.downloadConditionFile = try reader["downloadConditionFile"].readIfPresent(with: RoboMakerClientTypes.S3Object.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.S3Object {

    static func write(value: RoboMakerClientTypes.S3Object?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["etag"].write(value.etag)
        try writer["key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.S3Object {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.S3Object()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        value.etag = try reader["etag"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.Source {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.Source()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3Key = try reader["s3Key"].readIfPresent()
        value.etag = try reader["etag"].readIfPresent()
        value.architecture = try reader["architecture"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.RobotSoftwareSuite {

    static func write(value: RoboMakerClientTypes.RobotSoftwareSuite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.RobotSoftwareSuite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.RobotSoftwareSuite()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.Environment {

    static func write(value: RoboMakerClientTypes.Environment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.Environment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.Environment()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.SimulationSoftwareSuite {

    static func write(value: RoboMakerClientTypes.SimulationSoftwareSuite?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationSoftwareSuite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationSoftwareSuite()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.RenderingEngine {

    static func write(value: RoboMakerClientTypes.RenderingEngine?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.RenderingEngine {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.RenderingEngine()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.WorldCount {

    static func write(value: RoboMakerClientTypes.WorldCount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["floorplanCount"].write(value.floorplanCount)
        try writer["interiorCountPerFloorplan"].write(value.interiorCountPerFloorplan)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.WorldCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.WorldCount()
        value.floorplanCount = try reader["floorplanCount"].readIfPresent()
        value.interiorCountPerFloorplan = try reader["interiorCountPerFloorplan"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.RobotDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.RobotDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.RobotDeployment()
        value.arn = try reader["arn"].readIfPresent()
        value.deploymentStartTime = try reader["deploymentStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentFinishTime = try reader["deploymentFinishTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.progressDetail = try reader["progressDetail"].readIfPresent(with: RoboMakerClientTypes.ProgressDetail.read(from:))
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.ProgressDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.ProgressDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.ProgressDetail()
        value.currentProgress = try reader["currentProgress"].readIfPresent()
        value.percentDone = try reader["percentDone"].readIfPresent()
        value.estimatedTimeRemainingSeconds = try reader["estimatedTimeRemainingSeconds"].readIfPresent()
        value.targetResource = try reader["targetResource"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.Robot {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.Robot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.Robot()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.fleetArn = try reader["fleetArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.greenGrassGroupId = try reader["greenGrassGroupId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.architecture = try reader["architecture"].readIfPresent()
        value.lastDeploymentJob = try reader["lastDeploymentJob"].readIfPresent()
        value.lastDeploymentTime = try reader["lastDeploymentTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension RoboMakerClientTypes.BatchPolicy {

    static func write(value: RoboMakerClientTypes.BatchPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxConcurrency"].write(value.maxConcurrency)
        try writer["timeoutInSeconds"].write(value.timeoutInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.BatchPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.BatchPolicy()
        value.timeoutInSeconds = try reader["timeoutInSeconds"].readIfPresent()
        value.maxConcurrency = try reader["maxConcurrency"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.FailedCreateSimulationJobRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.FailedCreateSimulationJobRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.FailedCreateSimulationJobRequest()
        value.request = try reader["request"].readIfPresent(with: RoboMakerClientTypes.SimulationJobRequest.read(from:))
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failedAt = try reader["failedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension RoboMakerClientTypes.SimulationJobRequest {

    static func write(value: RoboMakerClientTypes.SimulationJobRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compute"].write(value.compute, with: RoboMakerClientTypes.Compute.write(value:to:))
        try writer["dataSources"].writeList(value.dataSources, memberWritingClosure: RoboMakerClientTypes.DataSourceConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["failureBehavior"].write(value.failureBehavior)
        try writer["iamRole"].write(value.iamRole)
        try writer["loggingConfig"].write(value.loggingConfig, with: RoboMakerClientTypes.LoggingConfig.write(value:to:))
        try writer["maxJobDurationInSeconds"].write(value.maxJobDurationInSeconds)
        try writer["outputLocation"].write(value.outputLocation, with: RoboMakerClientTypes.OutputLocation.write(value:to:))
        try writer["robotApplications"].writeList(value.robotApplications, memberWritingClosure: RoboMakerClientTypes.RobotApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["simulationApplications"].writeList(value.simulationApplications, memberWritingClosure: RoboMakerClientTypes.SimulationApplicationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["useDefaultApplications"].write(value.useDefaultApplications)
        try writer["vpcConfig"].write(value.vpcConfig, with: RoboMakerClientTypes.VPCConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationJobRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationJobRequest()
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: RoboMakerClientTypes.LoggingConfig.read(from:))
        value.maxJobDurationInSeconds = try reader["maxJobDurationInSeconds"].readIfPresent() ?? 0
        value.iamRole = try reader["iamRole"].readIfPresent()
        value.failureBehavior = try reader["failureBehavior"].readIfPresent()
        value.useDefaultApplications = try reader["useDefaultApplications"].readIfPresent()
        value.robotApplications = try reader["robotApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.RobotApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.simulationApplications = try reader["simulationApplications"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.SimulationApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DataSourceConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: RoboMakerClientTypes.VPCConfig.read(from:))
        value.compute = try reader["compute"].readIfPresent(with: RoboMakerClientTypes.Compute.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RoboMakerClientTypes.Compute {

    static func write(value: RoboMakerClientTypes.Compute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["computeType"].write(value.computeType)
        try writer["gpuUnitLimit"].write(value.gpuUnitLimit)
        try writer["simulationUnitLimit"].write(value.simulationUnitLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.Compute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.Compute()
        value.simulationUnitLimit = try reader["simulationUnitLimit"].readIfPresent()
        value.computeType = try reader["computeType"].readIfPresent()
        value.gpuUnitLimit = try reader["gpuUnitLimit"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.VPCConfig {

    static func write(value: RoboMakerClientTypes.VPCConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assignPublicIp"].write(value.assignPublicIp)
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.VPCConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.VPCConfig()
        value.subnets = try reader["subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.assignPublicIp = try reader["assignPublicIp"].readIfPresent() ?? false
        return value
    }
}

extension RoboMakerClientTypes.DataSourceConfig {

    static func write(value: RoboMakerClientTypes.DataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination)
        try writer["name"].write(value.name)
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3Keys"].writeList(value.s3Keys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.DataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.DataSourceConfig()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.s3Bucket = try reader["s3Bucket"].readIfPresent() ?? ""
        value.s3Keys = try reader["s3Keys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.SimulationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationJobSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.simulationApplicationNames = try reader["simulationApplicationNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.robotApplicationNames = try reader["robotApplicationNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSourceNames = try reader["dataSourceNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.computeType = try reader["computeType"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.FinishedWorldsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.FinishedWorldsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.FinishedWorldsSummary()
        value.finishedCount = try reader["finishedCount"].readIfPresent() ?? 0
        value.succeededWorlds = try reader["succeededWorlds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureSummary = try reader["failureSummary"].readIfPresent(with: RoboMakerClientTypes.FailureSummary.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.FailureSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.FailureSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.FailureSummary()
        value.totalFailureCount = try reader["totalFailureCount"].readIfPresent() ?? 0
        value.failures = try reader["failures"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.WorldFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RoboMakerClientTypes.WorldFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.WorldFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.WorldFailure()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.sampleFailureReason = try reader["sampleFailureReason"].readIfPresent()
        value.failureCount = try reader["failureCount"].readIfPresent() ?? 0
        return value
    }
}

extension RoboMakerClientTypes.DeploymentJob {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.DeploymentJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.DeploymentJob()
        value.arn = try reader["arn"].readIfPresent()
        value.fleet = try reader["fleet"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.deploymentApplicationConfigs = try reader["deploymentApplicationConfigs"].readListIfPresent(memberReadingClosure: RoboMakerClientTypes.DeploymentApplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deploymentConfig = try reader["deploymentConfig"].readIfPresent(with: RoboMakerClientTypes.DeploymentConfig.read(from:))
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension RoboMakerClientTypes.Fleet {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.Fleet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.Fleet()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastDeploymentStatus = try reader["lastDeploymentStatus"].readIfPresent()
        value.lastDeploymentJob = try reader["lastDeploymentJob"].readIfPresent()
        value.lastDeploymentTime = try reader["lastDeploymentTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension RoboMakerClientTypes.RobotApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.RobotApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.RobotApplicationSummary()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.SimulationApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationApplicationSummary()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.robotSoftwareSuite = try reader["robotSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.RobotSoftwareSuite.read(from:))
        value.simulationSoftwareSuite = try reader["simulationSoftwareSuite"].readIfPresent(with: RoboMakerClientTypes.SimulationSoftwareSuite.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.SimulationJobBatchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.SimulationJobBatchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.SimulationJobBatchSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.failedRequestCount = try reader["failedRequestCount"].readIfPresent() ?? 0
        value.pendingRequestCount = try reader["pendingRequestCount"].readIfPresent() ?? 0
        value.createdRequestCount = try reader["createdRequestCount"].readIfPresent() ?? 0
        return value
    }
}

extension RoboMakerClientTypes.WorldExportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.WorldExportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.WorldExportJobSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.worlds = try reader["worlds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: RoboMakerClientTypes.OutputLocation.read(from:))
        return value
    }
}

extension RoboMakerClientTypes.WorldGenerationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.WorldGenerationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.WorldGenerationJobSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.template = try reader["template"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.worldCount = try reader["worldCount"].readIfPresent(with: RoboMakerClientTypes.WorldCount.read(from:))
        value.succeededWorldCount = try reader["succeededWorldCount"].readIfPresent() ?? 0
        value.failedWorldCount = try reader["failedWorldCount"].readIfPresent() ?? 0
        return value
    }
}

extension RoboMakerClientTypes.WorldSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.WorldSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.WorldSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.generationJob = try reader["generationJob"].readIfPresent()
        value.template = try reader["template"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.TemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RoboMakerClientTypes.TemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RoboMakerClientTypes.TemplateSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension RoboMakerClientTypes.SourceConfig {

    static func write(value: RoboMakerClientTypes.SourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["architecture"].write(value.architecture)
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3Key"].write(value.s3Key)
    }
}

extension RoboMakerClientTypes.TemplateLocation {

    static func write(value: RoboMakerClientTypes.TemplateLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Bucket"].write(value.s3Bucket)
        try writer["s3Key"].write(value.s3Key)
    }
}

extension RoboMakerClientTypes.Filter {

    static func write(value: RoboMakerClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum RoboMakerClientTypes {}
