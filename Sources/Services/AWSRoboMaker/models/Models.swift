// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RoboMakerClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case armhf
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .armhf,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .armhf: return "ARMHF"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteWorldsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arn0 in worlds {
                try worldsContainer.encode(arn0)
            }
        }
    }
}

extension BatchDeleteWorldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batchDeleteWorlds"
    }
}

public struct BatchDeleteWorldsInput: Swift.Equatable {
    /// A list of Amazon Resource Names (arns) that correspond to worlds to delete.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init(
        worlds: [Swift.String]? = nil
    )
    {
        self.worlds = worlds
    }
}

struct BatchDeleteWorldsInputBody: Swift.Equatable {
    let worlds: [Swift.String]?
}

extension BatchDeleteWorldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case worlds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
    }
}

extension BatchDeleteWorldsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteWorldsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedWorlds = output.unprocessedWorlds
        } else {
            self.unprocessedWorlds = nil
        }
    }
}

public struct BatchDeleteWorldsOutput: Swift.Equatable {
    /// A list of unprocessed worlds associated with the call. These worlds were not deleted.
    public var unprocessedWorlds: [Swift.String]?

    public init(
        unprocessedWorlds: [Swift.String]? = nil
    )
    {
        self.unprocessedWorlds = unprocessedWorlds
    }
}

struct BatchDeleteWorldsOutputBody: Swift.Equatable {
    let unprocessedWorlds: [Swift.String]?
}

extension BatchDeleteWorldsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedWorlds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedWorldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedWorlds)
        var unprocessedWorldsDecoded0:[Swift.String]? = nil
        if let unprocessedWorldsContainer = unprocessedWorldsContainer {
            unprocessedWorldsDecoded0 = [Swift.String]()
            for string0 in unprocessedWorldsContainer {
                if let string0 = string0 {
                    unprocessedWorldsDecoded0?.append(string0)
                }
            }
        }
        unprocessedWorlds = unprocessedWorldsDecoded0
    }
}

enum BatchDeleteWorldsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDescribeSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobs = jobs {
            var jobsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobs)
            for arn0 in jobs {
                try jobsContainer.encode(arn0)
            }
        }
    }
}

extension BatchDescribeSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batchDescribeSimulationJob"
    }
}

public struct BatchDescribeSimulationJobInput: Swift.Equatable {
    /// A list of Amazon Resource Names (ARNs) of simulation jobs to describe.
    /// This member is required.
    public var jobs: [Swift.String]?

    public init(
        jobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct BatchDescribeSimulationJobInputBody: Swift.Equatable {
    let jobs: [Swift.String]?
}

extension BatchDescribeSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobs)
        var jobsDecoded0:[Swift.String]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Swift.String]()
            for string0 in jobsContainer {
                if let string0 = string0 {
                    jobsDecoded0?.append(string0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

extension BatchDescribeSimulationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDescribeSimulationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.unprocessedJobs = output.unprocessedJobs
        } else {
            self.jobs = nil
            self.unprocessedJobs = nil
        }
    }
}

public struct BatchDescribeSimulationJobOutput: Swift.Equatable {
    /// A list of simulation jobs.
    public var jobs: [RoboMakerClientTypes.SimulationJob]?
    /// A list of unprocessed simulation job Amazon Resource Names (ARNs).
    public var unprocessedJobs: [Swift.String]?

    public init(
        jobs: [RoboMakerClientTypes.SimulationJob]? = nil,
        unprocessedJobs: [Swift.String]? = nil
    )
    {
        self.jobs = jobs
        self.unprocessedJobs = unprocessedJobs
    }
}

struct BatchDescribeSimulationJobOutputBody: Swift.Equatable {
    let jobs: [RoboMakerClientTypes.SimulationJob]?
    let unprocessedJobs: [Swift.String]?
}

extension BatchDescribeSimulationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case unprocessedJobs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJob?].self, forKey: .jobs)
        var jobsDecoded0:[RoboMakerClientTypes.SimulationJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [RoboMakerClientTypes.SimulationJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let unprocessedJobsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedJobs)
        var unprocessedJobsDecoded0:[Swift.String]? = nil
        if let unprocessedJobsContainer = unprocessedJobsContainer {
            unprocessedJobsDecoded0 = [Swift.String]()
            for string0 in unprocessedJobsContainer {
                if let string0 = string0 {
                    unprocessedJobsDecoded0?.append(string0)
                }
            }
        }
        unprocessedJobs = unprocessedJobsDecoded0
    }
}

enum BatchDescribeSimulationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.BatchPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxConcurrency
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxConcurrency = self.maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about the batch policy.
    public struct BatchPolicy: Swift.Equatable {
        /// The number of active simulation jobs create as part of the batch that can be in an active state at the same time. Active states include: Pending,Preparing, Running, Restarting, RunningFailed and Terminating. All other states are terminal states.
        public var maxConcurrency: Swift.Int?
        /// The amount of time, in seconds, to wait for the batch to complete. If a batch times out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), they will be moved to the failed list and the batch status will be Failed. If the pending requests were failing for any other reason, the failed pending requests will be moved to the failed list and the batch status will be TimedOut.
        public var timeoutInSeconds: Swift.Int?

        public init(
            maxConcurrency: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.maxConcurrency = maxConcurrency
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension CancelDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelDeploymentJob"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CancelDeploymentJobInput: Swift.Equatable {
    /// The deployment job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelDeploymentJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelDeploymentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CancelDeploymentJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelDeploymentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelSimulationJobBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = self.batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

extension CancelSimulationJobBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelSimulationJobBatch"
    }
}

public struct CancelSimulationJobBatchInput: Swift.Equatable {
    /// The id of the batch to cancel.
    /// This member is required.
    public var batch: Swift.String?

    public init(
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

struct CancelSimulationJobBatchInputBody: Swift.Equatable {
    let batch: Swift.String?
}

extension CancelSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension CancelSimulationJobBatchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelSimulationJobBatchOutput: Swift.Equatable {

    public init() { }
}

enum CancelSimulationJobBatchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelSimulationJob"
    }
}

public struct CancelSimulationJobInput: Swift.Equatable {
    /// The simulation job ARN to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelSimulationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelSimulationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelSimulationJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelSimulationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelWorldExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelWorldExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelWorldExportJob"
    }
}

public struct CancelWorldExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world export job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldExportJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelWorldExportJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelWorldExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelWorldGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension CancelWorldGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancelWorldGenerationJob"
    }
}

public struct CancelWorldGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generator job to cancel.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct CancelWorldGenerationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension CancelWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension CancelWorldGenerationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelWorldGenerationJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelWorldGenerationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.Compute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeType
        case gpuUnitLimit
        case simulationUnitLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let gpuUnitLimit = self.gpuUnitLimit {
            try encodeContainer.encode(gpuUnitLimit, forKey: .gpuUnitLimit)
        }
        if let simulationUnitLimit = self.simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let gpuUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gpuUnitLimit)
        gpuUnitLimit = gpuUnitLimitDecoded
    }
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job.
    public struct Compute: Swift.Equatable {
        /// Compute type information for the simulation job.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public var gpuUnitLimit: Swift.Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init(
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            gpuUnitLimit: Swift.Int? = nil,
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension RoboMakerClientTypes.ComputeResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeType
        case gpuUnitLimit
        case simulationUnitLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let gpuUnitLimit = self.gpuUnitLimit {
            try encodeContainer.encode(gpuUnitLimit, forKey: .gpuUnitLimit)
        }
        if let simulationUnitLimit = self.simulationUnitLimit {
            try encodeContainer.encode(simulationUnitLimit, forKey: .simulationUnitLimit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationUnitLimit)
        simulationUnitLimit = simulationUnitLimitDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let gpuUnitLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gpuUnitLimit)
        gpuUnitLimit = gpuUnitLimitDecoded
    }
}

extension RoboMakerClientTypes {
    /// Compute information for the simulation job
    public struct ComputeResponse: Swift.Equatable {
        /// Compute type response information for the simulation job.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public var gpuUnitLimit: Swift.Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public var simulationUnitLimit: Swift.Int?

        public init(
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            gpuUnitLimit: Swift.Int? = nil,
            simulationUnitLimit: Swift.Int? = nil
        )
        {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }
    }

}

extension RoboMakerClientTypes {
    public enum ComputeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpu
        case gpuAndCpu
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeType] {
            return [
                .cpu,
                .gpuAndCpu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpu: return "CPU"
            case .gpuAndCpu: return "GPU_AND_CPU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentDeploymentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentDeploymentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The failure percentage threshold percentage was met.
public struct ConcurrentDeploymentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentDeploymentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentDeploymentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentDeploymentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfig0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfig0)
            }
        }
        if let deploymentConfig = self.deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createDeploymentJob"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateDeploymentJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The deployment application configuration.
    /// This member is required.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The requested deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The Amazon Resource Name (ARN) of the fleet to deploy.
    /// This member is required.
    public var fleet: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        fleet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.fleet = fleet
        self.tags = tags
    }
}

struct CreateDeploymentJobInputBody: Swift.Equatable {
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let clientRequestToken: Swift.String?
    let fleet: Swift.String?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deploymentApplicationConfigs
        case deploymentConfig
        case fleet
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateDeploymentJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code of the simulation job if it failed: BadPermissionError AWS Greengrass requires a service-level role permission to access other services. The role must include the [AWSGreengrassResourceAccessRolePolicy] managed policy(https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSGreengrassResourceAccessRolePolicy$jsonEditor). ExtractingBundleFailure The robot application could not be extracted from the bundle. FailureThresholdBreached The percentage of robots that could not be updated exceeded the percentage set for the deployment. GreengrassDeploymentFailed The robot application could not be deployed to the robot. GreengrassGroupVersionDoesNotExist The AWS Greengrass group or version associated with a robot is missing. InternalServerError An internal error has occurred. Retry your request, but if the problem persists, contact us with details. MissingRobotApplicationArchitecture The robot application does not have a source that matches the architecture of the robot. MissingRobotDeploymentResource One or more of the resources specified for the robot application are missing. For example, does the robot application have the correct launch package and launch file? PostLaunchFileFailure The post-launch script failed. PreLaunchFileFailure The pre-launch script failed. ResourceNotFound One or more deployment resources are missing. For example, do robot application source bundles still exist? RobotDeploymentNoResponse There is no response from the robot. It might not be powered on or connected to the internet.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason of the deployment job if it failed.
    public var failureReason: Swift.String?
    /// The target fleet for the deployment job.
    public var fleet: Swift.String?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
        self.tags = tags
    }
}

struct CreateDeploymentJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let fleet: Swift.String?
    let status: RoboMakerClientTypes.DeploymentStatus?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let failureReason: Swift.String?
    let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    let createdAt: ClientRuntime.Date?
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateDeploymentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentDeploymentException": return try await ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createFleet"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the fleet.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateFleetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// The list of all tags added to the fleet.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateFleetOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createRobotApplication"
    }
}

public struct CreateRobotApplicationInput: Swift.Equatable {
    /// The object that contains that URI of the Docker image that you use for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the robot application.
    /// This member is required.
    public var name: Swift.String?
    /// The robot software suite (ROS distribuition) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the robot application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateRobotApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case robotSoftwareSuite
        case sources
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateRobotApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRobotApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// An object that contains the Docker image URI used to a create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the robot application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateRobotApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CreateRobotApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRobotApplicationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let s3Etags = s3Etags {
            var s3EtagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Etags)
            for s3etag0 in s3Etags {
                try s3EtagsContainer.encode(s3etag0)
            }
        }
    }
}

extension CreateRobotApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createRobotApplicationVersion"
    }
}

public struct CreateRobotApplicationVersionInput: Swift.Equatable {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the robot application. If you provide a value and it matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 identifier for the zip file bundle that you use for your robot application.
    public var s3Etags: [Swift.String]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

struct CreateRobotApplicationVersionInputBody: Swift.Equatable {
    let application: Swift.String?
    let currentRevisionId: Swift.String?
    let s3Etags: [Swift.String]?
    let imageDigest: Swift.String?
}

extension CreateRobotApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let s3EtagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Etags)
        var s3EtagsDecoded0:[Swift.String]? = nil
        if let s3EtagsContainer = s3EtagsContainer {
            s3EtagsDecoded0 = [Swift.String]()
            for string0 in s3EtagsContainer {
                if let string0 = string0 {
                    s3EtagsDecoded0?.append(string0)
                }
            }
        }
        s3Etags = s3EtagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension CreateRobotApplicationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRobotApplicationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateRobotApplicationVersionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateRobotApplicationVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateRobotApplicationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CreateRobotApplicationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let greengrassGroupId = self.greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createRobot"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateRobotInput: Swift.Equatable {
    /// The target architecture of the robot.
    /// This member is required.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Greengrass group id.
    /// This member is required.
    public var greengrassGroupId: Swift.String?
    /// The name for the robot.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the robot.
    public var tags: [Swift.String:Swift.String]?

    public init(
        architecture: RoboMakerClientTypes.Architecture? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotInputBody: Swift.Equatable {
    let name: Swift.String?
    let architecture: RoboMakerClientTypes.Architecture?
    let greengrassGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case greengrassGroupId
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRobotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRobotOutputBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.greengrassGroupId = output.greengrassGroupId
            self.name = output.name
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.greengrassGroupId = nil
            self.name = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct CreateRobotOutput: Swift.Equatable {
    /// The target architecture of the robot.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the Greengrass group associated with the robot.
    public var greengrassGroupId: Swift.String?
    /// The name of the robot.
    public var name: Swift.String?
    /// The list of all tags added to the robot.
    public var tags: [Swift.String:Swift.String]?

    public init(
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        greengrassGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.greengrassGroupId = greengrassGroupId
        self.name = name
        self.tags = tags
    }
}

struct CreateRobotOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let greengrassGroupId: Swift.String?
    let architecture: RoboMakerClientTypes.Architecture?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRobotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case greengrassGroupId
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateRobotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingEngine = self.renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = self.simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSimulationApplication"
    }
}

public struct CreateSimulationApplicationInput: Swift.Equatable {
    /// The object that contains the Docker image URI used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The name of the simulation application.
    /// This member is required.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The robot software suite (ROS distribution) used by the simulation application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        environment: RoboMakerClientTypes.Environment? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.environment = environment
        self.name = name
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
    }
}

struct CreateSimulationApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
        case name
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension CreateSimulationApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSimulationApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI that you used to create your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the simulation application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct CreateSimulationApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CreateSimulationApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSimulationApplicationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let s3Etags = s3Etags {
            var s3EtagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Etags)
            for s3etag0 in s3Etags {
                try s3EtagsContainer.encode(s3etag0)
            }
        }
    }
}

extension CreateSimulationApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSimulationApplicationVersion"
    }
}

public struct CreateSimulationApplicationVersionInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The current revision id for the simulation application. If you provide a value and it matches the latest revision ID, a new version will be created.
    public var currentRevisionId: Swift.String?
    /// The SHA256 digest used to identify the Docker image URI used to created the simulation application.
    public var imageDigest: Swift.String?
    /// The Amazon S3 eTag identifier for the zip file bundle that you use to create the simulation application.
    public var s3Etags: [Swift.String]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        imageDigest: Swift.String? = nil,
        s3Etags: [Swift.String]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.imageDigest = imageDigest
        self.s3Etags = s3Etags
    }
}

struct CreateSimulationApplicationVersionInputBody: Swift.Equatable {
    let application: Swift.String?
    let currentRevisionId: Swift.String?
    let s3Etags: [Swift.String]?
    let imageDigest: Swift.String?
}

extension CreateSimulationApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case imageDigest
        case s3Etags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let s3EtagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Etags)
        var s3EtagsDecoded0:[Swift.String]? = nil
        if let s3EtagsContainer = s3EtagsContainer {
            s3EtagsDecoded0 = [Swift.String]()
            for string0 in s3EtagsContainer {
                if let string0 = string0 {
                    s3EtagsDecoded0?.append(string0)
                }
            }
        }
        s3Etags = s3EtagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension CreateSimulationApplicationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSimulationApplicationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct CreateSimulationApplicationVersionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision ID of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct CreateSimulationApplicationVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension CreateSimulationApplicationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CreateSimulationApplicationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfig0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfig0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if let maxJobDurationInSeconds = self.maxJobDurationInSeconds {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfig0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfig0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfig0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSimulationJob"
    }
}

public struct CreateSimulationJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.Compute?
    /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name. There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
    public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    /// The failure behavior the simulation job. Continue Leaves the instance running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When maxJobDurationInSeconds is reached, the simulation job will status will transition to Completed.
    /// This member is required.
    public var maxJobDurationInSeconds: Swift.Int?
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application to use in the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application to use in the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// A map that contains tag keys and tag values that are attached to the simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.
    public var vpcConfig: RoboMakerClientTypes.VPCConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.Compute? = nil,
        dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        iamRole: Swift.String? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.iamRole = iamRole
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    let maxJobDurationInSeconds: Swift.Int?
    let iamRole: Swift.String?
    let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    let dataSources: [RoboMakerClientTypes.DataSourceConfig]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfig: RoboMakerClientTypes.VPCConfig?
    let compute: RoboMakerClientTypes.Compute?
}

extension CreateSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case vpcConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds)
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Compute.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CreateSimulationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSimulationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct CreateSimulationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// the failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// The IAM role that allows the simulation job to call the AWS APIs that are specified in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last started.
    public var lastStartedAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum simulation job duration in seconds.
    public var maxJobDurationInSeconds: Swift.Int
    /// Simulation job output files location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The robot application used by the simulation job.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// The simulation application used by the simulation job.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// Information about the vpc configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateSimulationJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobStatus?
    let lastStartedAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    let failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    let maxJobDurationInSeconds: Swift.Int
    let simulationTimeMillis: Swift.Int
    let iamRole: Swift.String?
    let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    let dataSources: [RoboMakerClientTypes.DataSource]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfig: RoboMakerClientTypes.VPCConfigResponse?
    let compute: RoboMakerClientTypes.ComputeResponse?
}

extension CreateSimulationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

enum CreateSimulationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorldExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arn0 in worlds {
                try worldsContainer.encode(arn0)
            }
        }
    }
}

extension CreateWorldExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorldExportJob"
    }
}

public struct CreateWorldExportJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The output location.
    /// This member is required.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to export.
    /// This member is required.
    public var worlds: [Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.tags = tags
        self.worlds = worlds
    }
}

struct CreateWorldExportJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let worlds: [Swift.String]?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case iamRole
        case outputLocation
        case tags
        case worlds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorldExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldExportJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid. AllWorldGenerationFailed All of the worlds in the world generation job failed. This can happen if your worldCount is greater than 50 or less than 1. For more information about troubleshooting WorldForge, see [Troubleshooting Simulation WorldForge](https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting-worldforge.html).
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
    }
}

struct CreateWorldExportJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldExportJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case iamRole
        case outputLocation
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateWorldExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorldGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = self.worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
        if let worldTags = worldTags {
            var worldTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .worldTags)
            for (dictKey0, tagMap0) in worldTags {
                try worldTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorldGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorldGenerationJob"
    }
}

public struct CreateWorldGenerationJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world generator job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template describing the worlds you want to create.
    /// This member is required.
    public var template: Swift.String?
    /// Information about the world count.
    /// This member is required.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let template: Swift.String?
    let worldCount: RoboMakerClientTypes.WorldCount?
    let tags: [Swift.String:Swift.String]?
    let worldTags: [Swift.String:Swift.String]?
}

extension CreateWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

extension CreateWorldGenerationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorldGenerationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct CreateWorldGenerationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world generator job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generator job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world generator job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The status of the world generator job. Pending The world generator job request is pending. Running The world generator job is running. Completed The world generator job completed. Failed The world generator job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generator job was cancelled. Canceling The world generator job is being cancelled.
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generator job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct CreateWorldGenerationJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldGenerationJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    let clientRequestToken: Swift.String?
    let template: Swift.String?
    let worldCount: RoboMakerClientTypes.WorldCount?
    let tags: [Swift.String:Swift.String]?
    let worldTags: [Swift.String:Swift.String]?
}

extension CreateWorldGenerationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

enum CreateWorldGenerationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = self.templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

extension CreateWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorldTemplate"
    }
}

public struct CreateWorldTemplateInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String:Swift.String]?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct CreateWorldTemplateInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let name: Swift.String?
    let templateBody: Swift.String?
    let templateLocation: RoboMakerClientTypes.TemplateLocation?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
        case tags
        case templateBody
        case templateLocation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorldTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorldTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateWorldTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.name = name
        self.tags = tags
    }
}

struct CreateWorldTemplateOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let clientRequestToken: Swift.String?
    let createdAt: ClientRuntime.Date?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorldTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateWorldTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case name
        case s3Bucket
        case s3Keys
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keyoutput0 in s3Keys {
                try s3KeysContainer.encode(s3keyoutput0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.S3KeyOutput?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[RoboMakerClientTypes.S3KeyOutput]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [RoboMakerClientTypes.S3KeyOutput]()
            for structure0 in s3KeysContainer {
                if let structure0 = structure0 {
                    s3KeysDecoded0?.append(structure0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSource: Swift.Equatable {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public var destination: Swift.String?
        /// The name of the data source.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        public var s3Keys: [RoboMakerClientTypes.S3KeyOutput]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public var type: RoboMakerClientTypes.DataSourceType?

        public init(
            destination: Swift.String? = nil,
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [RoboMakerClientTypes.S3KeyOutput]? = nil,
            type: RoboMakerClientTypes.DataSourceType? = nil
        )
        {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }
    }

}

extension RoboMakerClientTypes.DataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case name
        case s3Bucket
        case s3Keys
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keyorprefix0 in s3Keys {
                try s3KeysContainer.encode(s3keyorprefix0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a data source.
    public struct DataSourceConfig: Swift.Equatable {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public var destination: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The S3 bucket where the data files are located.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Keys: [Swift.String]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public var type: RoboMakerClientTypes.DataSourceType?

        public init(
            destination: Swift.String? = nil,
            name: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil,
            type: RoboMakerClientTypes.DataSourceType? = nil
        )
        {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }
    }

}

extension RoboMakerClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case file
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .archive,
                .file,
                .prefix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "Archive"
            case .file: return "File"
            case .prefix: return "Prefix"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteFleet"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteFleetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init(
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    let fleet: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DeleteFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteFleetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DeleteRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteRobotApplication"
    }
}

public struct DeleteRobotApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to delete.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteRobotApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DeleteRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteRobotApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRobotApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRobotApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension DeleteRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteRobot"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

struct DeleteRobotInputBody: Swift.Equatable {
    let robot: Swift.String?
}

extension DeleteRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeleteRobotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeleteRobotOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRobotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DeleteSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSimulationApplication"
    }
}

public struct DeleteSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application to delete.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to delete.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DeleteSimulationApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DeleteSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DeleteSimulationApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSimulationApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSimulationApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension DeleteWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteWorldTemplate"
    }
}

public struct DeleteWorldTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template you want to delete.
    /// This member is required.
    public var template: Swift.String?

    public init(
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

struct DeleteWorldTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
}

extension DeleteWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DeleteWorldTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorldTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorldTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.DeploymentApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = self.launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentLaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a deployment application configuration.
    public struct DeploymentApplicationConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.String?
        /// The launch configuration.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig?

        public init(
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.DeploymentLaunchConfig? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
        }
    }

}

extension RoboMakerClientTypes.DeploymentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case concurrentDeploymentPercentage
        case downloadConditionFile
        case failureThresholdPercentage
        case robotDeploymentTimeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let concurrentDeploymentPercentage = self.concurrentDeploymentPercentage {
            try encodeContainer.encode(concurrentDeploymentPercentage, forKey: .concurrentDeploymentPercentage)
        }
        if let downloadConditionFile = self.downloadConditionFile {
            try encodeContainer.encode(downloadConditionFile, forKey: .downloadConditionFile)
        }
        if let failureThresholdPercentage = self.failureThresholdPercentage {
            try encodeContainer.encode(failureThresholdPercentage, forKey: .failureThresholdPercentage)
        }
        if let robotDeploymentTimeoutInSeconds = self.robotDeploymentTimeoutInSeconds {
            try encodeContainer.encode(robotDeploymentTimeoutInSeconds, forKey: .robotDeploymentTimeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let concurrentDeploymentPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentDeploymentPercentage)
        concurrentDeploymentPercentage = concurrentDeploymentPercentageDecoded
        let failureThresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureThresholdPercentage)
        failureThresholdPercentage = failureThresholdPercentageDecoded
        let robotDeploymentTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .robotDeploymentTimeoutInSeconds)
        robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSecondsDecoded
        let downloadConditionFileDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.S3Object.self, forKey: .downloadConditionFile)
        downloadConditionFile = downloadConditionFileDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a deployment configuration.
    public struct DeploymentConfig: Swift.Equatable {
        /// The percentage of robots receiving the deployment at the same time.
        public var concurrentDeploymentPercentage: Swift.Int?
        /// The download condition file.
        public var downloadConditionFile: RoboMakerClientTypes.S3Object?
        /// The percentage of deployments that need to fail before stopping deployment.
        public var failureThresholdPercentage: Swift.Int?
        /// The amount of time, in seconds, to wait for deployment to a single robot to complete. Choose a time between 1 minute and 7 days. The default is 5 hours.
        public var robotDeploymentTimeoutInSeconds: Swift.Int?

        public init(
            concurrentDeploymentPercentage: Swift.Int? = nil,
            downloadConditionFile: RoboMakerClientTypes.S3Object? = nil,
            failureThresholdPercentage: Swift.Int? = nil,
            robotDeploymentTimeoutInSeconds: Swift.Int? = nil
        )
        {
            self.concurrentDeploymentPercentage = concurrentDeploymentPercentage
            self.downloadConditionFile = downloadConditionFile
            self.failureThresholdPercentage = failureThresholdPercentage
            self.robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds
        }
    }

}

extension RoboMakerClientTypes.DeploymentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deploymentApplicationConfigs = deploymentApplicationConfigs {
            var deploymentApplicationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentApplicationConfigs)
            for deploymentapplicationconfig0 in deploymentApplicationConfigs {
                try deploymentApplicationConfigsContainer.encode(deploymentapplicationconfig0)
            }
        }
        if let deploymentConfig = self.deploymentConfig {
            try encodeContainer.encode(deploymentConfig, forKey: .deploymentConfig)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a deployment job.
    public struct DeploymentJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment job was created.
        public var createdAt: ClientRuntime.Date?
        /// The deployment application configuration.
        public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
        /// The deployment configuration.
        public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
        /// The deployment job failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the deployment job failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleet: Swift.String?
        /// The status of the deployment job.
        public var status: RoboMakerClientTypes.DeploymentStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
            deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            fleet: Swift.String? = nil,
            status: RoboMakerClientTypes.DeploymentStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum DeploymentJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badlambdaassociated
        case badpermissionerror
        case deploymentfleetdoesnotexist
        case downloadconditionfailed
        case environmentsetuperror
        case etagmismatch
        case extractingbundlefailure
        case failurethresholdbreached
        case fleetdeploymenttimeout
        case greengrassdeploymentfailed
        case greengrassgroupversiondoesnotexist
        case internalservererror
        case invalidgreengrassgroup
        case lambdadeleted
        case missingrobotapplicationarchitecture
        case missingrobotarchitecture
        case missingrobotdeploymentresource
        case postlaunchfilefailure
        case prelaunchfilefailure
        case resourcenotfound
        case robotagentconnectiontimeout
        case robotapplicationdoesnotexist
        case robotdeploymentaborted
        case robotdeploymentnoresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentJobErrorCode] {
            return [
                .badlambdaassociated,
                .badpermissionerror,
                .deploymentfleetdoesnotexist,
                .downloadconditionfailed,
                .environmentsetuperror,
                .etagmismatch,
                .extractingbundlefailure,
                .failurethresholdbreached,
                .fleetdeploymenttimeout,
                .greengrassdeploymentfailed,
                .greengrassgroupversiondoesnotexist,
                .internalservererror,
                .invalidgreengrassgroup,
                .lambdadeleted,
                .missingrobotapplicationarchitecture,
                .missingrobotarchitecture,
                .missingrobotdeploymentresource,
                .postlaunchfilefailure,
                .prelaunchfilefailure,
                .resourcenotfound,
                .robotagentconnectiontimeout,
                .robotapplicationdoesnotexist,
                .robotdeploymentaborted,
                .robotdeploymentnoresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badlambdaassociated: return "BadLambdaAssociated"
            case .badpermissionerror: return "BadPermissionError"
            case .deploymentfleetdoesnotexist: return "DeploymentFleetDoesNotExist"
            case .downloadconditionfailed: return "DownloadConditionFailed"
            case .environmentsetuperror: return "EnvironmentSetupError"
            case .etagmismatch: return "EtagMismatch"
            case .extractingbundlefailure: return "ExtractingBundleFailure"
            case .failurethresholdbreached: return "FailureThresholdBreached"
            case .fleetdeploymenttimeout: return "FleetDeploymentTimeout"
            case .greengrassdeploymentfailed: return "GreengrassDeploymentFailed"
            case .greengrassgroupversiondoesnotexist: return "GreengrassGroupVersionDoesNotExist"
            case .internalservererror: return "InternalServerError"
            case .invalidgreengrassgroup: return "InvalidGreengrassGroup"
            case .lambdadeleted: return "LambdaDeleted"
            case .missingrobotapplicationarchitecture: return "MissingRobotApplicationArchitecture"
            case .missingrobotarchitecture: return "MissingRobotArchitecture"
            case .missingrobotdeploymentresource: return "MissingRobotDeploymentResource"
            case .postlaunchfilefailure: return "PostLaunchFileFailure"
            case .prelaunchfilefailure: return "PreLaunchFileFailure"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotagentconnectiontimeout: return "RobotAgentConnectionTimeout"
            case .robotapplicationdoesnotexist: return "RobotApplicationDoesNotExist"
            case .robotdeploymentaborted: return "RobotDeploymentAborted"
            case .robotdeploymentnoresponse: return "RobotDeploymentNoResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentJobErrorCode(rawValue: rawValue) ?? DeploymentJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.DeploymentLaunchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVariables
        case launchFile
        case packageName
        case postLaunchFile
        case preLaunchFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariableMap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchFile = self.launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let postLaunchFile = self.postLaunchFile {
            try encodeContainer.encode(postLaunchFile, forKey: .postLaunchFile)
        }
        if let preLaunchFile = self.preLaunchFile {
            try encodeContainer.encode(preLaunchFile, forKey: .preLaunchFile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let preLaunchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preLaunchFile)
        preLaunchFile = preLaunchFileDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let postLaunchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postLaunchFile)
        postLaunchFile = postLaunchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for a deployment launch.
    public struct DeploymentLaunchConfig: Swift.Equatable {
        /// An array of key/value pairs specifying environment variables for the robot application
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The launch file name.
        /// This member is required.
        public var launchFile: Swift.String?
        /// The package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The deployment post-launch file. This file will be executed after the launch file.
        public var postLaunchFile: Swift.String?
        /// The deployment pre-launch file. This file will be executed prior to the launch file.
        public var preLaunchFile: Swift.String?

        public init(
            environmentVariables: [Swift.String:Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            postLaunchFile: Swift.String? = nil,
            preLaunchFile: Swift.String? = nil
        )
        {
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.postLaunchFile = postLaunchFile
            self.preLaunchFile = preLaunchFile
        }
    }

}

extension RoboMakerClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inprogress
        case pending
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .canceled,
                .failed,
                .inprogress,
                .pending,
                .preparing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeregisterRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension DeregisterRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deregisterRobot"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeregisterRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotInputBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension DeregisterRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DeregisterRobotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeregisterRobotOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DeregisterRobotOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct DeregisterRobotOutputBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension DeregisterRobotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

enum DeregisterRobotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeDeploymentJob"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeDeploymentJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeDeploymentJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeDeploymentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDeploymentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.robotDeploymentSummary = output.robotDeploymentSummary
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.robotDeploymentSummary = nil
            self.status = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeDeploymentJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deployment job.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment job was created.
    public var createdAt: ClientRuntime.Date?
    /// The deployment application configuration.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// The deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The deployment job failure code.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// A short description of the reason why the deployment job failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// A list of robot deployment summaries.
    public var robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    /// The status of the deployment job.
    public var status: RoboMakerClientTypes.DeploymentStatus?
    /// The list of all tags added to the specified deployment job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.robotDeploymentSummary = robotDeploymentSummary
        self.status = status
        self.tags = tags
    }
}

struct DescribeDeploymentJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let fleet: Swift.String?
    let status: RoboMakerClientTypes.DeploymentStatus?
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let failureReason: Swift.String?
    let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    let createdAt: ClientRuntime.Date?
    let robotDeploymentSummary: [RoboMakerClientTypes.RobotDeployment]?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeDeploymentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case robotDeploymentSummary
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let robotDeploymentSummaryContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotDeployment?].self, forKey: .robotDeploymentSummary)
        var robotDeploymentSummaryDecoded0:[RoboMakerClientTypes.RobotDeployment]? = nil
        if let robotDeploymentSummaryContainer = robotDeploymentSummaryContainer {
            robotDeploymentSummaryDecoded0 = [RoboMakerClientTypes.RobotDeployment]()
            for structure0 in robotDeploymentSummaryContainer {
                if let structure0 = structure0 {
                    robotDeploymentSummaryDecoded0?.append(structure0)
                }
            }
        }
        robotDeploymentSummary = robotDeploymentSummaryDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeDeploymentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

extension DescribeFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeFleet"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeFleetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?

    public init(
        fleet: Swift.String? = nil
    )
    {
        self.fleet = fleet
    }
}

struct DescribeFleetInputBody: Swift.Equatable {
    let fleet: Swift.String?
}

extension DescribeFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension DescribeFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentStatus = output.lastDeploymentStatus
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.robots = output.robots
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentStatus = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.robots = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeFleetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The status of the last deployment.
    public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    /// The time of the last deployment.
    public var lastDeploymentTime: ClientRuntime.Date?
    /// The name of the fleet.
    public var name: Swift.String?
    /// A list of robots.
    public var robots: [RoboMakerClientTypes.Robot]?
    /// The list of all tags added to the specified fleet.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
        lastDeploymentTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentStatus = lastDeploymentStatus
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.robots = robots
        self.tags = tags
    }
}

struct DescribeFleetOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let robots: [RoboMakerClientTypes.Robot]?
    let createdAt: ClientRuntime.Date?
    let lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
    let lastDeploymentJob: Swift.String?
    let lastDeploymentTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
        case robots
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let robotsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Robot?].self, forKey: .robots)
        var robotsDecoded0:[RoboMakerClientTypes.Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [RoboMakerClientTypes.Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DescribeRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeRobotApplication"
    }
}

public struct DescribeRobotApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the robot application to describe.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeRobotApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DescribeRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeRobotApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRobotApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.imageDigest = output.imageDigest
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.imageDigest = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeRobotApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your robot application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified robot application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeRobotApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let revisionId: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
    let imageDigest: Swift.String?
}

extension DescribeRobotApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case imageDigest
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

enum DescribeRobotApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension DescribeRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeRobot"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot to be described.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        robot: Swift.String? = nil
    )
    {
        self.robot = robot
    }
}

struct DescribeRobotInputBody: Swift.Equatable {
    let robot: Swift.String?
}

extension DescribeRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case robot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension DescribeRobotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRobotOutputBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.fleetArn = output.fleetArn
            self.greengrassGroupId = output.greengrassGroupId
            self.lastDeploymentJob = output.lastDeploymentJob
            self.lastDeploymentTime = output.lastDeploymentTime
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.arn = nil
            self.createdAt = nil
            self.fleetArn = nil
            self.greengrassGroupId = nil
            self.lastDeploymentJob = nil
            self.lastDeploymentTime = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct DescribeRobotOutput: Swift.Equatable {
    /// The target architecture of the robot application.
    public var architecture: RoboMakerClientTypes.Architecture?
    /// The Amazon Resource Name (ARN) of the robot.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the robot was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleetArn: Swift.String?
    /// The Greengrass group id.
    public var greengrassGroupId: Swift.String?
    /// The Amazon Resource Name (ARN) of the last deployment job.
    public var lastDeploymentJob: Swift.String?
    /// The time of the last deployment job.
    public var lastDeploymentTime: ClientRuntime.Date?
    /// The name of the robot.
    public var name: Swift.String?
    /// The status of the fleet.
    public var status: RoboMakerClientTypes.RobotStatus?
    /// The list of all tags added to the specified robot.
    public var tags: [Swift.String:Swift.String]?

    public init(
        architecture: RoboMakerClientTypes.Architecture? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        fleetArn: Swift.String? = nil,
        greengrassGroupId: Swift.String? = nil,
        lastDeploymentJob: Swift.String? = nil,
        lastDeploymentTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: RoboMakerClientTypes.RobotStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.arn = arn
        self.createdAt = createdAt
        self.fleetArn = fleetArn
        self.greengrassGroupId = greengrassGroupId
        self.lastDeploymentJob = lastDeploymentJob
        self.lastDeploymentTime = lastDeploymentTime
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct DescribeRobotOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let fleetArn: Swift.String?
    let status: RoboMakerClientTypes.RobotStatus?
    let greengrassGroupId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let architecture: RoboMakerClientTypes.Architecture?
    let lastDeploymentJob: Swift.String?
    let lastDeploymentTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRobotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greengrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeRobotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
    }
}

extension DescribeSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSimulationApplication"
    }
}

public struct DescribeSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The version of the simulation application to describe.
    public var applicationVersion: Swift.String?

    public init(
        application: Swift.String? = nil,
        applicationVersion: Swift.String? = nil
    )
    {
        self.application = application
        self.applicationVersion = applicationVersion
    }
}

struct DescribeSimulationApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let applicationVersion: Swift.String?
}

extension DescribeSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

extension DescribeSimulationApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSimulationApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.imageDigest = output.imageDigest
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.imageDigest = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeSimulationApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the robot simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used to create the simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// A SHA256 identifier for the Docker image that you use for your simulation application.
    public var imageDigest: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The list of all tags added to the specified simulation application.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the simulation application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        imageDigest: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.imageDigest = imageDigest
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.tags = tags
        self.version = version
    }
}

struct DescribeSimulationApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let revisionId: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let environment: RoboMakerClientTypes.Environment?
    let imageDigest: Swift.String?
}

extension DescribeSimulationApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case imageDigest
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

enum DescribeSimulationApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSimulationJobBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batch = self.batch {
            try encodeContainer.encode(batch, forKey: .batch)
        }
    }
}

extension DescribeSimulationJobBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSimulationJobBatch"
    }
}

public struct DescribeSimulationJobBatchInput: Swift.Equatable {
    /// The id of the batch to describe.
    /// This member is required.
    public var batch: Swift.String?

    public init(
        batch: Swift.String? = nil
    )
    {
        self.batch = batch
    }
}

struct DescribeSimulationJobBatchInputBody: Swift.Equatable {
    let batch: Swift.String?
}

extension DescribeSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batch)
        batch = batchDecoded
    }
}

extension DescribeSimulationJobBatchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSimulationJobBatchOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.lastUpdatedAt = output.lastUpdatedAt
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.lastUpdatedAt = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeSimulationJobBatchOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was created.
    public var createdAt: ClientRuntime.Date?
    /// A list of created simulation job summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed create simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code of the simulation job batch.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the simulation job batch.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.lastUpdatedAt = lastUpdatedAt
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct DescribeSimulationJobBatchOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobBatchStatus?
    let lastUpdatedAt: ClientRuntime.Date?
    let createdAt: ClientRuntime.Date?
    let clientRequestToken: Swift.String?
    let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    let failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    let failureReason: Swift.String?
    let failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    let pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    let createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeSimulationJobBatchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case lastUpdatedAt
        case pendingRequests
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [RoboMakerClientTypes.FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeSimulationJobBatchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSimulationJob"
    }
}

public struct DescribeSimulationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job to be described.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSimulationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSimulationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSimulationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.compute = output.compute
            self.dataSources = output.dataSources
            self.failureBehavior = output.failureBehavior
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.lastStartedAt = output.lastStartedAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.loggingConfig = output.loggingConfig
            self.maxJobDurationInSeconds = output.maxJobDurationInSeconds
            self.name = output.name
            self.networkInterface = output.networkInterface
            self.outputLocation = output.outputLocation
            self.robotApplications = output.robotApplications
            self.simulationApplications = output.simulationApplications
            self.simulationTimeMillis = output.simulationTimeMillis
            self.status = output.status
            self.tags = output.tags
            self.vpcConfig = output.vpcConfig
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.compute = nil
            self.dataSources = nil
            self.failureBehavior = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.lastStartedAt = nil
            self.lastUpdatedAt = nil
            self.loggingConfig = nil
            self.maxJobDurationInSeconds = 0
            self.name = nil
            self.networkInterface = nil
            self.outputLocation = nil
            self.robotApplications = nil
            self.simulationApplications = nil
            self.simulationTimeMillis = 0
            self.status = nil
            self.tags = nil
            self.vpcConfig = nil
        }
    }
}

public struct DescribeSimulationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// Compute information for the simulation job.
    public var compute: RoboMakerClientTypes.ComputeResponse?
    /// The data sources for the simulation job.
    public var dataSources: [RoboMakerClientTypes.DataSource]?
    /// The failure behavior for the simulation job.
    public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
    /// The failure code of the simulation job if it failed: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    /// Details about why the simulation job failed. For more information about troubleshooting, see [Troubleshooting](https://docs.aws.amazon.com/robomaker/latest/dg/troubleshooting.html).
    public var failureReason: Swift.String?
    /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf.
    public var iamRole: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job was last started.
    public var lastStartedAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the simulation job was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The logging configuration.
    public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
    /// The maximum job duration in seconds. The value must be 8 days (691,200 seconds) or less.
    public var maxJobDurationInSeconds: Swift.Int
    /// The name of the simulation job.
    public var name: Swift.String?
    /// The network interface information for the simulation job.
    public var networkInterface: RoboMakerClientTypes.NetworkInterface?
    /// Location for output files generated by the simulation job.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// A list of robot applications.
    public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    /// A list of simulation applications.
    public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    /// The simulation job execution duration in milliseconds.
    public var simulationTimeMillis: Swift.Int
    /// The status of the simulation job.
    public var status: RoboMakerClientTypes.SimulationJobStatus?
    /// The list of all tags added to the specified simulation job.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration.
    public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        compute: RoboMakerClientTypes.ComputeResponse? = nil,
        dataSources: [RoboMakerClientTypes.DataSource]? = nil,
        failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        lastStartedAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
        maxJobDurationInSeconds: Swift.Int = 0,
        name: Swift.String? = nil,
        networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
        simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
        simulationTimeMillis: Swift.Int = 0,
        status: RoboMakerClientTypes.SimulationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.compute = compute
        self.dataSources = dataSources
        self.failureBehavior = failureBehavior
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.lastStartedAt = lastStartedAt
        self.lastUpdatedAt = lastUpdatedAt
        self.loggingConfig = loggingConfig
        self.maxJobDurationInSeconds = maxJobDurationInSeconds
        self.name = name
        self.networkInterface = networkInterface
        self.outputLocation = outputLocation
        self.robotApplications = robotApplications
        self.simulationApplications = simulationApplications
        self.simulationTimeMillis = simulationTimeMillis
        self.status = status
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct DescribeSimulationJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobStatus?
    let lastStartedAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let failureBehavior: RoboMakerClientTypes.FailureBehavior?
    let failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
    let failureReason: Swift.String?
    let clientRequestToken: Swift.String?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let loggingConfig: RoboMakerClientTypes.LoggingConfig?
    let maxJobDurationInSeconds: Swift.Int
    let simulationTimeMillis: Swift.Int
    let iamRole: Swift.String?
    let robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
    let simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
    let dataSources: [RoboMakerClientTypes.DataSource]?
    let tags: [Swift.String:Swift.String]?
    let vpcConfig: RoboMakerClientTypes.VPCConfigResponse?
    let networkInterface: RoboMakerClientTypes.NetworkInterface?
    let compute: RoboMakerClientTypes.ComputeResponse?
}

extension DescribeSimulationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

enum DescribeSimulationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorldExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeWorldExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorldExportJob"
    }
}

public struct DescribeWorldExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world export job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldExportJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeWorldExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorldExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.iamRole = output.iamRole
            self.outputLocation = output.outputLocation
            self.status = output.status
            self.tags = output.tags
            self.worlds = output.worlds
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.iamRole = nil
            self.outputLocation = nil
            self.status = nil
            self.tags = nil
            self.worlds = nil
        }
    }
}

public struct DescribeWorldExportJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world export job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world export job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    /// The reason why the world export job failed.
    public var failureReason: Swift.String?
    /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
    public var iamRole: Swift.String?
    /// The output location.
    public var outputLocation: RoboMakerClientTypes.OutputLocation?
    /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode and failureReason for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
    public var status: RoboMakerClientTypes.WorldExportJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world export job.
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (arns) that correspond to worlds to be exported.
    public var worlds: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldExportJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        iamRole: Swift.String? = nil,
        outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
        status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        worlds: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.iamRole = iamRole
        self.outputLocation = outputLocation
        self.status = status
        self.tags = tags
        self.worlds = worlds
    }
}

struct DescribeWorldExportJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldExportJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldExportJobErrorCode?
    let failureReason: Swift.String?
    let clientRequestToken: Swift.String?
    let worlds: [Swift.String]?
    let outputLocation: RoboMakerClientTypes.OutputLocation?
    let iamRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeWorldExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case iamRole
        case outputLocation
        case status
        case tags
        case worlds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeWorldExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorldGenerationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension DescribeWorldGenerationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorldGenerationJob"
    }
}

public struct DescribeWorldGenerationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generation job to describe.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct DescribeWorldGenerationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension DescribeWorldGenerationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeWorldGenerationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorldGenerationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.finishedWorldsSummary = output.finishedWorldsSummary
            self.status = output.status
            self.tags = output.tags
            self.template = output.template
            self.worldCount = output.worldCount
            self.worldTags = output.worldTags
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureReason = nil
            self.finishedWorldsSummary = nil
            self.status = nil
            self.tags = nil
            self.template = nil
            self.worldCount = nil
            self.worldTags = nil
        }
    }
}

public struct DescribeWorldGenerationJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world generation job.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world generation job was created.
    public var createdAt: ClientRuntime.Date?
    /// The failure code of the world generation job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
    public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    /// The reason why the world generation job failed.
    public var failureReason: Swift.String?
    /// Summary information about finished worlds.
    public var finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    /// The status of the world generation job: Pending The world generation job request is pending. Running The world generation job is running. Completed The world generation job completed. Failed The world generation job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generation job was cancelled. Canceling The world generation job is being cancelled.
    public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
    /// A map that contains tag keys and tag values that are attached to the world generation job.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?
    /// Information about the world count.
    public var worldCount: RoboMakerClientTypes.WorldCount?
    /// A map that contains tag keys and tag values that are attached to the generated worlds.
    public var worldTags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary? = nil,
        status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldCount: RoboMakerClientTypes.WorldCount? = nil,
        worldTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.finishedWorldsSummary = finishedWorldsSummary
        self.status = status
        self.tags = tags
        self.template = template
        self.worldCount = worldCount
        self.worldTags = worldTags
    }
}

struct DescribeWorldGenerationJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.WorldGenerationJobStatus?
    let createdAt: ClientRuntime.Date?
    let failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
    let failureReason: Swift.String?
    let clientRequestToken: Swift.String?
    let template: Swift.String?
    let worldCount: RoboMakerClientTypes.WorldCount?
    let finishedWorldsSummary: RoboMakerClientTypes.FinishedWorldsSummary?
    let tags: [Swift.String:Swift.String]?
    let worldTags: [Swift.String:Swift.String]?
}

extension DescribeWorldGenerationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case failureCode
        case failureReason
        case finishedWorldsSummary
        case status
        case tags
        case template
        case worldCount
        case worldTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let finishedWorldsSummaryDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FinishedWorldsSummary.self, forKey: .finishedWorldsSummary)
        finishedWorldsSummary = finishedWorldsSummaryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .worldTags)
        var worldTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let worldTagsContainer = worldTagsContainer {
            worldTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in worldTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    worldTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        worldTags = worldTagsDecoded0
    }
}

enum DescribeWorldGenerationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = self.world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }
}

extension DescribeWorldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorld"
    }
}

public struct DescribeWorldInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world you want to describe.
    /// This member is required.
    public var world: Swift.String?

    public init(
        world: Swift.String? = nil
    )
    {
        self.world = world
    }
}

struct DescribeWorldInputBody: Swift.Equatable {
    let world: Swift.String?
}

extension DescribeWorldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .world)
        world = worldDecoded
    }
}

extension DescribeWorldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorldOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.generationJob = output.generationJob
            self.tags = output.tags
            self.template = output.template
            self.worldDescriptionBody = output.worldDescriptionBody
        } else {
            self.arn = nil
            self.createdAt = nil
            self.generationJob = nil
            self.tags = nil
            self.template = nil
            self.worldDescriptionBody = nil
        }
    }
}

public struct DescribeWorldOutput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (arn) of the world generation job that generated the world.
    public var generationJob: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world.
    public var tags: [Swift.String:Swift.String]?
    /// The world template.
    public var template: Swift.String?
    /// Returns the JSON formatted string that describes the contents of your world.
    public var worldDescriptionBody: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        generationJob: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        template: Swift.String? = nil,
        worldDescriptionBody: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.generationJob = generationJob
        self.tags = tags
        self.template = template
        self.worldDescriptionBody = worldDescriptionBody
    }
}

struct DescribeWorldOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let generationJob: Swift.String?
    let template: Swift.String?
    let createdAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let worldDescriptionBody: Swift.String?
}

extension DescribeWorldOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case generationJob
        case tags
        case template
        case worldDescriptionBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let worldDescriptionBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .worldDescriptionBody)
        worldDescriptionBody = worldDescriptionBodyDecoded
    }
}

enum DescribeWorldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension DescribeWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeWorldTemplate"
    }
}

public struct DescribeWorldTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template you want to describe.
    /// This member is required.
    public var template: Swift.String?

    public init(
        template: Swift.String? = nil
    )
    {
        self.template = template
    }
}

struct DescribeWorldTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
}

extension DescribeWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case template
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension DescribeWorldTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorldTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.tags = output.tags
            self.version = output.version
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.tags = nil
            self.version = nil
        }
    }
}

public struct DescribeWorldTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the world template.
    public var arn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the world template was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the world template.
    public var tags: [Swift.String:Swift.String]?
    /// The version of the world template that you're using.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.tags = tags
        self.version = version
    }
}

struct DescribeWorldTemplateOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let clientRequestToken: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
}

extension DescribeWorldTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdAt
        case lastUpdatedAt
        case name
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum DescribeWorldTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension RoboMakerClientTypes {
    /// The object that contains the Docker image URI for either your robot or simulation applications.
    public struct Environment: Swift.Equatable {
        /// The Docker image URI for either your robot or simulation applications.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension RoboMakerClientTypes {
    public enum ExitBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case restart
        case sdkUnknown(Swift.String)

        public static var allCases: [ExitBehavior] {
            return [
                .fail,
                .restart,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .restart: return "RESTART"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExitBehavior(rawValue: rawValue) ?? ExitBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.FailedCreateSimulationJobRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedAt
        case failureCode
        case failureReason
        case request
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedAt = self.failedAt {
            try encodeContainer.encodeTimestamp(failedAt, format: .epochSeconds, forKey: .failedAt)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let request = self.request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobRequest.self, forKey: .request)
        request = requestDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .failedAt)
        failedAt = failedAtDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a failed create simulation job request.
    public struct FailedCreateSimulationJobRequest: Swift.Equatable {
        /// The time, in milliseconds since the epoch, when the simulation job batch failed.
        public var failedAt: ClientRuntime.Date?
        /// The failure code.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The failure reason of the simulation job request.
        public var failureReason: Swift.String?
        /// The simulation job request.
        public var request: RoboMakerClientTypes.SimulationJobRequest?

        public init(
            failedAt: ClientRuntime.Date? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            request: RoboMakerClientTypes.SimulationJobRequest? = nil
        )
        {
            self.failedAt = failedAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.request = request
        }
    }

}

extension RoboMakerClientTypes {
    public enum FailureBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `continue`
        case fail
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureBehavior] {
            return [
                .continue,
                .fail,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continue: return "Continue"
            case .fail: return "Fail"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureBehavior(rawValue: rawValue) ?? FailureBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.FailureSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case totalFailureCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for worldfailure0 in failures {
                try failuresContainer.encode(worldfailure0)
            }
        }
        if totalFailureCount != 0 {
            try encodeContainer.encode(totalFailureCount, forKey: .totalFailureCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalFailureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalFailureCount) ?? 0
        totalFailureCount = totalFailureCountDecoded
        let failuresContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldFailure?].self, forKey: .failures)
        var failuresDecoded0:[RoboMakerClientTypes.WorldFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [RoboMakerClientTypes.WorldFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about worlds that failed.
    public struct FailureSummary: Swift.Equatable {
        /// The worlds that failed.
        public var failures: [RoboMakerClientTypes.WorldFailure]?
        /// The total number of failures.
        public var totalFailureCount: Swift.Int

        public init(
            failures: [RoboMakerClientTypes.WorldFailure]? = nil,
            totalFailureCount: Swift.Int = 0
        )
        {
            self.failures = failures
            self.totalFailureCount = totalFailureCount
        }
    }

}

extension RoboMakerClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for name0 in values {
                try valuesContainer.encode(name0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about a filter.
    public struct Filter: Swift.Equatable {
        /// The name of the filter.
        public var name: Swift.String?
        /// A list of values.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RoboMakerClientTypes.FinishedWorldsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureSummary
        case finishedCount
        case succeededWorlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureSummary = self.failureSummary {
            try encodeContainer.encode(failureSummary, forKey: .failureSummary)
        }
        if finishedCount != 0 {
            try encodeContainer.encode(finishedCount, forKey: .finishedCount)
        }
        if let succeededWorlds = succeededWorlds {
            var succeededWorldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .succeededWorlds)
            for arn0 in succeededWorlds {
                try succeededWorldsContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finishedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finishedCount) ?? 0
        finishedCount = finishedCountDecoded
        let succeededWorldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .succeededWorlds)
        var succeededWorldsDecoded0:[Swift.String]? = nil
        if let succeededWorldsContainer = succeededWorldsContainer {
            succeededWorldsDecoded0 = [Swift.String]()
            for string0 in succeededWorldsContainer {
                if let string0 = string0 {
                    succeededWorldsDecoded0?.append(string0)
                }
            }
        }
        succeededWorlds = succeededWorldsDecoded0
        let failureSummaryDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureSummary.self, forKey: .failureSummary)
        failureSummary = failureSummaryDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about worlds that finished.
    public struct FinishedWorldsSummary: Swift.Equatable {
        /// Information about worlds that failed.
        public var failureSummary: RoboMakerClientTypes.FailureSummary?
        /// The total number of finished worlds.
        public var finishedCount: Swift.Int
        /// A list of worlds that succeeded.
        public var succeededWorlds: [Swift.String]?

        public init(
            failureSummary: RoboMakerClientTypes.FailureSummary? = nil,
            finishedCount: Swift.Int = 0,
            succeededWorlds: [Swift.String]? = nil
        )
        {
            self.failureSummary = failureSummary
            self.finishedCount = finishedCount
            self.succeededWorlds = succeededWorlds
        }
    }

}

extension RoboMakerClientTypes.Fleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastDeploymentJob
        case lastDeploymentStatus
        case lastDeploymentTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastDeploymentJob = self.lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentStatus = self.lastDeploymentStatus {
            try encodeContainer.encode(lastDeploymentStatus.rawValue, forKey: .lastDeploymentStatus)
        }
        if let lastDeploymentTime = self.lastDeploymentTime {
            try encodeContainer.encodeTimestamp(lastDeploymentTime, format: .epochSeconds, forKey: .lastDeploymentTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastDeploymentStatusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .lastDeploymentStatus)
        lastDeploymentStatus = lastDeploymentStatusDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a fleet.
    public struct Fleet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the fleet.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The status of the last fleet deployment.
        public var lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus?
        /// The time of the last deployment.
        public var lastDeploymentTime: ClientRuntime.Date?
        /// The name of the fleet.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentStatus: RoboMakerClientTypes.DeploymentStatus? = nil,
            lastDeploymentTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentStatus = lastDeploymentStatus
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
        }
    }

}

extension GetWorldTemplateBodyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationJob
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationJob = self.generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }
}

extension GetWorldTemplateBodyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorldTemplateBody"
    }
}

public struct GetWorldTemplateBodyInput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world generator job.
    public var generationJob: Swift.String?
    /// The Amazon Resource Name (arn) of the world template.
    public var template: Swift.String?

    public init(
        generationJob: Swift.String? = nil,
        template: Swift.String? = nil
    )
    {
        self.generationJob = generationJob
        self.template = template
    }
}

struct GetWorldTemplateBodyInputBody: Swift.Equatable {
    let template: Swift.String?
    let generationJob: Swift.String?
}

extension GetWorldTemplateBodyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationJob
        case template
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
    }
}

extension GetWorldTemplateBodyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorldTemplateBodyOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateBody = output.templateBody
        } else {
            self.templateBody = nil
        }
    }
}

public struct GetWorldTemplateBodyOutput: Swift.Equatable {
    /// The world template body.
    public var templateBody: Swift.String?

    public init(
        templateBody: Swift.String? = nil
    )
    {
        self.templateBody = templateBody
    }
}

struct GetWorldTemplateBodyOutputBody: Swift.Equatable {
    let templateBody: Swift.String?
}

extension GetWorldTemplateBodyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
    }
}

enum GetWorldTemplateBodyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdempotentParameterMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request uses the same client token as a previous, but non-identical request. Do not reuse a client token with different requests, unless the requests are identical.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// AWS RoboMaker experienced a service issue. Try your call again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A parameter specified in a request is not valid, is unsupported, or cannot be used. The returned message provides an explanation of the error value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.LaunchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case environmentVariables
        case launchFile
        case packageName
        case portForwardingConfig
        case streamUI
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for nonemptystring0 in command {
                try commandContainer.encode(nonemptystring0)
            }
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariableMap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchFile = self.launchFile {
            try encodeContainer.encode(launchFile, forKey: .launchFile)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let portForwardingConfig = self.portForwardingConfig {
            try encodeContainer.encode(portForwardingConfig, forKey: .portForwardingConfig)
        }
        if streamUI != false {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let launchFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchFile)
        launchFile = launchFileDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let portForwardingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.PortForwardingConfig.self, forKey: .portForwardingConfig)
        portForwardingConfig = portForwardingConfigDecoded
        let streamUIDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamUI) ?? false
        streamUI = streamUIDecoded
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about a launch configuration.
    public struct LaunchConfig: Swift.Equatable {
        /// If you've specified General as the value for your RobotSoftwareSuite, you can use this field to specify a list of commands for your container image. If you've specified SimulationRuntime as the value for your SimulationSoftwareSuite, you can use this field to specify a list of commands for your container image.
        public var command: [Swift.String]?
        /// The environment variables for the application launch.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The launch file name.
        public var launchFile: Swift.String?
        /// The package name.
        public var packageName: Swift.String?
        /// The port forwarding configuration.
        public var portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig?
        /// Boolean indicating whether a streaming session will be configured for the application. If True, AWS RoboMaker will configure a connection so you can interact with your application as it is running in the simulation. You must configure and launch the component. It must have a graphical user interface.
        public var streamUI: Swift.Bool

        public init(
            command: [Swift.String]? = nil,
            environmentVariables: [Swift.String:Swift.String]? = nil,
            launchFile: Swift.String? = nil,
            packageName: Swift.String? = nil,
            portForwardingConfig: RoboMakerClientTypes.PortForwardingConfig? = nil,
            streamUI: Swift.Bool = false
        )
        {
            self.command = command
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.portForwardingConfig = portForwardingConfig
            self.streamUI = streamUI
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDeploymentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeploymentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDeploymentJobs"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListDeploymentJobsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status InProgress or the status Pending.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListDeploymentJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListDeploymentJobs request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListDeploymentJobs returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsInputBody: Swift.Equatable {
    let filters: [RoboMakerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeploymentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeploymentJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentJobs = output.deploymentJobs
            self.nextToken = output.nextToken
        } else {
            self.deploymentJobs = nil
            self.nextToken = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListDeploymentJobsOutput: Swift.Equatable {
    /// A list of deployment jobs that meet the criteria of the request.
    public var deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        deploymentJobs: [RoboMakerClientTypes.DeploymentJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentJobs = deploymentJobs
        self.nextToken = nextToken
    }
}

struct ListDeploymentJobsOutputBody: Swift.Equatable {
    let deploymentJobs: [RoboMakerClientTypes.DeploymentJob]?
    let nextToken: Swift.String?
}

extension ListDeploymentJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentJobsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentJob?].self, forKey: .deploymentJobs)
        var deploymentJobsDecoded0:[RoboMakerClientTypes.DeploymentJob]? = nil
        if let deploymentJobsContainer = deploymentJobsContainer {
            deploymentJobsDecoded0 = [RoboMakerClientTypes.DeploymentJob]()
            for structure0 in deploymentJobsContainer {
                if let structure0 = structure0 {
                    deploymentJobsDecoded0?.append(structure0)
                }
            }
        }
        deploymentJobs = deploymentJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listFleets"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListFleetsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListFleets only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFleets request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListFleets returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetDetails = output.fleetDetails
            self.nextToken = output.nextToken
        } else {
            self.fleetDetails = nil
            self.nextToken = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListFleetsOutput: Swift.Equatable {
    /// A list of fleet details meeting the request criteria.
    public var fleetDetails: [RoboMakerClientTypes.Fleet]?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        fleetDetails: [RoboMakerClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetDetails = fleetDetails
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputBody: Swift.Equatable {
    let fleetDetails: [RoboMakerClientTypes.Fleet]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetDetails
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDetailsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Fleet?].self, forKey: .fleetDetails)
        var fleetDetailsDecoded0:[RoboMakerClientTypes.Fleet]? = nil
        if let fleetDetailsContainer = fleetDetailsContainer {
            fleetDetailsDecoded0 = [RoboMakerClientTypes.Fleet]()
            for structure0 in fleetDetailsContainer {
                if let structure0 = structure0 {
                    fleetDetailsDecoded0?.append(structure0)
                }
            }
        }
        fleetDetails = fleetDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRobotApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = self.versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

extension ListRobotApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listRobotApplications"
    }
}

public struct ListRobotApplicationsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobotApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobotApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListRobotApplications returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the robot application.
    public var versionQualifier: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListRobotApplicationsInputBody: Swift.Equatable {
    let versionQualifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListRobotApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRobotApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.robotApplicationSummaries = output.robotApplicationSummaries
        } else {
            self.nextToken = nil
            self.robotApplicationSummaries = nil
        }
    }
}

public struct ListRobotApplicationsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robot application summaries that meet the criteria of the request.
    public var robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.robotApplicationSummaries = robotApplicationSummaries
    }
}

struct ListRobotApplicationsOutputBody: Swift.Equatable {
    let robotApplicationSummaries: [RoboMakerClientTypes.RobotApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListRobotApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case robotApplicationSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotApplicationSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationSummary?].self, forKey: .robotApplicationSummaries)
        var robotApplicationSummariesDecoded0:[RoboMakerClientTypes.RobotApplicationSummary]? = nil
        if let robotApplicationSummariesContainer = robotApplicationSummariesContainer {
            robotApplicationSummariesDecoded0 = [RoboMakerClientTypes.RobotApplicationSummary]()
            for structure0 in robotApplicationSummariesContainer {
                if let structure0 = structure0 {
                    robotApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        robotApplicationSummaries = robotApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRobotApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRobotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRobotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listRobots"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListRobotsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Registered or the status Available.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListRobots only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobots request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListRobots returns up to 200 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRobotsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListRobotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListRobotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRobotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.robots = output.robots
        } else {
            self.nextToken = nil
            self.robots = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct ListRobotsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of robots that meet the criteria of the request.
    public var robots: [RoboMakerClientTypes.Robot]?

    public init(
        nextToken: Swift.String? = nil,
        robots: [RoboMakerClientTypes.Robot]? = nil
    )
    {
        self.nextToken = nextToken
        self.robots = robots
    }
}

struct ListRobotsOutputBody: Swift.Equatable {
    let robots: [RoboMakerClientTypes.Robot]?
    let nextToken: Swift.String?
}

extension ListRobotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case robots
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let robotsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Robot?].self, forKey: .robots)
        var robotsDecoded0:[RoboMakerClientTypes.Robot]? = nil
        if let robotsContainer = robotsContainer {
            robotsDecoded0 = [RoboMakerClientTypes.Robot]()
            for structure0 in robotsContainer {
                if let structure0 = structure0 {
                    robotsDecoded0?.append(structure0)
                }
            }
        }
        robots = robotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRobotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSimulationApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let versionQualifier = self.versionQualifier {
            try encodeContainer.encode(versionQualifier, forKey: .versionQualifier)
        }
    }
}

extension ListSimulationApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSimulationApplications"
    }
}

public struct ListSimulationApplicationsInput: Swift.Equatable {
    /// Optional list of filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListSimulationApplications returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The version qualifier of the simulation application.
    public var versionQualifier: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        versionQualifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.versionQualifier = versionQualifier
    }
}

struct ListSimulationApplicationsInputBody: Swift.Equatable {
    let versionQualifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case versionQualifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionQualifier)
        versionQualifier = versionQualifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSimulationApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationApplicationSummaries = output.simulationApplicationSummaries
        } else {
            self.nextToken = nil
            self.simulationApplicationSummaries = nil
        }
    }
}

public struct ListSimulationApplicationsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation application summaries that meet the criteria of the request.
    public var simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationApplicationSummaries = simulationApplicationSummaries
    }
}

struct ListSimulationApplicationsOutputBody: Swift.Equatable {
    let simulationApplicationSummaries: [RoboMakerClientTypes.SimulationApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListSimulationApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationApplicationSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationApplicationSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationSummary?].self, forKey: .simulationApplicationSummaries)
        var simulationApplicationSummariesDecoded0:[RoboMakerClientTypes.SimulationApplicationSummary]? = nil
        if let simulationApplicationSummariesContainer = simulationApplicationSummariesContainer {
            simulationApplicationSummariesDecoded0 = [RoboMakerClientTypes.SimulationApplicationSummary]()
            for structure0 in simulationApplicationSummariesContainer {
                if let structure0 = structure0 {
                    simulationApplicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationApplicationSummaries = simulationApplicationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSimulationApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSimulationJobBatchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSimulationJobBatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSimulationJobBatches"
    }
}

public struct ListSimulationJobBatchesInput: Swift.Equatable {
    /// Optional filters to limit results.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobBatches only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobBatches request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobBatchesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationJobBatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobBatchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSimulationJobBatchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationJobBatchSummaries = output.simulationJobBatchSummaries
        } else {
            self.nextToken = nil
            self.simulationJobBatchSummaries = nil
        }
    }
}

public struct ListSimulationJobBatchesOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job batch summaries.
    public var simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?

    public init(
        nextToken: Swift.String? = nil,
        simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobBatchSummaries = simulationJobBatchSummaries
    }
}

struct ListSimulationJobBatchesOutputBody: Swift.Equatable {
    let simulationJobBatchSummaries: [RoboMakerClientTypes.SimulationJobBatchSummary]?
    let nextToken: Swift.String?
}

extension ListSimulationJobBatchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationJobBatchSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobBatchSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobBatchSummary?].self, forKey: .simulationJobBatchSummaries)
        var simulationJobBatchSummariesDecoded0:[RoboMakerClientTypes.SimulationJobBatchSummary]? = nil
        if let simulationJobBatchSummariesContainer = simulationJobBatchSummariesContainer {
            simulationJobBatchSummariesDecoded0 = [RoboMakerClientTypes.SimulationJobBatchSummary]()
            for structure0 in simulationJobBatchSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobBatchSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobBatchSummaries = simulationJobBatchSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSimulationJobBatchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSimulationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSimulationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSimulationJobs"
    }
}

public struct ListSimulationJobsInput: Swift.Equatable {
    /// Optional filters to limit results. The filter names status and simulationApplicationName and robotApplicationName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Preparing or the status Running.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListSimulationJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobs request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListSimulationJobs returns up to 1000 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListSimulationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListSimulationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSimulationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulationJobSummaries = output.simulationJobSummaries
        } else {
            self.nextToken = nil
            self.simulationJobSummaries = nil
        }
    }
}

public struct ListSimulationJobsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of simulation job summaries that meet the criteria of the request.
    /// This member is required.
    public var simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulationJobSummaries = simulationJobSummaries
    }
}

struct ListSimulationJobsOutputBody: Swift.Equatable {
    let simulationJobSummaries: [RoboMakerClientTypes.SimulationJobSummary]?
    let nextToken: Swift.String?
}

extension ListSimulationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case simulationJobSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .simulationJobSummaries)
        var simulationJobSummariesDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let simulationJobSummariesContainer = simulationJobSummariesContainer {
            simulationJobSummariesDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in simulationJobSummariesContainer {
                if let structure0 = structure0 {
                    simulationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        simulationJobSummaries = simulationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSimulationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The AWS RoboMaker Amazon Resource Name (ARN) with tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of all tags added to the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorldExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorldExportJobs"
    }
}

public struct ListWorldExportJobsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use generationJobId and templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldExportJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldExportJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldExportJobs returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorldExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldExportJobSummaries = output.worldExportJobSummaries
        } else {
            self.nextToken = nil
            self.worldExportJobSummaries = nil
        }
    }
}

public struct ListWorldExportJobsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world export jobs.
    /// This member is required.
    public var worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldExportJobSummaries = worldExportJobSummaries
    }
}

struct ListWorldExportJobsOutputBody: Swift.Equatable {
    let worldExportJobSummaries: [RoboMakerClientTypes.WorldExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListWorldExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldExportJobSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldExportJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldExportJobSummary?].self, forKey: .worldExportJobSummaries)
        var worldExportJobSummariesDecoded0:[RoboMakerClientTypes.WorldExportJobSummary]? = nil
        if let worldExportJobSummariesContainer = worldExportJobSummariesContainer {
            worldExportJobSummariesDecoded0 = [RoboMakerClientTypes.WorldExportJobSummary]()
            for structure0 in worldExportJobSummariesContainer {
                if let structure0 = structure0 {
                    worldExportJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldExportJobSummaries = worldExportJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorldExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorldGenerationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldGenerationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorldGenerationJobs"
    }
}

public struct ListWorldGenerationJobsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use status and templateId.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorldGeneratorJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldGeneratorJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldGeneratorJobs returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGenerationJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldGenerationJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldGenerationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldGenerationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorldGenerationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldGenerationJobSummaries = output.worldGenerationJobSummaries
        } else {
            self.nextToken = nil
            self.worldGenerationJobSummaries = nil
        }
    }
}

public struct ListWorldGenerationJobsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGeneratorJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for world generator jobs.
    /// This member is required.
    public var worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldGenerationJobSummaries = worldGenerationJobSummaries
    }
}

struct ListWorldGenerationJobsOutputBody: Swift.Equatable {
    let worldGenerationJobSummaries: [RoboMakerClientTypes.WorldGenerationJobSummary]?
    let nextToken: Swift.String?
}

extension ListWorldGenerationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldGenerationJobSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldGenerationJobSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldGenerationJobSummary?].self, forKey: .worldGenerationJobSummaries)
        var worldGenerationJobSummariesDecoded0:[RoboMakerClientTypes.WorldGenerationJobSummary]? = nil
        if let worldGenerationJobSummariesContainer = worldGenerationJobSummariesContainer {
            worldGenerationJobSummariesDecoded0 = [RoboMakerClientTypes.WorldGenerationJobSummary]()
            for structure0 in worldGenerationJobSummariesContainer {
                if let structure0 = structure0 {
                    worldGenerationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldGenerationJobSummaries = worldGenerationJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorldGenerationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorldTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorldTemplates"
    }
}

public struct ListWorldTemplatesInput: Swift.Equatable {
    /// When this parameter is used, ListWorldTemplates only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldTemplates request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldTemplates returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldTemplatesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWorldTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorldTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorldTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateSummaries = output.templateSummaries
        } else {
            self.nextToken = nil
            self.templateSummaries = nil
        }
    }
}

public struct ListWorldTemplatesOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for templates.
    public var templateSummaries: [RoboMakerClientTypes.TemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateSummaries: [RoboMakerClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateSummaries = templateSummaries
    }
}

struct ListWorldTemplatesOutputBody: Swift.Equatable {
    let templateSummaries: [RoboMakerClientTypes.TemplateSummary]?
    let nextToken: Swift.String?
}

extension ListWorldTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templateSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.TemplateSummary?].self, forKey: .templateSummaries)
        var templateSummariesDecoded0:[RoboMakerClientTypes.TemplateSummary]? = nil
        if let templateSummariesContainer = templateSummariesContainer {
            templateSummariesDecoded0 = [RoboMakerClientTypes.TemplateSummary]()
            for structure0 in templateSummariesContainer {
                if let structure0 = structure0 {
                    templateSummariesDecoded0?.append(structure0)
                }
            }
        }
        templateSummaries = templateSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorldTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorldsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorlds"
    }
}

public struct ListWorldsInput: Swift.Equatable {
    /// Optional filters to limit results. You can use status.
    public var filters: [RoboMakerClientTypes.Filter]?
    /// When this parameter is used, ListWorlds only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorlds request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorlds returns up to 100 results and a nextToken value if applicable.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        filters: [RoboMakerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorldsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [RoboMakerClientTypes.Filter]?
}

extension ListWorldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[RoboMakerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RoboMakerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListWorldsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorldsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.worldSummaries = output.worldSummaries
        } else {
            self.nextToken = nil
            self.worldSummaries = nil
        }
    }
}

public struct ListWorldsOutput: Swift.Equatable {
    /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// Summary information for worlds.
    public var worldSummaries: [RoboMakerClientTypes.WorldSummary]?

    public init(
        nextToken: Swift.String? = nil,
        worldSummaries: [RoboMakerClientTypes.WorldSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.worldSummaries = worldSummaries
    }
}

struct ListWorldsOutputBody: Swift.Equatable {
    let worldSummaries: [RoboMakerClientTypes.WorldSummary]?
    let nextToken: Swift.String?
}

extension ListWorldsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case worldSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldSummariesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldSummary?].self, forKey: .worldSummaries)
        var worldSummariesDecoded0:[RoboMakerClientTypes.WorldSummary]? = nil
        if let worldSummariesContainer = worldSummariesContainer {
            worldSummariesDecoded0 = [RoboMakerClientTypes.WorldSummary]()
            for structure0 in worldSummariesContainer {
                if let structure0 = structure0 {
                    worldSummariesDecoded0?.append(structure0)
                }
            }
        }
        worldSummaries = worldSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorldsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.LoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordAllRosTopics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordAllRosTopics = self.recordAllRosTopics {
            try encodeContainer.encode(recordAllRosTopics, forKey: .recordAllRosTopics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordAllRosTopicsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recordAllRosTopics)
        recordAllRosTopics = recordAllRosTopicsDecoded
    }
}

extension RoboMakerClientTypes {
    /// The logging configuration.
    public struct LoggingConfig: Swift.Equatable {
        /// A boolean indicating whether to record all ROS topics. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var recordAllRosTopics: Swift.Bool?

        public init(
            recordAllRosTopics: Swift.Bool? = nil
        )
        {
            self.recordAllRosTopics = recordAllRosTopics
        }
    }

}

extension RoboMakerClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId
        case privateIpAddress
        case publicIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = self.publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
    }
}

extension RoboMakerClientTypes {
    /// Describes a network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The IPv4 public address of the network interface.
        public var publicIpAddress: Swift.String?

        public init(
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }
    }

}

extension RoboMakerClientTypes.OutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Prefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension RoboMakerClientTypes {
    /// The output location.
    public struct OutputLocation: Swift.Equatable {
        /// The S3 bucket for output.
        public var s3Bucket: Swift.String?
        /// The S3 folder in the s3Bucket where output files will be placed.
        public var s3Prefix: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension RoboMakerClientTypes.PortForwardingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portMappings = portMappings {
            var portMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portMappings)
            for portmapping0 in portMappings {
                try portMappingsContainer.encode(portmapping0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[RoboMakerClientTypes.PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [RoboMakerClientTypes.PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for port forwarding.
    public struct PortForwardingConfig: Swift.Equatable {
        /// The port mappings for the configuration.
        public var portMappings: [RoboMakerClientTypes.PortMapping]?

        public init(
            portMappings: [RoboMakerClientTypes.PortMapping]? = nil
        )
        {
            self.portMappings = portMappings
        }
    }

}

extension RoboMakerClientTypes.PortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPort
        case enableOnPublicIp
        case jobPort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationPort != 0 {
            try encodeContainer.encode(applicationPort, forKey: .applicationPort)
        }
        if enableOnPublicIp != false {
            try encodeContainer.encode(enableOnPublicIp, forKey: .enableOnPublicIp)
        }
        if jobPort != 0 {
            try encodeContainer.encode(jobPort, forKey: .jobPort)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobPort) ?? 0
        jobPort = jobPortDecoded
        let applicationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationPort) ?? 0
        applicationPort = applicationPortDecoded
        let enableOnPublicIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableOnPublicIp) ?? false
        enableOnPublicIp = enableOnPublicIpDecoded
    }
}

extension RoboMakerClientTypes {
    /// An object representing a port mapping.
    public struct PortMapping: Swift.Equatable {
        /// The port number on the application.
        /// This member is required.
        public var applicationPort: Swift.Int
        /// A Boolean indicating whether to enable this port mapping on public IP.
        public var enableOnPublicIp: Swift.Bool
        /// The port number on the simulation job instance to use as a remote connection point.
        /// This member is required.
        public var jobPort: Swift.Int

        public init(
            applicationPort: Swift.Int = 0,
            enableOnPublicIp: Swift.Bool = false,
            jobPort: Swift.Int = 0
        )
        {
            self.applicationPort = applicationPort
            self.enableOnPublicIp = enableOnPublicIp
            self.jobPort = jobPort
        }
    }

}

extension RoboMakerClientTypes.ProgressDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentProgress
        case estimatedTimeRemainingSeconds
        case percentDone
        case targetResource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentProgress = self.currentProgress {
            try encodeContainer.encode(currentProgress.rawValue, forKey: .currentProgress)
        }
        if let estimatedTimeRemainingSeconds = self.estimatedTimeRemainingSeconds {
            try encodeContainer.encode(estimatedTimeRemainingSeconds, forKey: .estimatedTimeRemainingSeconds)
        }
        if let percentDone = self.percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let targetResource = self.targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentProgressDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotDeploymentStep.self, forKey: .currentProgress)
        currentProgress = currentProgressDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let estimatedTimeRemainingSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingSeconds)
        estimatedTimeRemainingSeconds = estimatedTimeRemainingSecondsDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about the progress of a deployment job.
    public struct ProgressDetail: Swift.Equatable {
        /// The current progress status. Validating Validating the deployment. DownloadingExtracting Downloading and extracting the bundle on the robot. ExecutingPreLaunch Executing pre-launch script(s) if provided. Launching Launching the robot application. ExecutingPostLaunch Executing post-launch script(s) if provided. Finished Deployment is complete.
        public var currentProgress: RoboMakerClientTypes.RobotDeploymentStep?
        /// Estimated amount of time in seconds remaining in the step. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public var estimatedTimeRemainingSeconds: Swift.Int?
        /// Precentage of the step that is done. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public var percentDone: Swift.Float?
        /// The Amazon Resource Name (ARN) of the deployment job.
        public var targetResource: Swift.String?

        public init(
            currentProgress: RoboMakerClientTypes.RobotDeploymentStep? = nil,
            estimatedTimeRemainingSeconds: Swift.Int? = nil,
            percentDone: Swift.Float? = nil,
            targetResource: Swift.String? = nil
        )
        {
            self.currentProgress = currentProgress
            self.estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds
            self.percentDone = percentDone
            self.targetResource = targetResource
        }
    }

}

extension RegisterRobotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let robot = self.robot {
            try encodeContainer.encode(robot, forKey: .robot)
        }
    }
}

extension RegisterRobotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/registerRobot"
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct RegisterRobotInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// The Amazon Resource Name (ARN) of the robot.
    /// This member is required.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotInputBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension RegisterRobotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

extension RegisterRobotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterRobotOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
            self.robot = output.robot
        } else {
            self.fleet = nil
            self.robot = nil
        }
    }
}

@available(*, deprecated, message: "AWS RoboMaker is unable to process this request as the support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct RegisterRobotOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet that the robot will join.
    public var fleet: Swift.String?
    /// Information about the robot registration.
    public var robot: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        robot: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.robot = robot
    }
}

struct RegisterRobotOutputBody: Swift.Equatable {
    let fleet: Swift.String?
    let robot: Swift.String?
}

extension RegisterRobotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet
        case robot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let robotDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .robot)
        robot = robotDecoded
    }
}

enum RegisterRobotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.RenderingEngine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngineType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a rendering engine.
    public struct RenderingEngine: Swift.Equatable {
        /// The name of the rendering engine.
        public var name: RoboMakerClientTypes.RenderingEngineType?
        /// The version of the rendering engine.
        public var version: Swift.String?

        public init(
            name: RoboMakerClientTypes.RenderingEngineType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum RenderingEngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ogre
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderingEngineType] {
            return [
                .ogre,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ogre: return "OGRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenderingEngineType(rawValue: rawValue) ?? RenderingEngineType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestartSimulationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let job = self.job {
            try encodeContainer.encode(job, forKey: .job)
        }
    }
}

extension RestartSimulationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restartSimulationJob"
    }
}

public struct RestartSimulationJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation job.
    /// This member is required.
    public var job: Swift.String?

    public init(
        job: Swift.String? = nil
    )
    {
        self.job = job
    }
}

struct RestartSimulationJobInputBody: Swift.Equatable {
    let job: Swift.String?
}

extension RestartSimulationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .job)
        job = jobDecoded
    }
}

extension RestartSimulationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RestartSimulationJobOutput: Swift.Equatable {

    public init() { }
}

enum RestartSimulationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.Robot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case fleetArn
        case greenGrassGroupId
        case lastDeploymentJob
        case lastDeploymentTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let fleetArn = self.fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let greenGrassGroupId = self.greenGrassGroupId {
            try encodeContainer.encode(greenGrassGroupId, forKey: .greenGrassGroupId)
        }
        if let lastDeploymentJob = self.lastDeploymentJob {
            try encodeContainer.encode(lastDeploymentJob, forKey: .lastDeploymentJob)
        }
        if let lastDeploymentTime = self.lastDeploymentTime {
            try encodeContainer.encodeTimestamp(lastDeploymentTime, format: .epochSeconds, forKey: .lastDeploymentTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let greenGrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greenGrassGroupId)
        greenGrassGroupId = greenGrassGroupIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let lastDeploymentJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentJob)
        lastDeploymentJob = lastDeploymentJobDecoded
        let lastDeploymentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeploymentTime)
        lastDeploymentTime = lastDeploymentTimeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot.
    public struct Robot: Swift.Equatable {
        /// The architecture of the robot.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the fleet.
        public var fleetArn: Swift.String?
        /// The Greengrass group associated with the robot.
        public var greenGrassGroupId: Swift.String?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public var lastDeploymentJob: Swift.String?
        /// The time of the last deployment.
        public var lastDeploymentTime: ClientRuntime.Date?
        /// The name of the robot.
        public var name: Swift.String?
        /// The status of the robot.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init(
            architecture: RoboMakerClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            fleetArn: Swift.String? = nil,
            greenGrassGroupId: Swift.String? = nil,
            lastDeploymentJob: Swift.String? = nil,
            lastDeploymentTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.fleetArn = fleetArn
            self.greenGrassGroupId = greenGrassGroupId
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.status = status
        }
    }

}

extension RoboMakerClientTypes.RobotApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = self.launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tool0 in tools {
                try toolsContainer.encode(tool0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfiguration0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfiguration0)
            }
        }
        if let useDefaultTools = self.useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = self.useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[RoboMakerClientTypes.UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [RoboMakerClientTypes.UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[RoboMakerClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [RoboMakerClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RoboMakerClientTypes {
    /// Application configuration information for a robot.
    public struct RobotApplicationConfig: Swift.Equatable {
        /// The application information for the robot application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the robot application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the robot application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the robot application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// The upload configurations for the robot application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default robot application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultUploadConfigurations: Swift.Bool?

        public init(
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
        }
    }

}

extension RoboMakerClientTypes.RobotApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a robot application.
    public struct RobotApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the robot.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the robot application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// The version of the robot application.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.version = version
        }
    }

}

extension RoboMakerClientTypes.RobotDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deploymentFinishTime
        case deploymentStartTime
        case failureCode
        case failureReason
        case progressDetail
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deploymentFinishTime = self.deploymentFinishTime {
            try encodeContainer.encodeTimestamp(deploymentFinishTime, format: .epochSeconds, forKey: .deploymentFinishTime)
        }
        if let deploymentStartTime = self.deploymentStartTime {
            try encodeContainer.encodeTimestamp(deploymentStartTime, format: .epochSeconds, forKey: .deploymentStartTime)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let progressDetail = self.progressDetail {
            try encodeContainer.encode(progressDetail, forKey: .progressDetail)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deploymentStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deploymentStartTime)
        deploymentStartTime = deploymentStartTimeDecoded
        let deploymentFinishTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deploymentFinishTime)
        deploymentFinishTime = deploymentFinishTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotStatus.self, forKey: .status)
        status = statusDecoded
        let progressDetailDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ProgressDetail.self, forKey: .progressDetail)
        progressDetail = progressDetailDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot deployment.
    public struct RobotDeployment: Swift.Equatable {
        /// The robot deployment Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the deployment finished.
        public var deploymentFinishTime: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the deployment was started.
        public var deploymentStartTime: ClientRuntime.Date?
        /// The robot deployment failure code.
        public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
        /// A short description of the reason why the robot deployment failed.
        public var failureReason: Swift.String?
        /// Information about how the deployment is progressing.
        public var progressDetail: RoboMakerClientTypes.ProgressDetail?
        /// The status of the robot deployment.
        public var status: RoboMakerClientTypes.RobotStatus?

        public init(
            arn: Swift.String? = nil,
            deploymentFinishTime: ClientRuntime.Date? = nil,
            deploymentStartTime: ClientRuntime.Date? = nil,
            failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            progressDetail: RoboMakerClientTypes.ProgressDetail? = nil,
            status: RoboMakerClientTypes.RobotStatus? = nil
        )
        {
            self.arn = arn
            self.deploymentFinishTime = deploymentFinishTime
            self.deploymentStartTime = deploymentStartTime
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.progressDetail = progressDetail
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum RobotDeploymentStep: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downloadingextractingstep
        case executingdownloadcondition
        case finishedstep
        case launchingstep
        case postlaunchstep
        case prelaunchstep
        case validatingstep
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotDeploymentStep] {
            return [
                .downloadingextractingstep,
                .executingdownloadcondition,
                .finishedstep,
                .launchingstep,
                .postlaunchstep,
                .prelaunchstep,
                .validatingstep,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downloadingextractingstep: return "DownloadingExtracting"
            case .executingdownloadcondition: return "ExecutingDownloadCondition"
            case .finishedstep: return "Finished"
            case .launchingstep: return "Launching"
            case .postlaunchstep: return "ExecutingPostLaunch"
            case .prelaunchstep: return "ExecutingPreLaunch"
            case .validatingstep: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotDeploymentStep(rawValue: rawValue) ?? RobotDeploymentStep.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.RobotSoftwareSuite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuiteVersionType.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a robot software suite (ROS distribution).
    public struct RobotSoftwareSuite: Swift.Equatable {
        /// The name of the robot software suite (ROS distribution).
        public var name: RoboMakerClientTypes.RobotSoftwareSuiteType?
        /// The version of the robot software suite (ROS distribution).
        public var version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType?

        public init(
            name: RoboMakerClientTypes.RobotSoftwareSuiteType? = nil,
            version: RoboMakerClientTypes.RobotSoftwareSuiteVersionType? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum RobotSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case general
        case ros
        case ros2
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteType] {
            return [
                .general,
                .ros,
                .ros2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .general: return "General"
            case .ros: return "ROS"
            case .ros2: return "ROS2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotSoftwareSuiteType(rawValue: rawValue) ?? RobotSoftwareSuiteType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum RobotSoftwareSuiteVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashing
        case foxy
        case kinetic
        case melodic
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotSoftwareSuiteVersionType] {
            return [
                .dashing,
                .foxy,
                .kinetic,
                .melodic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashing: return "Dashing"
            case .foxy: return "Foxy"
            case .kinetic: return "Kinetic"
            case .melodic: return "Melodic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotSoftwareSuiteVersionType(rawValue: rawValue) ?? RobotSoftwareSuiteVersionType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum RobotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deploying
        case failed
        case insync
        case noresponse
        case pendingnewdeployment
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [RobotStatus] {
            return [
                .available,
                .deploying,
                .failed,
                .insync,
                .noresponse,
                .pendingnewdeployment,
                .registered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .deploying: return "Deploying"
            case .failed: return "Failed"
            case .insync: return "InSync"
            case .noresponse: return "NoResponse"
            case .pendingnewdeployment: return "PendingNewDeployment"
            case .registered: return "Registered"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RobotStatus(rawValue: rawValue) ?? RobotStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.S3KeyOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case etag
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about S3 keys.
    public struct S3KeyOutput: Swift.Equatable {
        /// The etag for the object.
        public var etag: Swift.String?
        /// The S3 key.
        public var s3Key: Swift.String?

        public init(
            etag: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.etag = etag
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case etag
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about an S3 object.
    public struct S3Object: Swift.Equatable {
        /// The bucket containing the object.
        /// This member is required.
        public var bucket: Swift.String?
        /// The etag of the object.
        public var etag: Swift.String?
        /// The key of the object.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has failed due to a temporary failure of the server.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.SimulationApplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case applicationVersion
        case launchConfig
        case tools
        case uploadConfigurations
        case useDefaultTools
        case useDefaultUploadConfigurations
        case worldConfigs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let launchConfig = self.launchConfig {
            try encodeContainer.encode(launchConfig, forKey: .launchConfig)
        }
        if let tools = tools {
            var toolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tools)
            for tool0 in tools {
                try toolsContainer.encode(tool0)
            }
        }
        if let uploadConfigurations = uploadConfigurations {
            var uploadConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .uploadConfigurations)
            for uploadconfiguration0 in uploadConfigurations {
                try uploadConfigurationsContainer.encode(uploadconfiguration0)
            }
        }
        if let useDefaultTools = self.useDefaultTools {
            try encodeContainer.encode(useDefaultTools, forKey: .useDefaultTools)
        }
        if let useDefaultUploadConfigurations = self.useDefaultUploadConfigurations {
            try encodeContainer.encode(useDefaultUploadConfigurations, forKey: .useDefaultUploadConfigurations)
        }
        if let worldConfigs = worldConfigs {
            var worldConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worldConfigs)
            for worldconfig0 in worldConfigs {
                try worldConfigsContainer.encode(worldconfig0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let launchConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LaunchConfig.self, forKey: .launchConfig)
        launchConfig = launchConfigDecoded
        let uploadConfigurationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.UploadConfiguration?].self, forKey: .uploadConfigurations)
        var uploadConfigurationsDecoded0:[RoboMakerClientTypes.UploadConfiguration]? = nil
        if let uploadConfigurationsContainer = uploadConfigurationsContainer {
            uploadConfigurationsDecoded0 = [RoboMakerClientTypes.UploadConfiguration]()
            for structure0 in uploadConfigurationsContainer {
                if let structure0 = structure0 {
                    uploadConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        uploadConfigurations = uploadConfigurationsDecoded0
        let worldConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.WorldConfig?].self, forKey: .worldConfigs)
        var worldConfigsDecoded0:[RoboMakerClientTypes.WorldConfig]? = nil
        if let worldConfigsContainer = worldConfigsContainer {
            worldConfigsDecoded0 = [RoboMakerClientTypes.WorldConfig]()
            for structure0 in worldConfigsContainer {
                if let structure0 = structure0 {
                    worldConfigsDecoded0?.append(structure0)
                }
            }
        }
        worldConfigs = worldConfigsDecoded0
        let useDefaultUploadConfigurationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultUploadConfigurations)
        useDefaultUploadConfigurations = useDefaultUploadConfigurationsDecoded
        let toolsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Tool?].self, forKey: .tools)
        var toolsDecoded0:[RoboMakerClientTypes.Tool]? = nil
        if let toolsContainer = toolsContainer {
            toolsDecoded0 = [RoboMakerClientTypes.Tool]()
            for structure0 in toolsContainer {
                if let structure0 = structure0 {
                    toolsDecoded0?.append(structure0)
                }
            }
        }
        tools = toolsDecoded0
        let useDefaultToolsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultTools)
        useDefaultTools = useDefaultToolsDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation application configuration.
    public struct SimulationApplicationConfig: Swift.Equatable {
        /// The application information for the simulation application.
        /// This member is required.
        public var application: Swift.String?
        /// The version of the simulation application.
        public var applicationVersion: Swift.String?
        /// The launch configuration for the simulation application.
        /// This member is required.
        public var launchConfig: RoboMakerClientTypes.LaunchConfig?
        /// Information about tools configured for the simulation application.
        public var tools: [RoboMakerClientTypes.Tool]?
        /// Information about upload configurations for the simulation application.
        public var uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]?
        /// A Boolean indicating whether to use default simulation application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultTools: Swift.Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation. This API is no longer supported and will throw an error if used.
        @available(*, deprecated, message: "AWS RoboMaker is ending support for ROS software suite. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/software-support-policy.html.")
        public var useDefaultUploadConfigurations: Swift.Bool?
        /// A list of world configurations.
        public var worldConfigs: [RoboMakerClientTypes.WorldConfig]?

        public init(
            application: Swift.String? = nil,
            applicationVersion: Swift.String? = nil,
            launchConfig: RoboMakerClientTypes.LaunchConfig? = nil,
            tools: [RoboMakerClientTypes.Tool]? = nil,
            uploadConfigurations: [RoboMakerClientTypes.UploadConfiguration]? = nil,
            useDefaultTools: Swift.Bool? = nil,
            useDefaultUploadConfigurations: Swift.Bool? = nil,
            worldConfigs: [RoboMakerClientTypes.WorldConfig]? = nil
        )
        {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
            self.worldConfigs = worldConfigs
        }
    }

}

extension RoboMakerClientTypes.SimulationApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case lastUpdatedAt
        case name
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = self.simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation application.
    public struct SimulationApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the simulation application.
        public var name: Swift.String?
        /// Information about a robot software suite (ROS distribution).
        public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
        /// Information about a simulation software suite.
        public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
        /// The version of the simulation application.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
            simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.version = version
        }
    }

}

extension RoboMakerClientTypes.SimulationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let lastStartedAt = self.lastStartedAt {
            try encodeContainer.encodeTimestamp(lastStartedAt, format: .epochSeconds, forKey: .lastStartedAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfig0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfig0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfig0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfig0)
            }
        }
        if simulationTimeMillis != 0 {
            try encodeContainer.encode(simulationTimeMillis, forKey: .simulationTimeMillis)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job.
    public struct SimulationJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// A unique identifier for this SimulationJob request.
        public var clientRequestToken: Swift.String?
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.ComputeResponse?
        /// The data sources for the simulation job.
        public var dataSources: [RoboMakerClientTypes.DataSource]?
        /// The failure behavior the simulation job. Continue Leaves the host running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The failure code of the simulation job if it failed.
        public var failureCode: RoboMakerClientTypes.SimulationJobErrorCode?
        /// The reason why the simulation job failed.
        public var failureReason: Swift.String?
        /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public var iamRole: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job was last started.
        public var lastStartedAt: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        public var maxJobDurationInSeconds: Swift.Int
        /// The name of the simulation job.
        public var name: Swift.String?
        /// Information about a network interface.
        public var networkInterface: RoboMakerClientTypes.NetworkInterface?
        /// Location for output files generated by the simulation job.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// A list of robot applications.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// A list of simulation applications.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public var simulationTimeMillis: Swift.Int
        /// Status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the simulation job.
        public var tags: [Swift.String:Swift.String]?
        /// VPC configuration information.
        public var vpcConfig: RoboMakerClientTypes.VPCConfigResponse?

        public init(
            arn: Swift.String? = nil,
            clientRequestToken: Swift.String? = nil,
            compute: RoboMakerClientTypes.ComputeResponse? = nil,
            dataSources: [RoboMakerClientTypes.DataSource]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            failureCode: RoboMakerClientTypes.SimulationJobErrorCode? = nil,
            failureReason: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            lastStartedAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            name: Swift.String? = nil,
            networkInterface: RoboMakerClientTypes.NetworkInterface? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            simulationTimeMillis: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfigResponse? = nil
        )
        {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.name = name
            self.networkInterface = networkInterface
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobBatchErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalserviceerror
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchErrorCode] {
            return [
                .internalserviceerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalserviceerror: return "InternalServiceError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobBatchErrorCode(rawValue: rawValue) ?? SimulationJobBatchErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum SimulationJobBatchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case completing
        case failed
        case inprogress
        case pending
        case timedout
        case timingout
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobBatchStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .completing,
                .failed,
                .inprogress,
                .pending,
                .timedout,
                .timingout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .timedout: return "TimedOut"
            case .timingout: return "TimingOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobBatchStatus(rawValue: rawValue) ?? SimulationJobBatchStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobBatchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdRequestCount
        case failedRequestCount
        case lastUpdatedAt
        case pendingRequestCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if createdRequestCount != 0 {
            try encodeContainer.encode(createdRequestCount, forKey: .createdRequestCount)
        }
        if failedRequestCount != 0 {
            try encodeContainer.encode(failedRequestCount, forKey: .failedRequestCount)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if pendingRequestCount != 0 {
            try encodeContainer.encode(pendingRequestCount, forKey: .pendingRequestCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let failedRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedRequestCount) ?? 0
        failedRequestCount = failedRequestCountDecoded
        let pendingRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pendingRequestCount) ?? 0
        pendingRequestCount = pendingRequestCountDecoded
        let createdRequestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdRequestCount) ?? 0
        createdRequestCount = createdRequestCountDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job batch.
    public struct SimulationJobBatchSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was created.
        public var createdAt: ClientRuntime.Date?
        /// The number of created simulation job requests.
        public var createdRequestCount: Swift.Int
        /// The number of failed simulation job requests.
        public var failedRequestCount: Swift.Int
        /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The number of pending simulation job requests.
        public var pendingRequestCount: Swift.Int
        /// The status of the simulation job batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
        public var status: RoboMakerClientTypes.SimulationJobBatchStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdRequestCount: Swift.Int = 0,
            failedRequestCount: Swift.Int = 0,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            pendingRequestCount: Swift.Int = 0,
            status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdRequestCount = createdRequestCount
            self.failedRequestCount = failedRequestCount
            self.lastUpdatedAt = lastUpdatedAt
            self.pendingRequestCount = pendingRequestCount
            self.status = status
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badpermissionscloudwatchlogs
        case badpermissionsrobotapplication
        case badpermissionss3object
        case badpermissionss3output
        case badpermissionssimulationapplication
        case badpermissionsusercredentials
        case batchcanceled
        case batchtimedout
        case enilimitexceeded
        case internalserviceerror
        case invalidbundlerobotapplication
        case invalidbundlesimulationapplication
        case invalidinput
        case invalids3resource
        case limitexceeded
        case mismatchedetag
        case requestthrottled
        case resourcenotfound
        case robotapplicationcrash
        case robotapplicationhealthcheckfailure
        case robotapplicationversionmismatchedetag
        case simulationapplicationcrash
        case simulationapplicationhealthcheckfailure
        case simulationapplicationversionmismatchedetag
        case subnetiplimitexceeded
        case throttlingerror
        case uploadcontentmismatcherror
        case wrongregionrobotapplication
        case wrongregions3bucket
        case wrongregions3output
        case wrongregionsimulationapplication
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobErrorCode] {
            return [
                .badpermissionscloudwatchlogs,
                .badpermissionsrobotapplication,
                .badpermissionss3object,
                .badpermissionss3output,
                .badpermissionssimulationapplication,
                .badpermissionsusercredentials,
                .batchcanceled,
                .batchtimedout,
                .enilimitexceeded,
                .internalserviceerror,
                .invalidbundlerobotapplication,
                .invalidbundlesimulationapplication,
                .invalidinput,
                .invalids3resource,
                .limitexceeded,
                .mismatchedetag,
                .requestthrottled,
                .resourcenotfound,
                .robotapplicationcrash,
                .robotapplicationhealthcheckfailure,
                .robotapplicationversionmismatchedetag,
                .simulationapplicationcrash,
                .simulationapplicationhealthcheckfailure,
                .simulationapplicationversionmismatchedetag,
                .subnetiplimitexceeded,
                .throttlingerror,
                .uploadcontentmismatcherror,
                .wrongregionrobotapplication,
                .wrongregions3bucket,
                .wrongregions3output,
                .wrongregionsimulationapplication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badpermissionscloudwatchlogs: return "BadPermissionsCloudwatchLogs"
            case .badpermissionsrobotapplication: return "BadPermissionsRobotApplication"
            case .badpermissionss3object: return "BadPermissionsS3Object"
            case .badpermissionss3output: return "BadPermissionsS3Output"
            case .badpermissionssimulationapplication: return "BadPermissionsSimulationApplication"
            case .badpermissionsusercredentials: return "BadPermissionsUserCredentials"
            case .batchcanceled: return "BatchCanceled"
            case .batchtimedout: return "BatchTimedOut"
            case .enilimitexceeded: return "ENILimitExceeded"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidbundlerobotapplication: return "InvalidBundleRobotApplication"
            case .invalidbundlesimulationapplication: return "InvalidBundleSimulationApplication"
            case .invalidinput: return "InvalidInput"
            case .invalids3resource: return "InvalidS3Resource"
            case .limitexceeded: return "LimitExceeded"
            case .mismatchedetag: return "MismatchedEtag"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case .robotapplicationcrash: return "RobotApplicationCrash"
            case .robotapplicationhealthcheckfailure: return "RobotApplicationHealthCheckFailure"
            case .robotapplicationversionmismatchedetag: return "RobotApplicationVersionMismatchedEtag"
            case .simulationapplicationcrash: return "SimulationApplicationCrash"
            case .simulationapplicationhealthcheckfailure: return "SimulationApplicationHealthCheckFailure"
            case .simulationapplicationversionmismatchedetag: return "SimulationApplicationVersionMismatchedEtag"
            case .subnetiplimitexceeded: return "SubnetIpLimitExceeded"
            case .throttlingerror: return "ThrottlingError"
            case .uploadcontentmismatcherror: return "UploadContentMismatchError"
            case .wrongregionrobotapplication: return "WrongRegionRobotApplication"
            case .wrongregions3bucket: return "WrongRegionS3Bucket"
            case .wrongregions3output: return "WrongRegionS3Output"
            case .wrongregionsimulationapplication: return "WrongRegionSimulationApplication"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobErrorCode(rawValue: rawValue) ?? SimulationJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compute
        case dataSources
        case failureBehavior
        case iamRole
        case loggingConfig
        case maxJobDurationInSeconds
        case outputLocation
        case robotApplications
        case simulationApplications
        case tags
        case useDefaultApplications
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourceconfig0 in dataSources {
                try dataSourcesContainer.encode(datasourceconfig0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfig0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfig0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfig0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfig0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDefaultApplications = self.useDefaultApplications {
            try encodeContainer.encode(useDefaultApplications, forKey: .useDefaultApplications)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let useDefaultApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDefaultApplications)
        useDefaultApplications = useDefaultApplicationsDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSourceConfig?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSourceConfig]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSourceConfig]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Compute.self, forKey: .compute)
        compute = computeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation job request.
    public struct SimulationJobRequest: Swift.Equatable {
        /// Compute information for the simulation job
        public var compute: RoboMakerClientTypes.Compute?
        /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name. There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
        public var dataSources: [RoboMakerClientTypes.DataSourceConfig]?
        /// The failure behavior the simulation job. Continue Leaves the host running for its maximum timeout duration after a 4XX error code. Fail Stop the simulation job and terminate the instance.
        public var failureBehavior: RoboMakerClientTypes.FailureBehavior?
        /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public var iamRole: Swift.String?
        /// The logging configuration.
        public var loggingConfig: RoboMakerClientTypes.LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        /// This member is required.
        public var maxJobDurationInSeconds: Swift.Int
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The robot applications to use in the simulation job.
        public var robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]?
        /// The simulation applications to use in the simulation job.
        public var simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation job request.
        public var tags: [Swift.String:Swift.String]?
        /// A Boolean indicating whether to use default applications in the simulation job. Default applications include Gazebo, rqt, rviz and terminal access.
        public var useDefaultApplications: Swift.Bool?
        /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and two subnet IDs.
        public var vpcConfig: RoboMakerClientTypes.VPCConfig?

        public init(
            compute: RoboMakerClientTypes.Compute? = nil,
            dataSources: [RoboMakerClientTypes.DataSourceConfig]? = nil,
            failureBehavior: RoboMakerClientTypes.FailureBehavior? = nil,
            iamRole: Swift.String? = nil,
            loggingConfig: RoboMakerClientTypes.LoggingConfig? = nil,
            maxJobDurationInSeconds: Swift.Int = 0,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            robotApplications: [RoboMakerClientTypes.RobotApplicationConfig]? = nil,
            simulationApplications: [RoboMakerClientTypes.SimulationApplicationConfig]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDefaultApplications: Swift.Bool? = nil,
            vpcConfig: RoboMakerClientTypes.VPCConfig? = nil
        )
        {
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.iamRole = iamRole
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.tags = tags
            self.useDefaultApplications = useDefaultApplications
            self.vpcConfig = vpcConfig
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case pending
        case preparing
        case restarting
        case running
        case runningfailed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationJobStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .pending,
                .preparing,
                .restarting,
                .running,
                .runningfailed,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .preparing: return "Preparing"
            case .restarting: return "Restarting"
            case .running: return "Running"
            case .runningfailed: return "RunningFailed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationJobStatus(rawValue: rawValue) ?? SimulationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.SimulationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case computeType
        case dataSourceNames
        case lastUpdatedAt
        case name
        case robotApplicationNames
        case simulationApplicationNames
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let dataSourceNames = dataSourceNames {
            var dataSourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSourceNames)
            for name0 in dataSourceNames {
                try dataSourceNamesContainer.encode(name0)
            }
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let robotApplicationNames = robotApplicationNames {
            var robotApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplicationNames)
            for name0 in robotApplicationNames {
                try robotApplicationNamesContainer.encode(name0)
            }
        }
        if let simulationApplicationNames = simulationApplicationNames {
            var simulationApplicationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplicationNames)
            for name0 in simulationApplicationNames {
                try simulationApplicationNamesContainer.encode(name0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let simulationApplicationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .simulationApplicationNames)
        var simulationApplicationNamesDecoded0:[Swift.String]? = nil
        if let simulationApplicationNamesContainer = simulationApplicationNamesContainer {
            simulationApplicationNamesDecoded0 = [Swift.String]()
            for string0 in simulationApplicationNamesContainer {
                if let string0 = string0 {
                    simulationApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        simulationApplicationNames = simulationApplicationNamesDecoded0
        let robotApplicationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .robotApplicationNames)
        var robotApplicationNamesDecoded0:[Swift.String]? = nil
        if let robotApplicationNamesContainer = robotApplicationNamesContainer {
            robotApplicationNamesDecoded0 = [Swift.String]()
            for string0 in robotApplicationNamesContainer {
                if let string0 = string0 {
                    robotApplicationNamesDecoded0?.append(string0)
                }
            }
        }
        robotApplicationNames = robotApplicationNamesDecoded0
        let dataSourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSourceNames)
        var dataSourceNamesDecoded0:[Swift.String]? = nil
        if let dataSourceNamesContainer = dataSourceNamesContainer {
            dataSourceNamesDecoded0 = [Swift.String]()
            for string0 in dataSourceNamesContainer {
                if let string0 = string0 {
                    dataSourceNamesDecoded0?.append(string0)
                }
            }
        }
        dataSourceNames = dataSourceNamesDecoded0
        let computeTypeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a simulation job.
    public struct SimulationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public var arn: Swift.String?
        /// The compute type for the simulation job summary.
        public var computeType: RoboMakerClientTypes.ComputeType?
        /// The names of the data sources.
        public var dataSourceNames: [Swift.String]?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the simulation job.
        public var name: Swift.String?
        /// A list of simulation job robot application names.
        public var robotApplicationNames: [Swift.String]?
        /// A list of simulation job simulation application names.
        public var simulationApplicationNames: [Swift.String]?
        /// The status of the simulation job.
        public var status: RoboMakerClientTypes.SimulationJobStatus?

        public init(
            arn: Swift.String? = nil,
            computeType: RoboMakerClientTypes.ComputeType? = nil,
            dataSourceNames: [Swift.String]? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            robotApplicationNames: [Swift.String]? = nil,
            simulationApplicationNames: [Swift.String]? = nil,
            status: RoboMakerClientTypes.SimulationJobStatus? = nil
        )
        {
            self.arn = arn
            self.computeType = computeType
            self.dataSourceNames = dataSourceNames
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotApplicationNames = robotApplicationNames
            self.simulationApplicationNames = simulationApplicationNames
            self.status = status
        }
    }

}

extension RoboMakerClientTypes.SimulationSoftwareSuite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuiteType.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a simulation software suite.
    public struct SimulationSoftwareSuite: Swift.Equatable {
        /// The name of the simulation software suite.
        public var name: RoboMakerClientTypes.SimulationSoftwareSuiteType?
        /// The version of the simulation software suite.
        public var version: Swift.String?

        public init(
            name: RoboMakerClientTypes.SimulationSoftwareSuiteType? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension RoboMakerClientTypes {
    public enum SimulationSoftwareSuiteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gazebo
        case rosbagplay
        case simulationruntime
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationSoftwareSuiteType] {
            return [
                .gazebo,
                .rosbagplay,
                .simulationruntime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gazebo: return "Gazebo"
            case .rosbagplay: return "RosbagPlay"
            case .simulationruntime: return "SimulationRuntime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationSoftwareSuiteType(rawValue: rawValue) ?? SimulationSoftwareSuiteType.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case etag
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let etag = self.etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a source.
    public struct Source: Swift.Equatable {
        /// The taget processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// A hash of the object specified by s3Bucket and s3Key.
        public var etag: Swift.String?
        /// The s3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init(
            architecture: RoboMakerClientTypes.Architecture? = nil,
            etag: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.etag = etag
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a source configuration.
    public struct SourceConfig: Swift.Equatable {
        /// The target processor architecture for the application.
        public var architecture: RoboMakerClientTypes.Architecture?
        /// The Amazon S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The s3 object key.
        public var s3Key: Swift.String?

        public init(
            architecture: RoboMakerClientTypes.Architecture? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension StartSimulationJobBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchPolicy = self.batchPolicy {
            try encodeContainer.encode(batchPolicy, forKey: .batchPolicy)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let createSimulationJobRequests = createSimulationJobRequests {
            var createSimulationJobRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createSimulationJobRequests)
            for simulationjobrequest0 in createSimulationJobRequests {
                try createSimulationJobRequestsContainer.encode(simulationjobrequest0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSimulationJobBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startSimulationJobBatch"
    }
}

public struct StartSimulationJobBatchInput: Swift.Equatable {
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// A list of simulation job requests to create in the batch.
    /// This member is required.
    public var createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// A map that contains tag keys and tag values that are attached to the deployment job batch.
    public var tags: [Swift.String:Swift.String]?

    public init(
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createSimulationJobRequests = createSimulationJobRequests
        self.tags = tags
    }
}

struct StartSimulationJobBatchInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    let createSimulationJobRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    let tags: [Swift.String:Swift.String]?
}

extension StartSimulationJobBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPolicy
        case clientRequestToken
        case createSimulationJobRequests
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let createSimulationJobRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .createSimulationJobRequests)
        var createSimulationJobRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let createSimulationJobRequestsContainer = createSimulationJobRequestsContainer {
            createSimulationJobRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in createSimulationJobRequestsContainer {
                if let structure0 = structure0 {
                    createSimulationJobRequestsDecoded0?.append(structure0)
                }
            }
        }
        createSimulationJobRequests = createSimulationJobRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSimulationJobBatchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSimulationJobBatchOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.batchPolicy = output.batchPolicy
            self.clientRequestToken = output.clientRequestToken
            self.createdAt = output.createdAt
            self.createdRequests = output.createdRequests
            self.failedRequests = output.failedRequests
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.pendingRequests = output.pendingRequests
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.batchPolicy = nil
            self.clientRequestToken = nil
            self.createdAt = nil
            self.createdRequests = nil
            self.failedRequests = nil
            self.failureCode = nil
            self.failureReason = nil
            self.pendingRequests = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartSimulationJobBatchOutput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the batch.
    public var arn: Swift.String?
    /// The batch policy.
    public var batchPolicy: RoboMakerClientTypes.BatchPolicy?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientRequestToken: Swift.String?
    /// The time, in milliseconds since the epoch, when the simulation job batch was created.
    public var createdAt: ClientRuntime.Date?
    /// A list of created simulation job request summaries.
    public var createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    /// A list of failed simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
    public var failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    /// The failure code if the simulation job batch failed.
    public var failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    /// The reason the simulation job batch failed.
    public var failureReason: Swift.String?
    /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
    public var pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    /// The status of the simulation job batch. Pending The simulation job batch request is pending. InProgress The simulation job batch is in progress. Failed The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information. Completed The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed). Canceled The simulation batch job was cancelled. Canceling The simulation batch job is being cancelled. Completing The simulation batch job is completing. TimingOut The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut. TimedOut The simulation batch job timed out.
    public var status: RoboMakerClientTypes.SimulationJobBatchStatus?
    /// A map that contains tag keys and tag values that are attached to the deployment job batch.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        batchPolicy: RoboMakerClientTypes.BatchPolicy? = nil,
        clientRequestToken: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdRequests: [RoboMakerClientTypes.SimulationJobSummary]? = nil,
        failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil,
        failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode? = nil,
        failureReason: Swift.String? = nil,
        pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]? = nil,
        status: RoboMakerClientTypes.SimulationJobBatchStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.batchPolicy = batchPolicy
        self.clientRequestToken = clientRequestToken
        self.createdAt = createdAt
        self.createdRequests = createdRequests
        self.failedRequests = failedRequests
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.pendingRequests = pendingRequests
        self.status = status
        self.tags = tags
    }
}

struct StartSimulationJobBatchOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: RoboMakerClientTypes.SimulationJobBatchStatus?
    let createdAt: ClientRuntime.Date?
    let clientRequestToken: Swift.String?
    let batchPolicy: RoboMakerClientTypes.BatchPolicy?
    let failureCode: RoboMakerClientTypes.SimulationJobBatchErrorCode?
    let failureReason: Swift.String?
    let failedRequests: [RoboMakerClientTypes.FailedCreateSimulationJobRequest]?
    let pendingRequests: [RoboMakerClientTypes.SimulationJobRequest]?
    let createdRequests: [RoboMakerClientTypes.SimulationJobSummary]?
    let tags: [Swift.String:Swift.String]?
}

extension StartSimulationJobBatchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case batchPolicy
        case clientRequestToken
        case createdAt
        case createdRequests
        case failedRequests
        case failureCode
        case failureReason
        case pendingRequests
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let batchPolicyDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.BatchPolicy.self, forKey: .batchPolicy)
        batchPolicy = batchPolicyDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobBatchErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failedRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.FailedCreateSimulationJobRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[RoboMakerClientTypes.FailedCreateSimulationJobRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [RoboMakerClientTypes.FailedCreateSimulationJobRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobRequest?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[RoboMakerClientTypes.SimulationJobRequest]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobRequest]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
        let createdRequestsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationJobSummary?].self, forKey: .createdRequests)
        var createdRequestsDecoded0:[RoboMakerClientTypes.SimulationJobSummary]? = nil
        if let createdRequestsContainer = createdRequestsContainer {
            createdRequestsDecoded0 = [RoboMakerClientTypes.SimulationJobSummary]()
            for structure0 in createdRequestsContainer {
                if let structure0 = structure0 {
                    createdRequestsDecoded0?.append(structure0)
                }
            }
        }
        createdRequests = createdRequestsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum StartSimulationJobBatchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SyncDeploymentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case fleet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
    }
}

extension SyncDeploymentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/syncDeploymentJob"
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct SyncDeploymentJobInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The target fleet for the synchronization.
    /// This member is required.
    public var fleet: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        fleet: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fleet = fleet
    }
}

struct SyncDeploymentJobInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let fleet: Swift.String?
}

extension SyncDeploymentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case fleet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension SyncDeploymentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SyncDeploymentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deploymentApplicationConfigs = output.deploymentApplicationConfigs
            self.deploymentConfig = output.deploymentConfig
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.fleet = output.fleet
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deploymentApplicationConfigs = nil
            self.deploymentConfig = nil
            self.failureCode = nil
            self.failureReason = nil
            self.fleet = nil
            self.status = nil
        }
    }
}

@available(*, deprecated, message: "Support for the AWS RoboMaker application deployment feature has ended. For additional information, see https://docs.aws.amazon.com/robomaker/latest/dg/fleets.html.")
public struct SyncDeploymentJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the synchronization request.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the fleet was created.
    public var createdAt: ClientRuntime.Date?
    /// Information about the deployment application configurations.
    public var deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    /// Information about the deployment configuration.
    public var deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    /// The failure code if the job fails: InternalServiceError Internal service error. RobotApplicationCrash Robot application exited abnormally. SimulationApplicationCrash Simulation application exited abnormally. BadPermissionsRobotApplication Robot application bundle could not be downloaded. BadPermissionsSimulationApplication Simulation application bundle could not be downloaded. BadPermissionsS3Output Unable to publish outputs to customer-provided S3 bucket. BadPermissionsCloudwatchLogs Unable to publish logs to customer-provided CloudWatch Logs resource. SubnetIpLimitExceeded Subnet IP limit exceeded. ENILimitExceeded ENI limit exceeded. BadPermissionsUserCredentials Unable to use the Role provided. InvalidBundleRobotApplication Robot bundle cannot be extracted (invalid format, bundling error, or other issue). InvalidBundleSimulationApplication Simulation bundle cannot be extracted (invalid format, bundling error, or other issue). RobotApplicationVersionMismatchedEtag Etag for RobotApplication does not match value during version creation. SimulationApplicationVersionMismatchedEtag Etag for SimulationApplication does not match value during version creation.
    public var failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    /// The failure reason if the job fails.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the fleet.
    public var fleet: Swift.String?
    /// The status of the synchronization job.
    public var status: RoboMakerClientTypes.DeploymentStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]? = nil,
        deploymentConfig: RoboMakerClientTypes.DeploymentConfig? = nil,
        failureCode: RoboMakerClientTypes.DeploymentJobErrorCode? = nil,
        failureReason: Swift.String? = nil,
        fleet: Swift.String? = nil,
        status: RoboMakerClientTypes.DeploymentStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deploymentApplicationConfigs = deploymentApplicationConfigs
        self.deploymentConfig = deploymentConfig
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.fleet = fleet
        self.status = status
    }
}

struct SyncDeploymentJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let fleet: Swift.String?
    let status: RoboMakerClientTypes.DeploymentStatus?
    let deploymentConfig: RoboMakerClientTypes.DeploymentConfig?
    let deploymentApplicationConfigs: [RoboMakerClientTypes.DeploymentApplicationConfig]?
    let failureReason: Swift.String?
    let failureCode: RoboMakerClientTypes.DeploymentJobErrorCode?
    let createdAt: ClientRuntime.Date?
}

extension SyncDeploymentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case deploymentApplicationConfigs
        case deploymentConfig
        case failureCode
        case failureReason
        case fleet
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let deploymentConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentConfig.self, forKey: .deploymentConfig)
        deploymentConfig = deploymentConfigDecoded
        let deploymentApplicationConfigsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DeploymentApplicationConfig?].self, forKey: .deploymentApplicationConfigs)
        var deploymentApplicationConfigsDecoded0:[RoboMakerClientTypes.DeploymentApplicationConfig]? = nil
        if let deploymentApplicationConfigsContainer = deploymentApplicationConfigsContainer {
            deploymentApplicationConfigsDecoded0 = [RoboMakerClientTypes.DeploymentApplicationConfig]()
            for structure0 in deploymentApplicationConfigsContainer {
                if let structure0 = structure0 {
                    deploymentApplicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        deploymentApplicationConfigs = deploymentApplicationConfigsDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.DeploymentJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum SyncDeploymentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentDeploymentException": return try await ConcurrentDeploymentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IdempotentParameterMismatchException": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are tagging.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes.TemplateLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a template location.
    public struct TemplateLocation: Swift.Equatable {
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The list of S3 keys identifying the data source files.
        /// This member is required.
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension RoboMakerClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RoboMakerClientTypes {
    /// Summary information for a template.
    public struct TemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the template was created.
        public var createdAt: ClientRuntime.Date?
        /// The time, in milliseconds since the epoch, when the template was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the template.
        public var name: Swift.String?
        /// The version of the template that you're using.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.version = version
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// AWS RoboMaker is temporarily unable to process the request. Try your call again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoboMakerClientTypes.Tool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case exitBehavior
        case name
        case streamOutputToCloudWatch
        case streamUI
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let exitBehavior = self.exitBehavior {
            try encodeContainer.encode(exitBehavior.rawValue, forKey: .exitBehavior)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamOutputToCloudWatch = self.streamOutputToCloudWatch {
            try encodeContainer.encode(streamOutputToCloudWatch, forKey: .streamOutputToCloudWatch)
        }
        if let streamUI = self.streamUI {
            try encodeContainer.encode(streamUI, forKey: .streamUI)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamUIDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamUI)
        streamUI = streamUIDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let commandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .command)
        command = commandDecoded
        let streamOutputToCloudWatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamOutputToCloudWatch)
        streamOutputToCloudWatch = streamOutputToCloudWatchDecoded
        let exitBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ExitBehavior.self, forKey: .exitBehavior)
        exitBehavior = exitBehaviorDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a tool. Tools are used in a simulation job.
    public struct Tool: Swift.Equatable {
        /// Command-line arguments for the tool. It must include the tool executable name.
        /// This member is required.
        public var command: Swift.String?
        /// Exit behavior determines what happens when your tool quits running. RESTART will cause your tool to be restarted. FAIL will cause your job to exit. The default is RESTART.
        public var exitBehavior: RoboMakerClientTypes.ExitBehavior?
        /// The name of the tool.
        /// This member is required.
        public var name: Swift.String?
        /// Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default is False.
        public var streamOutputToCloudWatch: Swift.Bool?
        /// Boolean indicating whether a streaming session will be configured for the tool. If True, AWS RoboMaker will configure a connection so you can interact with the tool as it is running in the simulation. It must have a graphical user interface. The default is False.
        public var streamUI: Swift.Bool?

        public init(
            command: Swift.String? = nil,
            exitBehavior: RoboMakerClientTypes.ExitBehavior? = nil,
            name: Swift.String? = nil,
            streamOutputToCloudWatch: Swift.Bool? = nil,
            streamUI: Swift.Bool? = nil
        )
        {
            self.command = command
            self.exitBehavior = exitBehavior
            self.name = name
            self.streamOutputToCloudWatch = streamOutputToCloudWatch
            self.streamUI = streamUI
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that will be unattached from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRobotApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case robotSoftwareSuite
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
    }
}

extension UpdateRobotApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateRobotApplication"
    }
}

public struct UpdateRobotApplicationInput: Swift.Equatable {
    /// The application information for the robot application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The robot software suite (ROS distribution) used by the robot application.
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
    }
}

struct UpdateRobotApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let currentRevisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateRobotApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case robotSoftwareSuite
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateRobotApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRobotApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateRobotApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated robot application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI for your robot application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the robot application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the robot application.
    public var name: Swift.String?
    /// The revision id of the robot application.
    public var revisionId: Swift.String?
    /// The robot software suite (ROS distribution) used by the robot application.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The sources of the robot application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateRobotApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateRobotApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case revisionId
        case robotSoftwareSuite
        case sources
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum UpdateRobotApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSimulationApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let currentRevisionId = self.currentRevisionId {
            try encodeContainer.encode(currentRevisionId, forKey: .currentRevisionId)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let renderingEngine = self.renderingEngine {
            try encodeContainer.encode(renderingEngine, forKey: .renderingEngine)
        }
        if let robotSoftwareSuite = self.robotSoftwareSuite {
            try encodeContainer.encode(robotSoftwareSuite, forKey: .robotSoftwareSuite)
        }
        if let simulationSoftwareSuite = self.simulationSoftwareSuite {
            try encodeContainer.encode(simulationSoftwareSuite, forKey: .simulationSoftwareSuite)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for sourceconfig0 in sources {
                try sourcesContainer.encode(sourceconfig0)
            }
        }
    }
}

extension UpdateSimulationApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSimulationApplication"
    }
}

public struct UpdateSimulationApplicationInput: Swift.Equatable {
    /// The application information for the simulation application.
    /// This member is required.
    public var application: Swift.String?
    /// The revision id for the robot application.
    public var currentRevisionId: Swift.String?
    /// The object that contains the Docker image URI for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// Information about the robot software suite (ROS distribution).
    /// This member is required.
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    /// This member is required.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.SourceConfig]?

    public init(
        application: Swift.String? = nil,
        currentRevisionId: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.SourceConfig]? = nil
    )
    {
        self.application = application
        self.currentRevisionId = currentRevisionId
        self.environment = environment
        self.renderingEngine = renderingEngine
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
    }
}

struct UpdateSimulationApplicationInputBody: Swift.Equatable {
    let application: Swift.String?
    let sources: [RoboMakerClientTypes.SourceConfig]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let currentRevisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateSimulationApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
        case currentRevisionId
        case environment
        case renderingEngine
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SourceConfig?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.SourceConfig]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.SourceConfig]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let currentRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRevisionId)
        currentRevisionId = currentRevisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension UpdateSimulationApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSimulationApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environment = output.environment
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.renderingEngine = output.renderingEngine
            self.revisionId = output.revisionId
            self.robotSoftwareSuite = output.robotSoftwareSuite
            self.simulationSoftwareSuite = output.simulationSoftwareSuite
            self.sources = output.sources
            self.version = output.version
        } else {
            self.arn = nil
            self.environment = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.renderingEngine = nil
            self.revisionId = nil
            self.robotSoftwareSuite = nil
            self.simulationSoftwareSuite = nil
            self.sources = nil
            self.version = nil
        }
    }
}

public struct UpdateSimulationApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated simulation application.
    public var arn: Swift.String?
    /// The object that contains the Docker image URI used for your simulation application.
    public var environment: RoboMakerClientTypes.Environment?
    /// The time, in milliseconds since the epoch, when the simulation application was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the simulation application.
    public var name: Swift.String?
    /// The rendering engine for the simulation application.
    public var renderingEngine: RoboMakerClientTypes.RenderingEngine?
    /// The revision id of the simulation application.
    public var revisionId: Swift.String?
    /// Information about the robot software suite (ROS distribution).
    public var robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    /// The simulation software suite used by the simulation application.
    public var simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    /// The sources of the simulation application.
    public var sources: [RoboMakerClientTypes.Source]?
    /// The version of the robot application.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        environment: RoboMakerClientTypes.Environment? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        renderingEngine: RoboMakerClientTypes.RenderingEngine? = nil,
        revisionId: Swift.String? = nil,
        robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite? = nil,
        simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite? = nil,
        sources: [RoboMakerClientTypes.Source]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.environment = environment
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.renderingEngine = renderingEngine
        self.revisionId = revisionId
        self.robotSoftwareSuite = robotSoftwareSuite
        self.simulationSoftwareSuite = simulationSoftwareSuite
        self.sources = sources
        self.version = version
    }
}

struct UpdateSimulationApplicationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let version: Swift.String?
    let sources: [RoboMakerClientTypes.Source]?
    let simulationSoftwareSuite: RoboMakerClientTypes.SimulationSoftwareSuite?
    let robotSoftwareSuite: RoboMakerClientTypes.RobotSoftwareSuite?
    let renderingEngine: RoboMakerClientTypes.RenderingEngine?
    let lastUpdatedAt: ClientRuntime.Date?
    let revisionId: Swift.String?
    let environment: RoboMakerClientTypes.Environment?
}

extension UpdateSimulationApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case environment
        case lastUpdatedAt
        case name
        case renderingEngine
        case revisionId
        case robotSoftwareSuite
        case simulationSoftwareSuite
        case sources
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[RoboMakerClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [RoboMakerClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let simulationSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationSoftwareSuite.self, forKey: .simulationSoftwareSuite)
        simulationSoftwareSuite = simulationSoftwareSuiteDecoded
        let robotSoftwareSuiteDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RobotSoftwareSuite.self, forKey: .robotSoftwareSuite)
        robotSoftwareSuite = robotSoftwareSuiteDecoded
        let renderingEngineDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.RenderingEngine.self, forKey: .renderingEngine)
        renderingEngine = renderingEngineDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum UpdateSimulationApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorldTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateLocation = self.templateLocation {
            try encodeContainer.encode(templateLocation, forKey: .templateLocation)
        }
    }
}

extension UpdateWorldTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateWorldTemplate"
    }
}

public struct UpdateWorldTemplateInput: Swift.Equatable {
    /// The name of the template.
    public var name: Swift.String?
    /// The Amazon Resource Name (arn) of the world template to update.
    /// This member is required.
    public var template: Swift.String?
    /// The world template body.
    public var templateBody: Swift.String?
    /// The location of the world template.
    public var templateLocation: RoboMakerClientTypes.TemplateLocation?

    public init(
        name: Swift.String? = nil,
        template: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateLocation: RoboMakerClientTypes.TemplateLocation? = nil
    )
    {
        self.name = name
        self.template = template
        self.templateBody = templateBody
        self.templateLocation = templateLocation
    }
}

struct UpdateWorldTemplateInputBody: Swift.Equatable {
    let template: Swift.String?
    let name: Swift.String?
    let templateBody: Swift.String?
    let templateLocation: RoboMakerClientTypes.TemplateLocation?
}

extension UpdateWorldTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case template
        case templateBody
        case templateLocation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.TemplateLocation.self, forKey: .templateLocation)
        templateLocation = templateLocationDecoded
    }
}

extension UpdateWorldTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorldTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
        } else {
            self.arn = nil
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.name = nil
        }
    }
}

public struct UpdateWorldTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (arn) of the world template.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the world template was created.
    public var createdAt: ClientRuntime.Date?
    /// The time, in milliseconds since the epoch, when the world template was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the world template.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

struct UpdateWorldTemplateOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateWorldTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum UpdateWorldTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RoboMakerClientTypes {
    public enum UploadBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case uploadOnTerminate
        case uploadRollingAutoRemove
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadBehavior] {
            return [
                .uploadOnTerminate,
                .uploadRollingAutoRemove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .uploadOnTerminate: return "UPLOAD_ON_TERMINATE"
            case .uploadRollingAutoRemove: return "UPLOAD_ROLLING_AUTO_REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadBehavior(rawValue: rawValue) ?? UploadBehavior.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.UploadConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case path
        case uploadBehavior
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let uploadBehavior = self.uploadBehavior {
            try encodeContainer.encode(uploadBehavior.rawValue, forKey: .uploadBehavior)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let uploadBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.UploadBehavior.self, forKey: .uploadBehavior)
        uploadBehavior = uploadBehaviorDecoded
    }
}

extension RoboMakerClientTypes {
    /// Provides upload configuration information. Files are uploaded from the simulation job to a location you specify.
    public struct UploadConfiguration: Swift.Equatable {
        /// A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the simulation output location to determine the final path. For example, if your simulation output location is s3://my-bucket and your upload configuration name is robot-test, your files will be uploaded to s3://my-bucket///robot-test.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the path of the file(s) to upload. Standard Unix glob matching rules are accepted, with the addition of ** as a super asterisk. For example, specifying /var/log/**.log causes all .log files in the /var/log directory tree to be collected. For more examples, see [Glob Library](https://github.com/gobwas/glob).
        /// This member is required.
        public var path: Swift.String?
        /// Specifies when to upload the files: UPLOAD_ON_TERMINATE Matching files are uploaded once the simulation enters the TERMINATING state. Matching files are not uploaded until all of your code (including tools) have stopped. If there is a problem uploading a file, the upload is retried. If problems persist, no further upload attempts will be made. UPLOAD_ROLLING_AUTO_REMOVE Matching files are uploaded as they are created. They are deleted after they are uploaded. The specified path is checked every 5 seconds. A final check is made when all of your code (including tools) have stopped.
        /// This member is required.
        public var uploadBehavior: RoboMakerClientTypes.UploadBehavior?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            uploadBehavior: RoboMakerClientTypes.UploadBehavior? = nil
        )
        {
            self.name = name
            self.path = path
            self.uploadBehavior = uploadBehavior
        }
    }

}

extension RoboMakerClientTypes.VPCConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignPublicIp) ?? false
        assignPublicIp = assignPublicIpDecoded
    }
}

extension RoboMakerClientTypes {
    /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and two subnet IDs.
    public struct VPCConfig: Swift.Equatable {
        /// A boolean indicating whether to assign a public IP address.
        public var assignPublicIp: Swift.Bool
        /// A list of one or more security groups IDs in your VPC.
        public var securityGroups: [Swift.String]?
        /// A list of one or more subnet IDs in your VPC.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension RoboMakerClientTypes.VPCConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp
        case securityGroups
        case subnets
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignPublicIp != false {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignPublicIp) ?? false
        assignPublicIp = assignPublicIpDecoded
    }
}

extension RoboMakerClientTypes {
    /// VPC configuration associated with your simulation job.
    public struct VPCConfigResponse: Swift.Equatable {
        /// A boolean indicating if a public IP was assigned.
        public var assignPublicIp: Swift.Bool
        /// A list of security group IDs associated with the simulation job.
        public var securityGroups: [Swift.String]?
        /// A list of subnet IDs associated with the simulation job.
        public var subnets: [Swift.String]?
        /// The VPC ID associated with your simulation job.
        public var vpcId: Swift.String?

        public init(
            assignPublicIp: Swift.Bool = false,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension RoboMakerClientTypes.WorldConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case world
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let world = self.world {
            try encodeContainer.encode(world, forKey: .world)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let worldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .world)
        world = worldDecoded
    }
}

extension RoboMakerClientTypes {
    /// Configuration information for a world.
    public struct WorldConfig: Swift.Equatable {
        /// The world generated by Simulation WorldForge.
        public var world: Swift.String?

        public init(
            world: Swift.String? = nil
        )
        {
            self.world = world
        }
    }

}

extension RoboMakerClientTypes.WorldCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case floorplanCount
        case interiorCountPerFloorplan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let floorplanCount = self.floorplanCount {
            try encodeContainer.encode(floorplanCount, forKey: .floorplanCount)
        }
        if let interiorCountPerFloorplan = self.interiorCountPerFloorplan {
            try encodeContainer.encode(interiorCountPerFloorplan, forKey: .interiorCountPerFloorplan)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let floorplanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .floorplanCount)
        floorplanCount = floorplanCountDecoded
        let interiorCountPerFloorplanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interiorCountPerFloorplan)
        interiorCountPerFloorplan = interiorCountPerFloorplanDecoded
    }
}

extension RoboMakerClientTypes {
    /// The number of worlds that will be created. You can configure the number of unique floorplans and the number of unique interiors for each floor plan. For example, if you want 1 world with 20 unique interiors, you set floorplanCount = 1 and interiorCountPerFloorplan = 20. This will result in 20 worlds (floorplanCount * interiorCountPerFloorplan). If you set floorplanCount = 4 and interiorCountPerFloorplan = 5, there will be 20 worlds with 5 unique floor plans.
    public struct WorldCount: Swift.Equatable {
        /// The number of unique floorplans.
        public var floorplanCount: Swift.Int?
        /// The number of unique interiors per floorplan.
        public var interiorCountPerFloorplan: Swift.Int?

        public init(
            floorplanCount: Swift.Int? = nil,
            interiorCountPerFloorplan: Swift.Int? = nil
        )
        {
            self.floorplanCount = floorplanCount
            self.interiorCountPerFloorplan = interiorCountPerFloorplan
        }
    }

}

extension RoboMakerClientTypes {
    public enum WorldExportJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobErrorCode] {
            return [
                .accessdenied,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldExportJobErrorCode(rawValue: rawValue) ?? WorldExportJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum WorldExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldExportJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldExportJobStatus(rawValue: rawValue) ?? WorldExportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.WorldExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case outputLocation
        case status
        case worlds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let worlds = worlds {
            var worldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .worlds)
            for arn0 in worlds {
                try worldsContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let worldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .worlds)
        var worldsDecoded0:[Swift.String]? = nil
        if let worldsContainer = worldsContainer {
            worldsDecoded0 = [Swift.String]()
            for string0 in worldsContainer {
                if let string0 = string0 {
                    worldsDecoded0?.append(string0)
                }
            }
        }
        worlds = worldsDecoded0
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a world export job.
    public struct WorldExportJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world export job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public var createdAt: ClientRuntime.Date?
        /// The output location.
        public var outputLocation: RoboMakerClientTypes.OutputLocation?
        /// The status of the world export job. Pending The world export job request is pending. Running The world export job is running. Completed The world export job completed. Failed The world export job failed. See failureCode for more information. Canceled The world export job was cancelled. Canceling The world export job is being cancelled.
        public var status: RoboMakerClientTypes.WorldExportJobStatus?
        /// A list of worlds.
        public var worlds: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            outputLocation: RoboMakerClientTypes.OutputLocation? = nil,
            status: RoboMakerClientTypes.WorldExportJobStatus? = nil,
            worlds: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.outputLocation = outputLocation
            self.status = status
            self.worlds = worlds
        }
    }

}

extension RoboMakerClientTypes.WorldFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureCount
        case sampleFailureReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if failureCount != 0 {
            try encodeContainer.encode(failureCount, forKey: .failureCount)
        }
        if let sampleFailureReason = self.sampleFailureReason {
            try encodeContainer.encode(sampleFailureReason, forKey: .sampleFailureReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let sampleFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleFailureReason)
        sampleFailureReason = sampleFailureReasonDecoded
        let failureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureCount) ?? 0
        failureCount = failureCountDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a failed world.
    public struct WorldFailure: Swift.Equatable {
        /// The failure code of the world export job if it failed: InternalServiceError Internal service error. LimitExceeded The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed. ResourceNotFound The specified resource could not be found. RequestThrottled The request was throttled. InvalidInput An input parameter in the request is not valid.
        public var failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode?
        /// The number of failed worlds.
        public var failureCount: Swift.Int
        /// The sample reason why the world failed. World errors are aggregated. A sample is used as the sampleFailureReason.
        public var sampleFailureReason: Swift.String?

        public init(
            failureCode: RoboMakerClientTypes.WorldGenerationJobErrorCode? = nil,
            failureCount: Swift.Int = 0,
            sampleFailureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureCount = failureCount
            self.sampleFailureReason = sampleFailureReason
        }
    }

}

extension RoboMakerClientTypes {
    public enum WorldGenerationJobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allworldgenerationfailed
        case internalserviceerror
        case invalidinput
        case limitexceeded
        case requestthrottled
        case resourcenotfound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobErrorCode] {
            return [
                .allworldgenerationfailed,
                .internalserviceerror,
                .invalidinput,
                .limitexceeded,
                .requestthrottled,
                .resourcenotfound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allworldgenerationfailed: return "AllWorldGenerationFailed"
            case .internalserviceerror: return "InternalServiceError"
            case .invalidinput: return "InvalidInput"
            case .limitexceeded: return "LimitExceeded"
            case .requestthrottled: return "RequestThrottled"
            case .resourcenotfound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldGenerationJobErrorCode(rawValue: rawValue) ?? WorldGenerationJobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes {
    public enum WorldGenerationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case failed
        case partialfailed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [WorldGenerationJobStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .failed,
                .partialfailed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .canceling: return "Canceling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .partialfailed: return "PartialFailed"
            case .pending: return "Pending"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorldGenerationJobStatus(rawValue: rawValue) ?? WorldGenerationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension RoboMakerClientTypes.WorldGenerationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case failedWorldCount
        case status
        case succeededWorldCount
        case template
        case worldCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if failedWorldCount != 0 {
            try encodeContainer.encode(failedWorldCount, forKey: .failedWorldCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if succeededWorldCount != 0 {
            try encodeContainer.encode(succeededWorldCount, forKey: .succeededWorldCount)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
        if let worldCount = self.worldCount {
            try encodeContainer.encode(worldCount, forKey: .worldCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldGenerationJobStatus.self, forKey: .status)
        status = statusDecoded
        let worldCountDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.WorldCount.self, forKey: .worldCount)
        worldCount = worldCountDecoded
        let succeededWorldCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .succeededWorldCount) ?? 0
        succeededWorldCount = succeededWorldCountDecoded
        let failedWorldCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedWorldCount) ?? 0
        failedWorldCount = failedWorldCountDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a world generator job.
    public struct WorldGenerationJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world generator job.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world generator job was created.
        public var createdAt: ClientRuntime.Date?
        /// The number of worlds that failed.
        public var failedWorldCount: Swift.Int
        /// The status of the world generator job: Pending The world generator job request is pending. Running The world generator job is running. Completed The world generator job completed. Failed The world generator job failed. See failureCode for more information. PartialFailed Some worlds did not generate. Canceled The world generator job was cancelled. Canceling The world generator job is being cancelled.
        public var status: RoboMakerClientTypes.WorldGenerationJobStatus?
        /// The number of worlds that were generated.
        public var succeededWorldCount: Swift.Int
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?
        /// Information about the world count.
        public var worldCount: RoboMakerClientTypes.WorldCount?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            failedWorldCount: Swift.Int = 0,
            status: RoboMakerClientTypes.WorldGenerationJobStatus? = nil,
            succeededWorldCount: Swift.Int = 0,
            template: Swift.String? = nil,
            worldCount: RoboMakerClientTypes.WorldCount? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.failedWorldCount = failedWorldCount
            self.status = status
            self.succeededWorldCount = succeededWorldCount
            self.template = template
            self.worldCount = worldCount
        }
    }

}

extension RoboMakerClientTypes.WorldSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case generationJob
        case template
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let generationJob = self.generationJob {
            try encodeContainer.encode(generationJob, forKey: .generationJob)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let generationJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationJob)
        generationJob = generationJobDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
    }
}

extension RoboMakerClientTypes {
    /// Information about a world.
    public struct WorldSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the world.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the world was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (arn) of the world generation job.
        public var generationJob: Swift.String?
        /// The Amazon Resource Name (arn) of the world template.
        public var template: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            generationJob: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.generationJob = generationJob
            self.template = template
        }
    }

}
