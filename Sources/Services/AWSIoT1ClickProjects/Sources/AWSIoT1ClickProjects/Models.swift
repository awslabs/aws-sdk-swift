//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

///
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

///
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct AssociateDeviceWithPlacementInput: Swift.Sendable {
    /// The ID of the physical device to be associated with the given placement in the project. Note that a mandatory 4 character prefix is required for all deviceId values.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The device template name to associate with the device ID.
    /// This member is required.
    public var deviceTemplateName: Swift.String?
    /// The name of the placement in which to associate the device.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement in which to associate the device.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        deviceTemplateName: Swift.String? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

public struct AssociateDeviceWithPlacementOutput: Swift.Sendable {

    public init() { }
}

public struct CreatePlacementInput: Swift.Sendable {
    /// Optional user-defined key/value pairs providing contextual data (such as location or function) for the placement.
    public var attributes: [Swift.String: Swift.String]?
    /// The name of the placement to be created.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project in which to create the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

public struct CreatePlacementOutput: Swift.Sendable {

    public init() { }
}

extension IoT1ClickProjectsClientTypes {

    /// An object representing a device for a placement template (see [PlacementTemplate]).
    public struct DeviceTemplate: Swift.Sendable {
        /// An optional Lambda function to invoke instead of the default Lambda function provided by the placement template.
        public var callbackOverrides: [Swift.String: Swift.String]?
        /// The device type, which currently must be "button".
        public var deviceType: Swift.String?

        public init(
            callbackOverrides: [Swift.String: Swift.String]? = nil,
            deviceType: Swift.String? = nil
        )
        {
            self.callbackOverrides = callbackOverrides
            self.deviceType = deviceType
        }
    }
}

extension IoT1ClickProjectsClientTypes {

    /// An object defining the template for a placement.
    public struct PlacementTemplate: Swift.Sendable {
        /// The default attributes (key/value pairs) to be applied to all placements using this template.
        public var defaultAttributes: [Swift.String: Swift.String]?
        /// An object specifying the [DeviceTemplate] for all placements using this ([PlacementTemplate]) template.
        public var deviceTemplates: [Swift.String: IoT1ClickProjectsClientTypes.DeviceTemplate]?

        public init(
            defaultAttributes: [Swift.String: Swift.String]? = nil,
            deviceTemplates: [Swift.String: IoT1ClickProjectsClientTypes.DeviceTemplate]? = nil
        )
        {
            self.defaultAttributes = defaultAttributes
            self.deviceTemplates = deviceTemplates
        }
    }
}

public struct CreateProjectInput: Swift.Sendable {
    /// An optional description for the project.
    public var description: Swift.String?
    /// The schema defining the placement to be created. A placement template defines placement default attributes and device templates. You cannot add or remove device templates after the project has been created. However, you can update callbackOverrides for the device templates using the UpdateProject API.
    public var placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
    /// The name of the project to create.
    /// This member is required.
    public var projectName: Swift.String?
    /// Optional tags (metadata key/value pairs) to be associated with the project. For example, { {"key1": "value1", "key2": "value2"} }. For more information, see [AWS Tagging Strategies](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
        self.tags = tags
    }
}

public struct CreateProjectOutput: Swift.Sendable {

    public init() { }
}

///
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct DeletePlacementInput: Swift.Sendable {
    /// The name of the empty placement to delete.
    /// This member is required.
    public var placementName: Swift.String?
    /// The project containing the empty placement to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

public struct DeletePlacementOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProjectInput: Swift.Sendable {
    /// The name of the empty project to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

public struct DeleteProjectOutput: Swift.Sendable {

    public init() { }
}

public struct DescribePlacementInput: Swift.Sendable {
    /// The name of the placement within a project.
    /// This member is required.
    public var placementName: Swift.String?
    /// The project containing the placement to be described.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

extension IoT1ClickProjectsClientTypes {

    /// An object describing a project's placement.
    public struct PlacementDescription: Swift.Sendable {
        /// The user-defined attributes associated with the placement.
        /// This member is required.
        public var attributes: [Swift.String: Swift.String]?
        /// The date when the placement was initially created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// The name of the placement.
        /// This member is required.
        public var placementName: Swift.String?
        /// The name of the project containing the placement.
        /// This member is required.
        public var projectName: Swift.String?
        /// The date when the placement was last updated, in UNIX epoch time format. If the placement was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: Foundation.Date?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            createdDate: Foundation.Date? = nil,
            placementName: Swift.String? = nil,
            projectName: Swift.String? = nil,
            updatedDate: Foundation.Date? = nil
        )
        {
            self.attributes = attributes
            self.createdDate = createdDate
            self.placementName = placementName
            self.projectName = projectName
            self.updatedDate = updatedDate
        }
    }
}

public struct DescribePlacementOutput: Swift.Sendable {
    /// An object describing the placement.
    /// This member is required.
    public var placement: IoT1ClickProjectsClientTypes.PlacementDescription?

    public init(
        placement: IoT1ClickProjectsClientTypes.PlacementDescription? = nil
    )
    {
        self.placement = placement
    }
}

public struct DescribeProjectInput: Swift.Sendable {
    /// The name of the project to be described.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

extension IoT1ClickProjectsClientTypes {

    /// An object providing detailed information for a particular project associated with an AWS account and region.
    public struct ProjectDescription: Swift.Sendable {
        /// The ARN of the project.
        public var arn: Swift.String?
        /// The date when the project was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// The description of the project.
        public var description: Swift.String?
        /// An object describing the project's placement specifications.
        public var placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
        /// The name of the project for which to obtain information from.
        /// This member is required.
        public var projectName: Swift.String?
        /// The tags (metadata key/value pairs) associated with the project.
        public var tags: [Swift.String: Swift.String]?
        /// The date when the project was last updated, in UNIX epoch time format. If the project was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate? = nil,
            projectName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedDate: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.placementTemplate = placementTemplate
            self.projectName = projectName
            self.tags = tags
            self.updatedDate = updatedDate
        }
    }
}

public struct DescribeProjectOutput: Swift.Sendable {
    /// An object describing the project.
    /// This member is required.
    public var project: IoT1ClickProjectsClientTypes.ProjectDescription?

    public init(
        project: IoT1ClickProjectsClientTypes.ProjectDescription? = nil
    )
    {
        self.project = project
    }
}

public struct DisassociateDeviceFromPlacementInput: Swift.Sendable {
    /// The device ID that should be removed from the placement.
    /// This member is required.
    public var deviceTemplateName: Swift.String?
    /// The name of the placement that the device should be removed from.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project that contains the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        deviceTemplateName: Swift.String? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

public struct DisassociateDeviceFromPlacementOutput: Swift.Sendable {

    public init() { }
}

public struct GetDevicesInPlacementInput: Swift.Sendable {
    /// The name of the placement to get the devices from.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

public struct GetDevicesInPlacementOutput: Swift.Sendable {
    /// An object containing the devices (zero or more) within the placement.
    /// This member is required.
    public var devices: [Swift.String: Swift.String]?

    public init(
        devices: [Swift.String: Swift.String]? = nil
    )
    {
        self.devices = devices
    }
}

public struct ListPlacementsInput: Swift.Sendable {
    /// The maximum number of results to return per request. If not set, a default value of 100 is used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The project containing the placements to be listed.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

extension IoT1ClickProjectsClientTypes {

    /// An object providing summary information for a particular placement.
    public struct PlacementSummary: Swift.Sendable {
        /// The date when the placement was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// The name of the placement being summarized.
        /// This member is required.
        public var placementName: Swift.String?
        /// The name of the project containing the placement.
        /// This member is required.
        public var projectName: Swift.String?
        /// The date when the placement was last updated, in UNIX epoch time format. If the placement was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: Foundation.Date?

        public init(
            createdDate: Foundation.Date? = nil,
            placementName: Swift.String? = nil,
            projectName: Swift.String? = nil,
            updatedDate: Foundation.Date? = nil
        )
        {
            self.createdDate = createdDate
            self.placementName = placementName
            self.projectName = projectName
            self.updatedDate = updatedDate
        }
    }
}

public struct ListPlacementsOutput: Swift.Sendable {
    /// The token used to retrieve the next set of results - will be effectively empty if there are no further results.
    public var nextToken: Swift.String?
    /// An object listing the requested placements.
    /// This member is required.
    public var placements: [IoT1ClickProjectsClientTypes.PlacementSummary]?

    public init(
        nextToken: Swift.String? = nil,
        placements: [IoT1ClickProjectsClientTypes.PlacementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.placements = placements
    }
}

public struct ListProjectsInput: Swift.Sendable {
    /// The maximum number of results to return per request. If not set, a default value of 100 is used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoT1ClickProjectsClientTypes {

    /// An object providing summary information for a particular project for an associated AWS account and region.
    public struct ProjectSummary: Swift.Sendable {
        /// The ARN of the project.
        public var arn: Swift.String?
        /// The date when the project was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// The name of the project being summarized.
        /// This member is required.
        public var projectName: Swift.String?
        /// The tags (metadata key/value pairs) associated with the project.
        public var tags: [Swift.String: Swift.String]?
        /// The date when the project was last updated, in UNIX epoch time format. If the project was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            projectName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedDate: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.projectName = projectName
            self.tags = tags
            self.updatedDate = updatedDate
        }
    }
}

public struct ListProjectsOutput: Swift.Sendable {
    /// The token used to retrieve the next set of results - will be effectively empty if there are no further results.
    public var nextToken: Swift.String?
    /// An object containing the list of projects.
    /// This member is required.
    public var projects: [IoT1ClickProjectsClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [IoT1ClickProjectsClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags (metadata key/value pairs) which you have assigned to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resouce for which tag(s) should be added or modified.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modifying tag(s) for the resource. See [AWS IoT 1-Click Service Limits](https://docs.aws.amazon.com/iot-1-click/latest/developerguide/1click-appendix.html#1click-limits) for the maximum number of tags allowed per resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource whose tag you want to remove.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of those tags which you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdatePlacementInput: Swift.Sendable {
    /// The user-defined object of attributes used to update the placement. The maximum number of key/value pairs is 50.
    public var attributes: [Swift.String: Swift.String]?
    /// The name of the placement to update.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement to be updated.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

public struct UpdatePlacementOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateProjectInput: Swift.Sendable {
    /// An optional user-defined description for the project.
    public var description: Swift.String?
    /// An object defining the project update. Once a project has been created, you cannot add device template names to the project. However, for a given placementTemplate, you can update the associated callbackOverrides for the device definition using this API.
    public var placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
    /// The name of the project to be updated.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        description: Swift.String? = nil,
        placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
    }
}

public struct UpdateProjectOutput: Swift.Sendable {

    public init() { }
}

extension AssociateDeviceWithPlacementInput {

    static func urlPathProvider(_ value: AssociateDeviceWithPlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let placementName = value.placementName else {
            return nil
        }
        guard let deviceTemplateName = value.deviceTemplateName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices/\(deviceTemplateName.urlPercentEncoding())"
    }
}

extension CreatePlacementInput {

    static func urlPathProvider(_ value: CreatePlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements"
    }
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        return "/projects"
    }
}

extension DeletePlacementInput {

    static func urlPathProvider(_ value: DeletePlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let placementName = value.placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())"
    }
}

extension DescribePlacementInput {

    static func urlPathProvider(_ value: DescribePlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let placementName = value.placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
    }
}

extension DescribeProjectInput {

    static func urlPathProvider(_ value: DescribeProjectInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())"
    }
}

extension DisassociateDeviceFromPlacementInput {

    static func urlPathProvider(_ value: DisassociateDeviceFromPlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let placementName = value.placementName else {
            return nil
        }
        guard let deviceTemplateName = value.deviceTemplateName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices/\(deviceTemplateName.urlPercentEncoding())"
    }
}

extension GetDevicesInPlacementInput {

    static func urlPathProvider(_ value: GetDevicesInPlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let placementName = value.placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices"
    }
}

extension ListPlacementsInput {

    static func urlPathProvider(_ value: ListPlacementsInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements"
    }
}

extension ListPlacementsInput {

    static func queryItemProvider(_ value: ListPlacementsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        return "/projects"
    }
}

extension ListProjectsInput {

    static func queryItemProvider(_ value: ListProjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdatePlacementInput {

    static func urlPathProvider(_ value: UpdatePlacementInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        guard let placementName = value.placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
    }
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        guard let projectName = value.projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())"
    }
}

extension AssociateDeviceWithPlacementInput {

    static func write(value: AssociateDeviceWithPlacementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deviceId"].write(value.deviceId)
    }
}

extension CreatePlacementInput {

    static func write(value: CreatePlacementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["placementName"].write(value.placementName)
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["placementTemplate"].write(value.placementTemplate, with: IoT1ClickProjectsClientTypes.PlacementTemplate.write(value:to:))
        try writer["projectName"].write(value.projectName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdatePlacementInput {

    static func write(value: UpdatePlacementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["placementTemplate"].write(value.placementTemplate, with: IoT1ClickProjectsClientTypes.PlacementTemplate.write(value:to:))
    }
}

extension AssociateDeviceWithPlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDeviceWithPlacementOutput {
        return AssociateDeviceWithPlacementOutput()
    }
}

extension CreatePlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePlacementOutput {
        return CreatePlacementOutput()
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectOutput {
        return CreateProjectOutput()
    }
}

extension DeletePlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePlacementOutput {
        return DeletePlacementOutput()
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectOutput {
        return DeleteProjectOutput()
    }
}

extension DescribePlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePlacementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePlacementOutput()
        value.placement = try reader["placement"].readIfPresent(with: IoT1ClickProjectsClientTypes.PlacementDescription.read(from:))
        return value
    }
}

extension DescribeProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProjectOutput()
        value.project = try reader["project"].readIfPresent(with: IoT1ClickProjectsClientTypes.ProjectDescription.read(from:))
        return value
    }
}

extension DisassociateDeviceFromPlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateDeviceFromPlacementOutput {
        return DisassociateDeviceFromPlacementOutput()
    }
}

extension GetDevicesInPlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDevicesInPlacementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevicesInPlacementOutput()
        value.devices = try reader["devices"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ListPlacementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlacementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlacementsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.placements = try reader["placements"].readListIfPresent(memberReadingClosure: IoT1ClickProjectsClientTypes.PlacementSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projects = try reader["projects"].readListIfPresent(memberReadingClosure: IoT1ClickProjectsClientTypes.ProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdatePlacementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePlacementOutput {
        return UpdatePlacementOutput()
    }
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProjectOutput {
        return UpdateProjectOutput()
    }
}

enum AssociateDeviceWithPlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateDeviceFromPlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDevicesInPlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlacementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePlacementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceConflictException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoT1ClickProjectsClientTypes.PlacementDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickProjectsClientTypes.PlacementDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickProjectsClientTypes.PlacementDescription()
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        value.placementName = try reader["placementName"].readIfPresent() ?? ""
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedDate = try reader["updatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoT1ClickProjectsClientTypes.ProjectDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickProjectsClientTypes.ProjectDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickProjectsClientTypes.ProjectDescription()
        value.arn = try reader["arn"].readIfPresent()
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedDate = try reader["updatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.placementTemplate = try reader["placementTemplate"].readIfPresent(with: IoT1ClickProjectsClientTypes.PlacementTemplate.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoT1ClickProjectsClientTypes.PlacementTemplate {

    static func write(value: IoT1ClickProjectsClientTypes.PlacementTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultAttributes"].writeMap(value.defaultAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["deviceTemplates"].writeMap(value.deviceTemplates, valueWritingClosure: IoT1ClickProjectsClientTypes.DeviceTemplate.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickProjectsClientTypes.PlacementTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickProjectsClientTypes.PlacementTemplate()
        value.defaultAttributes = try reader["defaultAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.deviceTemplates = try reader["deviceTemplates"].readMapIfPresent(valueReadingClosure: IoT1ClickProjectsClientTypes.DeviceTemplate.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoT1ClickProjectsClientTypes.DeviceTemplate {

    static func write(value: IoT1ClickProjectsClientTypes.DeviceTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["callbackOverrides"].writeMap(value.callbackOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["deviceType"].write(value.deviceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickProjectsClientTypes.DeviceTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickProjectsClientTypes.DeviceTemplate()
        value.deviceType = try reader["deviceType"].readIfPresent()
        value.callbackOverrides = try reader["callbackOverrides"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoT1ClickProjectsClientTypes.PlacementSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickProjectsClientTypes.PlacementSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickProjectsClientTypes.PlacementSummary()
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        value.placementName = try reader["placementName"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedDate = try reader["updatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoT1ClickProjectsClientTypes.ProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickProjectsClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickProjectsClientTypes.ProjectSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedDate = try reader["updatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public enum IoT1ClickProjectsClientTypes {}
