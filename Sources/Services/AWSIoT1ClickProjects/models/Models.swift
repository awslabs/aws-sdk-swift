// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateDeviceWithPlacementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
    }
}

extension AssociateDeviceWithPlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let placementName = placementName else {
            return nil
        }
        guard let deviceTemplateName = deviceTemplateName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices/\(deviceTemplateName.urlPercentEncoding())"
    }
}

public struct AssociateDeviceWithPlacementInput: Swift.Equatable {
    /// The ID of the physical device to be associated with the given placement in the project. Note that a mandatory 4 character prefix is required for all deviceId values.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The device template name to associate with the device ID.
    /// This member is required.
    public var deviceTemplateName: Swift.String?
    /// The name of the placement in which to associate the device.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement in which to associate the device.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        deviceTemplateName: Swift.String? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct AssociateDeviceWithPlacementInputBody: Swift.Equatable {
    let deviceId: Swift.String?
}

extension AssociateDeviceWithPlacementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension AssociateDeviceWithPlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDeviceWithPlacementOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDeviceWithPlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePlacementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case placementName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, placementAttributeMap0) in attributes {
                try attributesContainer.encode(placementAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let placementName = self.placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
    }
}

extension CreatePlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements"
    }
}

public struct CreatePlacementInput: Swift.Equatable {
    /// Optional user-defined key/value pairs providing contextual data (such as location or function) for the placement.
    public var attributes: [Swift.String:Swift.String]?
    /// The name of the placement to be created.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project in which to create the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct CreatePlacementInputBody: Swift.Equatable {
    let placementName: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension CreatePlacementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case placementName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreatePlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreatePlacementOutput: Swift.Equatable {

    public init() { }
}

enum CreatePlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
        case projectName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = self.placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// An optional description for the project.
    public var description: Swift.String?
    /// The schema defining the placement to be created. A placement template defines placement default attributes and device templates. You cannot add or remove device templates after the project has been created. However, you can update callbackOverrides for the device templates using the UpdateProject API.
    public var placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
    /// The name of the project to create.
    /// This member is required.
    public var projectName: Swift.String?
    /// Optional tags (metadata key/value pairs) to be associated with the project. For example, { {"key1": "value1", "key2": "value2"} }. For more information, see [AWS Tagging Strategies](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let description: Swift.String?
    let placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
        case projectName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(IoT1ClickProjectsClientTypes.PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateProjectOutput: Swift.Equatable {

    public init() { }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let placementName = placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
    }
}

public struct DeletePlacementInput: Swift.Equatable {
    /// The name of the empty placement to delete.
    /// This member is required.
    public var placementName: Swift.String?
    /// The project containing the empty placement to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DeletePlacementInputBody: Swift.Equatable {
}

extension DeletePlacementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePlacementOutput: Swift.Equatable {

    public init() { }
}

enum DeletePlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name of the empty project to delete.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let placementName = placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
    }
}

public struct DescribePlacementInput: Swift.Equatable {
    /// The name of the placement within a project.
    /// This member is required.
    public var placementName: Swift.String?
    /// The project containing the placement to be described.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DescribePlacementInputBody: Swift.Equatable {
}

extension DescribePlacementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePlacementOutputBody = try responseDecoder.decode(responseBody: data)
            self.placement = output.placement
        } else {
            self.placement = nil
        }
    }
}

public struct DescribePlacementOutput: Swift.Equatable {
    /// An object describing the placement.
    /// This member is required.
    public var placement: IoT1ClickProjectsClientTypes.PlacementDescription?

    public init(
        placement: IoT1ClickProjectsClientTypes.PlacementDescription? = nil
    )
    {
        self.placement = placement
    }
}

struct DescribePlacementOutputBody: Swift.Equatable {
    let placement: IoT1ClickProjectsClientTypes.PlacementDescription?
}

extension DescribePlacementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case placement
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementDecoded = try containerValues.decodeIfPresent(IoT1ClickProjectsClientTypes.PlacementDescription.self, forKey: .placement)
        placement = placementDecoded
    }
}

enum DescribePlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The name of the project to be described.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct DescribeProjectOutput: Swift.Equatable {
    /// An object describing the project.
    /// This member is required.
    public var project: IoT1ClickProjectsClientTypes.ProjectDescription?

    public init(
        project: IoT1ClickProjectsClientTypes.ProjectDescription? = nil
    )
    {
        self.project = project
    }
}

struct DescribeProjectOutputBody: Swift.Equatable {
    let project: IoT1ClickProjectsClientTypes.ProjectDescription?
}

extension DescribeProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(IoT1ClickProjectsClientTypes.ProjectDescription.self, forKey: .project)
        project = projectDecoded
    }
}

enum DescribeProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoT1ClickProjectsClientTypes.DeviceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackOverrides
        case deviceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callbackOverrides = callbackOverrides {
            var callbackOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .callbackOverrides)
            for (dictKey0, deviceCallbackOverrideMap0) in callbackOverrides {
                try callbackOverridesContainer.encode(deviceCallbackOverrideMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let callbackOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .callbackOverrides)
        var callbackOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let callbackOverridesContainer = callbackOverridesContainer {
            callbackOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, devicecallbackvalue0) in callbackOverridesContainer {
                if let devicecallbackvalue0 = devicecallbackvalue0 {
                    callbackOverridesDecoded0?[key0] = devicecallbackvalue0
                }
            }
        }
        callbackOverrides = callbackOverridesDecoded0
    }
}

extension IoT1ClickProjectsClientTypes {
    /// An object representing a device for a placement template (see [PlacementTemplate]).
    public struct DeviceTemplate: Swift.Equatable {
        /// An optional Lambda function to invoke instead of the default Lambda function provided by the placement template.
        public var callbackOverrides: [Swift.String:Swift.String]?
        /// The device type, which currently must be "button".
        public var deviceType: Swift.String?

        public init(
            callbackOverrides: [Swift.String:Swift.String]? = nil,
            deviceType: Swift.String? = nil
        )
        {
            self.callbackOverrides = callbackOverrides
            self.deviceType = deviceType
        }
    }

}

extension DisassociateDeviceFromPlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let placementName = placementName else {
            return nil
        }
        guard let deviceTemplateName = deviceTemplateName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices/\(deviceTemplateName.urlPercentEncoding())"
    }
}

public struct DisassociateDeviceFromPlacementInput: Swift.Equatable {
    /// The device ID that should be removed from the placement.
    /// This member is required.
    public var deviceTemplateName: Swift.String?
    /// The name of the placement that the device should be removed from.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project that contains the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        deviceTemplateName: Swift.String? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.deviceTemplateName = deviceTemplateName
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct DisassociateDeviceFromPlacementInputBody: Swift.Equatable {
}

extension DisassociateDeviceFromPlacementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateDeviceFromPlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDeviceFromPlacementOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDeviceFromPlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDevicesInPlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let placementName = placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())/devices"
    }
}

public struct GetDevicesInPlacementInput: Swift.Equatable {
    /// The name of the placement to get the devices from.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct GetDevicesInPlacementInputBody: Swift.Equatable {
}

extension GetDevicesInPlacementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicesInPlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDevicesInPlacementOutputBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
        } else {
            self.devices = nil
        }
    }
}

public struct GetDevicesInPlacementOutput: Swift.Equatable {
    /// An object containing the devices (zero or more) within the placement.
    /// This member is required.
    public var devices: [Swift.String:Swift.String]?

    public init(
        devices: [Swift.String:Swift.String]? = nil
    )
    {
        self.devices = devices
    }
}

struct GetDevicesInPlacementOutputBody: Swift.Equatable {
    let devices: [Swift.String:Swift.String]?
}

extension GetDevicesInPlacementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .devices)
        var devicesDecoded0: [Swift.String:Swift.String]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Swift.String:Swift.String]()
            for (key0, deviceid0) in devicesContainer {
                if let deviceid0 = deviceid0 {
                    devicesDecoded0?[key0] = deviceid0
                }
            }
        }
        devices = devicesDecoded0
    }
}

enum GetDevicesInPlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPlacementsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPlacementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements"
    }
}

public struct ListPlacementsInput: Swift.Equatable {
    /// The maximum number of results to return per request. If not set, a default value of 100 is used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The project containing the placements to be listed.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListPlacementsInputBody: Swift.Equatable {
}

extension ListPlacementsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPlacementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPlacementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.placements = output.placements
        } else {
            self.nextToken = nil
            self.placements = nil
        }
    }
}

public struct ListPlacementsOutput: Swift.Equatable {
    /// The token used to retrieve the next set of results - will be effectively empty if there are no further results.
    public var nextToken: Swift.String?
    /// An object listing the requested placements.
    /// This member is required.
    public var placements: [IoT1ClickProjectsClientTypes.PlacementSummary]?

    public init(
        nextToken: Swift.String? = nil,
        placements: [IoT1ClickProjectsClientTypes.PlacementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.placements = placements
    }
}

struct ListPlacementsOutputBody: Swift.Equatable {
    let placements: [IoT1ClickProjectsClientTypes.PlacementSummary]?
    let nextToken: Swift.String?
}

extension ListPlacementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case placements
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placementsContainer = try containerValues.decodeIfPresent([IoT1ClickProjectsClientTypes.PlacementSummary?].self, forKey: .placements)
        var placementsDecoded0:[IoT1ClickProjectsClientTypes.PlacementSummary]? = nil
        if let placementsContainer = placementsContainer {
            placementsDecoded0 = [IoT1ClickProjectsClientTypes.PlacementSummary]()
            for structure0 in placementsContainer {
                if let structure0 = structure0 {
                    placementsDecoded0?.append(structure0)
                }
            }
        }
        placements = placementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPlacementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return per request. If not set, a default value of 100 is used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// The token used to retrieve the next set of results - will be effectively empty if there are no further results.
    public var nextToken: Swift.String?
    /// An object containing the list of projects.
    /// This member is required.
    public var projects: [IoT1ClickProjectsClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [IoT1ClickProjectsClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let projects: [IoT1ClickProjectsClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([IoT1ClickProjectsClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[IoT1ClickProjectsClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [IoT1ClickProjectsClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tags you want to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags (metadata key/value pairs) which you have assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoT1ClickProjectsClientTypes.PlacementDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case createdDate
        case placementName
        case projectName
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, placementAttributeMap0) in attributes {
                try attributesContainer.encode(placementAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let placementName = self.placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let updatedDate = self.updatedDate {
            try encodeContainer.encodeTimestamp(updatedDate, format: .epochSeconds, forKey: .updatedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let placementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
    }
}

extension IoT1ClickProjectsClientTypes {
    /// An object describing a project's placement.
    public struct PlacementDescription: Swift.Equatable {
        /// The user-defined attributes associated with the placement.
        /// This member is required.
        public var attributes: [Swift.String:Swift.String]?
        /// The date when the placement was initially created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The name of the placement.
        /// This member is required.
        public var placementName: Swift.String?
        /// The name of the project containing the placement.
        /// This member is required.
        public var projectName: Swift.String?
        /// The date when the placement was last updated, in UNIX epoch time format. If the placement was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            placementName: Swift.String? = nil,
            projectName: Swift.String? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.attributes = attributes
            self.createdDate = createdDate
            self.placementName = placementName
            self.projectName = projectName
            self.updatedDate = updatedDate
        }
    }

}

extension IoT1ClickProjectsClientTypes.PlacementSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case placementName
        case projectName
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let placementName = self.placementName {
            try encodeContainer.encode(placementName, forKey: .placementName)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let updatedDate = self.updatedDate {
            try encodeContainer.encodeTimestamp(updatedDate, format: .epochSeconds, forKey: .updatedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let placementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementName)
        placementName = placementNameDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
    }
}

extension IoT1ClickProjectsClientTypes {
    /// An object providing summary information for a particular placement.
    public struct PlacementSummary: Swift.Equatable {
        /// The date when the placement was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The name of the placement being summarized.
        /// This member is required.
        public var placementName: Swift.String?
        /// The name of the project containing the placement.
        /// This member is required.
        public var projectName: Swift.String?
        /// The date when the placement was last updated, in UNIX epoch time format. If the placement was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            placementName: Swift.String? = nil,
            projectName: Swift.String? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.createdDate = createdDate
            self.placementName = placementName
            self.projectName = projectName
            self.updatedDate = updatedDate
        }
    }

}

extension IoT1ClickProjectsClientTypes.PlacementTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAttributes
        case deviceTemplates
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAttributes = defaultAttributes {
            var defaultAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultAttributes)
            for (dictKey0, defaultPlacementAttributeMap0) in defaultAttributes {
                try defaultAttributesContainer.encode(defaultPlacementAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deviceTemplates = deviceTemplates {
            var deviceTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .deviceTemplates)
            for (dictKey0, deviceTemplateMap0) in deviceTemplates {
                try deviceTemplatesContainer.encode(deviceTemplateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultAttributes)
        var defaultAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultAttributesContainer = defaultAttributesContainer {
            defaultAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributedefaultvalue0) in defaultAttributesContainer {
                if let attributedefaultvalue0 = attributedefaultvalue0 {
                    defaultAttributesDecoded0?[key0] = attributedefaultvalue0
                }
            }
        }
        defaultAttributes = defaultAttributesDecoded0
        let deviceTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: IoT1ClickProjectsClientTypes.DeviceTemplate?].self, forKey: .deviceTemplates)
        var deviceTemplatesDecoded0: [Swift.String:IoT1ClickProjectsClientTypes.DeviceTemplate]? = nil
        if let deviceTemplatesContainer = deviceTemplatesContainer {
            deviceTemplatesDecoded0 = [Swift.String:IoT1ClickProjectsClientTypes.DeviceTemplate]()
            for (key0, devicetemplate0) in deviceTemplatesContainer {
                if let devicetemplate0 = devicetemplate0 {
                    deviceTemplatesDecoded0?[key0] = devicetemplate0
                }
            }
        }
        deviceTemplates = deviceTemplatesDecoded0
    }
}

extension IoT1ClickProjectsClientTypes {
    /// An object defining the template for a placement.
    public struct PlacementTemplate: Swift.Equatable {
        /// The default attributes (key/value pairs) to be applied to all placements using this template.
        public var defaultAttributes: [Swift.String:Swift.String]?
        /// An object specifying the [DeviceTemplate] for all placements using this ([PlacementTemplate]) template.
        public var deviceTemplates: [Swift.String:IoT1ClickProjectsClientTypes.DeviceTemplate]?

        public init(
            defaultAttributes: [Swift.String:Swift.String]? = nil,
            deviceTemplates: [Swift.String:IoT1ClickProjectsClientTypes.DeviceTemplate]? = nil
        )
        {
            self.defaultAttributes = defaultAttributes
            self.deviceTemplates = deviceTemplates
        }
    }

}

extension IoT1ClickProjectsClientTypes.ProjectDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case description
        case placementTemplate
        case projectName
        case tags
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = self.placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedDate = self.updatedDate {
            try encodeContainer.encodeTimestamp(updatedDate, format: .epochSeconds, forKey: .updatedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(IoT1ClickProjectsClientTypes.PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoT1ClickProjectsClientTypes {
    /// An object providing detailed information for a particular project associated with an AWS account and region.
    public struct ProjectDescription: Swift.Equatable {
        /// The ARN of the project.
        public var arn: Swift.String?
        /// The date when the project was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The description of the project.
        public var description: Swift.String?
        /// An object describing the project's placement specifications.
        public var placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
        /// The name of the project for which to obtain information from.
        /// This member is required.
        public var projectName: Swift.String?
        /// The tags (metadata key/value pairs) associated with the project.
        public var tags: [Swift.String:Swift.String]?
        /// The date when the project was last updated, in UNIX epoch time format. If the project was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate? = nil,
            projectName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.placementTemplate = placementTemplate
            self.projectName = projectName
            self.tags = tags
            self.updatedDate = updatedDate
        }
    }

}

extension IoT1ClickProjectsClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case projectName
        case tags
        case updatedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedDate = self.updatedDate {
            try encodeContainer.encodeTimestamp(updatedDate, format: .epochSeconds, forKey: .updatedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let updatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoT1ClickProjectsClientTypes {
    /// An object providing summary information for a particular project for an associated AWS account and region.
    public struct ProjectSummary: Swift.Equatable {
        /// The ARN of the project.
        public var arn: Swift.String?
        /// The date when the project was originally created, in UNIX epoch time format.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The name of the project being summarized.
        /// This member is required.
        public var projectName: Swift.String?
        /// The tags (metadata key/value pairs) associated with the project.
        public var tags: [Swift.String:Swift.String]?
        /// The date when the project was last updated, in UNIX epoch time format. If the project was not updated, then createdDate and updatedDate are the same.
        /// This member is required.
        public var updatedDate: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            projectName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.projectName = projectName
            self.tags = tags
            self.updatedDate = updatedDate
        }
    }

}

extension ResourceConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resouce for which tag(s) should be added or modified.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modifying tag(s) for the resource. See [AWS IoT 1-Click Service Limits](https://docs.aws.amazon.com/iot-1-click/latest/developerguide/1click-appendix.html#1click-limits) for the maximum number of tags allowed per resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tag you want to remove.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of those tags which you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePlacementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, placementAttributeMap0) in attributes {
                try attributesContainer.encode(placementAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdatePlacementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        guard let placementName = placementName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())/placements/\(placementName.urlPercentEncoding())"
    }
}

public struct UpdatePlacementInput: Swift.Equatable {
    /// The user-defined object of attributes used to update the placement. The maximum number of key/value pairs is 50.
    public var attributes: [Swift.String:Swift.String]?
    /// The name of the placement to update.
    /// This member is required.
    public var placementName: Swift.String?
    /// The name of the project containing the placement to be updated.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        placementName: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.placementName = placementName
        self.projectName = projectName
    }
}

struct UpdatePlacementInputBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension UpdatePlacementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdatePlacementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePlacementOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePlacementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let placementTemplate = self.placementTemplate {
            try encodeContainer.encode(placementTemplate, forKey: .placementTemplate)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectName = projectName else {
            return nil
        }
        return "/projects/\(projectName.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// An optional user-defined description for the project.
    public var description: Swift.String?
    /// An object defining the project update. Once a project has been created, you cannot add device template names to the project. However, for a given placementTemplate, you can update the associated callbackOverrides for the device definition using this API.
    public var placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
    /// The name of the project to be updated.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        description: Swift.String? = nil,
        placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.description = description
        self.placementTemplate = placementTemplate
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let description: Swift.String?
    let placementTemplate: IoT1ClickProjectsClientTypes.PlacementTemplate?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case placementTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let placementTemplateDecoded = try containerValues.decodeIfPresent(IoT1ClickProjectsClientTypes.PlacementTemplate.self, forKey: .placementTemplate)
        placementTemplate = placementTemplateDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProjectOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
