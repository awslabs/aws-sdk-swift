//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// The service could not respond to the request due to an internal problem.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RbinClientTypes {

    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case serviceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .serviceQuotaExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request would cause a service quota for the number of tags per resource to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension RbinClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidPageToken
        case invalidParameterValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidPageToken,
                .invalidParameterValue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidPageToken: return "INVALID_PAGE_TOKEN"
            case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// One or more of the parameters in the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension RbinClientTypes {

    public enum UnlockDelayUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlockDelayUnit] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RbinClientTypes {
    /// Information about the retention rule unlock delay. The unlock delay is the period after which a retention rule can be modified or edited after it has been unlocked by a user with the required permissions. The retention rule can't be modified or deleted during the unlock delay.
    public struct UnlockDelay {
        /// The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.
        /// This member is required.
        public var unlockDelayUnit: RbinClientTypes.UnlockDelayUnit?
        /// The unlock delay period, measured in the unit specified for UnlockDelayUnit.
        /// This member is required.
        public var unlockDelayValue: Swift.Int?

        public init(
            unlockDelayUnit: RbinClientTypes.UnlockDelayUnit? = nil,
            unlockDelayValue: Swift.Int? = nil
        )
        {
            self.unlockDelayUnit = unlockDelayUnit
            self.unlockDelayValue = unlockDelayValue
        }
    }

}

extension RbinClientTypes {
    /// Information about a retention rule lock configuration.
    public struct LockConfiguration {
        /// Information about the retention rule unlock delay.
        /// This member is required.
        public var unlockDelay: RbinClientTypes.UnlockDelay?

        public init(
            unlockDelay: RbinClientTypes.UnlockDelay? = nil
        )
        {
            self.unlockDelay = unlockDelay
        }
    }

}

extension RbinClientTypes {
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public struct ResourceTag {
        /// The tag key.
        /// This member is required.
        public var resourceTagKey: Swift.String?
        /// The tag value.
        public var resourceTagValue: Swift.String?

        public init(
            resourceTagKey: Swift.String? = nil,
            resourceTagValue: Swift.String? = nil
        )
        {
            self.resourceTagKey = resourceTagKey
            self.resourceTagValue = resourceTagValue
        }
    }

}

extension RbinClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ebsSnapshot
        case ec2Image
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ebsSnapshot,
                .ec2Image
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ebsSnapshot: return "EBS_SNAPSHOT"
            case .ec2Image: return "EC2_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RbinClientTypes {

    public enum RetentionPeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionPeriodUnit] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RbinClientTypes {
    /// Information about the retention period for which the retention rule is to retain resources.
    public struct RetentionPeriod {
        /// The unit of time in which the retention period is measured. Currently, only DAYS is supported.
        /// This member is required.
        public var retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit?
        /// The period value for which the retention rule is to retain resources. The period is measured using the unit specified for RetentionPeriodUnit.
        /// This member is required.
        public var retentionPeriodValue: Swift.Int?

        public init(
            retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit? = nil,
            retentionPeriodValue: Swift.Int? = nil
        )
        {
            self.retentionPeriodUnit = retentionPeriodUnit
            self.retentionPeriodValue = retentionPeriodValue
        }
    }

}

extension RbinClientTypes {
    /// Information about the tags to assign to the retention rule.
    public struct Tag {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateRuleInput {
    /// The retention rule description.
    public var description: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type to be retained by the retention rule. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To retain snapshots, specify EBS_SNAPSHOT. To retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    /// This member is required.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// Information about the tags to assign to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.lockConfiguration = lockConfiguration
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

extension RbinClientTypes {

    public enum LockState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case locked
        case pendingUnlock
        case unlocked
        case sdkUnknown(Swift.String)

        public static var allCases: [LockState] {
            return [
                .locked,
                .pendingUnlock,
                .unlocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .locked: return "locked"
            case .pendingUnlock: return "pending_unlock"
            case .unlocked: return "unlocked"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RbinClientTypes {

    public enum RuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStatus] {
            return [
                .available,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRuleOutput {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The Amazon Resource Name (ARN) of the retention rule.
    public var ruleArn: Swift.String?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        ruleArn: Swift.String? = nil,
        status: RbinClientTypes.RuleStatus? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.ruleArn = ruleArn
        self.status = status
        self.tags = tags
    }
}

extension RbinClientTypes {

    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidRuleState
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .invalidRuleState
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidRuleState: return "INVALID_RULE_STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified retention rule lock request can't be completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ConflictExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ConflictExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension RbinClientTypes {

    public enum ResourceNotFoundExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ruleNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .ruleNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ruleNotFound: return "RULE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ResourceNotFoundExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ResourceNotFoundExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct DeleteRuleInput {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteRuleOutput {

    public init() { }
}

public struct GetRuleInput {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetRuleOutput {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: Foundation.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The Amazon Resource Name (ARN) of the retention rule.
    public var ruleArn: Swift.String?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockEndTime: Foundation.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        ruleArn: Swift.String? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.ruleArn = ruleArn
        self.status = status
    }
}

public struct ListRulesInput {
    /// The lock state of the retention rules to list. Only retention rules with the specified lock state are returned.
    public var lockState: RbinClientTypes.LockState?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule. Only retention rules that retain the specified resource type are listed. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To list retention rules that retain snapshots, specify EBS_SNAPSHOT. To list retention rules that retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?

    public init(
        lockState: RbinClientTypes.LockState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil
    )
    {
        self.lockState = lockState
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceTags = resourceTags
        self.resourceType = resourceType
    }
}

extension RbinClientTypes {
    /// Information about a Recycle Bin retention rule.
    public struct RuleSummary {
        /// The retention rule description.
        public var description: Swift.String?
        /// The unique ID of the retention rule.
        public var identifier: Swift.String?
        /// The lock state for the retention rule.
        ///
        /// * locked - The retention rule is locked and can't be modified or deleted.
        ///
        /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
        ///
        /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
        ///
        /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
        public var lockState: RbinClientTypes.LockState?
        /// Information about the retention period for which the retention rule is to retain resources.
        public var retentionPeriod: RbinClientTypes.RetentionPeriod?
        /// The Amazon Resource Name (ARN) of the retention rule.
        public var ruleArn: Swift.String?

        public init(
            description: Swift.String? = nil,
            identifier: Swift.String? = nil,
            lockState: RbinClientTypes.LockState? = nil,
            retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
            ruleArn: Swift.String? = nil
        )
        {
            self.description = description
            self.identifier = identifier
            self.lockState = lockState
            self.retentionPeriod = retentionPeriod
            self.ruleArn = ruleArn
        }
    }

}

public struct ListRulesOutput {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the retention rules.
    public var rules: [RbinClientTypes.RuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        rules: [RbinClientTypes.RuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct LockRuleInput {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    /// This member is required.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?

    public init(
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil
    )
    {
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
    }
}

public struct LockRuleOutput {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The Amazon Resource Name (ARN) of the retention rule.
    public var ruleArn: Swift.String?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        ruleArn: Swift.String? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.ruleArn = ruleArn
        self.status = status
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information about the tags to assign to the retention rule.
    /// This member is required.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UnlockRuleInput {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct UnlockRuleOutput {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: Foundation.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The Amazon Resource Name (ARN) of the retention rule.
    public var ruleArn: Swift.String?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockEndTime: Foundation.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        ruleArn: Swift.String? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.ruleArn = ruleArn
        self.status = status
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to unassign. All tags that have the specified tag key are unassigned.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateRuleInput {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// This parameter is currently not supported. You can't update a retention rule's resource type after creation.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
    }
}

public struct UpdateRuleOutput {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: Foundation.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The Amazon Resource Name (ARN) of the retention rule.
    public var ruleArn: Swift.String?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockEndTime: Foundation.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        ruleArn: Swift.String? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.ruleArn = ruleArn
        self.status = status
    }
}

extension CreateRuleInput {

    static func urlPathProvider(_ value: CreateRuleInput) -> Swift.String? {
        return "/rules"
    }
}

extension DeleteRuleInput {

    static func urlPathProvider(_ value: DeleteRuleInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

extension GetRuleInput {

    static func urlPathProvider(_ value: GetRuleInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

extension ListRulesInput {

    static func urlPathProvider(_ value: ListRulesInput) -> Swift.String? {
        return "/list-rules"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension LockRuleInput {

    static func urlPathProvider(_ value: LockRuleInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())/lock"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UnlockRuleInput {

    static func urlPathProvider(_ value: UnlockRuleInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())/unlock"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateRuleInput {

    static func urlPathProvider(_ value: UpdateRuleInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

extension CreateRuleInput {

    static func write(value: CreateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["LockConfiguration"].write(value.lockConfiguration, with: RbinClientTypes.LockConfiguration.write(value:to:))
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: RbinClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
        try writer["RetentionPeriod"].write(value.retentionPeriod, with: RbinClientTypes.RetentionPeriod.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: RbinClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListRulesInput {

    static func write(value: ListRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LockState"].write(value.lockState)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: RbinClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension LockRuleInput {

    static func write(value: LockRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LockConfiguration"].write(value.lockConfiguration, with: RbinClientTypes.LockConfiguration.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: RbinClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRuleInput {

    static func write(value: UpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: RbinClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
        try writer["RetentionPeriod"].write(value.retentionPeriod, with: RbinClientTypes.RetentionPeriod.write(value:to:))
    }
}

extension CreateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleOutput()
        value.description = try reader["Description"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.lockConfiguration = try reader["LockConfiguration"].readIfPresent(with: RbinClientTypes.LockConfiguration.read(from:))
        value.lockState = try reader["LockState"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: RbinClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent(with: RbinClientTypes.RetentionPeriod.read(from:))
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: RbinClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleOutput {
        return DeleteRuleOutput()
    }
}

extension GetRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuleOutput()
        value.description = try reader["Description"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.lockConfiguration = try reader["LockConfiguration"].readIfPresent(with: RbinClientTypes.LockConfiguration.read(from:))
        value.lockEndTime = try reader["LockEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lockState = try reader["LockState"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: RbinClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent(with: RbinClientTypes.RetentionPeriod.read(from:))
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ListRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: RbinClientTypes.RuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: RbinClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LockRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> LockRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = LockRuleOutput()
        value.description = try reader["Description"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.lockConfiguration = try reader["LockConfiguration"].readIfPresent(with: RbinClientTypes.LockConfiguration.read(from:))
        value.lockState = try reader["LockState"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: RbinClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent(with: RbinClientTypes.RetentionPeriod.read(from:))
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UnlockRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnlockRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UnlockRuleOutput()
        value.description = try reader["Description"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.lockConfiguration = try reader["LockConfiguration"].readIfPresent(with: RbinClientTypes.LockConfiguration.read(from:))
        value.lockEndTime = try reader["LockEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lockState = try reader["LockState"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: RbinClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent(with: RbinClientTypes.RetentionPeriod.read(from:))
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRuleOutput()
        value.description = try reader["Description"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.lockEndTime = try reader["LockEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lockState = try reader["LockState"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: RbinClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent(with: RbinClientTypes.RetentionPeriod.read(from:))
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

enum CreateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum LockRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnlockRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RbinClientTypes.RetentionPeriod {

    static func write(value: RbinClientTypes.RetentionPeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionPeriodUnit"].write(value.retentionPeriodUnit)
        try writer["RetentionPeriodValue"].write(value.retentionPeriodValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RbinClientTypes.RetentionPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RbinClientTypes.RetentionPeriod()
        value.retentionPeriodValue = try reader["RetentionPeriodValue"].readIfPresent() ?? 0
        value.retentionPeriodUnit = try reader["RetentionPeriodUnit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RbinClientTypes.Tag {

    static func write(value: RbinClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RbinClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RbinClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension RbinClientTypes.ResourceTag {

    static func write(value: RbinClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceTagKey"].write(value.resourceTagKey)
        try writer["ResourceTagValue"].write(value.resourceTagValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RbinClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RbinClientTypes.ResourceTag()
        value.resourceTagKey = try reader["ResourceTagKey"].readIfPresent() ?? ""
        value.resourceTagValue = try reader["ResourceTagValue"].readIfPresent()
        return value
    }
}

extension RbinClientTypes.LockConfiguration {

    static func write(value: RbinClientTypes.LockConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UnlockDelay"].write(value.unlockDelay, with: RbinClientTypes.UnlockDelay.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RbinClientTypes.LockConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RbinClientTypes.LockConfiguration()
        value.unlockDelay = try reader["UnlockDelay"].readIfPresent(with: RbinClientTypes.UnlockDelay.read(from:))
        return value
    }
}

extension RbinClientTypes.UnlockDelay {

    static func write(value: RbinClientTypes.UnlockDelay?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UnlockDelayUnit"].write(value.unlockDelayUnit)
        try writer["UnlockDelayValue"].write(value.unlockDelayValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RbinClientTypes.UnlockDelay {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RbinClientTypes.UnlockDelay()
        value.unlockDelayValue = try reader["UnlockDelayValue"].readIfPresent() ?? 0
        value.unlockDelayUnit = try reader["UnlockDelayUnit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RbinClientTypes.RuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> RbinClientTypes.RuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RbinClientTypes.RuleSummary()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent(with: RbinClientTypes.RetentionPeriod.read(from:))
        value.lockState = try reader["LockState"].readIfPresent()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        return value
    }
}

public enum RbinClientTypes {}
