// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified retention rule lock request can't be completed.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ConflictExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ConflictExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidRuleState
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .invalidRuleState,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidRuleState: return "INVALID_RULE_STATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lockConfiguration = "LockConfiguration"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lockConfiguration = self.lockConfiguration {
            try encodeContainer.encode(lockConfiguration, forKey: .lockConfiguration)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rules"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type to be retained by the retention rule. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To retain snapshots, specify EBS_SNAPSHOT. To retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    /// This member is required.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// Information about the tags to assign to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.lockConfiguration = lockConfiguration
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let tags: [RbinClientTypes.Tag]?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lockConfiguration = "LockConfiguration"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
    }
}

extension CreateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.tags = output.tags
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.tags = tags
    }
}

struct CreateRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let tags: [RbinClientTypes.Tag]?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
}

extension CreateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
}

extension DeleteRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct GetRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetRuleInputBody: Swift.Equatable {
}

extension GetRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockEndTime = output.lockEndTime
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockEndTime = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct GetRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: ClientRuntime.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockEndTime: ClientRuntime.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct GetRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
    let lockEndTime: ClientRuntime.Date?
}

extension GetRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockEndTime = "LockEndTime"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
        let lockEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockEndTime)
        lockEndTime = lockEndTimeDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service could not respond to the request due to an internal problem.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockState = "LockState"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lockState = self.lockState {
            try encodeContainer.encode(lockState.rawValue, forKey: .lockState)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The lock state of the retention rules to list. Only retention rules with the specified lock state are returned.
    public var lockState: RbinClientTypes.LockState?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule. Only retention rules that retain the specified resource type are listed. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To list retention rules that retain snapshots, specify EBS_SNAPSHOT. To list retention rules that retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?

    public init (
        lockState: RbinClientTypes.LockState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil
    )
    {
        self.lockState = lockState
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceTags = resourceTags
        self.resourceType = resourceType
    }
}

struct ListRulesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let lockState: RbinClientTypes.LockState?
}

extension ListRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockState = "LockState"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the retention rules.
    public var rules: [RbinClientTypes.RuleSummary]?

    public init (
        nextToken: Swift.String? = nil,
        rules: [RbinClientTypes.RuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    let rules: [RbinClientTypes.RuleSummary]?
    let nextToken: Swift.String?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([RbinClientTypes.RuleSummary?].self, forKey: .rules)
        var rulesDecoded0:[RbinClientTypes.RuleSummary]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [RbinClientTypes.RuleSummary]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [RbinClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RbinClientTypes.LockConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockDelay = "UnlockDelay"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unlockDelay = self.unlockDelay {
            try encodeContainer.encode(unlockDelay, forKey: .unlockDelay)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockDelayDecoded = try containerValues.decodeIfPresent(RbinClientTypes.UnlockDelay.self, forKey: .unlockDelay)
        unlockDelay = unlockDelayDecoded
    }
}

extension RbinClientTypes {
    /// Information about a retention rule lock configuration.
    public struct LockConfiguration: Swift.Equatable {
        /// Information about the retention rule unlock delay.
        /// This member is required.
        public var unlockDelay: RbinClientTypes.UnlockDelay?

        public init (
            unlockDelay: RbinClientTypes.UnlockDelay? = nil
        )
        {
            self.unlockDelay = unlockDelay
        }
    }

}

extension LockRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockConfiguration = "LockConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lockConfiguration = self.lockConfiguration {
            try encodeContainer.encode(lockConfiguration, forKey: .lockConfiguration)
        }
    }
}

extension LockRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())/lock"
    }
}

public struct LockRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    /// This member is required.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?

    public init (
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil
    )
    {
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
    }
}

struct LockRuleInputBody: Swift.Equatable {
    let lockConfiguration: RbinClientTypes.LockConfiguration?
}

extension LockRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockConfiguration = "LockConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
    }
}

extension LockRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LockRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum LockRuleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LockRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LockRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct LockRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct LockRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
}

extension LockRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

extension RbinClientTypes {
    public enum LockState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case locked
        case pendingUnlock
        case unlocked
        case sdkUnknown(Swift.String)

        public static var allCases: [LockState] {
            return [
                .locked,
                .pendingUnlock,
                .unlocked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .locked: return "locked"
            case .pendingUnlock: return "pending_unlock"
            case .unlocked: return "unlocked"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LockState(rawValue: rawValue) ?? LockState.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ResourceNotFoundExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ResourceNotFoundExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ResourceNotFoundExceptionReason?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceNotFoundExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ResourceNotFoundExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ruleNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .ruleNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ruleNotFound: return "RULE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceNotFoundExceptionReason(rawValue: rawValue) ?? ResourceNotFoundExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTagKey = "ResourceTagKey"
        case resourceTagValue = "ResourceTagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTagKey = self.resourceTagKey {
            try encodeContainer.encode(resourceTagKey, forKey: .resourceTagKey)
        }
        if let resourceTagValue = self.resourceTagValue {
            try encodeContainer.encode(resourceTagValue, forKey: .resourceTagValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceTagKey)
        resourceTagKey = resourceTagKeyDecoded
        let resourceTagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceTagValue)
        resourceTagValue = resourceTagValueDecoded
    }
}

extension RbinClientTypes {
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public struct ResourceTag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var resourceTagKey: Swift.String?
        /// The tag value.
        public var resourceTagValue: Swift.String?

        public init (
            resourceTagKey: Swift.String? = nil,
            resourceTagValue: Swift.String? = nil
        )
        {
            self.resourceTagKey = resourceTagKey
            self.resourceTagValue = resourceTagValue
        }
    }

}

extension RbinClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsSnapshot
        case ec2Image
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ebsSnapshot,
                .ec2Image,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsSnapshot: return "EBS_SNAPSHOT"
            case .ec2Image: return "EC2_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.RetentionPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodUnit = "RetentionPeriodUnit"
        case retentionPeriodValue = "RetentionPeriodValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodUnit = self.retentionPeriodUnit {
            try encodeContainer.encode(retentionPeriodUnit.rawValue, forKey: .retentionPeriodUnit)
        }
        if let retentionPeriodValue = self.retentionPeriodValue {
            try encodeContainer.encode(retentionPeriodValue, forKey: .retentionPeriodValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodValue)
        retentionPeriodValue = retentionPeriodValueDecoded
        let retentionPeriodUnitDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriodUnit.self, forKey: .retentionPeriodUnit)
        retentionPeriodUnit = retentionPeriodUnitDecoded
    }
}

extension RbinClientTypes {
    /// Information about the retention period for which the retention rule is to retain resources.
    public struct RetentionPeriod: Swift.Equatable {
        /// The unit of time in which the retention period is measured. Currently, only DAYS is supported.
        /// This member is required.
        public var retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit?
        /// The period value for which the retention rule is to retain resources. The period is measured using the unit specified for RetentionPeriodUnit.
        /// This member is required.
        public var retentionPeriodValue: Swift.Int?

        public init (
            retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit? = nil,
            retentionPeriodValue: Swift.Int? = nil
        )
        {
            self.retentionPeriodUnit = retentionPeriodUnit
            self.retentionPeriodValue = retentionPeriodValue
        }
    }

}

extension RbinClientTypes {
    public enum RetentionPeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionPeriodUnit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionPeriodUnit(rawValue: rawValue) ?? RetentionPeriodUnit.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes {
    public enum RuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStatus] {
            return [
                .available,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleStatus(rawValue: rawValue) ?? RuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.RuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockState = "LockState"
        case retentionPeriod = "RetentionPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let lockState = self.lockState {
            try encodeContainer.encode(lockState.rawValue, forKey: .lockState)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

extension RbinClientTypes {
    /// Information about a Recycle Bin retention rule.
    public struct RuleSummary: Swift.Equatable {
        /// The retention rule description.
        public var description: Swift.String?
        /// The unique ID of the retention rule.
        public var identifier: Swift.String?
        /// The lock state for the retention rule.
        ///
        /// * locked - The retention rule is locked and can't be modified or deleted.
        ///
        /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
        ///
        /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
        ///
        /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
        public var lockState: RbinClientTypes.LockState?
        /// Information about the retention period for which the retention rule is to retain resources.
        public var retentionPeriod: RbinClientTypes.RetentionPeriod?

        public init (
            description: Swift.String? = nil,
            identifier: Swift.String? = nil,
            lockState: RbinClientTypes.LockState? = nil,
            retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
        )
        {
            self.description = description
            self.identifier = identifier
            self.lockState = lockState
            self.retentionPeriod = retentionPeriod
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota for the number of tags per resource to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ServiceQuotaExceededExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case serviceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .serviceQuotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RbinClientTypes {
    /// Information about the tags to assign to the retention rule.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information about the tags to assign to the retention rule.
    /// This member is required.
    public var tags: [RbinClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [RbinClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension RbinClientTypes.UnlockDelay: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockDelayUnit = "UnlockDelayUnit"
        case unlockDelayValue = "UnlockDelayValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unlockDelayUnit = self.unlockDelayUnit {
            try encodeContainer.encode(unlockDelayUnit.rawValue, forKey: .unlockDelayUnit)
        }
        if let unlockDelayValue = self.unlockDelayValue {
            try encodeContainer.encode(unlockDelayValue, forKey: .unlockDelayValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockDelayValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unlockDelayValue)
        unlockDelayValue = unlockDelayValueDecoded
        let unlockDelayUnitDecoded = try containerValues.decodeIfPresent(RbinClientTypes.UnlockDelayUnit.self, forKey: .unlockDelayUnit)
        unlockDelayUnit = unlockDelayUnitDecoded
    }
}

extension RbinClientTypes {
    /// Information about the retention rule unlock delay. The unlock delay is the period after which a retention rule can be modified or edited after it has been unlocked by a user with the required permissions. The retention rule can't be modified or deleted during the unlock delay.
    public struct UnlockDelay: Swift.Equatable {
        /// The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.
        /// This member is required.
        public var unlockDelayUnit: RbinClientTypes.UnlockDelayUnit?
        /// The unlock delay period, measured in the unit specified for UnlockDelayUnit.
        /// This member is required.
        public var unlockDelayValue: Swift.Int?

        public init (
            unlockDelayUnit: RbinClientTypes.UnlockDelayUnit? = nil,
            unlockDelayValue: Swift.Int? = nil
        )
        {
            self.unlockDelayUnit = unlockDelayUnit
            self.unlockDelayValue = unlockDelayValue
        }
    }

}

extension RbinClientTypes {
    public enum UnlockDelayUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlockDelayUnit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnlockDelayUnit(rawValue: rawValue) ?? UnlockDelayUnit.sdkUnknown(rawValue)
        }
    }
}

extension UnlockRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())/unlock"
    }
}

public struct UnlockRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct UnlockRuleInputBody: Swift.Equatable {
}

extension UnlockRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnlockRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlockRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UnlockRuleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlockRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnlockRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockEndTime = output.lockEndTime
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockEndTime = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct UnlockRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: ClientRuntime.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockEndTime: ClientRuntime.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct UnlockRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
    let lockEndTime: ClientRuntime.Date?
}

extension UnlockRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockEndTime = "LockEndTime"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
        let lockEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockEndTime)
        lockEndTime = lockEndTimeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to unassign. All tags that have the specified tag key are unassigned.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

extension UpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateRuleInput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// This parameter is currently not supported. You can't update a retention rule's resource type after creation.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateRuleInputBody: Swift.Equatable {
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
}

extension UpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension UpdateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRuleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockEndTime = output.lockEndTime
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockEndTime = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct UpdateRuleOutputResponse: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: ClientRuntime.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init (
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockEndTime: ClientRuntime.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct UpdateRuleOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockState: RbinClientTypes.LockState?
    let lockEndTime: ClientRuntime.Date?
}

extension UpdateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockEndTime = "LockEndTime"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
        let lockEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockEndTime)
        lockEndTime = lockEndTimeDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the parameters in the request is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the exception.
    public var reason: RbinClientTypes.ValidationExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: RbinClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidPageToken
        case invalidParameterValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidPageToken,
                .invalidParameterValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidPageToken: return "INVALID_PAGE_TOKEN"
            case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
