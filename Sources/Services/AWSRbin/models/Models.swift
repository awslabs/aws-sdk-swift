// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified retention rule lock request can't be completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ConflictExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ConflictExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidRuleState
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .invalidRuleState,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidRuleState: return "INVALID_RULE_STATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lockConfiguration = "LockConfiguration"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lockConfiguration = self.lockConfiguration {
            try encodeContainer.encode(lockConfiguration, forKey: .lockConfiguration)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rules"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type to be retained by the retention rule. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To retain snapshots, specify EBS_SNAPSHOT. To retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    /// This member is required.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// Information about the tags to assign to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.lockConfiguration = lockConfiguration
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let tags: [RbinClientTypes.Tag]?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lockConfiguration = "LockConfiguration"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
    }
}

extension CreateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.tags = output.tags
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateRuleOutput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.tags = tags
    }
}

struct CreateRuleOutputBody: Swift.Equatable {
    let identifier: Swift.String?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let tags: [RbinClientTypes.Tag]?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
}

extension CreateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

enum CreateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
}

extension DeleteRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct GetRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetRuleInputBody: Swift.Equatable {
}

extension GetRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockEndTime = output.lockEndTime
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockEndTime = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct GetRuleOutput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: ClientRuntime.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockEndTime: ClientRuntime.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct GetRuleOutputBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
    let lockEndTime: ClientRuntime.Date?
}

extension GetRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockEndTime = "LockEndTime"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
        let lockEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockEndTime)
        lockEndTime = lockEndTimeDecoded
    }
}

enum GetRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service could not respond to the request due to an internal problem.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockState = "LockState"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lockState = self.lockState {
            try encodeContainer.encode(lockState.rawValue, forKey: .lockState)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The lock state of the retention rules to list. Only retention rules with the specified lock state are returned.
    public var lockState: RbinClientTypes.LockState?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule. Only retention rules that retain the specified resource type are listed. Currently, only Amazon EBS snapshots and EBS-backed AMIs are supported. To list retention rules that retain snapshots, specify EBS_SNAPSHOT. To list retention rules that retain EBS-backed AMIs, specify EC2_IMAGE.
    /// This member is required.
    public var resourceType: RbinClientTypes.ResourceType?

    public init(
        lockState: RbinClientTypes.LockState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil
    )
    {
        self.lockState = lockState
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceTags = resourceTags
        self.resourceType = resourceType
    }
}

struct ListRulesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let lockState: RbinClientTypes.LockState?
}

extension ListRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockState = "LockState"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

extension ListRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the retention rules.
    public var rules: [RbinClientTypes.RuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        rules: [RbinClientTypes.RuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputBody: Swift.Equatable {
    let rules: [RbinClientTypes.RuleSummary]?
    let nextToken: Swift.String?
}

extension ListRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([RbinClientTypes.RuleSummary?].self, forKey: .rules)
        var rulesDecoded0:[RbinClientTypes.RuleSummary]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [RbinClientTypes.RuleSummary]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Information about the tags assigned to the retention rule.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [RbinClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RbinClientTypes.LockConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockDelay = "UnlockDelay"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unlockDelay = self.unlockDelay {
            try encodeContainer.encode(unlockDelay, forKey: .unlockDelay)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockDelayDecoded = try containerValues.decodeIfPresent(RbinClientTypes.UnlockDelay.self, forKey: .unlockDelay)
        unlockDelay = unlockDelayDecoded
    }
}

extension RbinClientTypes {
    /// Information about a retention rule lock configuration.
    public struct LockConfiguration: Swift.Equatable {
        /// Information about the retention rule unlock delay.
        /// This member is required.
        public var unlockDelay: RbinClientTypes.UnlockDelay?

        public init(
            unlockDelay: RbinClientTypes.UnlockDelay? = nil
        )
        {
            self.unlockDelay = unlockDelay
        }
    }

}

extension LockRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockConfiguration = "LockConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lockConfiguration = self.lockConfiguration {
            try encodeContainer.encode(lockConfiguration, forKey: .lockConfiguration)
        }
    }
}

extension LockRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())/lock"
    }
}

public struct LockRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    /// This member is required.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?

    public init(
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil
    )
    {
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
    }
}

struct LockRuleInputBody: Swift.Equatable {
    let lockConfiguration: RbinClientTypes.LockConfiguration?
}

extension LockRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lockConfiguration = "LockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
    }
}

extension LockRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LockRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct LockRuleOutput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct LockRuleOutputBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
}

extension LockRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

enum LockRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RbinClientTypes {
    public enum LockState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case locked
        case pendingUnlock
        case unlocked
        case sdkUnknown(Swift.String)

        public static var allCases: [LockState] {
            return [
                .locked,
                .pendingUnlock,
                .unlocked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .locked: return "locked"
            case .pendingUnlock: return "pending_unlock"
            case .unlocked: return "unlocked"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LockState(rawValue: rawValue) ?? LockState.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ResourceNotFoundExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ResourceNotFoundExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ResourceNotFoundExceptionReason?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceNotFoundExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ResourceNotFoundExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ruleNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .ruleNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ruleNotFound: return "RULE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceNotFoundExceptionReason(rawValue: rawValue) ?? ResourceNotFoundExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTagKey = "ResourceTagKey"
        case resourceTagValue = "ResourceTagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTagKey = self.resourceTagKey {
            try encodeContainer.encode(resourceTagKey, forKey: .resourceTagKey)
        }
        if let resourceTagValue = self.resourceTagValue {
            try encodeContainer.encode(resourceTagValue, forKey: .resourceTagValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceTagKey)
        resourceTagKey = resourceTagKeyDecoded
        let resourceTagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceTagValue)
        resourceTagValue = resourceTagValueDecoded
    }
}

extension RbinClientTypes {
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public struct ResourceTag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var resourceTagKey: Swift.String?
        /// The tag value.
        public var resourceTagValue: Swift.String?

        public init(
            resourceTagKey: Swift.String? = nil,
            resourceTagValue: Swift.String? = nil
        )
        {
            self.resourceTagKey = resourceTagKey
            self.resourceTagValue = resourceTagValue
        }
    }

}

extension RbinClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsSnapshot
        case ec2Image
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ebsSnapshot,
                .ec2Image,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsSnapshot: return "EBS_SNAPSHOT"
            case .ec2Image: return "EC2_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.RetentionPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodUnit = "RetentionPeriodUnit"
        case retentionPeriodValue = "RetentionPeriodValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodUnit = self.retentionPeriodUnit {
            try encodeContainer.encode(retentionPeriodUnit.rawValue, forKey: .retentionPeriodUnit)
        }
        if let retentionPeriodValue = self.retentionPeriodValue {
            try encodeContainer.encode(retentionPeriodValue, forKey: .retentionPeriodValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodValue)
        retentionPeriodValue = retentionPeriodValueDecoded
        let retentionPeriodUnitDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriodUnit.self, forKey: .retentionPeriodUnit)
        retentionPeriodUnit = retentionPeriodUnitDecoded
    }
}

extension RbinClientTypes {
    /// Information about the retention period for which the retention rule is to retain resources.
    public struct RetentionPeriod: Swift.Equatable {
        /// The unit of time in which the retention period is measured. Currently, only DAYS is supported.
        /// This member is required.
        public var retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit?
        /// The period value for which the retention rule is to retain resources. The period is measured using the unit specified for RetentionPeriodUnit.
        /// This member is required.
        public var retentionPeriodValue: Swift.Int?

        public init(
            retentionPeriodUnit: RbinClientTypes.RetentionPeriodUnit? = nil,
            retentionPeriodValue: Swift.Int? = nil
        )
        {
            self.retentionPeriodUnit = retentionPeriodUnit
            self.retentionPeriodValue = retentionPeriodValue
        }
    }

}

extension RbinClientTypes {
    public enum RetentionPeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionPeriodUnit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionPeriodUnit(rawValue: rawValue) ?? RetentionPeriodUnit.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes {
    public enum RuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStatus] {
            return [
                .available,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleStatus(rawValue: rawValue) ?? RuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.RuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockState = "LockState"
        case retentionPeriod = "RetentionPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let lockState = self.lockState {
            try encodeContainer.encode(lockState.rawValue, forKey: .lockState)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
    }
}

extension RbinClientTypes {
    /// Information about a Recycle Bin retention rule.
    public struct RuleSummary: Swift.Equatable {
        /// The retention rule description.
        public var description: Swift.String?
        /// The unique ID of the retention rule.
        public var identifier: Swift.String?
        /// The lock state for the retention rule.
        ///
        /// * locked - The retention rule is locked and can't be modified or deleted.
        ///
        /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
        ///
        /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
        ///
        /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
        public var lockState: RbinClientTypes.LockState?
        /// Information about the retention period for which the retention rule is to retain resources.
        public var retentionPeriod: RbinClientTypes.RetentionPeriod?

        public init(
            description: Swift.String? = nil,
            identifier: Swift.String? = nil,
            lockState: RbinClientTypes.LockState? = nil,
            retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
        )
        {
            self.description = description
            self.identifier = identifier
            self.lockState = lockState
            self.retentionPeriod = retentionPeriod
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota for the number of tags per resource to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case serviceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .serviceQuotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RbinClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RbinClientTypes {
    /// Information about the tags to assign to the retention rule.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information about the tags to assign to the retention rule.
    /// This member is required.
    public var tags: [RbinClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RbinClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [RbinClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RbinClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RbinClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RbinClientTypes.UnlockDelay: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockDelayUnit = "UnlockDelayUnit"
        case unlockDelayValue = "UnlockDelayValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unlockDelayUnit = self.unlockDelayUnit {
            try encodeContainer.encode(unlockDelayUnit.rawValue, forKey: .unlockDelayUnit)
        }
        if let unlockDelayValue = self.unlockDelayValue {
            try encodeContainer.encode(unlockDelayValue, forKey: .unlockDelayValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockDelayValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unlockDelayValue)
        unlockDelayValue = unlockDelayValueDecoded
        let unlockDelayUnitDecoded = try containerValues.decodeIfPresent(RbinClientTypes.UnlockDelayUnit.self, forKey: .unlockDelayUnit)
        unlockDelayUnit = unlockDelayUnitDecoded
    }
}

extension RbinClientTypes {
    /// Information about the retention rule unlock delay. The unlock delay is the period after which a retention rule can be modified or edited after it has been unlocked by a user with the required permissions. The retention rule can't be modified or deleted during the unlock delay.
    public struct UnlockDelay: Swift.Equatable {
        /// The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.
        /// This member is required.
        public var unlockDelayUnit: RbinClientTypes.UnlockDelayUnit?
        /// The unlock delay period, measured in the unit specified for UnlockDelayUnit.
        /// This member is required.
        public var unlockDelayValue: Swift.Int?

        public init(
            unlockDelayUnit: RbinClientTypes.UnlockDelayUnit? = nil,
            unlockDelayValue: Swift.Int? = nil
        )
        {
            self.unlockDelayUnit = unlockDelayUnit
            self.unlockDelayValue = unlockDelayValue
        }
    }

}

extension RbinClientTypes {
    public enum UnlockDelayUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlockDelayUnit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnlockDelayUnit(rawValue: rawValue) ?? UnlockDelayUnit.sdkUnknown(rawValue)
        }
    }
}

extension UnlockRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())/unlock"
    }
}

public struct UnlockRuleInput: Swift.Equatable {
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct UnlockRuleInputBody: Swift.Equatable {
}

extension UnlockRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UnlockRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnlockRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockConfiguration = output.lockConfiguration
            self.lockEndTime = output.lockEndTime
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockConfiguration = nil
            self.lockEndTime = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct UnlockRuleOutput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// Information about the retention rule lock configuration.
    public var lockConfiguration: RbinClientTypes.LockConfiguration?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: ClientRuntime.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockConfiguration: RbinClientTypes.LockConfiguration? = nil,
        lockEndTime: ClientRuntime.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockConfiguration = lockConfiguration
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct UnlockRuleOutputBody: Swift.Equatable {
    let identifier: Swift.String?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockConfiguration: RbinClientTypes.LockConfiguration?
    let lockState: RbinClientTypes.LockState?
    let lockEndTime: ClientRuntime.Date?
}

extension UnlockRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockConfiguration = "LockConfiguration"
        case lockEndTime = "LockEndTime"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockConfigurationDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockConfiguration.self, forKey: .lockConfiguration)
        lockConfiguration = lockConfigurationDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
        let lockEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockEndTime)
        lockEndTime = lockEndTimeDecoded
    }
}

enum UnlockRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the retention rule.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to unassign. All tags that have the specified tag key are unassigned.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

extension UpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/rules/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateRuleInput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the resource tags to use to identify resources that are to be retained by a tag-level retention rule. For tag-level retention rules, only deleted resources, of the specified resource type, that have one or more of the specified tag key and value pairs are retained. If a resource is deleted, but it does not have any of the specified tag key and value pairs, it is immediately deleted without being retained by the retention rule. You can add the same tag key and value pair to a maximum or five retention rules. To create a Region-level retention rule, omit this parameter. A Region-level retention rule does not have any resource tags specified. It retains all deleted resources of the specified resource type in the Region in which the rule is created, even if the resources are not tagged.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// This parameter is currently not supported. You can't update a retention rule's resource type after creation.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateRuleInputBody: Swift.Equatable {
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
}

extension UpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension UpdateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.identifier = output.identifier
            self.lockEndTime = output.lockEndTime
            self.lockState = output.lockState
            self.resourceTags = output.resourceTags
            self.resourceType = output.resourceType
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
        } else {
            self.description = nil
            self.identifier = nil
            self.lockEndTime = nil
            self.lockState = nil
            self.resourceTags = nil
            self.resourceType = nil
            self.retentionPeriod = nil
            self.status = nil
        }
    }
}

public struct UpdateRuleOutput: Swift.Equatable {
    /// The retention rule description.
    public var description: Swift.String?
    /// The unique ID of the retention rule.
    public var identifier: Swift.String?
    /// The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.
    public var lockEndTime: ClientRuntime.Date?
    /// The lock state for the retention rule.
    ///
    /// * locked - The retention rule is locked and can't be modified or deleted.
    ///
    /// * pending_unlock - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.
    ///
    /// * unlocked - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.
    ///
    /// * null - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the locked and unlocked states only; it can never transition back to null.
    public var lockState: RbinClientTypes.LockState?
    /// Information about the resource tags used to identify resources that are retained by the retention rule.
    public var resourceTags: [RbinClientTypes.ResourceTag]?
    /// The resource type retained by the retention rule.
    public var resourceType: RbinClientTypes.ResourceType?
    /// Information about the retention period for which the retention rule is to retain resources.
    public var retentionPeriod: RbinClientTypes.RetentionPeriod?
    /// The state of the retention rule. Only retention rules that are in the available state retain resources.
    public var status: RbinClientTypes.RuleStatus?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        lockEndTime: ClientRuntime.Date? = nil,
        lockState: RbinClientTypes.LockState? = nil,
        resourceTags: [RbinClientTypes.ResourceTag]? = nil,
        resourceType: RbinClientTypes.ResourceType? = nil,
        retentionPeriod: RbinClientTypes.RetentionPeriod? = nil,
        status: RbinClientTypes.RuleStatus? = nil
    )
    {
        self.description = description
        self.identifier = identifier
        self.lockEndTime = lockEndTime
        self.lockState = lockState
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.retentionPeriod = retentionPeriod
        self.status = status
    }
}

struct UpdateRuleOutputBody: Swift.Equatable {
    let identifier: Swift.String?
    let retentionPeriod: RbinClientTypes.RetentionPeriod?
    let description: Swift.String?
    let resourceType: RbinClientTypes.ResourceType?
    let resourceTags: [RbinClientTypes.ResourceTag]?
    let status: RbinClientTypes.RuleStatus?
    let lockState: RbinClientTypes.LockState?
    let lockEndTime: ClientRuntime.Date?
}

extension UpdateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case identifier = "Identifier"
        case lockEndTime = "LockEndTime"
        case lockState = "LockState"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([RbinClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[RbinClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [RbinClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RbinClientTypes.RuleStatus.self, forKey: .status)
        status = statusDecoded
        let lockStateDecoded = try containerValues.decodeIfPresent(RbinClientTypes.LockState.self, forKey: .lockState)
        lockState = lockStateDecoded
        let lockEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lockEndTime)
        lockEndTime = lockEndTimeDecoded
    }
}

enum UpdateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the parameters in the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: RbinClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: RbinClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: RbinClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RbinClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RbinClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidPageToken
        case invalidParameterValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidPageToken,
                .invalidParameterValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidPageToken: return "INVALID_PAGE_TOKEN"
            case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
