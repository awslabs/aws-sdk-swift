// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PIClientTypes {
    public enum AcceptLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptLanguage] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "EN_US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptLanguage(rawValue: rawValue) ?? AcceptLanguage.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes.AnalysisReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReportId = "AnalysisReportId"
        case createTime = "CreateTime"
        case endTime = "EndTime"
        case identifier = "Identifier"
        case insights = "Insights"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisReportId = self.analysisReportId {
            try encodeContainer.encode(analysisReportId, forKey: .analysisReportId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let insights = insights {
            var insightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insights)
            for insight0 in insights {
                try insightsContainer.encode(insight0)
            }
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisReportId)
        analysisReportId = analysisReportIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PIClientTypes.AnalysisStatus.self, forKey: .status)
        status = statusDecoded
        let insightsContainer = try containerValues.decodeIfPresent([PIClientTypes.Insight?].self, forKey: .insights)
        var insightsDecoded0:[PIClientTypes.Insight]? = nil
        if let insightsContainer = insightsContainer {
            insightsDecoded0 = [PIClientTypes.Insight]()
            for structure0 in insightsContainer {
                if let structure0 = structure0 {
                    insightsDecoded0?.append(structure0)
                }
            }
        }
        insights = insightsDecoded0
    }
}

extension PIClientTypes {
    /// Retrieves the summary of the performance analysis report created for a time period.
    public struct AnalysisReport: Swift.Equatable {
        /// The name of the analysis report.
        /// This member is required.
        public var analysisReportId: Swift.String?
        /// The time you created the analysis report.
        public var createTime: ClientRuntime.Date?
        /// The analysis end time in the report.
        public var endTime: ClientRuntime.Date?
        /// The unique identifier of the analysis report.
        public var identifier: Swift.String?
        /// The list of identified insights in the analysis report.
        public var insights: [PIClientTypes.Insight]?
        /// List the tags for the Amazon Web Services service for which Performance Insights returns metrics. Valid values are as follows:
        ///
        /// * RDS
        ///
        /// * DOCDB
        public var serviceType: PIClientTypes.ServiceType?
        /// The analysis start time in the report.
        public var startTime: ClientRuntime.Date?
        /// The status of the created analysis report.
        public var status: PIClientTypes.AnalysisStatus?

        public init(
            analysisReportId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            identifier: Swift.String? = nil,
            insights: [PIClientTypes.Insight]? = nil,
            serviceType: PIClientTypes.ServiceType? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: PIClientTypes.AnalysisStatus? = nil
        )
        {
            self.analysisReportId = analysisReportId
            self.createTime = createTime
            self.endTime = endTime
            self.identifier = identifier
            self.insights = insights
            self.serviceType = serviceType
            self.startTime = startTime
            self.status = status
        }
    }

}

extension PIClientTypes.AnalysisReportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReportId = "AnalysisReportId"
        case createTime = "CreateTime"
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisReportId = self.analysisReportId {
            try encodeContainer.encode(analysisReportId, forKey: .analysisReportId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisReportId)
        analysisReportId = analysisReportIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PIClientTypes.AnalysisStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PIClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PIClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PIClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PIClientTypes {
    /// Retrieves the details of the performance analysis report.
    public struct AnalysisReportSummary: Swift.Equatable {
        /// The name of the analysis report.
        public var analysisReportId: Swift.String?
        /// The time you created the analysis report.
        public var createTime: ClientRuntime.Date?
        /// The end time of the analysis in the report.
        public var endTime: ClientRuntime.Date?
        /// The start time of the analysis in the report.
        public var startTime: ClientRuntime.Date?
        /// The status of the analysis report.
        public var status: PIClientTypes.AnalysisStatus?
        /// List of all the tags added to the analysis report.
        public var tags: [PIClientTypes.Tag]?

        public init(
            analysisReportId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: PIClientTypes.AnalysisStatus? = nil,
            tags: [PIClientTypes.Tag]? = nil
        )
        {
            self.analysisReportId = analysisReportId
            self.createTime = createTime
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.tags = tags
        }
    }

}

extension PIClientTypes {
    public enum AnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisStatus(rawValue: rawValue) ?? AnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes {
    public enum ContextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case causal
        case contextual
        case sdkUnknown(Swift.String)

        public static var allCases: [ContextType] {
            return [
                .causal,
                .contextual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .causal: return "CAUSAL"
            case .contextual: return "CONTEXTUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContextType(rawValue: rawValue) ?? ContextType.sdkUnknown(rawValue)
        }
    }
}

extension CreatePerformanceAnalysisReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePerformanceAnalysisReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePerformanceAnalysisReportInput: Swift.Equatable {
    /// The end time defined for the analysis report.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// An immutable, Amazon Web Services Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use an Amazon RDS instance as a data source, you specify its DbiResourceId value. For example, specify db-ADECBTYHKTSAUMUZQYPDS2GW4A.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The start time defined for the analysis report.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The metadata assigned to the analysis report consisting of a key-value pair.
    public var tags: [PIClientTypes.Tag]?

    public init(
        endTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [PIClientTypes.Tag]? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.serviceType = serviceType
        self.startTime = startTime
        self.tags = tags
    }
}

struct CreatePerformanceAnalysisReportInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let tags: [PIClientTypes.Tag]?
}

extension CreatePerformanceAnalysisReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PIClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PIClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PIClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePerformanceAnalysisReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePerformanceAnalysisReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisReportId = output.analysisReportId
        } else {
            self.analysisReportId = nil
        }
    }
}

public struct CreatePerformanceAnalysisReportOutput: Swift.Equatable {
    /// A unique identifier for the created analysis report.
    public var analysisReportId: Swift.String?

    public init(
        analysisReportId: Swift.String? = nil
    )
    {
        self.analysisReportId = analysisReportId
    }
}

struct CreatePerformanceAnalysisReportOutputBody: Swift.Equatable {
    let analysisReportId: Swift.String?
}

extension CreatePerformanceAnalysisReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReportId = "AnalysisReportId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisReportId)
        analysisReportId = analysisReportIdDecoded
    }
}

enum CreatePerformanceAnalysisReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PIClientTypes.Data: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case performanceInsightsMetric = "PerformanceInsightsMetric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let performanceInsightsMetric = self.performanceInsightsMetric {
            try encodeContainer.encode(performanceInsightsMetric, forKey: .performanceInsightsMetric)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let performanceInsightsMetricDecoded = try containerValues.decodeIfPresent(PIClientTypes.PerformanceInsightsMetric.self, forKey: .performanceInsightsMetric)
        performanceInsightsMetric = performanceInsightsMetricDecoded
    }
}

extension PIClientTypes {
    /// List of data objects which provide details about source metrics. This field can be used to determine the PI metric to render for the insight. This data type also includes static values for the metrics for the Insight that were calculated and included in text and annotations on the DB load chart.
    public struct Data: Swift.Equatable {
        /// This field determines the Performance Insights metric to render for the insight. The name field refers to a Performance Insights metric.
        public var performanceInsightsMetric: PIClientTypes.PerformanceInsightsMetric?

        public init(
            performanceInsightsMetric: PIClientTypes.PerformanceInsightsMetric? = nil
        )
        {
            self.performanceInsightsMetric = performanceInsightsMetric
        }
    }

}

extension PIClientTypes.DataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension PIClientTypes {
    /// A timestamp, and a single numerical value, which together represent a measurement at a particular point in time.
    public struct DataPoint: Swift.Equatable {
        /// The time, in epoch format, associated with a particular Value.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The actual value associated with a particular Timestamp.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Double? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension DeletePerformanceAnalysisReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReportId = "AnalysisReportId"
        case identifier = "Identifier"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisReportId = self.analysisReportId {
            try encodeContainer.encode(analysisReportId, forKey: .analysisReportId)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension DeletePerformanceAnalysisReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePerformanceAnalysisReportInput: Swift.Equatable {
    /// The unique identifier of the analysis report for deletion.
    /// This member is required.
    public var analysisReportId: Swift.String?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        analysisReportId: Swift.String? = nil,
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.analysisReportId = analysisReportId
        self.identifier = identifier
        self.serviceType = serviceType
    }
}

struct DeletePerformanceAnalysisReportInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let analysisReportId: Swift.String?
}

extension DeletePerformanceAnalysisReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReportId = "AnalysisReportId"
        case identifier = "Identifier"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let analysisReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisReportId)
        analysisReportId = analysisReportIdDecoded
    }
}

extension DeletePerformanceAnalysisReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePerformanceAnalysisReportOutput: Swift.Equatable {

    public init() { }
}

enum DeletePerformanceAnalysisReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDimensionKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetrics = "AdditionalMetrics"
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetrics = additionalMetrics {
            var additionalMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetrics)
            for requeststring0 in additionalMetrics {
                try additionalMetricsContainer.encode(requeststring0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricQueryFilterMap0) in filter {
                try filterContainer.encode(metricQueryFilterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let partitionBy = self.partitionBy {
            try encodeContainer.encode(partitionBy, forKey: .partitionBy)
        }
        if let periodInSeconds = self.periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension DescribeDimensionKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDimensionKeysInput: Swift.Equatable {
    /// Additional metrics for the top N dimension keys. If the specified dimension group in the GroupBy parameter is db.sql_tokenized, you can specify per-SQL metrics to get the values for the top N SQL digests. The response syntax is as follows: "AdditionalMetrics" : { "string" : "string" }.
    public var additionalMetrics: [Swift.String]?
    /// The date and time specifying the end of the requested time series data. The value specified is exclusive, which means that data points less than (but not equal to) EndTime are returned. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// One or more filters to apply in the request. Restrictions:
    ///
    /// * Any number of filters by the same dimension, as specified in the GroupBy or Partition parameters.
    ///
    /// * A single filter for any other dimension in this dimension group.
    public var filter: [Swift.String:Swift.String]?
    /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights returns all dimensions within this group, unless you provide the names of specific dimensions within this group. You can also request that Performance Insights return a limited number of values for a dimension.
    /// This member is required.
    public var groupBy: PIClientTypes.DimensionGroup?
    /// An immutable, Amazon Web Services Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use an Amazon RDS instance as a data source, you specify its DbiResourceId value. For example, specify db-FAIHNTYBKTGAUSUZQYPDS2GW4A.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
    ///
    /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
    ///
    /// * db.sampledload.avg - The raw number of active sessions for the database engine.
    ///
    ///
    /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
    /// This member is required.
    public var metric: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// For each dimension specified in GroupBy, specify a secondary dimension to further subdivide the partition keys in the response.
    public var partitionBy: PIClientTypes.DimensionGroup?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights chooses a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid values are as follows:
    ///
    /// * RDS
    ///
    /// * DOCDB
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series data. You must specify a StartTime within the past 7 days. The value specified is inclusive, which means that data points equal to or greater than StartTime are returned. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        additionalMetrics: [Swift.String]? = nil,
        endTime: ClientRuntime.Date? = nil,
        filter: [Swift.String:Swift.String]? = nil,
        groupBy: PIClientTypes.DimensionGroup? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metric: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        partitionBy: PIClientTypes.DimensionGroup? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.additionalMetrics = additionalMetrics
        self.endTime = endTime
        self.filter = filter
        self.groupBy = groupBy
        self.identifier = identifier
        self.maxResults = maxResults
        self.metric = metric
        self.nextToken = nextToken
        self.partitionBy = partitionBy
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct DescribeDimensionKeysInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metric: Swift.String?
    let periodInSeconds: Swift.Int?
    let groupBy: PIClientTypes.DimensionGroup?
    let additionalMetrics: [Swift.String]?
    let partitionBy: PIClientTypes.DimensionGroup?
    let filter: [Swift.String:Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDimensionKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetrics = "AdditionalMetrics"
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PIClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let additionalMetricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalMetrics)
        var additionalMetricsDecoded0:[Swift.String]? = nil
        if let additionalMetricsContainer = additionalMetricsContainer {
            additionalMetricsDecoded0 = [Swift.String]()
            for string0 in additionalMetricsContainer {
                if let string0 = string0 {
                    additionalMetricsDecoded0?.append(string0)
                }
            }
        }
        additionalMetrics = additionalMetricsDecoded0
        let partitionByDecoded = try containerValues.decodeIfPresent(PIClientTypes.DimensionGroup.self, forKey: .partitionBy)
        partitionBy = partitionByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDimensionKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDimensionKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.keys = output.keys
            self.nextToken = output.nextToken
            self.partitionKeys = output.partitionKeys
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.keys = nil
            self.nextToken = nil
            self.partitionKeys = nil
        }
    }
}

public struct DescribeDimensionKeysOutput: Swift.Equatable {
    /// The end time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: ClientRuntime.Date?
    /// The start time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: ClientRuntime.Date?
    /// The dimension keys that were requested.
    public var keys: [PIClientTypes.DimensionKeyDescription]?
    /// A pagination token that indicates the response didn’t return all available records because MaxRecords was specified in the previous request. To get the remaining records, specify NextToken in a separate request with this value.
    public var nextToken: Swift.String?
    /// If PartitionBy was present in the request, PartitionKeys contains the breakdown of dimension keys by the specified partitions.
    public var partitionKeys: [PIClientTypes.ResponsePartitionKey]?

    public init(
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        keys: [PIClientTypes.DimensionKeyDescription]? = nil,
        nextToken: Swift.String? = nil,
        partitionKeys: [PIClientTypes.ResponsePartitionKey]? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.keys = keys
        self.nextToken = nextToken
        self.partitionKeys = partitionKeys
    }
}

struct DescribeDimensionKeysOutputBody: Swift.Equatable {
    let alignedStartTime: ClientRuntime.Date?
    let alignedEndTime: ClientRuntime.Date?
    let partitionKeys: [PIClientTypes.ResponsePartitionKey]?
    let keys: [PIClientTypes.DimensionKeyDescription]?
    let nextToken: Swift.String?
}

extension DescribeDimensionKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case keys = "Keys"
        case nextToken = "NextToken"
        case partitionKeys = "PartitionKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([PIClientTypes.ResponsePartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[PIClientTypes.ResponsePartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [PIClientTypes.ResponsePartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let keysContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionKeyDescription?].self, forKey: .keys)
        var keysDecoded0:[PIClientTypes.DimensionKeyDescription]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [PIClientTypes.DimensionKeyDescription]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeDimensionKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PIClientTypes {
    public enum DetailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case processing
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailStatus] {
            return [
                .available,
                .processing,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .processing: return "PROCESSING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailStatus(rawValue: rawValue) ?? DetailStatus.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes.DimensionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension PIClientTypes {
    /// The information about a dimension.
    public struct DimensionDetail: Swift.Equatable {
        /// The identifier of a dimension.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension PIClientTypes.DimensionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for requeststring0 in dimensions {
                try dimensionsContainer.encode(requeststring0)
            }
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension PIClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions:
    ///
    /// * db.sql.id - The hash of a running SQL statement, generated by Performance Insights.
    ///
    /// * db.sql.db_id - Either the SQL ID generated by the database engine, or a value generated by Performance Insights that begins with pi-.
    ///
    /// * db.sql.statement - The full text of the SQL statement that is running, for example, SELECT * FROM employees.
    ///
    /// * db.sql_tokenized.id - The hash of the SQL digest generated by Performance Insights.
    ///
    ///
    /// Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned.
    public struct DimensionGroup: Swift.Equatable {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested, or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database. Valid values are as follows:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.host.id - The host ID of the connected client (all engines).
        ///
        /// * db.host.name - The host name of the connected client (all engines).
        ///
        /// * db.name - The name of the database to which the client is connected. Valid values are as follows:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Aurora MySQL
        ///
        /// * Amazon RDS MySQL
        ///
        /// * Amazon RDS MariaDB
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.query.id - The query ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.db_id - The query ID generated by the database (only Amazon DocumentDB).
        ///
        /// * db.query.statement - The text of the query that is being run (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized_id
        ///
        /// * db.query.tokenized.id - The query digest ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized.db_id - The query digest ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized.statement - The text of the query digest (only Amazon DocumentDB).
        ///
        /// * db.session_type.name - The type of the current session (only Amazon DocumentDB).
        ///
        /// * db.sql.id - The hash of the full, non-tokenized SQL statement generated by Performance Insights (all engines except Amazon DocumentDB).
        ///
        /// * db.sql.db_id - Either the SQL ID generated by the database engine, or a value generated by Performance Insights that begins with pi- (all engines except Amazon DocumentDB).
        ///
        /// * db.sql.statement - The full text of the SQL statement that is running, as in SELECT * FROM employees (all engines except Amazon DocumentDB)
        ///
        /// * db.sql.tokenized_id
        ///
        /// * db.sql_tokenized.id - The hash of the SQL digest generated by Performance Insights (all engines except Amazon DocumentDB). In the console, db.sql_tokenized.id is called the Support ID because Amazon Web Services Support can look at this data to help you troubleshoot database issues.
        ///
        /// * db.sql_tokenized.db_id - Either the native database ID used to refer to the SQL statement, or a synthetic ID such as pi-2372568224 that Performance Insights generates if the native database ID isn't available (all engines except Amazon DocumentDB).
        ///
        /// * db.sql_tokenized.statement - The text of the SQL digest, as in SELECT * FROM employees WHERE employee_id = ? (all engines except Amazon DocumentDB)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_state.name - The event for which the backend is waiting (only Amazon DocumentDB).
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Valid values are as follows:
        ///
        /// * db - The name of the database to which the client is connected. The following values are permitted:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Aurora MySQL
        ///
        /// * Amazon RDS MySQL
        ///
        /// * Amazon RDS MariaDB
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.application - The name of the application that is connected to the database. The following values are permitted:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.host - The host name of the connected client (all engines).
        ///
        /// * db.query - The query that is currently running (only Amazon DocumentDB).
        ///
        /// * db.query_tokenized - The digest query (only Amazon DocumentDB).
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL).
        ///
        /// * db.sql - The text of the SQL statement that is currently running (all engines except Amazon DocumentDB).
        ///
        /// * db.sql_tokenized - The SQL digest (all engines except Amazon DocumentDB).
        ///
        /// * db.user - The user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_state - The event for which the database backend is waiting (only Amazon DocumentDB).
        /// This member is required.
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init(
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension PIClientTypes.DimensionGroupDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimensiondetail0 in dimensions {
                try dimensionsContainer.encode(dimensiondetail0)
            }
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[PIClientTypes.DimensionDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [PIClientTypes.DimensionDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PIClientTypes {
    /// Information about dimensions within a dimension group.
    public struct DimensionGroupDetail: Swift.Equatable {
        /// The dimensions within a dimension group.
        public var dimensions: [PIClientTypes.DimensionDetail]?
        /// The name of the dimension group.
        public var group: Swift.String?

        public init(
            dimensions: [PIClientTypes.DimensionDetail]? = nil,
            group: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
        }
    }

}

extension PIClientTypes.DimensionKeyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetrics = "AdditionalMetrics"
        case dimensions = "Dimensions"
        case partitions = "Partitions"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetrics = additionalMetrics {
            var additionalMetricsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalMetrics)
            for (dictKey0, additionalMetricsMap0) in additionalMetrics {
                try additionalMetricsContainer.encode(additionalMetricsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionMap0) in dimensions {
                try dimensionsContainer.encode(dimensionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitions = partitions {
            var partitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitions)
            for double0 in partitions {
                try partitionsContainer.encode(double0)
            }
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let additionalMetricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .additionalMetrics)
        var additionalMetricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let additionalMetricsContainer = additionalMetricsContainer {
            additionalMetricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, double0) in additionalMetricsContainer {
                if let double0 = double0 {
                    additionalMetricsDecoded0?[key0] = double0
                }
            }
        }
        additionalMetrics = additionalMetricsDecoded0
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.Double]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.Double]()
            for double0 in partitionsContainer {
                if let double0 = double0 {
                    partitionsDecoded0?.append(double0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension PIClientTypes {
    /// An object that includes the requested dimension key values and aggregated metric values within a dimension group.
    public struct DimensionKeyDescription: Swift.Equatable {
        /// A map that contains the value for each additional metric.
        public var additionalMetrics: [Swift.String:Swift.Double]?
        /// A map of name-value pairs for the dimensions in the group.
        public var dimensions: [Swift.String:Swift.String]?
        /// If PartitionBy was specified, PartitionKeys contains the dimensions that were.
        public var partitions: [Swift.Double]?
        /// The aggregated metric value for the dimensions, over the requested time range.
        public var total: Swift.Double?

        public init(
            additionalMetrics: [Swift.String:Swift.Double]? = nil,
            dimensions: [Swift.String:Swift.String]? = nil,
            partitions: [Swift.Double]? = nil,
            total: Swift.Double? = nil
        )
        {
            self.additionalMetrics = additionalMetrics
            self.dimensions = dimensions
            self.partitions = partitions
            self.total = total
        }
    }

}

extension PIClientTypes.DimensionKeyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension = "Dimension"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PIClientTypes.DetailStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PIClientTypes {
    /// An object that describes the details for a specified dimension.
    public struct DimensionKeyDetail: Swift.Equatable {
        /// The full name of the dimension. The full name includes the group name and key name. The following values are valid:
        ///
        /// * db.query.statement (Amazon DocumentDB)
        ///
        /// * db.sql.statement (Amazon RDS and Aurora)
        public var dimension: Swift.String?
        /// The status of the dimension detail data. Possible values include the following:
        ///
        /// * AVAILABLE - The dimension detail data is ready to be retrieved.
        ///
        /// * PROCESSING - The dimension detail data isn't ready to be retrieved because more processing time is required. If the requested detail data has the status PROCESSING, Performance Insights returns the truncated query.
        ///
        /// * UNAVAILABLE - The dimension detail data could not be collected successfully.
        public var status: PIClientTypes.DetailStatus?
        /// The value of the dimension detail data. Depending on the return status, this value is either the full or truncated SQL query for the following dimensions:
        ///
        /// * db.query.statement (Amazon DocumentDB)
        ///
        /// * db.sql.statement (Amazon RDS and Aurora)
        public var value: Swift.String?

        public init(
            dimension: Swift.String? = nil,
            status: PIClientTypes.DetailStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimension = dimension
            self.status = status
            self.value = value
        }
    }

}

extension PIClientTypes.FeatureMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(PIClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PIClientTypes {
    /// The metadata for a feature. For example, the metadata might indicate that a feature is turned on or off on a specific DB instance.
    public struct FeatureMetadata: Swift.Equatable {
        /// The status of the feature on the DB instance. Possible values include the following:
        ///
        /// * ENABLED - The feature is enabled on the instance.
        ///
        /// * DISABLED - The feature is disabled on the instance.
        ///
        /// * UNSUPPORTED - The feature isn't supported on the instance.
        ///
        /// * ENABLED_PENDING_REBOOT - The feature is enabled on the instance but requires a reboot to take effect.
        ///
        /// * DISABLED_PENDING_REBOOT - The feature is disabled on the instance but requires a reboot to take effect.
        ///
        /// * UNKNOWN - The feature status couldn't be determined.
        public var status: PIClientTypes.FeatureStatus?

        public init(
            status: PIClientTypes.FeatureStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension PIClientTypes {
    public enum FeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabledPendingReboot
        case enabled
        case enabledPendingReboot
        case unknown
        case unsupported
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .disabled,
                .disabledPendingReboot,
                .enabled,
                .enabledPendingReboot,
                .unknown,
                .unsupported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabledPendingReboot: return "DISABLED_PENDING_REBOOT"
            case .enabled: return "ENABLED"
            case .enabledPendingReboot: return "ENABLED_PENDING_REBOOT"
            case .unknown: return "UNKNOWN"
            case .unsupported: return "UNSUPPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureStatus(rawValue: rawValue) ?? FeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetDimensionKeyDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupIdentifier = self.groupIdentifier {
            try encodeContainer.encode(groupIdentifier, forKey: .groupIdentifier)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let requestedDimensions = requestedDimensions {
            var requestedDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDimensions)
            for requeststring0 in requestedDimensions {
                try requestedDimensionsContainer.encode(requeststring0)
            }
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension GetDimensionKeyDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDimensionKeyDetailsInput: Swift.Equatable {
    /// The name of the dimension group. Performance Insights searches the specified group for the dimension group ID. The following group name values are valid:
    ///
    /// * db.query (Amazon DocumentDB only)
    ///
    /// * db.sql (Amazon RDS and Aurora only)
    /// This member is required.
    public var group: Swift.String?
    /// The ID of the dimension group from which to retrieve dimension details. For dimension group db.sql, the group ID is db.sql.id. The following group ID values are valid:
    ///
    /// * db.sql.id for dimension group db.sql (Aurora and RDS only)
    ///
    /// * db.query.id for dimension group db.query (DocumentDB only)
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The ID for a data source from which to gather dimension data. This ID must be immutable and unique within an Amazon Web Services Region. When a DB instance is the data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// A list of dimensions to retrieve the detail data for within the given dimension group. If you don't specify this parameter, Performance Insights returns all dimension data within the specified dimension group. Specify dimension names for the following dimension groups:
    ///
    /// * db.sql - Specify either the full dimension name db.sql.statement or the short dimension name statement (Aurora and RDS only).
    ///
    /// * db.query - Specify either the full dimension name db.query.statement or the short dimension name statement (DocumentDB only).
    public var requestedDimensions: [Swift.String]?
    /// The Amazon Web Services service for which Performance Insights returns data. The only valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        group: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestedDimensions: [Swift.String]? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.group = group
        self.groupIdentifier = groupIdentifier
        self.identifier = identifier
        self.requestedDimensions = requestedDimensions
        self.serviceType = serviceType
    }
}

struct GetDimensionKeyDetailsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let group: Swift.String?
    let groupIdentifier: Swift.String?
    let requestedDimensions: [Swift.String]?
}

extension GetDimensionKeyDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let groupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupIdentifier)
        groupIdentifier = groupIdentifierDecoded
        let requestedDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requestedDimensions)
        var requestedDimensionsDecoded0:[Swift.String]? = nil
        if let requestedDimensionsContainer = requestedDimensionsContainer {
            requestedDimensionsDecoded0 = [Swift.String]()
            for string0 in requestedDimensionsContainer {
                if let string0 = string0 {
                    requestedDimensionsDecoded0?.append(string0)
                }
            }
        }
        requestedDimensions = requestedDimensionsDecoded0
    }
}

extension GetDimensionKeyDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDimensionKeyDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dimensions = output.dimensions
        } else {
            self.dimensions = nil
        }
    }
}

public struct GetDimensionKeyDetailsOutput: Swift.Equatable {
    /// The details for the requested dimensions.
    public var dimensions: [PIClientTypes.DimensionKeyDetail]?

    public init(
        dimensions: [PIClientTypes.DimensionKeyDetail]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

struct GetDimensionKeyDetailsOutputBody: Swift.Equatable {
    let dimensions: [PIClientTypes.DimensionKeyDetail]?
}

extension GetDimensionKeyDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionKeyDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[PIClientTypes.DimensionKeyDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [PIClientTypes.DimensionKeyDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

enum GetDimensionKeyDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPerformanceAnalysisReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case analysisReportId = "AnalysisReportId"
        case identifier = "Identifier"
        case serviceType = "ServiceType"
        case textFormat = "TextFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage.rawValue, forKey: .acceptLanguage)
        }
        if let analysisReportId = self.analysisReportId {
            try encodeContainer.encode(analysisReportId, forKey: .analysisReportId)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let textFormat = self.textFormat {
            try encodeContainer.encode(textFormat.rawValue, forKey: .textFormat)
        }
    }
}

extension GetPerformanceAnalysisReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPerformanceAnalysisReportInput: Swift.Equatable {
    /// The text language in the report. The default language is EN_US (English).
    public var acceptLanguage: PIClientTypes.AcceptLanguage?
    /// A unique identifier of the created analysis report. For example, report-12345678901234567
    /// This member is required.
    public var analysisReportId: Swift.String?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// Indicates the text format in the report. The options are PLAIN_TEXT or MARKDOWN. The default value is plain text.
    public var textFormat: PIClientTypes.TextFormat?

    public init(
        acceptLanguage: PIClientTypes.AcceptLanguage? = nil,
        analysisReportId: Swift.String? = nil,
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        textFormat: PIClientTypes.TextFormat? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.analysisReportId = analysisReportId
        self.identifier = identifier
        self.serviceType = serviceType
        self.textFormat = textFormat
    }
}

struct GetPerformanceAnalysisReportInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let analysisReportId: Swift.String?
    let textFormat: PIClientTypes.TextFormat?
    let acceptLanguage: PIClientTypes.AcceptLanguage?
}

extension GetPerformanceAnalysisReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case analysisReportId = "AnalysisReportId"
        case identifier = "Identifier"
        case serviceType = "ServiceType"
        case textFormat = "TextFormat"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let analysisReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisReportId)
        analysisReportId = analysisReportIdDecoded
        let textFormatDecoded = try containerValues.decodeIfPresent(PIClientTypes.TextFormat.self, forKey: .textFormat)
        textFormat = textFormatDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(PIClientTypes.AcceptLanguage.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension GetPerformanceAnalysisReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPerformanceAnalysisReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisReport = output.analysisReport
        } else {
            self.analysisReport = nil
        }
    }
}

public struct GetPerformanceAnalysisReportOutput: Swift.Equatable {
    /// The summary of the performance analysis report created for a time period.
    public var analysisReport: PIClientTypes.AnalysisReport?

    public init(
        analysisReport: PIClientTypes.AnalysisReport? = nil
    )
    {
        self.analysisReport = analysisReport
    }
}

struct GetPerformanceAnalysisReportOutputBody: Swift.Equatable {
    let analysisReport: PIClientTypes.AnalysisReport?
}

extension GetPerformanceAnalysisReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReport = "AnalysisReport"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisReportDecoded = try containerValues.decodeIfPresent(PIClientTypes.AnalysisReport.self, forKey: .analysisReport)
        analysisReport = analysisReportDecoded
    }
}

enum GetPerformanceAnalysisReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension GetResourceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceMetadataInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.serviceType = serviceType
    }
}

struct GetResourceMetadataInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
}

extension GetResourceMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetResourceMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.features = output.features
            self.identifier = output.identifier
        } else {
            self.features = nil
            self.identifier = nil
        }
    }
}

public struct GetResourceMetadataOutput: Swift.Equatable {
    /// The metadata for different features. For example, the metadata might indicate that a feature is turned on or off on a specific DB instance.
    public var features: [Swift.String:PIClientTypes.FeatureMetadata]?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    public var identifier: Swift.String?

    public init(
        features: [Swift.String:PIClientTypes.FeatureMetadata]? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.features = features
        self.identifier = identifier
    }
}

struct GetResourceMetadataOutputBody: Swift.Equatable {
    let identifier: Swift.String?
    let features: [Swift.String:PIClientTypes.FeatureMetadata]?
}

extension GetResourceMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case features = "Features"
        case identifier = "Identifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String: PIClientTypes.FeatureMetadata?].self, forKey: .features)
        var featuresDecoded0: [Swift.String:PIClientTypes.FeatureMetadata]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String:PIClientTypes.FeatureMetadata]()
            for (key0, featuremetadata0) in featuresContainer {
                if let featuremetadata0 = featuremetadata0 {
                    featuresDecoded0?[key0] = featuremetadata0
                }
            }
        }
        features = featuresDecoded0
    }
}

enum GetResourceMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodAlignment = "PeriodAlignment"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricQueries = metricQueries {
            var metricQueriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricQueries)
            for metricquery0 in metricQueries {
                try metricQueriesContainer.encode(metricquery0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let periodAlignment = self.periodAlignment {
            try encodeContainer.encode(periodAlignment.rawValue, forKey: .periodAlignment)
        }
        if let periodInSeconds = self.periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetResourceMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceMetricsInput: Swift.Equatable {
    /// The date and time specifying the end of the requested time series query range. The value specified is exclusive. Thus, the command returns data points less than (but not equal to) EndTime. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An array of one or more queries to perform. Each query must specify a Performance Insights metric, and can optionally specify aggregation and filtering criteria.
    /// This member is required.
    public var metricQueries: [PIClientTypes.MetricQuery]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The returned timestamp which is the start or end time of the time periods. The default value is END_TIME.
    public var periodAlignment: PIClientTypes.PeriodAlignment?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights will choose a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid values are as follows:
    ///
    /// * RDS
    ///
    /// * DOCDB
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series query range. You can't specify a StartTime that is earlier than 7 days ago. By default, Performance Insights has 7 days of retention, but you can extend this range up to 2 years. The value specified is inclusive. Thus, the command returns data points equal to or greater than StartTime. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricQueries: [PIClientTypes.MetricQuery]? = nil,
        nextToken: Swift.String? = nil,
        periodAlignment: PIClientTypes.PeriodAlignment? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricQueries = metricQueries
        self.nextToken = nextToken
        self.periodAlignment = periodAlignment
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct GetResourceMetricsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let metricQueries: [PIClientTypes.MetricQuery]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let periodInSeconds: Swift.Int?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let periodAlignment: PIClientTypes.PeriodAlignment?
}

extension GetResourceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodAlignment = "PeriodAlignment"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricQueriesContainer = try containerValues.decodeIfPresent([PIClientTypes.MetricQuery?].self, forKey: .metricQueries)
        var metricQueriesDecoded0:[PIClientTypes.MetricQuery]? = nil
        if let metricQueriesContainer = metricQueriesContainer {
            metricQueriesDecoded0 = [PIClientTypes.MetricQuery]()
            for structure0 in metricQueriesContainer {
                if let structure0 = structure0 {
                    metricQueriesDecoded0?.append(structure0)
                }
            }
        }
        metricQueries = metricQueriesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let periodAlignmentDecoded = try containerValues.decodeIfPresent(PIClientTypes.PeriodAlignment.self, forKey: .periodAlignment)
        periodAlignment = periodAlignmentDecoded
    }
}

extension GetResourceMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.identifier = output.identifier
            self.metricList = output.metricList
            self.nextToken = output.nextToken
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.identifier = nil
            self.metricList = nil
            self.nextToken = nil
        }
    }
}

public struct GetResourceMetricsOutput: Swift.Equatable {
    /// The end time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: ClientRuntime.Date?
    /// The start time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: ClientRuntime.Date?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId.
    public var identifier: Swift.String?
    /// An array of metric results, where each array element contains all of the data points for a particular dimension.
    public var metricList: [PIClientTypes.MetricKeyDataPoints]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init(
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        metricList: [PIClientTypes.MetricKeyDataPoints]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.identifier = identifier
        self.metricList = metricList
        self.nextToken = nextToken
    }
}

struct GetResourceMetricsOutputBody: Swift.Equatable {
    let alignedStartTime: ClientRuntime.Date?
    let alignedEndTime: ClientRuntime.Date?
    let identifier: Swift.String?
    let metricList: [PIClientTypes.MetricKeyDataPoints]?
    let nextToken: Swift.String?
}

extension GetResourceMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case identifier = "Identifier"
        case metricList = "MetricList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricListContainer = try containerValues.decodeIfPresent([PIClientTypes.MetricKeyDataPoints?].self, forKey: .metricList)
        var metricListDecoded0:[PIClientTypes.MetricKeyDataPoints]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [PIClientTypes.MetricKeyDataPoints]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetResourceMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PIClientTypes.Insight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baselineData = "BaselineData"
        case context = "Context"
        case description = "Description"
        case endTime = "EndTime"
        case insightData = "InsightData"
        case insightId = "InsightId"
        case insightType = "InsightType"
        case recommendations = "Recommendations"
        case severity = "Severity"
        case startTime = "StartTime"
        case supportingInsights = "SupportingInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineData = baselineData {
            var baselineDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baselineData)
            for data0 in baselineData {
                try baselineDataContainer.encode(data0)
            }
        }
        if let context = self.context {
            try encodeContainer.encode(context.rawValue, forKey: .context)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let insightData = insightData {
            var insightDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightData)
            for data0 in insightData {
                try insightDataContainer.encode(data0)
            }
        }
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let insightType = self.insightType {
            try encodeContainer.encode(insightType, forKey: .insightType)
        }
        if let recommendations = recommendations {
            var recommendationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendations)
            for recommendation0 in recommendations {
                try recommendationsContainer.encode(recommendation0)
            }
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let supportingInsights = supportingInsights {
            var supportingInsightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportingInsights)
            for insight0 in supportingInsights {
                try supportingInsightsContainer.encode(insight0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let insightTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightType)
        insightType = insightTypeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(PIClientTypes.ContextType.self, forKey: .context)
        context = contextDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let severityDecoded = try containerValues.decodeIfPresent(PIClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let supportingInsightsContainer = try containerValues.decodeIfPresent([PIClientTypes.Insight?].self, forKey: .supportingInsights)
        var supportingInsightsDecoded0:[PIClientTypes.Insight]? = nil
        if let supportingInsightsContainer = supportingInsightsContainer {
            supportingInsightsDecoded0 = [PIClientTypes.Insight]()
            for structure0 in supportingInsightsContainer {
                if let structure0 = structure0 {
                    supportingInsightsDecoded0?.append(structure0)
                }
            }
        }
        supportingInsights = supportingInsightsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([PIClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[PIClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [PIClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let insightDataContainer = try containerValues.decodeIfPresent([PIClientTypes.Data?].self, forKey: .insightData)
        var insightDataDecoded0:[PIClientTypes.Data]? = nil
        if let insightDataContainer = insightDataContainer {
            insightDataDecoded0 = [PIClientTypes.Data]()
            for structure0 in insightDataContainer {
                if let structure0 = structure0 {
                    insightDataDecoded0?.append(structure0)
                }
            }
        }
        insightData = insightDataDecoded0
        let baselineDataContainer = try containerValues.decodeIfPresent([PIClientTypes.Data?].self, forKey: .baselineData)
        var baselineDataDecoded0:[PIClientTypes.Data]? = nil
        if let baselineDataContainer = baselineDataContainer {
            baselineDataDecoded0 = [PIClientTypes.Data]()
            for structure0 in baselineDataContainer {
                if let structure0 = structure0 {
                    baselineDataDecoded0?.append(structure0)
                }
            }
        }
        baselineData = baselineDataDecoded0
    }
}

extension PIClientTypes.Insight: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Insight(baselineData: \(Swift.String(describing: baselineData)), context: \(Swift.String(describing: context)), endTime: \(Swift.String(describing: endTime)), insightData: \(Swift.String(describing: insightData)), insightId: \(Swift.String(describing: insightId)), insightType: \(Swift.String(describing: insightType)), recommendations: \(Swift.String(describing: recommendations)), severity: \(Swift.String(describing: severity)), startTime: \(Swift.String(describing: startTime)), supportingInsights: \(Swift.String(describing: supportingInsights)), description: \"CONTENT_REDACTED\")"}
}

extension PIClientTypes {
    /// Retrieves the list of performance issues which are identified.
    public struct Insight: Swift.Equatable {
        /// Metric names and values from the timeframe used as baseline to generate the insight.
        public var baselineData: [PIClientTypes.Data]?
        /// Indicates if the insight is causal or correlated insight.
        public var context: PIClientTypes.ContextType?
        /// Description of the insight. For example: A high severity Insight found between 02:00 to 02:30, where there was an unusually high DB load 600x above baseline. Likely performance impact.
        public var description: Swift.String?
        /// The end time of the insight. For example, 2018-10-30T00:00:00Z.
        public var endTime: ClientRuntime.Date?
        /// List of data objects containing metrics and references from the time range while generating the insight.
        public var insightData: [PIClientTypes.Data]?
        /// The unique identifier for the insight. For example, insight-12345678901234567.
        /// This member is required.
        public var insightId: Swift.String?
        /// The type of insight. For example, HighDBLoad, HighCPU, or DominatingSQLs.
        public var insightType: Swift.String?
        /// List of recommendations for the insight. For example, Investigate the following SQLs that contributed to 100% of the total DBLoad during that time period: sql-id.
        public var recommendations: [PIClientTypes.Recommendation]?
        /// The severity of the insight. The values are: Low, Medium, or High.
        public var severity: PIClientTypes.Severity?
        /// The start time of the insight. For example, 2018-10-30T00:00:00Z.
        public var startTime: ClientRuntime.Date?
        /// List of supporting insights that provide additional factors for the insight.
        public var supportingInsights: [PIClientTypes.Insight]?

        public init(
            baselineData: [PIClientTypes.Data]? = nil,
            context: PIClientTypes.ContextType? = nil,
            description: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            insightData: [PIClientTypes.Data]? = nil,
            insightId: Swift.String? = nil,
            insightType: Swift.String? = nil,
            recommendations: [PIClientTypes.Recommendation]? = nil,
            severity: PIClientTypes.Severity? = nil,
            startTime: ClientRuntime.Date? = nil,
            supportingInsights: [PIClientTypes.Insight]? = nil
        )
        {
            self.baselineData = baselineData
            self.context = context
            self.description = description
            self.endTime = endTime
            self.insightData = insightData
            self.insightId = insightId
            self.insightType = insightType
            self.recommendations = recommendations
            self.severity = severity
            self.startTime = startTime
            self.supportingInsights = supportingInsights
        }
    }

}

extension InternalServiceError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed due to an unknown error.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the arguments provided is invalid for this request.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAvailableResourceDimensionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for requeststring0 in metrics {
                try metricsContainer.encode(requeststring0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension ListAvailableResourceDimensionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableResourceDimensionsInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique within an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use an Amazon RDS DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VWZ.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The types of metrics for which to retrieve dimensions. Valid values include db.load.
    /// This member is required.
    public var metrics: [Swift.String]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct ListAvailableResourceDimensionsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let metrics: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailableResourceDimensionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableResourceDimensionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableResourceDimensionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricDimensions = output.metricDimensions
            self.nextToken = output.nextToken
        } else {
            self.metricDimensions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableResourceDimensionsOutput: Swift.Equatable {
    /// The dimension information returned for requested metric types.
    public var metricDimensions: [PIClientTypes.MetricDimensionGroups]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init(
        metricDimensions: [PIClientTypes.MetricDimensionGroups]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricDimensions = metricDimensions
        self.nextToken = nextToken
    }
}

struct ListAvailableResourceDimensionsOutputBody: Swift.Equatable {
    let metricDimensions: [PIClientTypes.MetricDimensionGroups]?
    let nextToken: Swift.String?
}

extension ListAvailableResourceDimensionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDimensions = "MetricDimensions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDimensionsContainer = try containerValues.decodeIfPresent([PIClientTypes.MetricDimensionGroups?].self, forKey: .metricDimensions)
        var metricDimensionsDecoded0:[PIClientTypes.MetricDimensionGroups]? = nil
        if let metricDimensionsContainer = metricDimensionsContainer {
            metricDimensionsDecoded0 = [PIClientTypes.MetricDimensionGroups]()
            for structure0 in metricDimensionsContainer {
                if let structure0 = structure0 {
                    metricDimensionsDecoded0?.append(structure0)
                }
            }
        }
        metricDimensions = metricDimensionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAvailableResourceDimensionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAvailableResourceMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricTypes = "MetricTypes"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricTypes = metricTypes {
            var metricTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricTypes)
            for requeststring0 in metricTypes {
                try metricTypesContainer.encode(requeststring0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension ListAvailableResourceMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableResourceMetricsInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique within an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use an Amazon RDS DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VWZ.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return. If the MaxRecords value is less than the number of existing items, the response includes a pagination token.
    public var maxResults: Swift.Int?
    /// The types of metrics to return in the response. Valid values in the array include the following:
    ///
    /// * os (OS counter metrics) - All engines
    ///
    /// * db (DB load metrics) - All engines except for Amazon DocumentDB
    ///
    /// * db.sql.stats (per-SQL metrics) - All engines except for Amazon DocumentDB
    ///
    /// * db.sql_tokenized.stats (per-SQL digest metrics) - All engines except for Amazon DocumentDB
    /// This member is required.
    public var metricTypes: [Swift.String]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricTypes: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricTypes = metricTypes
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct ListAvailableResourceMetricsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let metricTypes: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAvailableResourceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricTypes = "MetricTypes"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricTypes)
        var metricTypesDecoded0:[Swift.String]? = nil
        if let metricTypesContainer = metricTypesContainer {
            metricTypesDecoded0 = [Swift.String]()
            for string0 in metricTypesContainer {
                if let string0 = string0 {
                    metricTypesDecoded0?.append(string0)
                }
            }
        }
        metricTypes = metricTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAvailableResourceMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableResourceMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.nextToken = output.nextToken
        } else {
            self.metrics = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableResourceMetricsOutput: Swift.Equatable {
    /// An array of metrics available to query. Each array element contains the full name, description, and unit of the metric.
    public var metrics: [PIClientTypes.ResponseResourceMetric]?
    /// A pagination token that indicates the response didn’t return all available records because MaxRecords was specified in the previous request. To get the remaining records, specify NextToken in a separate request with this value.
    public var nextToken: Swift.String?

    public init(
        metrics: [PIClientTypes.ResponseResourceMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

struct ListAvailableResourceMetricsOutputBody: Swift.Equatable {
    let metrics: [PIClientTypes.ResponseResourceMetric]?
    let nextToken: Swift.String?
}

extension ListAvailableResourceMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics = "Metrics"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsContainer = try containerValues.decodeIfPresent([PIClientTypes.ResponseResourceMetric?].self, forKey: .metrics)
        var metricsDecoded0:[PIClientTypes.ResponseResourceMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [PIClientTypes.ResponseResourceMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAvailableResourceMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPerformanceAnalysisReportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case listTags = "ListTags"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let listTags = self.listTags {
            try encodeContainer.encode(listTags, forKey: .listTags)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension ListPerformanceAnalysisReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPerformanceAnalysisReportsInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies whether or not to include the list of tags in the response.
    public var listTags: Swift.Bool?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxResults value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        listTags: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.listTags = listTags
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct ListPerformanceAnalysisReportsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let listTags: Swift.Bool?
}

extension ListPerformanceAnalysisReportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case listTags = "ListTags"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let listTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .listTags)
        listTags = listTagsDecoded
    }
}

extension ListPerformanceAnalysisReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPerformanceAnalysisReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisReports = output.analysisReports
            self.nextToken = output.nextToken
        } else {
            self.analysisReports = nil
            self.nextToken = nil
        }
    }
}

public struct ListPerformanceAnalysisReportsOutput: Swift.Equatable {
    /// List of reports including the report identifier, start and end time, creation time, and status.
    public var analysisReports: [PIClientTypes.AnalysisReportSummary]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        analysisReports: [PIClientTypes.AnalysisReportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisReports = analysisReports
        self.nextToken = nextToken
    }
}

struct ListPerformanceAnalysisReportsOutputBody: Swift.Equatable {
    let analysisReports: [PIClientTypes.AnalysisReportSummary]?
    let nextToken: Swift.String?
}

extension ListPerformanceAnalysisReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisReports = "AnalysisReports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisReportsContainer = try containerValues.decodeIfPresent([PIClientTypes.AnalysisReportSummary?].self, forKey: .analysisReports)
        var analysisReportsDecoded0:[PIClientTypes.AnalysisReportSummary]? = nil
        if let analysisReportsContainer = analysisReportsContainer {
            analysisReportsDecoded0 = [PIClientTypes.AnalysisReportSummary]()
            for structure0 in analysisReportsContainer {
                if let structure0 = structure0 {
                    analysisReportsDecoded0?.append(structure0)
                }
            }
        }
        analysisReports = analysisReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPerformanceAnalysisReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Lists all the tags for the Amazon RDS Performance Insights resource. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List the tags for the Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        resourceARN: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.resourceARN = resourceARN
        self.serviceType = serviceType
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case serviceType = "ServiceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    public var tags: [PIClientTypes.Tag]?

    public init(
        tags: [PIClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [PIClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([PIClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PIClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PIClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PIClientTypes.MetricDimensionGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for dimensiongroupdetail0 in groups {
                try groupsContainer.encode(dimensiongroupdetail0)
            }
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupsContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionGroupDetail?].self, forKey: .groups)
        var groupsDecoded0:[PIClientTypes.DimensionGroupDetail]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [PIClientTypes.DimensionGroupDetail]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension PIClientTypes {
    /// The available dimension information for a metric type.
    public struct MetricDimensionGroups: Swift.Equatable {
        /// The available dimension groups for a metric type.
        public var groups: [PIClientTypes.DimensionGroupDetail]?
        /// The metric type to which the dimension information belongs.
        public var metric: Swift.String?

        public init(
            groups: [PIClientTypes.DimensionGroupDetail]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.groups = groups
            self.metric = metric
        }
    }

}

extension PIClientTypes.MetricKeyDataPoints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPoints = "DataPoints"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPoints = dataPoints {
            var dataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPoints)
            for datapoint0 in dataPoints {
                try dataPointsContainer.encode(datapoint0)
            }
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(PIClientTypes.ResponseResourceMetricKey.self, forKey: .key)
        key = keyDecoded
        let dataPointsContainer = try containerValues.decodeIfPresent([PIClientTypes.DataPoint?].self, forKey: .dataPoints)
        var dataPointsDecoded0:[PIClientTypes.DataPoint]? = nil
        if let dataPointsContainer = dataPointsContainer {
            dataPointsDecoded0 = [PIClientTypes.DataPoint]()
            for structure0 in dataPointsContainer {
                if let structure0 = structure0 {
                    dataPointsDecoded0?.append(structure0)
                }
            }
        }
        dataPoints = dataPointsDecoded0
    }
}

extension PIClientTypes {
    /// A time-ordered series of data points, corresponding to a dimension of a Performance Insights metric.
    public struct MetricKeyDataPoints: Swift.Equatable {
        /// An array of timestamp-value pairs, representing measurements over a period of time.
        public var dataPoints: [PIClientTypes.DataPoint]?
        /// The dimensions to which the data points apply.
        public var key: PIClientTypes.ResponseResourceMetricKey?

        public init(
            dataPoints: [PIClientTypes.DataPoint]? = nil,
            key: PIClientTypes.ResponseResourceMetricKey? = nil
        )
        {
            self.dataPoints = dataPoints
            self.key = key
        }
    }

}

extension PIClientTypes.MetricQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricQueryFilterMap0) in filter {
                try filterContainer.encode(metricQueryFilterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PIClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension PIClientTypes {
    /// A single query to be processed. You must provide the metric to query. If no other parameters are specified, Performance Insights returns all data points for the specified metric. Optionally, you can request that the data points be aggregated by dimension group (GroupBy), and return only those data points that match your criteria (Filter).
    public struct MetricQuery: Swift.Equatable {
        /// One or more filters to apply in the request. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        public var filter: [Swift.String:Swift.String]?
        /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights will return all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: PIClientTypes.DimensionGroup?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - The raw number of active sessions for the database engine.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon Aurora User Guide.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init(
            filter: [Swift.String:Swift.String]? = nil,
            groupBy: PIClientTypes.DimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension NotAuthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user is not authorized to perform this request.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PIClientTypes.PerformanceInsightsMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case displayName = "DisplayName"
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, descriptiveMap0) in dimensions {
                try dimensionsContainer.encode(descriptiveMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, descriptivestring0) in dimensionsContainer {
                if let descriptivestring0 = descriptivestring0 {
                    dimensionsDecoded0?[key0] = descriptivestring0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension PIClientTypes {
    /// This data type helps to determine Performance Insights metric to render for the insight.
    public struct PerformanceInsightsMetric: Swift.Equatable {
        /// A dimension map that contains the dimensions for this partition.
        public var dimensions: [Swift.String:Swift.String]?
        /// The Performance Insights metric name.
        public var displayName: Swift.String?
        /// The Performance Insights metric.
        public var metric: Swift.String?
        /// The value of the metric. For example, 9 for db.load.avg.
        public var value: Swift.Double?

        public init(
            dimensions: [Swift.String:Swift.String]? = nil,
            displayName: Swift.String? = nil,
            metric: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.dimensions = dimensions
            self.displayName = displayName
            self.metric = metric
            self.value = value
        }
    }

}

extension PIClientTypes {
    public enum PeriodAlignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case endTime
        case startTime
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodAlignment] {
            return [
                .endTime,
                .startTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .endTime: return "END_TIME"
            case .startTime: return "START_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PeriodAlignment(rawValue: rawValue) ?? PeriodAlignment.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationDescription = "RecommendationDescription"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationDescription = self.recommendationDescription {
            try encodeContainer.encode(recommendationDescription, forKey: .recommendationDescription)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let recommendationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationDescription)
        recommendationDescription = recommendationDescriptionDecoded
    }
}

extension PIClientTypes.Recommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recommendation(recommendationId: \(Swift.String(describing: recommendationId)), recommendationDescription: \"CONTENT_REDACTED\")"}
}

extension PIClientTypes {
    /// The list of recommendations for the insight.
    public struct Recommendation: Swift.Equatable {
        /// The recommendation details to help resolve the performance issue. For example, Investigate the following SQLs that contributed to 100% of the total DBLoad during that time period: sql-id
        public var recommendationDescription: Swift.String?
        /// The unique identifier for the recommendation.
        public var recommendationId: Swift.String?

        public init(
            recommendationDescription: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.recommendationDescription = recommendationDescription
            self.recommendationId = recommendationId
        }
    }

}

extension PIClientTypes.ResponsePartitionKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionMap0) in dimensions {
                try dimensionsContainer.encode(dimensionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PIClientTypes {
    /// If PartitionBy was specified in a DescribeDimensionKeys request, the dimensions are returned in an array. Each element in the array specifies one dimension.
    public struct ResponsePartitionKey: Swift.Equatable {
        /// A dimension map that contains the dimensions for this partition.
        /// This member is required.
        public var dimensions: [Swift.String:Swift.String]?

        public init(
            dimensions: [Swift.String:Swift.String]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

extension PIClientTypes.ResponseResourceMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case metric = "Metric"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension PIClientTypes {
    /// An object that contains the full name, description, and unit of a metric.
    public struct ResponseResourceMetric: Swift.Equatable {
        /// The description of the metric.
        public var description: Swift.String?
        /// The full name of the metric.
        public var metric: Swift.String?
        /// The unit of the metric.
        public var unit: Swift.String?

        public init(
            description: Swift.String? = nil,
            metric: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.description = description
            self.metric = metric
            self.unit = unit
        }
    }

}

extension PIClientTypes.ResponseResourceMetricKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionMap0) in dimensions {
                try dimensionsContainer.encode(dimensionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PIClientTypes {
    /// An object describing a Performance Insights metric and one or more dimensions for that metric.
    public struct ResponseResourceMetricKey: Swift.Equatable {
        /// The valid dimensions for the metric.
        public var dimensions: [Swift.String:Swift.String]?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - The raw number of active sessions for the database engine.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon Aurora User Guide.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init(
            dimensions: [Swift.String:Swift.String]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metric = metric
        }
    }

}

extension PIClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case docdb
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .docdb,
                .rds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .docdb: return "DOCDB"
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PIClientTypes {
    /// Metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        /// This member is required.
        public var key: Swift.String?
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case serviceType = "ServiceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon RDS Performance Insights resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    /// This member is required.
    public var tags: [PIClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        tags: [PIClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.serviceType = serviceType
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let resourceARN: Swift.String?
    let tags: [PIClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case serviceType = "ServiceType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PIClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PIClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PIClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PIClientTypes {
    public enum TextFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case markdown
        case plainText
        case sdkUnknown(Swift.String)

        public static var allCases: [TextFormat] {
            return [
                .markdown,
                .plainText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .markdown: return "MARKDOWN"
            case .plainText: return "PLAIN_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextFormat(rawValue: rawValue) ?? TextFormat.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case serviceType = "ServiceType"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon RDS Performance Insights resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List the tags for the Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The metadata assigned to an Amazon RDS Performance Insights resource consisting of a key-value pair.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.serviceType = serviceType
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case serviceType = "ServiceType"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
