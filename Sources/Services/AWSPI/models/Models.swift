// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PIClientTypes.DataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension PIClientTypes {
    /// A timestamp, and a single numerical value, which together represent a measurement at a particular point in time.
    public struct DataPoint: Swift.Equatable {
        /// The time, in epoch format, associated with a particular Value.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The actual value associated with a particular Timestamp.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Double? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension DescribeDimensionKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetrics = "AdditionalMetrics"
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetrics = additionalMetrics {
            var additionalMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetrics)
            for requeststring0 in additionalMetrics {
                try additionalMetricsContainer.encode(requeststring0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricQueryFilterMap0) in filter {
                try filterContainer.encode(metricQueryFilterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let partitionBy = self.partitionBy {
            try encodeContainer.encode(partitionBy, forKey: .partitionBy)
        }
        if let periodInSeconds = self.periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension DescribeDimensionKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDimensionKeysInput: Swift.Equatable {
    /// Additional metrics for the top N dimension keys. If the specified dimension group in the GroupBy parameter is db.sql_tokenized, you can specify per-SQL metrics to get the values for the top N SQL digests. The response syntax is as follows: "AdditionalMetrics" : { "string" : "string" }.
    public var additionalMetrics: [Swift.String]?
    /// The date and time specifying the end of the requested time series data. The value specified is exclusive, which means that data points less than (but not equal to) EndTime are returned. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// One or more filters to apply in the request. Restrictions:
    ///
    /// * Any number of filters by the same dimension, as specified in the GroupBy or Partition parameters.
    ///
    /// * A single filter for any other dimension in this dimension group.
    public var filter: [Swift.String:Swift.String]?
    /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights returns all dimensions within this group, unless you provide the names of specific dimensions within this group. You can also request that Performance Insights return a limited number of values for a dimension.
    /// This member is required.
    public var groupBy: PIClientTypes.DimensionGroup?
    /// An immutable, Amazon Web Services Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use an Amazon RDS instance as a data source, you specify its DbiResourceId value. For example, specify db-FAIHNTYBKTGAUSUZQYPDS2GW4A.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
    ///
    /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
    ///
    /// * db.sampledload.avg - The raw number of active sessions for the database engine.
    ///
    ///
    /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
    /// This member is required.
    public var metric: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// For each dimension specified in GroupBy, specify a secondary dimension to further subdivide the partition keys in the response.
    public var partitionBy: PIClientTypes.DimensionGroup?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights chooses a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid values are as follows:
    ///
    /// * RDS
    ///
    /// * DOCDB
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series data. You must specify a StartTime within the past 7 days. The value specified is inclusive, which means that data points equal to or greater than StartTime are returned. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init (
        additionalMetrics: [Swift.String]? = nil,
        endTime: ClientRuntime.Date? = nil,
        filter: [Swift.String:Swift.String]? = nil,
        groupBy: PIClientTypes.DimensionGroup? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metric: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        partitionBy: PIClientTypes.DimensionGroup? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.additionalMetrics = additionalMetrics
        self.endTime = endTime
        self.filter = filter
        self.groupBy = groupBy
        self.identifier = identifier
        self.maxResults = maxResults
        self.metric = metric
        self.nextToken = nextToken
        self.partitionBy = partitionBy
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct DescribeDimensionKeysInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metric: Swift.String?
    let periodInSeconds: Swift.Int?
    let groupBy: PIClientTypes.DimensionGroup?
    let additionalMetrics: [Swift.String]?
    let partitionBy: PIClientTypes.DimensionGroup?
    let filter: [Swift.String:Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDimensionKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetrics = "AdditionalMetrics"
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PIClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let additionalMetricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalMetrics)
        var additionalMetricsDecoded0:[Swift.String]? = nil
        if let additionalMetricsContainer = additionalMetricsContainer {
            additionalMetricsDecoded0 = [Swift.String]()
            for string0 in additionalMetricsContainer {
                if let string0 = string0 {
                    additionalMetricsDecoded0?.append(string0)
                }
            }
        }
        additionalMetrics = additionalMetricsDecoded0
        let partitionByDecoded = try containerValues.decodeIfPresent(PIClientTypes.DimensionGroup.self, forKey: .partitionBy)
        partitionBy = partitionByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDimensionKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDimensionKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDimensionKeysOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDimensionKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDimensionKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.keys = output.keys
            self.nextToken = output.nextToken
            self.partitionKeys = output.partitionKeys
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.keys = nil
            self.nextToken = nil
            self.partitionKeys = nil
        }
    }
}

public struct DescribeDimensionKeysOutputResponse: Swift.Equatable {
    /// The end time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: ClientRuntime.Date?
    /// The start time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: ClientRuntime.Date?
    /// The dimension keys that were requested.
    public var keys: [PIClientTypes.DimensionKeyDescription]?
    /// A pagination token that indicates the response didn’t return all available records because MaxRecords was specified in the previous request. To get the remaining records, specify NextToken in a separate request with this value.
    public var nextToken: Swift.String?
    /// If PartitionBy was present in the request, PartitionKeys contains the breakdown of dimension keys by the specified partitions.
    public var partitionKeys: [PIClientTypes.ResponsePartitionKey]?

    public init (
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        keys: [PIClientTypes.DimensionKeyDescription]? = nil,
        nextToken: Swift.String? = nil,
        partitionKeys: [PIClientTypes.ResponsePartitionKey]? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.keys = keys
        self.nextToken = nextToken
        self.partitionKeys = partitionKeys
    }
}

struct DescribeDimensionKeysOutputResponseBody: Swift.Equatable {
    let alignedStartTime: ClientRuntime.Date?
    let alignedEndTime: ClientRuntime.Date?
    let partitionKeys: [PIClientTypes.ResponsePartitionKey]?
    let keys: [PIClientTypes.DimensionKeyDescription]?
    let nextToken: Swift.String?
}

extension DescribeDimensionKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case keys = "Keys"
        case nextToken = "NextToken"
        case partitionKeys = "PartitionKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([PIClientTypes.ResponsePartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[PIClientTypes.ResponsePartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [PIClientTypes.ResponsePartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let keysContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionKeyDescription?].self, forKey: .keys)
        var keysDecoded0:[PIClientTypes.DimensionKeyDescription]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [PIClientTypes.DimensionKeyDescription]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PIClientTypes {
    public enum DetailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case processing
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailStatus] {
            return [
                .available,
                .processing,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .processing: return "PROCESSING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailStatus(rawValue: rawValue) ?? DetailStatus.sdkUnknown(rawValue)
        }
    }
}

extension PIClientTypes.DimensionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension PIClientTypes {
    /// The information about a dimension.
    public struct DimensionDetail: Swift.Equatable {
        /// The identifier of a dimension.
        public var identifier: Swift.String?

        public init (
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension PIClientTypes.DimensionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for requeststring0 in dimensions {
                try dimensionsContainer.encode(requeststring0)
            }
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension PIClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions:
    ///
    /// * db.sql.id - The hash of a running SQL statement, generated by Performance Insights.
    ///
    /// * db.sql.db_id - Either the SQL ID generated by the database engine, or a value generated by Performance Insights that begins with pi-.
    ///
    /// * db.sql.statement - The full text of the SQL statement that is running, for example, SELECT * FROM employees.
    ///
    /// * db.sql_tokenized.id - The hash of the SQL digest generated by Performance Insights.
    ///
    ///
    /// Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned.
    public struct DimensionGroup: Swift.Equatable {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested, or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database. Valid values are as follows:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.host.id - The host ID of the connected client (all engines).
        ///
        /// * db.host.name - The host name of the connected client (all engines).
        ///
        /// * db.name - The name of the database to which the client is connected. Valid values are as follows:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Aurora MySQL
        ///
        /// * Amazon RDS MySQL
        ///
        /// * Amazon RDS MariaDB
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.query.id - The query ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.db_id - The query ID generated by the database (only Amazon DocumentDB).
        ///
        /// * db.query.statement - The text of the query that is being run (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized_id
        ///
        /// * db.query.tokenized.id - The query digest ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized.db_id - The query digest ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized.statement - The text of the query digest (only Amazon DocumentDB).
        ///
        /// * db.session_type.name - The type of the current session (only Amazon DocumentDB).
        ///
        /// * db.sql.id - The hash of the full, non-tokenized SQL statement generated by Performance Insights (all engines except Amazon DocumentDB).
        ///
        /// * db.sql.db_id - Either the SQL ID generated by the database engine, or a value generated by Performance Insights that begins with pi- (all engines except Amazon DocumentDB).
        ///
        /// * db.sql.statement - The full text of the SQL statement that is running, as in SELECT * FROM employees (all engines except Amazon DocumentDB)
        ///
        /// * db.sql.tokenized_id
        ///
        /// * db.sql_tokenized.id - The hash of the SQL digest generated by Performance Insights (all engines except Amazon DocumentDB). In the console, db.sql_tokenized.id is called the Support ID because Amazon Web Services Support can look at this data to help you troubleshoot database issues.
        ///
        /// * db.sql_tokenized.db_id - Either the native database ID used to refer to the SQL statement, or a synthetic ID such as pi-2372568224 that Performance Insights generates if the native database ID isn't available (all engines except Amazon DocumentDB).
        ///
        /// * db.sql_tokenized.statement - The text of the SQL digest, as in SELECT * FROM employees WHERE employee_id = ? (all engines except Amazon DocumentDB)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_state.name - The event for which the backend is waiting (only Amazon DocumentDB).
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Valid values are as follows:
        ///
        /// * db - The name of the database to which the client is connected. The following values are permitted:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Aurora MySQL
        ///
        /// * Amazon RDS MySQL
        ///
        /// * Amazon RDS MariaDB
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.application - The name of the application that is connected to the database. The following values are permitted:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.host - The host name of the connected client (all engines).
        ///
        /// * db.query - The query that is currently running (only Amazon DocumentDB).
        ///
        /// * db.query_tokenized - The digest query (only Amazon DocumentDB).
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL).
        ///
        /// * db.sql - The text of the SQL statement that is currently running (all engines except Amazon DocumentDB).
        ///
        /// * db.sql_tokenized - The SQL digest (all engines except Amazon DocumentDB).
        ///
        /// * db.user - The user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_state - The event for which the database backend is waiting (only Amazon DocumentDB).
        /// This member is required.
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init (
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension PIClientTypes.DimensionGroupDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimensiondetail0 in dimensions {
                try dimensionsContainer.encode(dimensiondetail0)
            }
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[PIClientTypes.DimensionDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [PIClientTypes.DimensionDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PIClientTypes {
    /// Information about dimensions within a dimension group.
    public struct DimensionGroupDetail: Swift.Equatable {
        /// The dimensions within a dimension group.
        public var dimensions: [PIClientTypes.DimensionDetail]?
        /// The name of the dimension group.
        public var group: Swift.String?

        public init (
            dimensions: [PIClientTypes.DimensionDetail]? = nil,
            group: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
        }
    }

}

extension PIClientTypes.DimensionKeyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetrics = "AdditionalMetrics"
        case dimensions = "Dimensions"
        case partitions = "Partitions"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetrics = additionalMetrics {
            var additionalMetricsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalMetrics)
            for (dictKey0, additionalMetricsMap0) in additionalMetrics {
                try additionalMetricsContainer.encode(additionalMetricsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionMap0) in dimensions {
                try dimensionsContainer.encode(dimensionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitions = partitions {
            var partitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitions)
            for double0 in partitions {
                try partitionsContainer.encode(double0)
            }
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let additionalMetricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .additionalMetrics)
        var additionalMetricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let additionalMetricsContainer = additionalMetricsContainer {
            additionalMetricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, double0) in additionalMetricsContainer {
                if let double0 = double0 {
                    additionalMetricsDecoded0?[key0] = double0
                }
            }
        }
        additionalMetrics = additionalMetricsDecoded0
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.Double]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.Double]()
            for double0 in partitionsContainer {
                if let double0 = double0 {
                    partitionsDecoded0?.append(double0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension PIClientTypes {
    /// An object that includes the requested dimension key values and aggregated metric values within a dimension group.
    public struct DimensionKeyDescription: Swift.Equatable {
        /// A map that contains the value for each additional metric.
        public var additionalMetrics: [Swift.String:Swift.Double]?
        /// A map of name-value pairs for the dimensions in the group.
        public var dimensions: [Swift.String:Swift.String]?
        /// If PartitionBy was specified, PartitionKeys contains the dimensions that were.
        public var partitions: [Swift.Double]?
        /// The aggregated metric value for the dimensions, over the requested time range.
        public var total: Swift.Double?

        public init (
            additionalMetrics: [Swift.String:Swift.Double]? = nil,
            dimensions: [Swift.String:Swift.String]? = nil,
            partitions: [Swift.Double]? = nil,
            total: Swift.Double? = nil
        )
        {
            self.additionalMetrics = additionalMetrics
            self.dimensions = dimensions
            self.partitions = partitions
            self.total = total
        }
    }

}

extension PIClientTypes.DimensionKeyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension = "Dimension"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PIClientTypes.DetailStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PIClientTypes {
    /// An object that describes the details for a specified dimension.
    public struct DimensionKeyDetail: Swift.Equatable {
        /// The full name of the dimension. The full name includes the group name and key name. The following values are valid:
        ///
        /// * db.query.statement (Amazon DocumentDB)
        ///
        /// * db.sql.statement (Amazon RDS and Aurora)
        public var dimension: Swift.String?
        /// The status of the dimension detail data. Possible values include the following:
        ///
        /// * AVAILABLE - The dimension detail data is ready to be retrieved.
        ///
        /// * PROCESSING - The dimension detail data isn't ready to be retrieved because more processing time is required. If the requested detail data has the status PROCESSING, Performance Insights returns the truncated query.
        ///
        /// * UNAVAILABLE - The dimension detail data could not be collected successfully.
        public var status: PIClientTypes.DetailStatus?
        /// The value of the dimension detail data. Depending on the return status, this value is either the full or truncated SQL query for the following dimensions:
        ///
        /// * db.query.statement (Amazon DocumentDB)
        ///
        /// * db.sql.statement (Amazon RDS and Aurora)
        public var value: Swift.String?

        public init (
            dimension: Swift.String? = nil,
            status: PIClientTypes.DetailStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimension = dimension
            self.status = status
            self.value = value
        }
    }

}

extension PIClientTypes.FeatureMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(PIClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PIClientTypes {
    /// The metadata for a feature. For example, the metadata might indicate that a feature is turned on or off on a specific DB instance.
    public struct FeatureMetadata: Swift.Equatable {
        /// The status of the feature on the DB instance. Possible values include the following:
        ///
        /// * ENABLED - The feature is enabled on the instance.
        ///
        /// * DISABLED - The feature is disabled on the instance.
        ///
        /// * UNSUPPORTED - The feature isn't supported on the instance.
        ///
        /// * ENABLED_PENDING_REBOOT - The feature is enabled on the instance but requires a reboot to take effect.
        ///
        /// * DISABLED_PENDING_REBOOT - The feature is disabled on the instance but requires a reboot to take effect.
        ///
        /// * UNKNOWN - The feature status couldn't be determined.
        public var status: PIClientTypes.FeatureStatus?

        public init (
            status: PIClientTypes.FeatureStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension PIClientTypes {
    public enum FeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabledPendingReboot
        case enabled
        case enabledPendingReboot
        case unknown
        case unsupported
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .disabled,
                .disabledPendingReboot,
                .enabled,
                .enabledPendingReboot,
                .unknown,
                .unsupported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabledPendingReboot: return "DISABLED_PENDING_REBOOT"
            case .enabled: return "ENABLED"
            case .enabledPendingReboot: return "ENABLED_PENDING_REBOOT"
            case .unknown: return "UNKNOWN"
            case .unsupported: return "UNSUPPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureStatus(rawValue: rawValue) ?? FeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetDimensionKeyDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupIdentifier = self.groupIdentifier {
            try encodeContainer.encode(groupIdentifier, forKey: .groupIdentifier)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let requestedDimensions = requestedDimensions {
            var requestedDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDimensions)
            for requeststring0 in requestedDimensions {
                try requestedDimensionsContainer.encode(requeststring0)
            }
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension GetDimensionKeyDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDimensionKeyDetailsInput: Swift.Equatable {
    /// The name of the dimension group. Performance Insights searches the specified group for the dimension group ID. The following group name values are valid:
    ///
    /// * db.query (Amazon DocumentDB only)
    ///
    /// * db.sql (Amazon RDS and Aurora only)
    /// This member is required.
    public var group: Swift.String?
    /// The ID of the dimension group from which to retrieve dimension details. For dimension group db.sql, the group ID is db.sql.id. The following group ID values are valid:
    ///
    /// * db.sql.id for dimension group db.sql (Aurora and RDS only)
    ///
    /// * db.query.id for dimension group db.query (DocumentDB only)
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The ID for a data source from which to gather dimension data. This ID must be immutable and unique within an Amazon Web Services Region. When a DB instance is the data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// A list of dimensions to retrieve the detail data for within the given dimension group. If you don't specify this parameter, Performance Insights returns all dimension data within the specified dimension group. Specify dimension names for the following dimension groups:
    ///
    /// * db.sql - Specify either the full dimension name db.sql.statement or the short dimension name statement (Aurora and RDS only).
    ///
    /// * db.query - Specify either the full dimension name db.query.statement or the short dimension name statement (DocumentDB only).
    public var requestedDimensions: [Swift.String]?
    /// The Amazon Web Services service for which Performance Insights returns data. The only valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init (
        group: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestedDimensions: [Swift.String]? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.group = group
        self.groupIdentifier = groupIdentifier
        self.identifier = identifier
        self.requestedDimensions = requestedDimensions
        self.serviceType = serviceType
    }
}

struct GetDimensionKeyDetailsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let group: Swift.String?
    let groupIdentifier: Swift.String?
    let requestedDimensions: [Swift.String]?
}

extension GetDimensionKeyDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let groupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupIdentifier)
        groupIdentifier = groupIdentifierDecoded
        let requestedDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requestedDimensions)
        var requestedDimensionsDecoded0:[Swift.String]? = nil
        if let requestedDimensionsContainer = requestedDimensionsContainer {
            requestedDimensionsDecoded0 = [Swift.String]()
            for string0 in requestedDimensionsContainer {
                if let string0 = string0 {
                    requestedDimensionsDecoded0?.append(string0)
                }
            }
        }
        requestedDimensions = requestedDimensionsDecoded0
    }
}

extension GetDimensionKeyDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDimensionKeyDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDimensionKeyDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDimensionKeyDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDimensionKeyDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dimensions = output.dimensions
        } else {
            self.dimensions = nil
        }
    }
}

public struct GetDimensionKeyDetailsOutputResponse: Swift.Equatable {
    /// The details for the requested dimensions.
    public var dimensions: [PIClientTypes.DimensionKeyDetail]?

    public init (
        dimensions: [PIClientTypes.DimensionKeyDetail]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

struct GetDimensionKeyDetailsOutputResponseBody: Swift.Equatable {
    let dimensions: [PIClientTypes.DimensionKeyDetail]?
}

extension GetDimensionKeyDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionKeyDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[PIClientTypes.DimensionKeyDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [PIClientTypes.DimensionKeyDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension GetResourceMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension GetResourceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceMetadataInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init (
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.serviceType = serviceType
    }
}

struct GetResourceMetadataInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
}

extension GetResourceMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetResourceMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.features = output.features
            self.identifier = output.identifier
        } else {
            self.features = nil
            self.identifier = nil
        }
    }
}

public struct GetResourceMetadataOutputResponse: Swift.Equatable {
    /// The metadata for different features. For example, the metadata might indicate that a feature is turned on or off on a specific DB instance.
    public var features: [Swift.String:PIClientTypes.FeatureMetadata]?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    public var identifier: Swift.String?

    public init (
        features: [Swift.String:PIClientTypes.FeatureMetadata]? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.features = features
        self.identifier = identifier
    }
}

struct GetResourceMetadataOutputResponseBody: Swift.Equatable {
    let identifier: Swift.String?
    let features: [Swift.String:PIClientTypes.FeatureMetadata]?
}

extension GetResourceMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case features = "Features"
        case identifier = "Identifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String: PIClientTypes.FeatureMetadata?].self, forKey: .features)
        var featuresDecoded0: [Swift.String:PIClientTypes.FeatureMetadata]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String:PIClientTypes.FeatureMetadata]()
            for (key0, featuremetadata0) in featuresContainer {
                if let featuremetadata0 = featuremetadata0 {
                    featuresDecoded0?[key0] = featuremetadata0
                }
            }
        }
        features = featuresDecoded0
    }
}

extension GetResourceMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricQueries = metricQueries {
            var metricQueriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricQueries)
            for metricquery0 in metricQueries {
                try metricQueriesContainer.encode(metricquery0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let periodInSeconds = self.periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetResourceMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceMetricsInput: Swift.Equatable {
    /// The date and time specifying the end of the requested time series query range. The value specified is exclusive. Thus, the command returns data points less than (but not equal to) EndTime. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An array of one or more queries to perform. Each query must specify a Performance Insights metric, and can optionally specify aggregation and filtering criteria.
    /// This member is required.
    public var metricQueries: [PIClientTypes.MetricQuery]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights will choose a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid values are as follows:
    ///
    /// * RDS
    ///
    /// * DOCDB
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series query range. You can't specify a StartTime that is earlier than 7 days ago. By default, Performance Insights has 7 days of retention, but you can extend this range up to 2 years. The value specified is inclusive. Thus, the command returns data points equal to or greater than StartTime. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricQueries: [PIClientTypes.MetricQuery]? = nil,
        nextToken: Swift.String? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricQueries = metricQueries
        self.nextToken = nextToken
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct GetResourceMetricsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let metricQueries: [PIClientTypes.MetricQuery]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let periodInSeconds: Swift.Int?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetResourceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricQueriesContainer = try containerValues.decodeIfPresent([PIClientTypes.MetricQuery?].self, forKey: .metricQueries)
        var metricQueriesDecoded0:[PIClientTypes.MetricQuery]? = nil
        if let metricQueriesContainer = metricQueriesContainer {
            metricQueriesDecoded0 = [PIClientTypes.MetricQuery]()
            for structure0 in metricQueriesContainer {
                if let structure0 = structure0 {
                    metricQueriesDecoded0?.append(structure0)
                }
            }
        }
        metricQueries = metricQueriesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceMetricsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.identifier = output.identifier
            self.metricList = output.metricList
            self.nextToken = output.nextToken
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.identifier = nil
            self.metricList = nil
            self.nextToken = nil
        }
    }
}

public struct GetResourceMetricsOutputResponse: Swift.Equatable {
    /// The end time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: ClientRuntime.Date?
    /// The start time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: ClientRuntime.Date?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId.
    public var identifier: Swift.String?
    /// An array of metric results, where each array element contains all of the data points for a particular dimension.
    public var metricList: [PIClientTypes.MetricKeyDataPoints]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init (
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        metricList: [PIClientTypes.MetricKeyDataPoints]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.identifier = identifier
        self.metricList = metricList
        self.nextToken = nextToken
    }
}

struct GetResourceMetricsOutputResponseBody: Swift.Equatable {
    let alignedStartTime: ClientRuntime.Date?
    let alignedEndTime: ClientRuntime.Date?
    let identifier: Swift.String?
    let metricList: [PIClientTypes.MetricKeyDataPoints]?
    let nextToken: Swift.String?
}

extension GetResourceMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case identifier = "Identifier"
        case metricList = "MetricList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricListContainer = try containerValues.decodeIfPresent([PIClientTypes.MetricKeyDataPoints?].self, forKey: .metricList)
        var metricListDecoded0:[PIClientTypes.MetricKeyDataPoints]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [PIClientTypes.MetricKeyDataPoints]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to an unknown error.
public struct InternalServiceError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the arguments provided is invalid for this request.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAvailableResourceDimensionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for requeststring0 in metrics {
                try metricsContainer.encode(requeststring0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension ListAvailableResourceDimensionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableResourceDimensionsInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique within an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use an Amazon RDS DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VWZ.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The types of metrics for which to retrieve dimensions. Valid values include db.load.
    /// This member is required.
    public var metrics: [Swift.String]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init (
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct ListAvailableResourceDimensionsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let metrics: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailableResourceDimensionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableResourceDimensionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableResourceDimensionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAvailableResourceDimensionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableResourceDimensionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAvailableResourceDimensionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricDimensions = output.metricDimensions
            self.nextToken = output.nextToken
        } else {
            self.metricDimensions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableResourceDimensionsOutputResponse: Swift.Equatable {
    /// The dimension information returned for requested metric types.
    public var metricDimensions: [PIClientTypes.MetricDimensionGroups]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init (
        metricDimensions: [PIClientTypes.MetricDimensionGroups]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricDimensions = metricDimensions
        self.nextToken = nextToken
    }
}

struct ListAvailableResourceDimensionsOutputResponseBody: Swift.Equatable {
    let metricDimensions: [PIClientTypes.MetricDimensionGroups]?
    let nextToken: Swift.String?
}

extension ListAvailableResourceDimensionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDimensions = "MetricDimensions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDimensionsContainer = try containerValues.decodeIfPresent([PIClientTypes.MetricDimensionGroups?].self, forKey: .metricDimensions)
        var metricDimensionsDecoded0:[PIClientTypes.MetricDimensionGroups]? = nil
        if let metricDimensionsContainer = metricDimensionsContainer {
            metricDimensionsDecoded0 = [PIClientTypes.MetricDimensionGroups]()
            for structure0 in metricDimensionsContainer {
                if let structure0 = structure0 {
                    metricDimensionsDecoded0?.append(structure0)
                }
            }
        }
        metricDimensions = metricDimensionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableResourceMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricTypes = "MetricTypes"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricTypes = metricTypes {
            var metricTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricTypes)
            for requeststring0 in metricTypes {
                try metricTypesContainer.encode(requeststring0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension ListAvailableResourceMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableResourceMetricsInput: Swift.Equatable {
    /// An immutable identifier for a data source that is unique within an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use an Amazon RDS DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VWZ.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return. If the MaxRecords value is less than the number of existing items, the response includes a pagination token.
    public var maxResults: Swift.Int?
    /// The types of metrics to return in the response. Valid values in the array include the following:
    ///
    /// * os (OS counter metrics) - All engines
    ///
    /// * db (DB load metrics) - All engines except for Amazon DocumentDB
    ///
    /// * db.sql.stats (per-SQL metrics) - All engines except for Amazon DocumentDB
    ///
    /// * db.sql_tokenized.stats (per-SQL digest metrics) - All engines except for Amazon DocumentDB
    /// This member is required.
    public var metricTypes: [Swift.String]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init (
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricTypes: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricTypes = metricTypes
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct ListAvailableResourceMetricsInputBody: Swift.Equatable {
    let serviceType: PIClientTypes.ServiceType?
    let identifier: Swift.String?
    let metricTypes: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAvailableResourceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricTypes = "MetricTypes"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PIClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricTypes)
        var metricTypesDecoded0:[Swift.String]? = nil
        if let metricTypesContainer = metricTypesContainer {
            metricTypesDecoded0 = [Swift.String]()
            for string0 in metricTypesContainer {
                if let string0 = string0 {
                    metricTypesDecoded0?.append(string0)
                }
            }
        }
        metricTypes = metricTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAvailableResourceMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableResourceMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAvailableResourceMetricsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableResourceMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAvailableResourceMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.nextToken = output.nextToken
        } else {
            self.metrics = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableResourceMetricsOutputResponse: Swift.Equatable {
    /// An array of metrics available to query. Each array element contains the full name, description, and unit of the metric.
    public var metrics: [PIClientTypes.ResponseResourceMetric]?
    /// A pagination token that indicates the response didn’t return all available records because MaxRecords was specified in the previous request. To get the remaining records, specify NextToken in a separate request with this value.
    public var nextToken: Swift.String?

    public init (
        metrics: [PIClientTypes.ResponseResourceMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

struct ListAvailableResourceMetricsOutputResponseBody: Swift.Equatable {
    let metrics: [PIClientTypes.ResponseResourceMetric]?
    let nextToken: Swift.String?
}

extension ListAvailableResourceMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics = "Metrics"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsContainer = try containerValues.decodeIfPresent([PIClientTypes.ResponseResourceMetric?].self, forKey: .metrics)
        var metricsDecoded0:[PIClientTypes.ResponseResourceMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [PIClientTypes.ResponseResourceMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PIClientTypes.MetricDimensionGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for dimensiongroupdetail0 in groups {
                try groupsContainer.encode(dimensiongroupdetail0)
            }
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupsContainer = try containerValues.decodeIfPresent([PIClientTypes.DimensionGroupDetail?].self, forKey: .groups)
        var groupsDecoded0:[PIClientTypes.DimensionGroupDetail]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [PIClientTypes.DimensionGroupDetail]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension PIClientTypes {
    /// The available dimension information for a metric type.
    public struct MetricDimensionGroups: Swift.Equatable {
        /// The available dimension groups for a metric type.
        public var groups: [PIClientTypes.DimensionGroupDetail]?
        /// The metric type to which the dimension information belongs.
        public var metric: Swift.String?

        public init (
            groups: [PIClientTypes.DimensionGroupDetail]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.groups = groups
            self.metric = metric
        }
    }

}

extension PIClientTypes.MetricKeyDataPoints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPoints = "DataPoints"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPoints = dataPoints {
            var dataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPoints)
            for datapoint0 in dataPoints {
                try dataPointsContainer.encode(datapoint0)
            }
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(PIClientTypes.ResponseResourceMetricKey.self, forKey: .key)
        key = keyDecoded
        let dataPointsContainer = try containerValues.decodeIfPresent([PIClientTypes.DataPoint?].self, forKey: .dataPoints)
        var dataPointsDecoded0:[PIClientTypes.DataPoint]? = nil
        if let dataPointsContainer = dataPointsContainer {
            dataPointsDecoded0 = [PIClientTypes.DataPoint]()
            for structure0 in dataPointsContainer {
                if let structure0 = structure0 {
                    dataPointsDecoded0?.append(structure0)
                }
            }
        }
        dataPoints = dataPointsDecoded0
    }
}

extension PIClientTypes {
    /// A time-ordered series of data points, corresponding to a dimension of a Performance Insights metric.
    public struct MetricKeyDataPoints: Swift.Equatable {
        /// An array of timestamp-value pairs, representing measurements over a period of time.
        public var dataPoints: [PIClientTypes.DataPoint]?
        /// The dimensions to which the data points apply.
        public var key: PIClientTypes.ResponseResourceMetricKey?

        public init (
            dataPoints: [PIClientTypes.DataPoint]? = nil,
            key: PIClientTypes.ResponseResourceMetricKey? = nil
        )
        {
            self.dataPoints = dataPoints
            self.key = key
        }
    }

}

extension PIClientTypes.MetricQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricQueryFilterMap0) in filter {
                try filterContainer.encode(metricQueryFilterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PIClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension PIClientTypes {
    /// A single query to be processed. You must provide the metric to query. If no other parameters are specified, Performance Insights returns all data points for the specified metric. Optionally, you can request that the data points be aggregated by dimension group (GroupBy), and return only those data points that match your criteria (Filter).
    public struct MetricQuery: Swift.Equatable {
        /// One or more filters to apply in the request. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        public var filter: [Swift.String:Swift.String]?
        /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights will return all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: PIClientTypes.DimensionGroup?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - The raw number of active sessions for the database engine.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon Aurora User Guide.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init (
            filter: [Swift.String:Swift.String]? = nil,
            groupBy: PIClientTypes.DimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension NotAuthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user is not authorized to perform this request.
public struct NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PIClientTypes.ResponsePartitionKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionMap0) in dimensions {
                try dimensionsContainer.encode(dimensionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PIClientTypes {
    /// If PartitionBy was specified in a DescribeDimensionKeys request, the dimensions are returned in an array. Each element in the array specifies one dimension.
    public struct ResponsePartitionKey: Swift.Equatable {
        /// A dimension map that contains the dimensions for this partition.
        /// This member is required.
        public var dimensions: [Swift.String:Swift.String]?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

extension PIClientTypes.ResponseResourceMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case metric = "Metric"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension PIClientTypes {
    /// An object that contains the full name, description, and unit of a metric.
    public struct ResponseResourceMetric: Swift.Equatable {
        /// The description of the metric.
        public var description: Swift.String?
        /// The full name of the metric.
        public var metric: Swift.String?
        /// The unit of the metric.
        public var unit: Swift.String?

        public init (
            description: Swift.String? = nil,
            metric: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.description = description
            self.metric = metric
            self.unit = unit
        }
    }

}

extension PIClientTypes.ResponseResourceMetricKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionMap0) in dimensions {
                try dimensionsContainer.encode(dimensionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PIClientTypes {
    /// An object describing a Performance Insights metric and one or more dimensions for that metric.
    public struct ResponseResourceMetricKey: Swift.Equatable {
        /// The valid dimensions for the metric.
        public var dimensions: [Swift.String:Swift.String]?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - The raw number of active sessions for the database engine.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon Aurora User Guide.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metric = metric
        }
    }

}

extension PIClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case docdb
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .docdb,
                .rds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .docdb: return "DOCDB"
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}
