//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension PIClientTypes {

    public enum AcceptLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptLanguage] {
            return [
                .enUs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "EN_US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {
    /// This data type helps to determine Performance Insights metric to render for the insight.
    public struct PerformanceInsightsMetric {
        /// A dimension map that contains the dimensions for this partition.
        public var dimensions: [Swift.String: Swift.String]?
        /// The Performance Insights metric name.
        public var displayName: Swift.String?
        /// The Performance Insights metric.
        public var metric: Swift.String?
        /// The value of the metric. For example, 9 for db.load.avg.
        public var value: Swift.Double?

        public init(
            dimensions: [Swift.String: Swift.String]? = nil,
            displayName: Swift.String? = nil,
            metric: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.dimensions = dimensions
            self.displayName = displayName
            self.metric = metric
            self.value = value
        }
    }

}

extension PIClientTypes {
    /// List of data objects which provide details about source metrics. This field can be used to determine the PI metric to render for the insight. This data type also includes static values for the metrics for the Insight that were calculated and included in text and annotations on the DB load chart.
    public struct Data {
        /// This field determines the Performance Insights metric to render for the insight. The name field refers to a Performance Insights metric.
        public var performanceInsightsMetric: PIClientTypes.PerformanceInsightsMetric?

        public init(
            performanceInsightsMetric: PIClientTypes.PerformanceInsightsMetric? = nil
        )
        {
            self.performanceInsightsMetric = performanceInsightsMetric
        }
    }

}

extension PIClientTypes {

    public enum ContextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case causal
        case contextual
        case sdkUnknown(Swift.String)

        public static var allCases: [ContextType] {
            return [
                .causal,
                .contextual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .causal: return "CAUSAL"
            case .contextual: return "CONTEXTUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {
    /// The list of recommendations for the insight.
    public struct Recommendation {
        /// The recommendation details to help resolve the performance issue. For example, Investigate the following SQLs that contributed to 100% of the total DBLoad during that time period: sql-id
        public var recommendationDescription: Swift.String?
        /// The unique identifier for the recommendation.
        public var recommendationId: Swift.String?

        public init(
            recommendationDescription: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.recommendationDescription = recommendationDescription
            self.recommendationId = recommendationId
        }
    }

}

extension PIClientTypes.Recommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recommendation(recommendationId: \(Swift.String(describing: recommendationId)), recommendationDescription: \"CONTENT_REDACTED\")"}
}

extension PIClientTypes {

    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {

    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case docdb
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .docdb,
                .rds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .docdb: return "DOCDB"
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {

    public enum AnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisStatus] {
            return [
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {
    /// Metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    public struct Tag {
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        /// This member is required.
        public var key: Swift.String?
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension PIClientTypes {
    /// Retrieves the details of the performance analysis report.
    public struct AnalysisReportSummary {
        /// The name of the analysis report.
        public var analysisReportId: Swift.String?
        /// The time you created the analysis report.
        public var createTime: Foundation.Date?
        /// The end time of the analysis in the report.
        public var endTime: Foundation.Date?
        /// The start time of the analysis in the report.
        public var startTime: Foundation.Date?
        /// The status of the analysis report.
        public var status: PIClientTypes.AnalysisStatus?
        /// List of all the tags added to the analysis report.
        public var tags: [PIClientTypes.Tag]?

        public init(
            analysisReportId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            status: PIClientTypes.AnalysisStatus? = nil,
            tags: [PIClientTypes.Tag]? = nil
        )
        {
            self.analysisReportId = analysisReportId
            self.createTime = createTime
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.tags = tags
        }
    }

}

extension PIClientTypes {

    public enum FineGrainedAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case describeDimensionKeys
        case getDimensionKeyDetails
        case getResourceMetrics
        case sdkUnknown(Swift.String)

        public static var allCases: [FineGrainedAction] {
            return [
                .describeDimensionKeys,
                .getDimensionKeyDetails,
                .getResourceMetrics
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .describeDimensionKeys: return "DescribeDimensionKeys"
            case .getDimensionKeyDetails: return "GetDimensionKeyDetails"
            case .getResourceMetrics: return "GetResourceMetrics"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request failed due to an unknown error.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One of the arguments provided is invalid for this request.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The user is not authorized to perform this request.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreatePerformanceAnalysisReportInput {
    /// The end time defined for the analysis report.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// An immutable, Amazon Web Services Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use an Amazon RDS instance as a data source, you specify its DbiResourceId value. For example, specify db-ADECBTYHKTSAUMUZQYPDS2GW4A.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The start time defined for the analysis report.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The metadata assigned to the analysis report consisting of a key-value pair.
    public var tags: [PIClientTypes.Tag]?

    public init(
        endTime: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: Foundation.Date? = nil,
        tags: [PIClientTypes.Tag]? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.serviceType = serviceType
        self.startTime = startTime
        self.tags = tags
    }
}

public struct CreatePerformanceAnalysisReportOutput {
    /// A unique identifier for the created analysis report.
    public var analysisReportId: Swift.String?

    public init(
        analysisReportId: Swift.String? = nil
    )
    {
        self.analysisReportId = analysisReportId
    }
}

extension PIClientTypes {
    /// A timestamp, and a single numerical value, which together represent a measurement at a particular point in time.
    public struct DataPoint {
        /// The time, in epoch format, associated with a particular Value.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The actual value associated with a particular Timestamp.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            timestamp: Foundation.Date? = nil,
            value: Swift.Double? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

public struct DeletePerformanceAnalysisReportInput {
    /// The unique identifier of the analysis report for deletion.
    /// This member is required.
    public var analysisReportId: Swift.String?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        analysisReportId: Swift.String? = nil,
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.analysisReportId = analysisReportId
        self.identifier = identifier
        self.serviceType = serviceType
    }
}

public struct DeletePerformanceAnalysisReportOutput {

    public init() { }
}

extension PIClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions:
    ///
    /// * db.sql.id - The hash of a running SQL statement, generated by Performance Insights.
    ///
    /// * db.sql.db_id - Either the SQL ID generated by the database engine, or a value generated by Performance Insights that begins with pi-.
    ///
    /// * db.sql.statement - The full text of the SQL statement that is running, for example, SELECT * FROM employees.
    ///
    /// * db.sql_tokenized.id - The hash of the SQL digest generated by Performance Insights.
    ///
    ///
    /// Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned.
    public struct DimensionGroup {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested, or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database. Valid values are as follows:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.host.id - The host ID of the connected client (all engines).
        ///
        /// * db.host.name - The host name of the connected client (all engines).
        ///
        /// * db.name - The name of the database to which the client is connected. Valid values are as follows:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Aurora MySQL
        ///
        /// * Amazon RDS MySQL
        ///
        /// * Amazon RDS MariaDB
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.query.id - The query ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.db_id - The query ID generated by the database (only Amazon DocumentDB).
        ///
        /// * db.query.statement - The text of the query that is being run (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized_id
        ///
        /// * db.query.tokenized.id - The query digest ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized.db_id - The query digest ID generated by Performance Insights (only Amazon DocumentDB).
        ///
        /// * db.query.tokenized.statement - The text of the query digest (only Amazon DocumentDB).
        ///
        /// * db.session_type.name - The type of the current session (only Amazon DocumentDB).
        ///
        /// * db.sql.id - The hash of the full, non-tokenized SQL statement generated by Performance Insights (all engines except Amazon DocumentDB).
        ///
        /// * db.sql.db_id - Either the SQL ID generated by the database engine, or a value generated by Performance Insights that begins with pi- (all engines except Amazon DocumentDB).
        ///
        /// * db.sql.statement - The full text of the SQL statement that is running, as in SELECT * FROM employees (all engines except Amazon DocumentDB)
        ///
        /// * db.sql.tokenized_id - The hash of the SQL digest generated by Performance Insights (all engines except Amazon DocumentDB). The db.sql.tokenized_id dimension fetches the value of the db.sql_tokenized.id dimension. Amazon RDS returns db.sql.tokenized_id from the db.sql dimension group.
        ///
        /// * db.sql_tokenized.id - The hash of the SQL digest generated by Performance Insights (all engines except Amazon DocumentDB). In the console, db.sql_tokenized.id is called the Support ID because Amazon Web Services Support can look at this data to help you troubleshoot database issues.
        ///
        /// * db.sql_tokenized.db_id - Either the native database ID used to refer to the SQL statement, or a synthetic ID such as pi-2372568224 that Performance Insights generates if the native database ID isn't available (all engines except Amazon DocumentDB).
        ///
        /// * db.sql_tokenized.statement - The text of the SQL digest, as in SELECT * FROM employees WHERE employee_id = ? (all engines except Amazon DocumentDB)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_state.name - The event for which the backend is waiting (only Amazon DocumentDB).
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Valid values are as follows:
        ///
        /// * db - The name of the database to which the client is connected. The following values are permitted:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Aurora MySQL
        ///
        /// * Amazon RDS MySQL
        ///
        /// * Amazon RDS MariaDB
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.application - The name of the application that is connected to the database. The following values are permitted:
        ///
        /// * Aurora PostgreSQL
        ///
        /// * Amazon RDS PostgreSQL
        ///
        /// * Amazon DocumentDB
        ///
        ///
        ///
        ///
        /// * db.host - The host name of the connected client (all engines).
        ///
        /// * db.query - The query that is currently running (only Amazon DocumentDB).
        ///
        /// * db.query_tokenized - The digest query (only Amazon DocumentDB).
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL).
        ///
        /// * db.sql - The text of the SQL statement that is currently running (all engines except Amazon DocumentDB).
        ///
        /// * db.sql_tokenized - The SQL digest (all engines except Amazon DocumentDB).
        ///
        /// * db.user - The user logged in to the database (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines except Amazon DocumentDB).
        ///
        /// * db.wait_state - The event for which the database backend is waiting (only Amazon DocumentDB).
        /// This member is required.
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init(
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

public struct DescribeDimensionKeysInput {
    /// Additional metrics for the top N dimension keys. If the specified dimension group in the GroupBy parameter is db.sql_tokenized, you can specify per-SQL metrics to get the values for the top N SQL digests. The response syntax is as follows: "AdditionalMetrics" : { "string" : "string" }.
    public var additionalMetrics: [Swift.String]?
    /// The date and time specifying the end of the requested time series data. The value specified is exclusive, which means that data points less than (but not equal to) EndTime are returned. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// One or more filters to apply in the request. Restrictions:
    ///
    /// * Any number of filters by the same dimension, as specified in the GroupBy or Partition parameters.
    ///
    /// * A single filter for any other dimension in this dimension group.
    ///
    ///
    /// The db.sql.db_id filter isn't available for RDS for SQL Server DB instances.
    public var filter: [Swift.String: Swift.String]?
    /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights returns all dimensions within this group, unless you provide the names of specific dimensions within this group. You can also request that Performance Insights return a limited number of values for a dimension.
    /// This member is required.
    public var groupBy: PIClientTypes.DimensionGroup?
    /// An immutable, Amazon Web Services Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use an Amazon RDS instance as a data source, you specify its DbiResourceId value. For example, specify db-FAIHNTYBKTGAUSUZQYPDS2GW4A.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
    ///
    /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
    ///
    /// * db.sampledload.avg - The raw number of active sessions for the database engine.
    ///
    ///
    /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
    /// This member is required.
    public var metric: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// For each dimension specified in GroupBy, specify a secondary dimension to further subdivide the partition keys in the response.
    public var partitionBy: PIClientTypes.DimensionGroup?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights chooses a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid values are as follows:
    ///
    /// * RDS
    ///
    /// * DOCDB
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series data. You must specify a StartTime within the past 7 days. The value specified is inclusive, which means that data points equal to or greater than StartTime are returned. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        additionalMetrics: [Swift.String]? = nil,
        endTime: Foundation.Date? = nil,
        filter: [Swift.String: Swift.String]? = nil,
        groupBy: PIClientTypes.DimensionGroup? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metric: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        partitionBy: PIClientTypes.DimensionGroup? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.additionalMetrics = additionalMetrics
        self.endTime = endTime
        self.filter = filter
        self.groupBy = groupBy
        self.identifier = identifier
        self.maxResults = maxResults
        self.metric = metric
        self.nextToken = nextToken
        self.partitionBy = partitionBy
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

extension PIClientTypes {
    /// An object that includes the requested dimension key values and aggregated metric values within a dimension group.
    public struct DimensionKeyDescription {
        /// A map that contains the value for each additional metric.
        public var additionalMetrics: [Swift.String: Swift.Double]?
        /// A map of name-value pairs for the dimensions in the group.
        public var dimensions: [Swift.String: Swift.String]?
        /// If PartitionBy was specified, PartitionKeys contains the dimensions that were.
        public var partitions: [Swift.Double]?
        /// The aggregated metric value for the dimensions, over the requested time range.
        public var total: Swift.Double?

        public init(
            additionalMetrics: [Swift.String: Swift.Double]? = nil,
            dimensions: [Swift.String: Swift.String]? = nil,
            partitions: [Swift.Double]? = nil,
            total: Swift.Double? = nil
        )
        {
            self.additionalMetrics = additionalMetrics
            self.dimensions = dimensions
            self.partitions = partitions
            self.total = total
        }
    }

}

extension PIClientTypes {
    /// If PartitionBy was specified in a DescribeDimensionKeys request, the dimensions are returned in an array. Each element in the array specifies one dimension.
    public struct ResponsePartitionKey {
        /// A dimension map that contains the dimensions for this partition.
        /// This member is required.
        public var dimensions: [Swift.String: Swift.String]?

        public init(
            dimensions: [Swift.String: Swift.String]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

public struct DescribeDimensionKeysOutput {
    /// The end time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: Foundation.Date?
    /// The start time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: Foundation.Date?
    /// The dimension keys that were requested.
    public var keys: [PIClientTypes.DimensionKeyDescription]?
    /// A pagination token that indicates the response didn’t return all available records because MaxRecords was specified in the previous request. To get the remaining records, specify NextToken in a separate request with this value.
    public var nextToken: Swift.String?
    /// If PartitionBy was present in the request, PartitionKeys contains the breakdown of dimension keys by the specified partitions.
    public var partitionKeys: [PIClientTypes.ResponsePartitionKey]?

    public init(
        alignedEndTime: Foundation.Date? = nil,
        alignedStartTime: Foundation.Date? = nil,
        keys: [PIClientTypes.DimensionKeyDescription]? = nil,
        nextToken: Swift.String? = nil,
        partitionKeys: [PIClientTypes.ResponsePartitionKey]? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.keys = keys
        self.nextToken = nextToken
        self.partitionKeys = partitionKeys
    }
}

extension PIClientTypes {

    public enum DetailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case processing
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailStatus] {
            return [
                .available,
                .processing,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .processing: return "PROCESSING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {
    /// The information about a dimension.
    public struct DimensionDetail {
        /// The identifier of a dimension.
        public var identifier: Swift.String?

        public init(
            identifier: Swift.String? = nil
        )
        {
            self.identifier = identifier
        }
    }

}

extension PIClientTypes {
    /// Information about dimensions within a dimension group.
    public struct DimensionGroupDetail {
        /// The dimensions within a dimension group.
        public var dimensions: [PIClientTypes.DimensionDetail]?
        /// The name of the dimension group.
        public var group: Swift.String?

        public init(
            dimensions: [PIClientTypes.DimensionDetail]? = nil,
            group: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
        }
    }

}

extension PIClientTypes {
    /// An object that describes the details for a specified dimension.
    public struct DimensionKeyDetail {
        /// The full name of the dimension. The full name includes the group name and key name. The following values are valid:
        ///
        /// * db.query.statement (Amazon DocumentDB)
        ///
        /// * db.sql.statement (Amazon RDS and Aurora)
        public var dimension: Swift.String?
        /// The status of the dimension detail data. Possible values include the following:
        ///
        /// * AVAILABLE - The dimension detail data is ready to be retrieved.
        ///
        /// * PROCESSING - The dimension detail data isn't ready to be retrieved because more processing time is required. If the requested detail data has the status PROCESSING, Performance Insights returns the truncated query.
        ///
        /// * UNAVAILABLE - The dimension detail data could not be collected successfully.
        public var status: PIClientTypes.DetailStatus?
        /// The value of the dimension detail data. Depending on the return status, this value is either the full or truncated SQL query for the following dimensions:
        ///
        /// * db.query.statement (Amazon DocumentDB)
        ///
        /// * db.sql.statement (Amazon RDS and Aurora)
        public var value: Swift.String?

        public init(
            dimension: Swift.String? = nil,
            status: PIClientTypes.DetailStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimension = dimension
            self.status = status
            self.value = value
        }
    }

}

extension PIClientTypes {

    public enum FeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabledPendingReboot
        case enabled
        case enabledPendingReboot
        case unknown
        case unsupported
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .disabled,
                .disabledPendingReboot,
                .enabled,
                .enabledPendingReboot,
                .unknown,
                .unsupported
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabledPendingReboot: return "DISABLED_PENDING_REBOOT"
            case .enabled: return "ENABLED"
            case .enabledPendingReboot: return "ENABLED_PENDING_REBOOT"
            case .unknown: return "UNKNOWN"
            case .unsupported: return "UNSUPPORTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PIClientTypes {
    /// The metadata for a feature. For example, the metadata might indicate that a feature is turned on or off on a specific DB instance.
    public struct FeatureMetadata {
        /// The status of the feature on the DB instance. Possible values include the following:
        ///
        /// * ENABLED - The feature is enabled on the instance.
        ///
        /// * DISABLED - The feature is disabled on the instance.
        ///
        /// * UNSUPPORTED - The feature isn't supported on the instance.
        ///
        /// * ENABLED_PENDING_REBOOT - The feature is enabled on the instance but requires a reboot to take effect.
        ///
        /// * DISABLED_PENDING_REBOOT - The feature is disabled on the instance but requires a reboot to take effect.
        ///
        /// * UNKNOWN - The feature status couldn't be determined.
        public var status: PIClientTypes.FeatureStatus?

        public init(
            status: PIClientTypes.FeatureStatus? = nil
        )
        {
            self.status = status
        }
    }

}

public struct GetDimensionKeyDetailsInput {
    /// The name of the dimension group. Performance Insights searches the specified group for the dimension group ID. The following group name values are valid:
    ///
    /// * db.query (Amazon DocumentDB only)
    ///
    /// * db.sql (Amazon RDS and Aurora only)
    /// This member is required.
    public var group: Swift.String?
    /// The ID of the dimension group from which to retrieve dimension details. For dimension group db.sql, the group ID is db.sql.id. The following group ID values are valid:
    ///
    /// * db.sql.id for dimension group db.sql (Aurora and RDS only)
    ///
    /// * db.query.id for dimension group db.query (DocumentDB only)
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The ID for a data source from which to gather dimension data. This ID must be immutable and unique within an Amazon Web Services Region. When a DB instance is the data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// A list of dimensions to retrieve the detail data for within the given dimension group. If you don't specify this parameter, Performance Insights returns all dimension data within the specified dimension group. Specify dimension names for the following dimension groups:
    ///
    /// * db.sql - Specify either the full dimension name db.sql.statement or the short dimension name statement (Aurora and RDS only).
    ///
    /// * db.query - Specify either the full dimension name db.query.statement or the short dimension name statement (DocumentDB only).
    public var requestedDimensions: [Swift.String]?
    /// The Amazon Web Services service for which Performance Insights returns data. The only valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        group: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestedDimensions: [Swift.String]? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.group = group
        self.groupIdentifier = groupIdentifier
        self.identifier = identifier
        self.requestedDimensions = requestedDimensions
        self.serviceType = serviceType
    }
}

public struct GetDimensionKeyDetailsOutput {
    /// The details for the requested dimensions.
    public var dimensions: [PIClientTypes.DimensionKeyDetail]?

    public init(
        dimensions: [PIClientTypes.DimensionKeyDetail]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

extension PIClientTypes {

    public enum TextFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case markdown
        case plainText
        case sdkUnknown(Swift.String)

        public static var allCases: [TextFormat] {
            return [
                .markdown,
                .plainText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .markdown: return "MARKDOWN"
            case .plainText: return "PLAIN_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPerformanceAnalysisReportInput {
    /// The text language in the report. The default language is EN_US (English).
    public var acceptLanguage: PIClientTypes.AcceptLanguage?
    /// A unique identifier of the created analysis report. For example, report-12345678901234567
    /// This member is required.
    public var analysisReportId: Swift.String?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights will return metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// Indicates the text format in the report. The options are PLAIN_TEXT or MARKDOWN. The default value is plain text.
    public var textFormat: PIClientTypes.TextFormat?

    public init(
        acceptLanguage: PIClientTypes.AcceptLanguage? = nil,
        analysisReportId: Swift.String? = nil,
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        textFormat: PIClientTypes.TextFormat? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.analysisReportId = analysisReportId
        self.identifier = identifier
        self.serviceType = serviceType
        self.textFormat = textFormat
    }
}

public struct GetResourceMetadataInput {
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.serviceType = serviceType
    }
}

public struct GetResourceMetadataOutput {
    /// The metadata for different features. For example, the metadata might indicate that a feature is turned on or off on a specific DB instance.
    public var features: [Swift.String: PIClientTypes.FeatureMetadata]?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    public var identifier: Swift.String?

    public init(
        features: [Swift.String: PIClientTypes.FeatureMetadata]? = nil,
        identifier: Swift.String? = nil
    )
    {
        self.features = features
        self.identifier = identifier
    }
}

extension PIClientTypes {
    /// A single query to be processed. You must provide the metric to query and append an aggregate function to the metric. For example, to find the average for the metric db.load you must use db.load.avg. Valid values for aggregate functions include .avg, .min, .max, and .sum. If no other parameters are specified, Performance Insights returns all data points for the specified metric. Optionally, you can request that the data points be aggregated by dimension group (GroupBy), and return only those data points that match your criteria (Filter).
    public struct MetricQuery {
        /// One or more filters to apply in the request. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        ///
        ///
        /// The db.sql.db_id filter isn't available for RDS for SQL Server DB instances.
        public var filter: [Swift.String: Swift.String]?
        /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights will return all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: PIClientTypes.DimensionGroup?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - The raw number of active sessions for the database engine.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon Aurora User Guide.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon RDS User Guide.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init(
            filter: [Swift.String: Swift.String]? = nil,
            groupBy: PIClientTypes.DimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension PIClientTypes {

    public enum PeriodAlignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case endTime
        case startTime
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodAlignment] {
            return [
                .endTime,
                .startTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .endTime: return "END_TIME"
            case .startTime: return "START_TIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourceMetricsInput {
    /// The date and time specifying the end of the requested time series query range. The value specified is exclusive. Thus, the command returns data points less than (but not equal to) EndTime. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An array of one or more queries to perform. Each query must specify a Performance Insights metric and specify an aggregate function, and you can provide filtering criteria. You must append the aggregate function to the metric. For example, to find the average for the metric db.load you must use db.load.avg. Valid values for aggregate functions include .avg, .min, .max, and .sum.
    /// This member is required.
    public var metricQueries: [PIClientTypes.MetricQuery]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The returned timestamp which is the start or end time of the time periods. The default value is END_TIME.
    public var periodAlignment: PIClientTypes.PeriodAlignment?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights will choose a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid values are as follows:
    ///
    /// * RDS
    ///
    /// * DOCDB
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series query range. You can't specify a StartTime that is earlier than 7 days ago. By default, Performance Insights has 7 days of retention, but you can extend this range up to 2 years. The value specified is inclusive. Thus, the command returns data points equal to or greater than StartTime. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricQueries: [PIClientTypes.MetricQuery]? = nil,
        nextToken: Swift.String? = nil,
        periodAlignment: PIClientTypes.PeriodAlignment? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricQueries = metricQueries
        self.nextToken = nextToken
        self.periodAlignment = periodAlignment
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

extension PIClientTypes {
    /// An object describing a Performance Insights metric and one or more dimensions for that metric.
    public struct ResponseResourceMetricKey {
        /// The valid dimensions for the metric.
        public var dimensions: [Swift.String: Swift.String]?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - A scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - The raw number of active sessions for the database engine.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon Aurora User Guide.
        ///
        /// * The counter metrics listed in [Performance Insights operating system counters](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights_Counters.html#USER_PerfInsights_Counters.OS) in the Amazon RDS User Guide.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init(
            dimensions: [Swift.String: Swift.String]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metric = metric
        }
    }

}

extension PIClientTypes {
    /// A time-ordered series of data points, corresponding to a dimension of a Performance Insights metric.
    public struct MetricKeyDataPoints {
        /// An array of timestamp-value pairs, representing measurements over a period of time.
        public var dataPoints: [PIClientTypes.DataPoint]?
        /// The dimensions to which the data points apply.
        public var key: PIClientTypes.ResponseResourceMetricKey?

        public init(
            dataPoints: [PIClientTypes.DataPoint]? = nil,
            key: PIClientTypes.ResponseResourceMetricKey? = nil
        )
        {
            self.dataPoints = dataPoints
            self.key = key
        }
    }

}

public struct GetResourceMetricsOutput {
    /// The end time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: Foundation.Date?
    /// The start time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: Foundation.Date?
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId.
    public var identifier: Swift.String?
    /// An array of metric results, where each array element contains all of the data points for a particular dimension.
    public var metricList: [PIClientTypes.MetricKeyDataPoints]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init(
        alignedEndTime: Foundation.Date? = nil,
        alignedStartTime: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        metricList: [PIClientTypes.MetricKeyDataPoints]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.identifier = identifier
        self.metricList = metricList
        self.nextToken = nextToken
    }
}

public struct ListAvailableResourceDimensionsInput {
    /// The actions to discover the dimensions you are authorized to access. If you specify multiple actions, then the response will contain the dimensions common for all the actions. When you don't specify this request parameter or provide an empty list, the response contains all the available dimensions for the target database engine whether or not you are authorized to access them.
    public var authorizedActions: [PIClientTypes.FineGrainedAction]?
    /// An immutable identifier for a data source that is unique within an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use an Amazon RDS DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VWZ.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The types of metrics for which to retrieve dimensions. Valid values include db.load.
    /// This member is required.
    public var metrics: [Swift.String]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        authorizedActions: [PIClientTypes.FineGrainedAction]? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.authorizedActions = authorizedActions
        self.identifier = identifier
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

extension PIClientTypes {
    /// The available dimension information for a metric type.
    public struct MetricDimensionGroups {
        /// The available dimension groups for a metric type.
        public var groups: [PIClientTypes.DimensionGroupDetail]?
        /// The metric type to which the dimension information belongs.
        public var metric: Swift.String?

        public init(
            groups: [PIClientTypes.DimensionGroupDetail]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.groups = groups
            self.metric = metric
        }
    }

}

public struct ListAvailableResourceDimensionsOutput {
    /// The dimension information returned for requested metric types.
    public var metricDimensions: [PIClientTypes.MetricDimensionGroups]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init(
        metricDimensions: [PIClientTypes.MetricDimensionGroups]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricDimensions = metricDimensions
        self.nextToken = nextToken
    }
}

public struct ListAvailableResourceMetricsInput {
    /// An immutable identifier for a data source that is unique within an Amazon Web Services Region. Performance Insights gathers metrics from this data source. To use an Amazon RDS DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VWZ.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return. If the MaxRecords value is less than the number of existing items, the response includes a pagination token.
    public var maxResults: Swift.Int?
    /// The types of metrics to return in the response. Valid values in the array include the following:
    ///
    /// * os (OS counter metrics) - All engines
    ///
    /// * db (DB load metrics) - All engines except for Amazon DocumentDB
    ///
    /// * db.sql.stats (per-SQL metrics) - All engines except for Amazon DocumentDB
    ///
    /// * db.sql_tokenized.stats (per-SQL digest metrics) - All engines except for Amazon DocumentDB
    /// This member is required.
    public var metricTypes: [Swift.String]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricTypes: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricTypes = metricTypes
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

extension PIClientTypes {
    /// An object that contains the full name, description, and unit of a metric.
    public struct ResponseResourceMetric {
        /// The description of the metric.
        public var description: Swift.String?
        /// The full name of the metric.
        public var metric: Swift.String?
        /// The unit of the metric.
        public var unit: Swift.String?

        public init(
            description: Swift.String? = nil,
            metric: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.description = description
            self.metric = metric
            self.unit = unit
        }
    }

}

public struct ListAvailableResourceMetricsOutput {
    /// An array of metrics available to query. Each array element contains the full name, description, and unit of the metric.
    public var metrics: [PIClientTypes.ResponseResourceMetric]?
    /// A pagination token that indicates the response didn’t return all available records because MaxRecords was specified in the previous request. To get the remaining records, specify NextToken in a separate request with this value.
    public var nextToken: Swift.String?

    public init(
        metrics: [PIClientTypes.ResponseResourceMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

public struct ListPerformanceAnalysisReportsInput {
    /// An immutable identifier for a data source that is unique for an Amazon Web Services Region. Performance Insights gathers metrics from this data source. In the console, the identifier is shown as ResourceID. When you call DescribeDBInstances, the identifier is returned as DbiResourceId. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies whether or not to include the list of tags in the response.
    public var listTags: Swift.Bool?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxResults value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        identifier: Swift.String? = nil,
        listTags: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.identifier = identifier
        self.listTags = listTags
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

public struct ListPerformanceAnalysisReportsOutput {
    /// List of reports including the report identifier, start and end time, creation time, and status.
    public var analysisReports: [PIClientTypes.AnalysisReportSummary]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        analysisReports: [PIClientTypes.AnalysisReportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisReports = analysisReports
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// Lists all the tags for the Amazon RDS Performance Insights resource. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List the tags for the Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?

    public init(
        resourceARN: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil
    )
    {
        self.resourceARN = resourceARN
        self.serviceType = serviceType
    }
}

public struct ListTagsForResourceOutput {
    /// The metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    public var tags: [PIClientTypes.Tag]?

    public init(
        tags: [PIClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The Amazon RDS Performance Insights resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    /// This member is required.
    public var tags: [PIClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        tags: [PIClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.serviceType = serviceType
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon RDS Performance Insights resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about creating an ARN, see [ Constructing an RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List the tags for the Amazon Web Services service for which Performance Insights returns metrics. Valid value is RDS.
    /// This member is required.
    public var serviceType: PIClientTypes.ServiceType?
    /// The metadata assigned to an Amazon RDS Performance Insights resource consisting of a key-value pair.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        serviceType: PIClientTypes.ServiceType? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.serviceType = serviceType
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension PIClientTypes {
    /// Retrieves the list of performance issues which are identified.
    public struct Insight {
        /// Metric names and values from the timeframe used as baseline to generate the insight.
        public var baselineData: [PIClientTypes.Data]?
        /// Indicates if the insight is causal or correlated insight.
        public var context: PIClientTypes.ContextType?
        /// Description of the insight. For example: A high severity Insight found between 02:00 to 02:30, where there was an unusually high DB load 600x above baseline. Likely performance impact.
        public var description: Swift.String?
        /// The end time of the insight. For example, 2018-10-30T00:00:00Z.
        public var endTime: Foundation.Date?
        /// List of data objects containing metrics and references from the time range while generating the insight.
        public var insightData: [PIClientTypes.Data]?
        /// The unique identifier for the insight. For example, insight-12345678901234567.
        /// This member is required.
        public var insightId: Swift.String?
        /// The type of insight. For example, HighDBLoad, HighCPU, or DominatingSQLs.
        public var insightType: Swift.String?
        /// List of recommendations for the insight. For example, Investigate the following SQLs that contributed to 100% of the total DBLoad during that time period: sql-id.
        public var recommendations: [PIClientTypes.Recommendation]?
        /// The severity of the insight. The values are: Low, Medium, or High.
        public var severity: PIClientTypes.Severity?
        /// The start time of the insight. For example, 2018-10-30T00:00:00Z.
        public var startTime: Foundation.Date?
        /// List of supporting insights that provide additional factors for the insight.
        public var supportingInsights: [PIClientTypes.Insight]?

        public init(
            baselineData: [PIClientTypes.Data]? = nil,
            context: PIClientTypes.ContextType? = nil,
            description: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            insightData: [PIClientTypes.Data]? = nil,
            insightId: Swift.String? = nil,
            insightType: Swift.String? = nil,
            recommendations: [PIClientTypes.Recommendation]? = nil,
            severity: PIClientTypes.Severity? = nil,
            startTime: Foundation.Date? = nil,
            supportingInsights: [PIClientTypes.Insight]? = nil
        )
        {
            self.baselineData = baselineData
            self.context = context
            self.description = description
            self.endTime = endTime
            self.insightData = insightData
            self.insightId = insightId
            self.insightType = insightType
            self.recommendations = recommendations
            self.severity = severity
            self.startTime = startTime
            self.supportingInsights = supportingInsights
        }
    }

}

extension PIClientTypes.Insight: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Insight(baselineData: \(Swift.String(describing: baselineData)), context: \(Swift.String(describing: context)), endTime: \(Swift.String(describing: endTime)), insightData: \(Swift.String(describing: insightData)), insightId: \(Swift.String(describing: insightId)), insightType: \(Swift.String(describing: insightType)), recommendations: \(Swift.String(describing: recommendations)), severity: \(Swift.String(describing: severity)), startTime: \(Swift.String(describing: startTime)), supportingInsights: \(Swift.String(describing: supportingInsights)), description: \"CONTENT_REDACTED\")"}
}

extension PIClientTypes {
    /// Retrieves the summary of the performance analysis report created for a time period.
    public struct AnalysisReport {
        /// The name of the analysis report.
        /// This member is required.
        public var analysisReportId: Swift.String?
        /// The time you created the analysis report.
        public var createTime: Foundation.Date?
        /// The analysis end time in the report.
        public var endTime: Foundation.Date?
        /// The unique identifier of the analysis report.
        public var identifier: Swift.String?
        /// The list of identified insights in the analysis report.
        public var insights: [PIClientTypes.Insight]?
        /// List the tags for the Amazon Web Services service for which Performance Insights returns metrics. Valid values are as follows:
        ///
        /// * RDS
        ///
        /// * DOCDB
        public var serviceType: PIClientTypes.ServiceType?
        /// The analysis start time in the report.
        public var startTime: Foundation.Date?
        /// The status of the created analysis report.
        public var status: PIClientTypes.AnalysisStatus?

        public init(
            analysisReportId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            identifier: Swift.String? = nil,
            insights: [PIClientTypes.Insight]? = nil,
            serviceType: PIClientTypes.ServiceType? = nil,
            startTime: Foundation.Date? = nil,
            status: PIClientTypes.AnalysisStatus? = nil
        )
        {
            self.analysisReportId = analysisReportId
            self.createTime = createTime
            self.endTime = endTime
            self.identifier = identifier
            self.insights = insights
            self.serviceType = serviceType
            self.startTime = startTime
            self.status = status
        }
    }

}

public struct GetPerformanceAnalysisReportOutput {
    /// The summary of the performance analysis report created for a time period.
    public var analysisReport: PIClientTypes.AnalysisReport?

    public init(
        analysisReport: PIClientTypes.AnalysisReport? = nil
    )
    {
        self.analysisReport = analysisReport
    }
}

extension CreatePerformanceAnalysisReportInput {

    static func urlPathProvider(_ value: CreatePerformanceAnalysisReportInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePerformanceAnalysisReportInput {

    static func urlPathProvider(_ value: DeletePerformanceAnalysisReportInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDimensionKeysInput {

    static func urlPathProvider(_ value: DescribeDimensionKeysInput) -> Swift.String? {
        return "/"
    }
}

extension GetDimensionKeyDetailsInput {

    static func urlPathProvider(_ value: GetDimensionKeyDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetPerformanceAnalysisReportInput {

    static func urlPathProvider(_ value: GetPerformanceAnalysisReportInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceMetadataInput {

    static func urlPathProvider(_ value: GetResourceMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceMetricsInput {

    static func urlPathProvider(_ value: GetResourceMetricsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAvailableResourceDimensionsInput {

    static func urlPathProvider(_ value: ListAvailableResourceDimensionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAvailableResourceMetricsInput {

    static func urlPathProvider(_ value: ListAvailableResourceMetricsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPerformanceAnalysisReportsInput {

    static func urlPathProvider(_ value: ListPerformanceAnalysisReportsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePerformanceAnalysisReportInput {

    static func write(value: CreatePerformanceAnalysisReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Identifier"].write(value.identifier)
        try writer["ServiceType"].write(value.serviceType)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PIClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeletePerformanceAnalysisReportInput {

    static func write(value: DeletePerformanceAnalysisReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisReportId"].write(value.analysisReportId)
        try writer["Identifier"].write(value.identifier)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension DescribeDimensionKeysInput {

    static func write(value: DescribeDimensionKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalMetrics"].writeList(value.additionalMetrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Filter"].writeMap(value.filter, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["GroupBy"].write(value.groupBy, with: PIClientTypes.DimensionGroup.write(value:to:))
        try writer["Identifier"].write(value.identifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Metric"].write(value.metric)
        try writer["NextToken"].write(value.nextToken)
        try writer["PartitionBy"].write(value.partitionBy, with: PIClientTypes.DimensionGroup.write(value:to:))
        try writer["PeriodInSeconds"].write(value.periodInSeconds)
        try writer["ServiceType"].write(value.serviceType)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GetDimensionKeyDetailsInput {

    static func write(value: GetDimensionKeyDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Group"].write(value.group)
        try writer["GroupIdentifier"].write(value.groupIdentifier)
        try writer["Identifier"].write(value.identifier)
        try writer["RequestedDimensions"].writeList(value.requestedDimensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension GetPerformanceAnalysisReportInput {

    static func write(value: GetPerformanceAnalysisReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AnalysisReportId"].write(value.analysisReportId)
        try writer["Identifier"].write(value.identifier)
        try writer["ServiceType"].write(value.serviceType)
        try writer["TextFormat"].write(value.textFormat)
    }
}

extension GetResourceMetadataInput {

    static func write(value: GetResourceMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension GetResourceMetricsInput {

    static func write(value: GetResourceMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Identifier"].write(value.identifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["MetricQueries"].writeList(value.metricQueries, memberWritingClosure: PIClientTypes.MetricQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["PeriodAlignment"].write(value.periodAlignment)
        try writer["PeriodInSeconds"].write(value.periodInSeconds)
        try writer["ServiceType"].write(value.serviceType)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListAvailableResourceDimensionsInput {

    static func write(value: ListAvailableResourceDimensionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedActions"].writeList(value.authorizedActions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PIClientTypes.FineGrainedAction>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Identifier"].write(value.identifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension ListAvailableResourceMetricsInput {

    static func write(value: ListAvailableResourceMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["MetricTypes"].writeList(value.metricTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension ListPerformanceAnalysisReportsInput {

    static func write(value: ListPerformanceAnalysisReportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
        try writer["ListTags"].write(value.listTags)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["ServiceType"].write(value.serviceType)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["ServiceType"].write(value.serviceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PIClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["ServiceType"].write(value.serviceType)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePerformanceAnalysisReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePerformanceAnalysisReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePerformanceAnalysisReportOutput()
        value.analysisReportId = try reader["AnalysisReportId"].readIfPresent()
        return value
    }
}

extension DeletePerformanceAnalysisReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePerformanceAnalysisReportOutput {
        return DeletePerformanceAnalysisReportOutput()
    }
}

extension DescribeDimensionKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDimensionKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDimensionKeysOutput()
        value.alignedEndTime = try reader["AlignedEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.alignedStartTime = try reader["AlignedStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.keys = try reader["Keys"].readListIfPresent(memberReadingClosure: PIClientTypes.DimensionKeyDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: PIClientTypes.ResponsePartitionKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDimensionKeyDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDimensionKeyDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDimensionKeyDetailsOutput()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: PIClientTypes.DimensionKeyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPerformanceAnalysisReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPerformanceAnalysisReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPerformanceAnalysisReportOutput()
        value.analysisReport = try reader["AnalysisReport"].readIfPresent(with: PIClientTypes.AnalysisReport.read(from:))
        return value
    }
}

extension GetResourceMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceMetadataOutput()
        value.features = try reader["Features"].readMapIfPresent(valueReadingClosure: PIClientTypes.FeatureMetadata.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.identifier = try reader["Identifier"].readIfPresent()
        return value
    }
}

extension GetResourceMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceMetricsOutput()
        value.alignedEndTime = try reader["AlignedEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.alignedStartTime = try reader["AlignedStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.identifier = try reader["Identifier"].readIfPresent()
        value.metricList = try reader["MetricList"].readListIfPresent(memberReadingClosure: PIClientTypes.MetricKeyDataPoints.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAvailableResourceDimensionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAvailableResourceDimensionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAvailableResourceDimensionsOutput()
        value.metricDimensions = try reader["MetricDimensions"].readListIfPresent(memberReadingClosure: PIClientTypes.MetricDimensionGroups.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAvailableResourceMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAvailableResourceMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAvailableResourceMetricsOutput()
        value.metrics = try reader["Metrics"].readListIfPresent(memberReadingClosure: PIClientTypes.ResponseResourceMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPerformanceAnalysisReportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPerformanceAnalysisReportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPerformanceAnalysisReportsOutput()
        value.analysisReports = try reader["AnalysisReports"].readListIfPresent(memberReadingClosure: PIClientTypes.AnalysisReportSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PIClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreatePerformanceAnalysisReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePerformanceAnalysisReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDimensionKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDimensionKeyDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPerformanceAnalysisReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAvailableResourceDimensionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAvailableResourceMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPerformanceAnalysisReportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceError.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotAuthorizedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotAuthorizedException {
        let reader = baseError.errorBodyReader
        var value = NotAuthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceError {
        let reader = baseError.errorBodyReader
        var value = InternalServiceError()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PIClientTypes.ResponsePartitionKey {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.ResponsePartitionKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.ResponsePartitionKey()
        value.dimensions = try reader["Dimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PIClientTypes.DimensionKeyDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.DimensionKeyDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.DimensionKeyDescription()
        value.dimensions = try reader["Dimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.total = try reader["Total"].readIfPresent()
        value.additionalMetrics = try reader["AdditionalMetrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.partitions = try reader["Partitions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.DimensionKeyDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.DimensionKeyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.DimensionKeyDetail()
        value.value = try reader["Value"].readIfPresent()
        value.dimension = try reader["Dimension"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension PIClientTypes.AnalysisReport {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.AnalysisReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.AnalysisReport()
        value.analysisReportId = try reader["AnalysisReportId"].readIfPresent() ?? ""
        value.identifier = try reader["Identifier"].readIfPresent()
        value.serviceType = try reader["ServiceType"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.insights = try reader["Insights"].readListIfPresent(memberReadingClosure: PIClientTypes.Insight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.Insight {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.Insight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.Insight()
        value.insightId = try reader["InsightId"].readIfPresent() ?? ""
        value.insightType = try reader["InsightType"].readIfPresent()
        value.context = try reader["Context"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.severity = try reader["Severity"].readIfPresent()
        value.supportingInsights = try reader["SupportingInsights"].readListIfPresent(memberReadingClosure: PIClientTypes.Insight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readIfPresent()
        value.recommendations = try reader["Recommendations"].readListIfPresent(memberReadingClosure: PIClientTypes.Recommendation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.insightData = try reader["InsightData"].readListIfPresent(memberReadingClosure: PIClientTypes.Data.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.baselineData = try reader["BaselineData"].readListIfPresent(memberReadingClosure: PIClientTypes.Data.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.Data {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.Data {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.Data()
        value.performanceInsightsMetric = try reader["PerformanceInsightsMetric"].readIfPresent(with: PIClientTypes.PerformanceInsightsMetric.read(from:))
        return value
    }
}

extension PIClientTypes.PerformanceInsightsMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.PerformanceInsightsMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.PerformanceInsightsMetric()
        value.metric = try reader["Metric"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension PIClientTypes.Recommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.Recommendation()
        value.recommendationId = try reader["RecommendationId"].readIfPresent()
        value.recommendationDescription = try reader["RecommendationDescription"].readIfPresent()
        return value
    }
}

extension PIClientTypes.FeatureMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.FeatureMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.FeatureMetadata()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension PIClientTypes.MetricKeyDataPoints {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.MetricKeyDataPoints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.MetricKeyDataPoints()
        value.key = try reader["Key"].readIfPresent(with: PIClientTypes.ResponseResourceMetricKey.read(from:))
        value.dataPoints = try reader["DataPoints"].readListIfPresent(memberReadingClosure: PIClientTypes.DataPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.DataPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.DataPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.DataPoint()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension PIClientTypes.ResponseResourceMetricKey {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.ResponseResourceMetricKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.ResponseResourceMetricKey()
        value.metric = try reader["Metric"].readIfPresent() ?? ""
        value.dimensions = try reader["Dimensions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PIClientTypes.MetricDimensionGroups {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.MetricDimensionGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.MetricDimensionGroups()
        value.metric = try reader["Metric"].readIfPresent()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: PIClientTypes.DimensionGroupDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.DimensionGroupDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.DimensionGroupDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.DimensionGroupDetail()
        value.group = try reader["Group"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: PIClientTypes.DimensionDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.DimensionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.DimensionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.DimensionDetail()
        value.identifier = try reader["Identifier"].readIfPresent()
        return value
    }
}

extension PIClientTypes.ResponseResourceMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.ResponseResourceMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.ResponseResourceMetric()
        value.metric = try reader["Metric"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension PIClientTypes.AnalysisReportSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.AnalysisReportSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.AnalysisReportSummary()
        value.analysisReportId = try reader["AnalysisReportId"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PIClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PIClientTypes.Tag {

    static func write(value: PIClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PIClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PIClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PIClientTypes.DimensionGroup {

    static func write(value: PIClientTypes.DimensionGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Group"].write(value.group)
        try writer["Limit"].write(value.limit)
    }
}

extension PIClientTypes.MetricQuery {

    static func write(value: PIClientTypes.MetricQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].writeMap(value.filter, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["GroupBy"].write(value.groupBy, with: PIClientTypes.DimensionGroup.write(value:to:))
        try writer["Metric"].write(value.metric)
    }
}

public enum PIClientTypes {}
