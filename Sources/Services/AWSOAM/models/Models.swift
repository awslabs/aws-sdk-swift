// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.amznErrorType = amznErrorTypeHeaderValue
        } else {
            self.properties.amznErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelTemplate = "LabelTemplate"
        case resourceTypes = "ResourceTypes"
        case sinkIdentifier = "SinkIdentifier"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelTemplate = self.labelTemplate {
            try encodeContainer.encode(labelTemplate, forKey: .labelTemplate)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetype0.rawValue)
            }
        }
        if let sinkIdentifier = self.sinkIdentifier {
            try encodeContainer.encode(sinkIdentifier, forKey: .sinkIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMapInput0) in tags {
                try tagsContainer.encode(tagMapInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLink"
    }
}

public struct CreateLinkInput: Swift.Equatable {
    /// Specify a friendly human-readable name to use to identify this source account when you are viewing data from it in the monitoring account. You can use a custom label or use the following variables:
    ///
    /// * $AccountName is the name of the account
    ///
    /// * $AccountEmail is the globally unique email address of the account
    ///
    /// * $AccountEmailNoDomain is the email address of the account without the domain name
    /// This member is required.
    public var labelTemplate: Swift.String?
    /// An array of strings that define which types of data that the source account shares with the monitoring account.
    /// This member is required.
    public var resourceTypes: [OAMClientTypes.ResourceType]?
    /// The ARN of the sink to use to create this link. You can use [ListSinks](https://docs.aws.amazon.com/OAM/latest/APIReference/API_ListSinks.html) to find the ARNs of sinks. For more information about sinks, see [CreateSink](https://docs.aws.amazon.com/OAM/latest/APIReference/API_CreateSink.html).
    /// This member is required.
    public var sinkIdentifier: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the link. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. For more information about using tags to control access, see [Controlling access to Amazon Web Services resources using tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        labelTemplate: Swift.String? = nil,
        resourceTypes: [OAMClientTypes.ResourceType]? = nil,
        sinkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.labelTemplate = labelTemplate
        self.resourceTypes = resourceTypes
        self.sinkIdentifier = sinkIdentifier
        self.tags = tags
    }
}

struct CreateLinkInputBody: Swift.Equatable {
    let labelTemplate: Swift.String?
    let resourceTypes: [OAMClientTypes.ResourceType]?
    let sinkIdentifier: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelTemplate = "LabelTemplate"
        case resourceTypes = "ResourceTypes"
        case sinkIdentifier = "SinkIdentifier"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTemplate)
        labelTemplate = labelTemplateDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([OAMClientTypes.ResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[OAMClientTypes.ResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [OAMClientTypes.ResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let sinkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkIdentifier)
        sinkIdentifier = sinkIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.label = output.label
            self.labelTemplate = output.labelTemplate
            self.resourceTypes = output.resourceTypes
            self.sinkArn = output.sinkArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.label = nil
            self.labelTemplate = nil
            self.resourceTypes = nil
            self.sinkArn = nil
            self.tags = nil
        }
    }
}

public struct CreateLinkOutput: Swift.Equatable {
    /// The ARN of the link that is newly created.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the link ARN.
    public var id: Swift.String?
    /// The label that you assigned to this link. If the labelTemplate includes variables, this field displays the variables resolved to their actual values.
    public var label: Swift.String?
    /// The exact label template that you specified, with the variables not resolved.
    public var labelTemplate: Swift.String?
    /// The resource types supported by this link.
    public var resourceTypes: [Swift.String]?
    /// The ARN of the sink that is used for this link.
    public var sinkArn: Swift.String?
    /// The tags assigned to the link.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        label: Swift.String? = nil,
        labelTemplate: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil,
        sinkArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.label = label
        self.labelTemplate = labelTemplate
        self.resourceTypes = resourceTypes
        self.sinkArn = sinkArn
        self.tags = tags
    }
}

struct CreateLinkOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let label: Swift.String?
    let labelTemplate: Swift.String?
    let resourceTypes: [Swift.String]?
    let sinkArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case label = "Label"
        case labelTemplate = "LabelTemplate"
        case resourceTypes = "ResourceTypes"
        case sinkArn = "SinkArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let labelTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTemplate)
        labelTemplate = labelTemplateDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMapInput0) in tags {
                try tagsContainer.encode(tagMapInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateSink"
    }
}

public struct CreateSinkInput: Swift.Equatable {
    /// A name for the sink.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the link. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. For more information about using tags to control access, see [Controlling access to Amazon Web Services resources using tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

struct CreateSinkInputBody: Swift.Equatable {
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct CreateSinkOutput: Swift.Equatable {
    /// The ARN of the sink that is newly created.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var id: Swift.String?
    /// The name of the sink.
    public var name: Swift.String?
    /// The tags assigned to the sink.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.tags = tags
    }
}

struct CreateSinkOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateSinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLink"
    }
}

public struct DeleteLinkInput: Swift.Equatable {
    /// The ARN of the link to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteLinkInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLinkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteSinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSink"
    }
}

public struct DeleteSinkInput: Swift.Equatable {
    /// The ARN of the sink to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteSinkInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteSinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteSinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSinkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLink"
    }
}

public struct GetLinkInput: Swift.Equatable {
    /// The ARN of the link to retrieve information for.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetLinkInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.label = output.label
            self.labelTemplate = output.labelTemplate
            self.resourceTypes = output.resourceTypes
            self.sinkArn = output.sinkArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.label = nil
            self.labelTemplate = nil
            self.resourceTypes = nil
            self.sinkArn = nil
            self.tags = nil
        }
    }
}

public struct GetLinkOutput: Swift.Equatable {
    /// The ARN of the link.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the link ARN.
    public var id: Swift.String?
    /// The label that you assigned to this link, with the variables resolved to their actual values.
    public var label: Swift.String?
    /// The exact label template that was specified when the link was created, with the template variables not resolved.
    public var labelTemplate: Swift.String?
    /// The resource types supported by this link.
    public var resourceTypes: [Swift.String]?
    /// The ARN of the sink that is used for this link.
    public var sinkArn: Swift.String?
    /// The tags assigned to the link.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        label: Swift.String? = nil,
        labelTemplate: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil,
        sinkArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.label = label
        self.labelTemplate = labelTemplate
        self.resourceTypes = resourceTypes
        self.sinkArn = sinkArn
        self.tags = tags
    }
}

struct GetLinkOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let label: Swift.String?
    let labelTemplate: Swift.String?
    let resourceTypes: [Swift.String]?
    let sinkArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case label = "Label"
        case labelTemplate = "LabelTemplate"
        case resourceTypes = "ResourceTypes"
        case sinkArn = "SinkArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let labelTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTemplate)
        labelTemplate = labelTemplateDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetSinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetSink"
    }
}

public struct GetSinkInput: Swift.Equatable {
    /// The ARN of the sink to retrieve information for.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetSinkInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetSinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetSinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetSinkOutput: Swift.Equatable {
    /// The ARN of the sink.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var id: Swift.String?
    /// The name of the sink.
    public var name: Swift.String?
    /// The tags assigned to the sink.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.tags = tags
    }
}

struct GetSinkOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSinkPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sinkIdentifier = "SinkIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sinkIdentifier = self.sinkIdentifier {
            try encodeContainer.encode(sinkIdentifier, forKey: .sinkIdentifier)
        }
    }
}

extension GetSinkPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetSinkPolicy"
    }
}

public struct GetSinkPolicyInput: Swift.Equatable {
    /// The ARN of the sink to retrieve the policy of.
    /// This member is required.
    public var sinkIdentifier: Swift.String?

    public init(
        sinkIdentifier: Swift.String? = nil
    )
    {
        self.sinkIdentifier = sinkIdentifier
    }
}

struct GetSinkPolicyInputBody: Swift.Equatable {
    let sinkIdentifier: Swift.String?
}

extension GetSinkPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sinkIdentifier = "SinkIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkIdentifier)
        sinkIdentifier = sinkIdentifierDecoded
    }
}

extension GetSinkPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSinkPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.sinkArn = output.sinkArn
            self.sinkId = output.sinkId
        } else {
            self.policy = nil
            self.sinkArn = nil
            self.sinkId = nil
        }
    }
}

public struct GetSinkPolicyOutput: Swift.Equatable {
    /// The policy that you specified, in JSON format.
    public var policy: Swift.String?
    /// The ARN of the sink.
    public var sinkArn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var sinkId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.sinkArn = sinkArn
        self.sinkId = sinkId
    }
}

struct GetSinkPolicyOutputBody: Swift.Equatable {
    let sinkArn: Swift.String?
    let sinkId: Swift.String?
    let policy: Swift.String?
}

extension GetSinkPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case sinkArn = "SinkArn"
        case sinkId = "SinkId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let sinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkId)
        sinkId = sinkIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetSinkPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServiceFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.amznErrorType = amznErrorTypeHeaderValue
        } else {
            self.properties.amznErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServiceFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceFault" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

struct InternalServiceFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.amznErrorType = amznErrorTypeHeaderValue
        } else {
            self.properties.amznErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A parameter is specified incorrectly.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAttachedLinksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sinkIdentifier = "SinkIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sinkIdentifier = self.sinkIdentifier {
            try encodeContainer.encode(sinkIdentifier, forKey: .sinkIdentifier)
        }
    }
}

extension ListAttachedLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAttachedLinks"
    }
}

public struct ListAttachedLinksInput: Swift.Equatable {
    /// Limits the number of returned links to the specified number.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You received this token from a previous call.
    public var nextToken: Swift.String?
    /// The ARN of the sink that you want to retrieve links for.
    /// This member is required.
    public var sinkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sinkIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sinkIdentifier = sinkIdentifier
    }
}

struct ListAttachedLinksInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let sinkIdentifier: Swift.String?
}

extension ListAttachedLinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sinkIdentifier = "SinkIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sinkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkIdentifier)
        sinkIdentifier = sinkIdentifierDecoded
    }
}

extension OAMClientTypes.ListAttachedLinksItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
        case linkArn = "LinkArn"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let linkArn = self.linkArn {
            try encodeContainer.encode(linkArn, forKey: .linkArn)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for string0 in resourceTypes {
                try resourceTypesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let linkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkArn)
        linkArn = linkArnDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension OAMClientTypes {
    /// A structure that contains information about one link attached to this monitoring account sink.
    public struct ListAttachedLinksItem: Swift.Equatable {
        /// The label that was assigned to this link at creation, with the variables resolved to their actual values.
        public var label: Swift.String?
        /// The ARN of the link.
        public var linkArn: Swift.String?
        /// The resource types supported by this link.
        public var resourceTypes: [Swift.String]?

        public init(
            label: Swift.String? = nil,
            linkArn: Swift.String? = nil,
            resourceTypes: [Swift.String]? = nil
        )
        {
            self.label = label
            self.linkArn = linkArn
            self.resourceTypes = resourceTypes
        }
    }

}

extension ListAttachedLinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttachedLinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttachedLinksOutput: Swift.Equatable {
    /// An array of structures that contain the information about the attached links.
    /// This member is required.
    public var items: [OAMClientTypes.ListAttachedLinksItem]?
    /// The token to use when requesting the next set of links.
    public var nextToken: Swift.String?

    public init(
        items: [OAMClientTypes.ListAttachedLinksItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAttachedLinksOutputBody: Swift.Equatable {
    let items: [OAMClientTypes.ListAttachedLinksItem]?
    let nextToken: Swift.String?
}

extension ListAttachedLinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OAMClientTypes.ListAttachedLinksItem?].self, forKey: .items)
        var itemsDecoded0:[OAMClientTypes.ListAttachedLinksItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OAMClientTypes.ListAttachedLinksItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttachedLinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLinksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLinks"
    }
}

public struct ListLinksInput: Swift.Equatable {
    /// Limits the number of returned links to the specified number.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You received this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLinksInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OAMClientTypes.ListLinksItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case label = "Label"
        case resourceTypes = "ResourceTypes"
        case sinkArn = "SinkArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for string0 in resourceTypes {
                try resourceTypesContainer.encode(string0)
            }
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
    }
}

extension OAMClientTypes {
    /// A structure that contains information about one of this source account's links to a monitoring account.
    public struct ListLinksItem: Swift.Equatable {
        /// The ARN of the link.
        public var arn: Swift.String?
        /// The random ID string that Amazon Web Services generated as part of the link ARN.
        public var id: Swift.String?
        /// The label that was assigned to this link at creation, with the variables resolved to their actual values.
        public var label: Swift.String?
        /// The resource types supported by this link.
        public var resourceTypes: [Swift.String]?
        /// The ARN of the sink that this link is attached to.
        public var sinkArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            label: Swift.String? = nil,
            resourceTypes: [Swift.String]? = nil,
            sinkArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.label = label
            self.resourceTypes = resourceTypes
            self.sinkArn = sinkArn
        }
    }

}

extension ListLinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListLinksOutput: Swift.Equatable {
    /// An array of structures that contain the information about the returned links.
    /// This member is required.
    public var items: [OAMClientTypes.ListLinksItem]?
    /// The token to use when requesting the next set of links.
    public var nextToken: Swift.String?

    public init(
        items: [OAMClientTypes.ListLinksItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListLinksOutputBody: Swift.Equatable {
    let items: [OAMClientTypes.ListLinksItem]?
    let nextToken: Swift.String?
}

extension ListLinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OAMClientTypes.ListLinksItem?].self, forKey: .items)
        var itemsDecoded0:[OAMClientTypes.ListLinksItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OAMClientTypes.ListLinksItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSinksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListSinks"
    }
}

public struct ListSinksInput: Swift.Equatable {
    /// Limits the number of returned links to the specified number.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You received this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSinksInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OAMClientTypes.ListSinksItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension OAMClientTypes {
    /// A structure that contains information about one of this monitoring account's sinks.
    public struct ListSinksItem: Swift.Equatable {
        /// The ARN of the sink.
        public var arn: Swift.String?
        /// The random ID string that Amazon Web Services generated as part of the sink ARN.
        public var id: Swift.String?
        /// The name of the sink.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ListSinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSinksOutput: Swift.Equatable {
    /// An array of structures that contain the information about the returned sinks.
    /// This member is required.
    public var items: [OAMClientTypes.ListSinksItem]?
    /// The token to use when requesting the next set of sinks.
    public var nextToken: Swift.String?

    public init(
        items: [OAMClientTypes.ListSinksItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSinksOutputBody: Swift.Equatable {
    let items: [OAMClientTypes.ListSinksItem]?
    let nextToken: Swift.String?
}

extension ListSinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OAMClientTypes.ListSinksItem?].self, forKey: .items)
        var itemsDecoded0:[OAMClientTypes.ListSinksItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OAMClientTypes.ListSinksItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource that you want to view tags for. The ARN format of a sink is arn:aws:oam:Region:account-id:sink/sink-id  The ARN format of a link is arn:aws:oam:Region:account-id:link/link-id  For more information about ARN format, see [CloudWatch Logs resources and operations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html). Unlike tagging permissions in other Amazon Web Services services, to retrieve the list of tags for links or sinks you must have the oam:RequestTag permission. The aws:ReguestTag permission does not allow you to tag and untag links and sinks.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags associated with the requested resource.>
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MissingRequiredParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.amznErrorType = amznErrorTypeHeaderValue
        } else {
            self.properties.amznErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A required parameter is missing from the request.
public struct MissingRequiredParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingRequiredParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingRequiredParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutSinkPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case sinkIdentifier = "SinkIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let sinkIdentifier = self.sinkIdentifier {
            try encodeContainer.encode(sinkIdentifier, forKey: .sinkIdentifier)
        }
    }
}

extension PutSinkPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutSinkPolicy"
    }
}

public struct PutSinkPolicyInput: Swift.Equatable {
    /// The JSON policy to use. If you are updating an existing policy, the entire existing policy is replaced by what you specify here. The policy must be in JSON string format with quotation marks escaped and no newlines. For examples of different types of policies, see the Examples section on this page.
    /// This member is required.
    public var policy: Swift.String?
    /// The ARN of the sink to attach this policy to.
    /// This member is required.
    public var sinkIdentifier: Swift.String?

    public init(
        policy: Swift.String? = nil,
        sinkIdentifier: Swift.String? = nil
    )
    {
        self.policy = policy
        self.sinkIdentifier = sinkIdentifier
    }
}

struct PutSinkPolicyInputBody: Swift.Equatable {
    let sinkIdentifier: Swift.String?
    let policy: Swift.String?
}

extension PutSinkPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case sinkIdentifier = "SinkIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkIdentifier)
        sinkIdentifier = sinkIdentifierDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutSinkPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSinkPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.sinkArn = output.sinkArn
            self.sinkId = output.sinkId
        } else {
            self.policy = nil
            self.sinkArn = nil
            self.sinkId = nil
        }
    }
}

public struct PutSinkPolicyOutput: Swift.Equatable {
    /// The policy that you specified.
    public var policy: Swift.String?
    /// The ARN of the sink.
    public var sinkArn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var sinkId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.sinkArn = sinkArn
        self.sinkId = sinkId
    }
}

struct PutSinkPolicyOutputBody: Swift.Equatable {
    let sinkArn: Swift.String?
    let sinkId: Swift.String?
    let policy: Swift.String?
}

extension PutSinkPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case sinkArn = "SinkArn"
        case sinkId = "SinkId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let sinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkId)
        sinkId = sinkIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum PutSinkPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.amznErrorType = amznErrorTypeHeaderValue
        } else {
            self.properties.amznErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OAMClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsApplicationinsightsApplication
        case awsCloudwatchMetric
        case awsLogsLoggroup
        case awsXrayTrace
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsApplicationinsightsApplication,
                .awsCloudwatchMetric,
                .awsLogsLoggroup,
                .awsXrayTrace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsApplicationinsightsApplication: return "AWS::ApplicationInsights::Application"
            case .awsCloudwatchMetric: return "AWS::CloudWatch::Metric"
            case .awsLogsLoggroup: return "AWS::Logs::LogGroup"
            case .awsXrayTrace: return "AWS::XRay::Trace"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.amznErrorType = amznErrorTypeHeaderValue
        } else {
            self.properties.amznErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMapInput0) in tags {
                try tagsContainer.encode(tagMapInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource that you're adding tags to. The ARN format of a sink is arn:aws:oam:Region:account-id:sink/sink-id  The ARN format of a link is arn:aws:oam:Region:account-id:link/link-id  For more information about ARN format, see [CloudWatch Logs resources and operations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource can have no more than 50 tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource that you're removing tags from. The ARN format of a sink is arn:aws:oam:Region:account-id:sink/sink-id  The ARN format of a link is arn:aws:oam:Region:account-id:link/link-id  For more information about ARN format, see [CloudWatch Logs resources and operations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetype0.rawValue)
            }
        }
    }
}

extension UpdateLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLink"
    }
}

public struct UpdateLinkInput: Swift.Equatable {
    /// The ARN of the link that you want to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// An array of strings that define which types of data that the source account will send to the monitoring account. Your input here replaces the current set of data types that are shared.
    /// This member is required.
    public var resourceTypes: [OAMClientTypes.ResourceType]?

    public init(
        identifier: Swift.String? = nil,
        resourceTypes: [OAMClientTypes.ResourceType]? = nil
    )
    {
        self.identifier = identifier
        self.resourceTypes = resourceTypes
    }
}

struct UpdateLinkInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let resourceTypes: [OAMClientTypes.ResourceType]?
}

extension UpdateLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case resourceTypes = "ResourceTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([OAMClientTypes.ResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[OAMClientTypes.ResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [OAMClientTypes.ResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension UpdateLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.label = output.label
            self.labelTemplate = output.labelTemplate
            self.resourceTypes = output.resourceTypes
            self.sinkArn = output.sinkArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.label = nil
            self.labelTemplate = nil
            self.resourceTypes = nil
            self.sinkArn = nil
            self.tags = nil
        }
    }
}

public struct UpdateLinkOutput: Swift.Equatable {
    /// The ARN of the link that you have updated.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var id: Swift.String?
    /// The label assigned to this link, with the variables resolved to their actual values.
    public var label: Swift.String?
    /// The exact label template that was specified when the link was created, with the template variables not resolved.
    public var labelTemplate: Swift.String?
    /// The resource types now supported by this link.
    public var resourceTypes: [Swift.String]?
    /// The ARN of the sink that is used for this link.
    public var sinkArn: Swift.String?
    /// The tags assigned to the link.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        label: Swift.String? = nil,
        labelTemplate: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil,
        sinkArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.label = label
        self.labelTemplate = labelTemplate
        self.resourceTypes = resourceTypes
        self.sinkArn = sinkArn
        self.tags = tags
    }
}

struct UpdateLinkOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let label: Swift.String?
    let labelTemplate: Swift.String?
    let resourceTypes: [Swift.String]?
    let sinkArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case label = "Label"
        case labelTemplate = "LabelTemplate"
        case resourceTypes = "ResourceTypes"
        case sinkArn = "SinkArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let labelTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTemplate)
        labelTemplate = labelTemplateDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceFault": return try await InternalServiceFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameterException": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
