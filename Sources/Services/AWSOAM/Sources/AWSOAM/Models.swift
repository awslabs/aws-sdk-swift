//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// A resource was in an inconsistent state during an update or a deletion.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// Unexpected error while processing the request. Retry the request.
public struct InternalServiceFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceFault" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// A parameter is specified incorrectly.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// A required parameter is missing from the request.
public struct MissingRequiredParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingRequiredParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

extension OAMClientTypes {
    /// This structure contains the Filter parameter which you can use to specify which log groups are to share log events from this source account to the monitoring account.
    public struct LogGroupConfiguration {
        /// Use this field to specify which log groups are to share their log events with the monitoring account. Use the term LogGroupName and one or more of the following operands. Use single quotation marks (') around log group names. The matching of log group names is case sensitive. Each filter has a limit of five conditional operands. Conditional operands are AND and OR.
        ///
        /// * = and !=
        ///
        /// * AND
        ///
        /// * OR
        ///
        /// * LIKE and NOT LIKE. These can be used only as prefix searches. Include a % at the end of the string that you want to search for and include.
        ///
        /// * IN and NOT IN, using parentheses ( )
        ///
        ///
        /// Examples:
        ///
        /// * LogGroupName IN ('This-Log-Group', 'Other-Log-Group') includes only the log groups with names This-Log-Group and Other-Log-Group.
        ///
        /// * LogGroupName NOT IN ('Private-Log-Group', 'Private-Log-Group-2') includes all log groups except the log groups with names Private-Log-Group and Private-Log-Group-2.
        ///
        /// * LogGroupName LIKE 'aws/lambda/%' OR LogGroupName LIKE 'AWSLogs%' includes all log groups that have names that start with aws/lambda/ or AWSLogs.
        ///
        ///
        /// If you are updating a link that uses filters, you can specify * as the only value for the filter parameter to delete the filter and share all log groups with the monitoring account.
        /// This member is required.
        public var filter: Swift.String?

        public init(
            filter: Swift.String? = nil
        )
        {
            self.filter = filter
        }
    }

}

extension OAMClientTypes {
    /// This structure contains the Filter parameter which you can use to specify which metric namespaces are to be shared from this source account to the monitoring account.
    public struct MetricConfiguration {
        /// Use this field to specify which metrics are to be shared with the monitoring account. Use the term Namespace and one or more of the following operands. Use single quotation marks (') around namespace names. The matching of namespace names is case sensitive. Each filter has a limit of five conditional operands. Conditional operands are AND and OR.
        ///
        /// * = and !=
        ///
        /// * AND
        ///
        /// * OR
        ///
        /// * LIKE and NOT LIKE. These can be used only as prefix searches. Include a % at the end of the string that you want to search for and include.
        ///
        /// * IN and NOT IN, using parentheses ( )
        ///
        ///
        /// Examples:
        ///
        /// * Namespace NOT LIKE 'AWS/%' includes only namespaces that don't start with AWS/, such as custom namespaces.
        ///
        /// * Namespace IN ('AWS/EC2', 'AWS/ELB', 'AWS/S3') includes only the metrics in the EC2, Elastic Load Balancing, and Amazon S3 namespaces.
        ///
        /// * Namespace = 'AWS/EC2' OR Namespace NOT LIKE 'AWS/%' includes only the EC2 namespace and your custom namespaces.
        ///
        ///
        /// If you are updating a link that uses filters, you can specify * as the only value for the filter parameter to delete the filter and share all metric namespaces with the monitoring account.
        /// This member is required.
        public var filter: Swift.String?

        public init(
            filter: Swift.String? = nil
        )
        {
            self.filter = filter
        }
    }

}

extension OAMClientTypes {
    /// Use this structure to optionally create filters that specify that only some metric namespaces or log groups are to be shared from the source account to the monitoring account.
    public struct LinkConfiguration {
        /// Use this structure to filter which log groups are to send log events from the source account to the monitoring account.
        public var logGroupConfiguration: OAMClientTypes.LogGroupConfiguration?
        /// Use this structure to filter which metric namespaces are to be shared from the source account to the monitoring account.
        public var metricConfiguration: OAMClientTypes.MetricConfiguration?

        public init(
            logGroupConfiguration: OAMClientTypes.LogGroupConfiguration? = nil,
            metricConfiguration: OAMClientTypes.MetricConfiguration? = nil
        )
        {
            self.logGroupConfiguration = logGroupConfiguration
            self.metricConfiguration = metricConfiguration
        }
    }

}

extension OAMClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsApplicationinsightsApplication
        case awsCloudwatchMetric
        case awsInternetmonitorMonitor
        case awsLogsLoggroup
        case awsXrayTrace
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsApplicationinsightsApplication,
                .awsCloudwatchMetric,
                .awsInternetmonitorMonitor,
                .awsLogsLoggroup,
                .awsXrayTrace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsApplicationinsightsApplication: return "AWS::ApplicationInsights::Application"
            case .awsCloudwatchMetric: return "AWS::CloudWatch::Metric"
            case .awsInternetmonitorMonitor: return "AWS::InternetMonitor::Monitor"
            case .awsLogsLoggroup: return "AWS::Logs::LogGroup"
            case .awsXrayTrace: return "AWS::XRay::Trace"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLinkInput {
    /// Specify a friendly human-readable name to use to identify this source account when you are viewing data from it in the monitoring account. You can use a custom label or use the following variables:
    ///
    /// * $AccountName is the name of the account
    ///
    /// * $AccountEmail is the globally unique email address of the account
    ///
    /// * $AccountEmailNoDomain is the email address of the account without the domain name
    /// This member is required.
    public var labelTemplate: Swift.String?
    /// Use this structure to optionally create filters that specify that only some metric namespaces or log groups are to be shared from the source account to the monitoring account.
    public var linkConfiguration: OAMClientTypes.LinkConfiguration?
    /// An array of strings that define which types of data that the source account shares with the monitoring account.
    /// This member is required.
    public var resourceTypes: [OAMClientTypes.ResourceType]?
    /// The ARN of the sink to use to create this link. You can use [ListSinks](https://docs.aws.amazon.com/OAM/latest/APIReference/API_ListSinks.html) to find the ARNs of sinks. For more information about sinks, see [CreateSink](https://docs.aws.amazon.com/OAM/latest/APIReference/API_CreateSink.html).
    /// This member is required.
    public var sinkIdentifier: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the link. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. For more information about using tags to control access, see [Controlling access to Amazon Web Services resources using tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        labelTemplate: Swift.String? = nil,
        linkConfiguration: OAMClientTypes.LinkConfiguration? = nil,
        resourceTypes: [OAMClientTypes.ResourceType]? = nil,
        sinkIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.labelTemplate = labelTemplate
        self.linkConfiguration = linkConfiguration
        self.resourceTypes = resourceTypes
        self.sinkIdentifier = sinkIdentifier
        self.tags = tags
    }
}

public struct CreateLinkOutput {
    /// The ARN of the link that is newly created.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the link ARN.
    public var id: Swift.String?
    /// The label that you assigned to this link. If the labelTemplate includes variables, this field displays the variables resolved to their actual values.
    public var label: Swift.String?
    /// The exact label template that you specified, with the variables not resolved.
    public var labelTemplate: Swift.String?
    /// This structure includes filters that specify which metric namespaces and which log groups are shared from the source account to the monitoring account.
    public var linkConfiguration: OAMClientTypes.LinkConfiguration?
    /// The resource types supported by this link.
    public var resourceTypes: [Swift.String]?
    /// The ARN of the sink that is used for this link.
    public var sinkArn: Swift.String?
    /// The tags assigned to the link.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        label: Swift.String? = nil,
        labelTemplate: Swift.String? = nil,
        linkConfiguration: OAMClientTypes.LinkConfiguration? = nil,
        resourceTypes: [Swift.String]? = nil,
        sinkArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.label = label
        self.labelTemplate = labelTemplate
        self.linkConfiguration = linkConfiguration
        self.resourceTypes = resourceTypes
        self.sinkArn = sinkArn
        self.tags = tags
    }
}

public struct CreateSinkInput {
    /// A name for the sink.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the link. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. For more information about using tags to control access, see [Controlling access to Amazon Web Services resources using tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

public struct CreateSinkOutput {
    /// The ARN of the sink that is newly created.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var id: Swift.String?
    /// The name of the sink.
    public var name: Swift.String?
    /// The tags assigned to the sink.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.tags = tags
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

public struct DeleteLinkInput {
    /// The ARN of the link to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteLinkOutput {

    public init() { }
}

public struct DeleteSinkInput {
    /// The ARN of the sink to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteSinkOutput {

    public init() { }
}

public struct GetLinkInput {
    /// The ARN of the link to retrieve information for.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetLinkOutput {
    /// The ARN of the link.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the link ARN.
    public var id: Swift.String?
    /// The label that you assigned to this link, with the variables resolved to their actual values.
    public var label: Swift.String?
    /// The exact label template that was specified when the link was created, with the template variables not resolved.
    public var labelTemplate: Swift.String?
    /// This structure includes filters that specify which metric namespaces and which log groups are shared from the source account to the monitoring account.
    public var linkConfiguration: OAMClientTypes.LinkConfiguration?
    /// The resource types supported by this link.
    public var resourceTypes: [Swift.String]?
    /// The ARN of the sink that is used for this link.
    public var sinkArn: Swift.String?
    /// The tags assigned to the link.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        label: Swift.String? = nil,
        labelTemplate: Swift.String? = nil,
        linkConfiguration: OAMClientTypes.LinkConfiguration? = nil,
        resourceTypes: [Swift.String]? = nil,
        sinkArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.label = label
        self.labelTemplate = labelTemplate
        self.linkConfiguration = linkConfiguration
        self.resourceTypes = resourceTypes
        self.sinkArn = sinkArn
        self.tags = tags
    }
}

public struct GetSinkInput {
    /// The ARN of the sink to retrieve information for.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetSinkOutput {
    /// The ARN of the sink.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var id: Swift.String?
    /// The name of the sink.
    public var name: Swift.String?
    /// The tags assigned to the sink.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.tags = tags
    }
}

public struct GetSinkPolicyInput {
    /// The ARN of the sink to retrieve the policy of.
    /// This member is required.
    public var sinkIdentifier: Swift.String?

    public init(
        sinkIdentifier: Swift.String? = nil
    )
    {
        self.sinkIdentifier = sinkIdentifier
    }
}

public struct GetSinkPolicyOutput {
    /// The policy that you specified, in JSON format.
    public var policy: Swift.String?
    /// The ARN of the sink.
    public var sinkArn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var sinkId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.sinkArn = sinkArn
        self.sinkId = sinkId
    }
}

public struct ListAttachedLinksInput {
    /// Limits the number of returned links to the specified number.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You received this token from a previous call.
    public var nextToken: Swift.String?
    /// The ARN of the sink that you want to retrieve links for.
    /// This member is required.
    public var sinkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sinkIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sinkIdentifier = sinkIdentifier
    }
}

extension OAMClientTypes {
    /// A structure that contains information about one link attached to this monitoring account sink.
    public struct ListAttachedLinksItem {
        /// The label that was assigned to this link at creation, with the variables resolved to their actual values.
        public var label: Swift.String?
        /// The ARN of the link.
        public var linkArn: Swift.String?
        /// The resource types supported by this link.
        public var resourceTypes: [Swift.String]?

        public init(
            label: Swift.String? = nil,
            linkArn: Swift.String? = nil,
            resourceTypes: [Swift.String]? = nil
        )
        {
            self.label = label
            self.linkArn = linkArn
            self.resourceTypes = resourceTypes
        }
    }

}

public struct ListAttachedLinksOutput {
    /// An array of structures that contain the information about the attached links.
    /// This member is required.
    public var items: [OAMClientTypes.ListAttachedLinksItem]?
    /// The token to use when requesting the next set of links.
    public var nextToken: Swift.String?

    public init(
        items: [OAMClientTypes.ListAttachedLinksItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListLinksInput {
    /// Limits the number of returned links to the specified number.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You received this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OAMClientTypes {
    /// A structure that contains information about one of this source account's links to a monitoring account.
    public struct ListLinksItem {
        /// The ARN of the link.
        public var arn: Swift.String?
        /// The random ID string that Amazon Web Services generated as part of the link ARN.
        public var id: Swift.String?
        /// The label that was assigned to this link at creation, with the variables resolved to their actual values.
        public var label: Swift.String?
        /// The resource types supported by this link.
        public var resourceTypes: [Swift.String]?
        /// The ARN of the sink that this link is attached to.
        public var sinkArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            label: Swift.String? = nil,
            resourceTypes: [Swift.String]? = nil,
            sinkArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.label = label
            self.resourceTypes = resourceTypes
            self.sinkArn = sinkArn
        }
    }

}

public struct ListLinksOutput {
    /// An array of structures that contain the information about the returned links.
    /// This member is required.
    public var items: [OAMClientTypes.ListLinksItem]?
    /// The token to use when requesting the next set of links.
    public var nextToken: Swift.String?

    public init(
        items: [OAMClientTypes.ListLinksItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListSinksInput {
    /// Limits the number of returned links to the specified number.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. You received this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OAMClientTypes {
    /// A structure that contains information about one of this monitoring account's sinks.
    public struct ListSinksItem {
        /// The ARN of the sink.
        public var arn: Swift.String?
        /// The random ID string that Amazon Web Services generated as part of the sink ARN.
        public var id: Swift.String?
        /// The name of the sink.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

public struct ListSinksOutput {
    /// An array of structures that contain the information about the returned sinks.
    /// This member is required.
    public var items: [OAMClientTypes.ListSinksItem]?
    /// The token to use when requesting the next set of sinks.
    public var nextToken: Swift.String?

    public init(
        items: [OAMClientTypes.ListSinksItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

/// The value of a parameter in the request caused an error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource that you want to view tags for. The ARN format of a sink is arn:aws:oam:Region:account-id:sink/sink-id  The ARN format of a link is arn:aws:oam:Region:account-id:link/link-id  For more information about ARN format, see [CloudWatch Logs resources and operations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html). Unlike tagging permissions in other Amazon Web Services services, to retrieve the list of tags for links or sinks you must have the oam:RequestTag permission. The aws:ReguestTag permission does not allow you to tag and untag links and sinks.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags associated with the requested resource.>
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutSinkPolicyInput {
    /// The JSON policy to use. If you are updating an existing policy, the entire existing policy is replaced by what you specify here. The policy must be in JSON string format with quotation marks escaped and no newlines. For examples of different types of policies, see the Examples section on this page.
    /// This member is required.
    public var policy: Swift.String?
    /// The ARN of the sink to attach this policy to.
    /// This member is required.
    public var sinkIdentifier: Swift.String?

    public init(
        policy: Swift.String? = nil,
        sinkIdentifier: Swift.String? = nil
    )
    {
        self.policy = policy
        self.sinkIdentifier = sinkIdentifier
    }
}

public struct PutSinkPolicyOutput {
    /// The policy that you specified.
    public var policy: Swift.String?
    /// The ARN of the sink.
    public var sinkArn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var sinkId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.sinkArn = sinkArn
        self.sinkId = sinkId
    }
}

/// A resource can have no more than 50 tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput {
    /// The ARN of the resource that you're adding tags to. The ARN format of a sink is arn:aws:oam:Region:account-id:sink/sink-id  The ARN format of a link is arn:aws:oam:Region:account-id:link/link-id  For more information about ARN format, see [CloudWatch Logs resources and operations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the resource that you're removing tags from. The ARN format of a sink is arn:aws:oam:Region:account-id:sink/sink-id  The ARN format of a link is arn:aws:oam:Region:account-id:link/link-id  For more information about ARN format, see [CloudWatch Logs resources and operations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateLinkInput {
    /// The ARN of the link that you want to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// Use this structure to filter which metric namespaces and which log groups are to be shared from the source account to the monitoring account.
    public var linkConfiguration: OAMClientTypes.LinkConfiguration?
    /// An array of strings that define which types of data that the source account will send to the monitoring account. Your input here replaces the current set of data types that are shared.
    /// This member is required.
    public var resourceTypes: [OAMClientTypes.ResourceType]?

    public init(
        identifier: Swift.String? = nil,
        linkConfiguration: OAMClientTypes.LinkConfiguration? = nil,
        resourceTypes: [OAMClientTypes.ResourceType]? = nil
    )
    {
        self.identifier = identifier
        self.linkConfiguration = linkConfiguration
        self.resourceTypes = resourceTypes
    }
}

public struct UpdateLinkOutput {
    /// The ARN of the link that you have updated.
    public var arn: Swift.String?
    /// The random ID string that Amazon Web Services generated as part of the sink ARN.
    public var id: Swift.String?
    /// The label assigned to this link, with the variables resolved to their actual values.
    public var label: Swift.String?
    /// The exact label template that was specified when the link was created, with the template variables not resolved.
    public var labelTemplate: Swift.String?
    /// This structure includes filters that specify which metric namespaces and which log groups are shared from the source account to the monitoring account.
    public var linkConfiguration: OAMClientTypes.LinkConfiguration?
    /// The resource types now supported by this link.
    public var resourceTypes: [Swift.String]?
    /// The ARN of the sink that is used for this link.
    public var sinkArn: Swift.String?
    /// The tags assigned to the link.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        label: Swift.String? = nil,
        labelTemplate: Swift.String? = nil,
        linkConfiguration: OAMClientTypes.LinkConfiguration? = nil,
        resourceTypes: [Swift.String]? = nil,
        sinkArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.label = label
        self.labelTemplate = labelTemplate
        self.linkConfiguration = linkConfiguration
        self.resourceTypes = resourceTypes
        self.sinkArn = sinkArn
        self.tags = tags
    }
}

extension CreateLinkInput {

    static func urlPathProvider(_ value: CreateLinkInput) -> Swift.String? {
        return "/CreateLink"
    }
}

extension CreateSinkInput {

    static func urlPathProvider(_ value: CreateSinkInput) -> Swift.String? {
        return "/CreateSink"
    }
}

extension DeleteLinkInput {

    static func urlPathProvider(_ value: DeleteLinkInput) -> Swift.String? {
        return "/DeleteLink"
    }
}

extension DeleteSinkInput {

    static func urlPathProvider(_ value: DeleteSinkInput) -> Swift.String? {
        return "/DeleteSink"
    }
}

extension GetLinkInput {

    static func urlPathProvider(_ value: GetLinkInput) -> Swift.String? {
        return "/GetLink"
    }
}

extension GetSinkInput {

    static func urlPathProvider(_ value: GetSinkInput) -> Swift.String? {
        return "/GetSink"
    }
}

extension GetSinkPolicyInput {

    static func urlPathProvider(_ value: GetSinkPolicyInput) -> Swift.String? {
        return "/GetSinkPolicy"
    }
}

extension ListAttachedLinksInput {

    static func urlPathProvider(_ value: ListAttachedLinksInput) -> Swift.String? {
        return "/ListAttachedLinks"
    }
}

extension ListLinksInput {

    static func urlPathProvider(_ value: ListLinksInput) -> Swift.String? {
        return "/ListLinks"
    }
}

extension ListSinksInput {

    static func urlPathProvider(_ value: ListSinksInput) -> Swift.String? {
        return "/ListSinks"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutSinkPolicyInput {

    static func urlPathProvider(_ value: PutSinkPolicyInput) -> Swift.String? {
        return "/PutSinkPolicy"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLinkInput {

    static func urlPathProvider(_ value: UpdateLinkInput) -> Swift.String? {
        return "/UpdateLink"
    }
}

extension CreateLinkInput {

    static func write(value: CreateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LabelTemplate"].write(value.labelTemplate)
        try writer["LinkConfiguration"].write(value.linkConfiguration, with: OAMClientTypes.LinkConfiguration.write(value:to:))
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<OAMClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SinkIdentifier"].write(value.sinkIdentifier)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSinkInput {

    static func write(value: CreateSinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteLinkInput {

    static func write(value: DeleteLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
    }
}

extension DeleteSinkInput {

    static func write(value: DeleteSinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetLinkInput {

    static func write(value: GetLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetSinkInput {

    static func write(value: GetSinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetSinkPolicyInput {

    static func write(value: GetSinkPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SinkIdentifier"].write(value.sinkIdentifier)
    }
}

extension ListAttachedLinksInput {

    static func write(value: ListAttachedLinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SinkIdentifier"].write(value.sinkIdentifier)
    }
}

extension ListLinksInput {

    static func write(value: ListLinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListSinksInput {

    static func write(value: ListSinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PutSinkPolicyInput {

    static func write(value: PutSinkPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["SinkIdentifier"].write(value.sinkIdentifier)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLinkInput {

    static func write(value: UpdateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
        try writer["LinkConfiguration"].write(value.linkConfiguration, with: OAMClientTypes.LinkConfiguration.write(value:to:))
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<OAMClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLinkOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.labelTemplate = try reader["LabelTemplate"].readIfPresent()
        value.linkConfiguration = try reader["LinkConfiguration"].readIfPresent(with: OAMClientTypes.LinkConfiguration.read(from:))
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateSinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSinkOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DeleteLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLinkOutput {
        return DeleteLinkOutput()
    }
}

extension DeleteSinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSinkOutput {
        return DeleteSinkOutput()
    }
}

extension GetLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLinkOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.labelTemplate = try reader["LabelTemplate"].readIfPresent()
        value.linkConfiguration = try reader["LinkConfiguration"].readIfPresent(with: OAMClientTypes.LinkConfiguration.read(from:))
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSinkOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSinkPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSinkPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSinkPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.sinkId = try reader["SinkId"].readIfPresent()
        return value
    }
}

extension ListAttachedLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachedLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttachedLinksOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: OAMClientTypes.ListAttachedLinksItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLinksOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: OAMClientTypes.ListLinksItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSinksOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: OAMClientTypes.ListSinksItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutSinkPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSinkPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSinkPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.sinkId = try reader["SinkId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLinkOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.labelTemplate = try reader["LabelTemplate"].readIfPresent()
        value.linkConfiguration = try reader["LinkConfiguration"].readIfPresent(with: OAMClientTypes.LinkConfiguration.read(from:))
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

enum CreateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSinkPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachedLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSinkPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceFault": return try InternalServiceFault.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameterException": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ConflictException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ServiceQuotaExceededException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceFault {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceFault {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServiceFault()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MissingRequiredParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MissingRequiredParameterException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = MissingRequiredParameterException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InvalidParameterException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ResourceNotFoundException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OAMClientTypes.LinkConfiguration {

    static func write(value: OAMClientTypes.LinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogGroupConfiguration"].write(value.logGroupConfiguration, with: OAMClientTypes.LogGroupConfiguration.write(value:to:))
        try writer["MetricConfiguration"].write(value.metricConfiguration, with: OAMClientTypes.MetricConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OAMClientTypes.LinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OAMClientTypes.LinkConfiguration()
        value.logGroupConfiguration = try reader["LogGroupConfiguration"].readIfPresent(with: OAMClientTypes.LogGroupConfiguration.read(from:))
        value.metricConfiguration = try reader["MetricConfiguration"].readIfPresent(with: OAMClientTypes.MetricConfiguration.read(from:))
        return value
    }
}

extension OAMClientTypes.MetricConfiguration {

    static func write(value: OAMClientTypes.MetricConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OAMClientTypes.MetricConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OAMClientTypes.MetricConfiguration()
        value.filter = try reader["Filter"].readIfPresent() ?? ""
        return value
    }
}

extension OAMClientTypes.LogGroupConfiguration {

    static func write(value: OAMClientTypes.LogGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OAMClientTypes.LogGroupConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OAMClientTypes.LogGroupConfiguration()
        value.filter = try reader["Filter"].readIfPresent() ?? ""
        return value
    }
}

extension OAMClientTypes.ListAttachedLinksItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OAMClientTypes.ListAttachedLinksItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OAMClientTypes.ListAttachedLinksItem()
        value.label = try reader["Label"].readIfPresent()
        value.linkArn = try reader["LinkArn"].readIfPresent()
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OAMClientTypes.ListLinksItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OAMClientTypes.ListLinksItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OAMClientTypes.ListLinksItem()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        return value
    }
}

extension OAMClientTypes.ListSinksItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OAMClientTypes.ListSinksItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OAMClientTypes.ListSinksItem()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public enum OAMClientTypes {}
