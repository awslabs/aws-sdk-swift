// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpenSearchServerlessClientTypes.AccessPolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .policy)
        policy = policyDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an OpenSearch Serverless access policy.
    public struct AccessPolicyDetail: Swift.Equatable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: ClientRuntime.Document?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of access policy.
        public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: ClientRuntime.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.AccessPolicyStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPolicyCount = "DataPolicyCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPolicyCount = self.dataPolicyCount {
            try encodeContainer.encode(dataPolicyCount, forKey: .dataPolicyCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataPolicyCount)
        dataPolicyCount = dataPolicyCountDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Statistics for an OpenSearch Serverless access policy.
    public struct AccessPolicyStats: Swift.Equatable {
        /// The number of data access policies in the current account.
        public var dataPolicyCount: Swift.Int?

        public init(
            dataPolicyCount: Swift.Int? = nil
        )
        {
            self.dataPolicyCount = dataPolicyCount
        }
    }

}

extension OpenSearchServerlessClientTypes.AccessPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A summary of the data access policy.
    public struct AccessPolicySummary: Swift.Equatable {
        /// The Epoch time when the access policy was created.
        public var createdDate: Swift.Int?
        /// The description of the access policy.
        public var description: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the access policy.
        public var name: Swift.String?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of access policy. Currently the only available type is data.
        public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum AccessPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// data policy type
        case data
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPolicyType] {
            return [
                .data,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .data: return "data"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPolicyType(rawValue: rawValue) ?? AccessPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.AccountSettingsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityLimits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityLimits = self.capacityLimits {
            try encodeContainer.encode(capacityLimits, forKey: .capacityLimits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityLimitsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CapacityLimits.self, forKey: .capacityLimits)
        capacityLimits = capacityLimitsDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// OpenSearch Serverless-related information for the current account.
    public struct AccountSettingsDetail: Swift.Equatable {
        /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Managing capacity limits for Amazon OpenSearch Serverless](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-scaling.html).
        public var capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?

        public init(
            capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits? = nil
        )
        {
            self.capacityLimits = capacityLimits
        }
    }

}

extension BatchGetCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case names
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for collectionid0 in ids {
                try idsContainer.encode(collectionid0)
            }
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for collectionname0 in names {
                try namesContainer.encode(collectionname0)
            }
        }
    }
}

extension BatchGetCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetCollectionInput: Swift.Equatable {
    /// A list of collection IDs. You can't provide names and IDs in the same request. The ID is part of the collection endpoint. You can also retrieve it using the [ListCollections](https://docs.aws.amazon.com/opensearch-service/latest/ServerlessAPIReference/API_ListCollections.html) API.
    public var ids: [Swift.String]?
    /// A list of collection names. You can't provide names and IDs in the same request.
    public var names: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.names = names
    }
}

struct BatchGetCollectionInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let names: [Swift.String]?
}

extension BatchGetCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case names
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectionDetails = output.collectionDetails
            self.collectionErrorDetails = output.collectionErrorDetails
        } else {
            self.collectionDetails = nil
            self.collectionErrorDetails = nil
        }
    }
}

public struct BatchGetCollectionOutput: Swift.Equatable {
    /// Details about each collection.
    public var collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]?
    /// Error information for the request.
    public var collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]?

    public init(
        collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]? = nil,
        collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]? = nil
    )
    {
        self.collectionDetails = collectionDetails
        self.collectionErrorDetails = collectionErrorDetails
    }
}

struct BatchGetCollectionOutputBody: Swift.Equatable {
    let collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]?
    let collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]?
}

extension BatchGetCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionDetails
        case collectionErrorDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.CollectionDetail?].self, forKey: .collectionDetails)
        var collectionDetailsDecoded0:[OpenSearchServerlessClientTypes.CollectionDetail]? = nil
        if let collectionDetailsContainer = collectionDetailsContainer {
            collectionDetailsDecoded0 = [OpenSearchServerlessClientTypes.CollectionDetail]()
            for structure0 in collectionDetailsContainer {
                if let structure0 = structure0 {
                    collectionDetailsDecoded0?.append(structure0)
                }
            }
        }
        collectionDetails = collectionDetailsDecoded0
        let collectionErrorDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.CollectionErrorDetail?].self, forKey: .collectionErrorDetails)
        var collectionErrorDetailsDecoded0:[OpenSearchServerlessClientTypes.CollectionErrorDetail]? = nil
        if let collectionErrorDetailsContainer = collectionErrorDetailsContainer {
            collectionErrorDetailsDecoded0 = [OpenSearchServerlessClientTypes.CollectionErrorDetail]()
            for structure0 in collectionErrorDetailsContainer {
                if let structure0 = structure0 {
                    collectionErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        collectionErrorDetails = collectionErrorDetailsDecoded0
    }
}

enum BatchGetCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for vpcendpointid0 in ids {
                try idsContainer.encode(vpcendpointid0)
            }
        }
    }
}

extension BatchGetVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetVpcEndpointInput: Swift.Equatable {
    /// A list of VPC endpoint identifiers.
    /// This member is required.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetVpcEndpointInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchGetVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetVpcEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetVpcEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.vpcEndpointDetails = output.vpcEndpointDetails
            self.vpcEndpointErrorDetails = output.vpcEndpointErrorDetails
        } else {
            self.vpcEndpointDetails = nil
            self.vpcEndpointErrorDetails = nil
        }
    }
}

public struct BatchGetVpcEndpointOutput: Swift.Equatable {
    /// Details about the specified VPC endpoint.
    public var vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]?
    /// Error information for a failed request.
    public var vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]?

    public init(
        vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]? = nil,
        vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]? = nil
    )
    {
        self.vpcEndpointDetails = vpcEndpointDetails
        self.vpcEndpointErrorDetails = vpcEndpointErrorDetails
    }
}

struct BatchGetVpcEndpointOutputBody: Swift.Equatable {
    let vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]?
    let vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]?
}

extension BatchGetVpcEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcEndpointDetails
        case vpcEndpointErrorDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.VpcEndpointDetail?].self, forKey: .vpcEndpointDetails)
        var vpcEndpointDetailsDecoded0:[OpenSearchServerlessClientTypes.VpcEndpointDetail]? = nil
        if let vpcEndpointDetailsContainer = vpcEndpointDetailsContainer {
            vpcEndpointDetailsDecoded0 = [OpenSearchServerlessClientTypes.VpcEndpointDetail]()
            for structure0 in vpcEndpointDetailsContainer {
                if let structure0 = structure0 {
                    vpcEndpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpointDetails = vpcEndpointDetailsDecoded0
        let vpcEndpointErrorDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.VpcEndpointErrorDetail?].self, forKey: .vpcEndpointErrorDetails)
        var vpcEndpointErrorDetailsDecoded0:[OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]? = nil
        if let vpcEndpointErrorDetailsContainer = vpcEndpointErrorDetailsContainer {
            vpcEndpointErrorDetailsDecoded0 = [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]()
            for structure0 in vpcEndpointErrorDetailsContainer {
                if let structure0 = structure0 {
                    vpcEndpointErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpointErrorDetails = vpcEndpointErrorDetailsDecoded0
    }
}

enum BatchGetVpcEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.CapacityLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxIndexingCapacityInOCU
        case maxSearchCapacityInOCU
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxIndexingCapacityInOCU = self.maxIndexingCapacityInOCU {
            try encodeContainer.encode(maxIndexingCapacityInOCU, forKey: .maxIndexingCapacityInOCU)
        }
        if let maxSearchCapacityInOCU = self.maxSearchCapacityInOCU {
            try encodeContainer.encode(maxSearchCapacityInOCU, forKey: .maxSearchCapacityInOCU)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxIndexingCapacityInOCUDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIndexingCapacityInOCU)
        maxIndexingCapacityInOCU = maxIndexingCapacityInOCUDecoded
        let maxSearchCapacityInOCUDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSearchCapacityInOCU)
        maxSearchCapacityInOCU = maxSearchCapacityInOCUDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Managing capacity limits for Amazon OpenSearch Serverless](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-scaling.html).
    public struct CapacityLimits: Swift.Equatable {
        /// The maximum indexing capacity for collections.
        public var maxIndexingCapacityInOCU: Swift.Int?
        /// The maximum search capacity for collections.
        public var maxSearchCapacityInOCU: Swift.Int?

        public init(
            maxIndexingCapacityInOCU: Swift.Int? = nil,
            maxSearchCapacityInOCU: Swift.Int? = nil
        )
        {
            self.maxIndexingCapacityInOCU = maxIndexingCapacityInOCU
            self.maxSearchCapacityInOCU = maxSearchCapacityInOCU
        }
    }

}

extension OpenSearchServerlessClientTypes.CollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collectionEndpoint
        case createdDate
        case dashboardEndpoint
        case description
        case id
        case kmsKeyArn
        case lastModifiedDate
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collectionEndpoint = self.collectionEndpoint {
            try encodeContainer.encode(collectionEndpoint, forKey: .collectionEndpoint)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let dashboardEndpoint = self.dashboardEndpoint {
            try encodeContainer.encode(dashboardEndpoint, forKey: .dashboardEndpoint)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let collectionEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionEndpoint)
        collectionEndpoint = collectionEndpointDecoded
        let dashboardEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardEndpoint)
        dashboardEndpoint = dashboardEndpointDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about each OpenSearch Serverless collection, including the collection endpoint and the OpenSearch Dashboards endpoint.
    public struct CollectionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// Collection-specific endpoint used to submit index, search, and data upload requests to an OpenSearch Serverless collection.
        public var collectionEndpoint: Swift.String?
        /// The Epoch time when the collection was created.
        public var createdDate: Swift.Int?
        /// Collection-specific endpoint used to access OpenSearch Dashboards.
        public var dashboardEndpoint: Swift.String?
        /// A description of the collection.
        public var description: Swift.String?
        /// A unique identifier for the collection.
        public var id: Swift.String?
        /// The ARN of the Amazon Web Services KMS key used to encrypt the collection.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The type of collection.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init(
            arn: Swift.String? = nil,
            collectionEndpoint: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            dashboardEndpoint: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.collectionEndpoint = collectionEndpoint
            self.createdDate = createdDate
            self.dashboardEndpoint = dashboardEndpoint
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.CollectionErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Error information for an OpenSearch Serverless request.
    public struct CollectionErrorDetail: Swift.Equatable {
        /// The error code for the request. For example, NOT_FOUND.
        public var errorCode: Swift.String?
        /// A description of the error. For example, The specified Collection is not found.
        public var errorMessage: Swift.String?
        /// If the request contains collection IDs, the response includes the IDs provided in the request.
        public var id: Swift.String?
        /// If the request contains collection names, the response includes the names provided in the request.
        public var name: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
        }
    }

}

extension OpenSearchServerlessClientTypes.CollectionFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// List of filter keys that you can use for LIST, UPDATE, and DELETE requests to OpenSearch Serverless collections.
    public struct CollectionFilters: Swift.Equatable {
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init(
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum CollectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Collection resource is ready to use
        case active
        /// Creating collection resource
        case creating
        /// Deleting collection resource
        case deleting
        /// Collection resource create or delete failed
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectionStatus(rawValue: rawValue) ?? CollectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.CollectionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about each OpenSearch Serverless collection.
    public struct CollectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum CollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Search collection type
        case search
        /// Timeseries collection type
        case timeseries
        /// Vectorsearch collection type
        case vectorsearch
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectionType] {
            return [
                .search,
                .timeseries,
                .vectorsearch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .search: return "SEARCH"
            case .timeseries: return "TIMESERIES"
            case .vectorsearch: return "VECTORSEARCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectionType(rawValue: rawValue) ?? CollectionType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// When creating a resource, thrown when a resource with the same name already exists or is being created. When deleting a resource, thrown when the resource is not in the ACTIVE or FAILED state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccessPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

struct CreateAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyDetail = output.accessPolicyDetail
        } else {
            self.accessPolicyDetail = nil
        }
    }
}

public struct CreateAccessPolicyOutput: Swift.Equatable {
    /// Details about the created access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init(
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

struct CreateAccessPolicyOutputBody: Swift.Equatable {
    let accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?
}

extension CreateAccessPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyDetail.self, forKey: .accessPolicyDetail)
        accessPolicyDetail = accessPolicyDetailDecoded
    }
}

enum CreateAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.CreateCollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case description
        case id
        case kmsKeyArn
        case lastModifiedDate
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about the created OpenSearch Serverless collection.
    public struct CreateCollectionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The Epoch time when the collection was created.
        public var createdDate: Swift.Int?
        /// A description of the collection.
        public var description: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the collection.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The type of collection.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init(
            arn: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension CreateCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCollectionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// Description of the collection.
    public var description: Swift.String?
    /// Name of the collection.
    /// This member is required.
    public var name: Swift.String?
    /// An arbitrary set of tags (keyvalue pairs) to associate with the OpenSearch Serverless collection.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?
    /// The type of collection.
    public var type: OpenSearchServerlessClientTypes.CollectionType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil,
        type: OpenSearchServerlessClientTypes.CollectionType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateCollectionInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: OpenSearchServerlessClientTypes.CollectionType?
    let description: Swift.String?
    let tags: [OpenSearchServerlessClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpenSearchServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpenSearchServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createCollectionDetail = output.createCollectionDetail
        } else {
            self.createCollectionDetail = nil
        }
    }
}

public struct CreateCollectionOutput: Swift.Equatable {
    /// Details about the collection.
    public var createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail?

    public init(
        createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail? = nil
    )
    {
        self.createCollectionDetail = createCollectionDetail
    }
}

struct CreateCollectionOutputBody: Swift.Equatable {
    let createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail?
}

extension CreateCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createCollectionDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createCollectionDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CreateCollectionDetail.self, forKey: .createCollectionDetail)
        createCollectionDetail = createCollectionDetailDecoded
    }
}

enum CreateCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OcuLimitExceededException": return try await OcuLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case samlOptions
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let samlOptions = self.samlOptions {
            try encodeContainer.encode(samlOptions, forKey: .samlOptions)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSecurityConfigInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the security configuration.
    public var description: Swift.String?
    /// The name of the security configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Describes SAML options in in the form of a key-value map. This field is required if you specify saml for the type parameter.
    public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    /// The type of security configuration.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil,
        type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.samlOptions = samlOptions
        self.type = type
    }
}

struct CreateSecurityConfigInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityConfigType?
    let name: Swift.String?
    let description: Swift.String?
    let samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    let clientToken: Swift.String?
}

extension CreateSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case samlOptions
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let samlOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SamlConfigOptions.self, forKey: .samlOptions)
        samlOptions = samlOptionsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSecurityConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSecurityConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityConfigDetail = output.securityConfigDetail
        } else {
            self.securityConfigDetail = nil
        }
    }
}

public struct CreateSecurityConfigOutput: Swift.Equatable {
    /// Details about the created security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init(
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

struct CreateSecurityConfigOutputBody: Swift.Equatable {
    let securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?
}

extension CreateSecurityConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityConfigDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigDetail.self, forKey: .securityConfigDetail)
        securityConfigDetail = securityConfigDetailDecoded
    }
}

enum CreateSecurityConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSecurityPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the new policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of security policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

struct CreateSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSecurityPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSecurityPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicyDetail = output.securityPolicyDetail
        } else {
            self.securityPolicyDetail = nil
        }
    }
}

public struct CreateSecurityPolicyOutput: Swift.Equatable {
    /// Details about the created security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init(
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

struct CreateSecurityPolicyOutputBody: Swift.Equatable {
    let securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?
}

extension CreateSecurityPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyDetail.self, forKey: .securityPolicyDetail)
        securityPolicyDetail = securityPolicyDetailDecoded
    }
}

enum CreateSecurityPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.CreateVpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Creation details for an OpenSearch Serverless-managed interface endpoint. For more information, see [Access Amazon OpenSearch Serverless using an interface endpoint](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-vpc.html).
    public struct CreateVpcEndpointDetail: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status in the endpoint creation process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension CreateVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVpcEndpointInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the interface endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var securityGroupIds: [Swift.String]?
    /// The ID of one or more subnets from which you'll access OpenSearch Serverless.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC from which you'll access OpenSearch Serverless.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct CreateVpcEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension CreateVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVpcEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVpcEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.createVpcEndpointDetail = output.createVpcEndpointDetail
        } else {
            self.createVpcEndpointDetail = nil
        }
    }
}

public struct CreateVpcEndpointOutput: Swift.Equatable {
    /// Details about the created interface VPC endpoint.
    public var createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail?

    public init(
        createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail? = nil
    )
    {
        self.createVpcEndpointDetail = createVpcEndpointDetail
    }
}

struct CreateVpcEndpointOutputBody: Swift.Equatable {
    let createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail?
}

extension CreateVpcEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createVpcEndpointDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createVpcEndpointDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CreateVpcEndpointDetail.self, forKey: .createVpcEndpointDetail)
        createVpcEndpointDetail = createVpcEndpointDetailDecoded
    }
}

enum CreateVpcEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DeleteAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

struct DeleteAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.DeleteCollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about a deleted OpenSearch Serverless collection.
    public struct DeleteCollectionDetail: Swift.Equatable {
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension DeleteCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCollectionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the collection. For example, 1iu5usc406kd. The ID is part of the collection endpoint. You can also retrieve it using the [ListCollections](https://docs.aws.amazon.com/opensearch-service/latest/ServerlessAPIReference/API_ListCollections.html) API.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteCollectionInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.deleteCollectionDetail = output.deleteCollectionDetail
        } else {
            self.deleteCollectionDetail = nil
        }
    }
}

public struct DeleteCollectionOutput: Swift.Equatable {
    /// Details of the deleted collection.
    public var deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail?

    public init(
        deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail? = nil
    )
    {
        self.deleteCollectionDetail = deleteCollectionDetail
    }
}

struct DeleteCollectionOutputBody: Swift.Equatable {
    let deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail?
}

extension DeleteCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteCollectionDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteCollectionDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.DeleteCollectionDetail.self, forKey: .deleteCollectionDetail)
        deleteCollectionDetail = deleteCollectionDetailDecoded
    }
}

enum DeleteCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSecurityConfigInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The security configuration identifier. For SAML the ID will be saml/<accountId>/<idpProviderName>. For example, saml/123456789123/OKTADev.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteSecurityConfigInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteSecurityConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSecurityConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSecurityConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DeleteSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSecurityPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

struct DeleteSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteSecurityPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSecurityPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSecurityPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Deletion details for an OpenSearch Serverless-managed interface endpoint.
    public struct DeleteVpcEndpointDetail: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status of the endpoint deletion process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension DeleteVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVpcEndpointInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The VPC endpoint identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteVpcEndpointInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteVpcEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVpcEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.deleteVpcEndpointDetail = output.deleteVpcEndpointDetail
        } else {
            self.deleteVpcEndpointDetail = nil
        }
    }
}

public struct DeleteVpcEndpointOutput: Swift.Equatable {
    /// Details about the deleted endpoint.
    public var deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail?

    public init(
        deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail? = nil
    )
    {
        self.deleteVpcEndpointDetail = deleteVpcEndpointDetail
    }
}

struct DeleteVpcEndpointOutputBody: Swift.Equatable {
    let deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail?
}

extension DeleteVpcEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteVpcEndpointDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteVpcEndpointDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail.self, forKey: .deleteVpcEndpointDetail)
        deleteVpcEndpointDetail = deleteVpcEndpointDetailDecoded
    }
}

enum DeleteVpcEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessPolicyInput: Swift.Equatable {
    /// The name of the access policy.
    /// This member is required.
    public var name: Swift.String?
    /// Tye type of policy. Currently the only supported value is data.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

struct GetAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
}

extension GetAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyDetail = output.accessPolicyDetail
        } else {
            self.accessPolicyDetail = nil
        }
    }
}

public struct GetAccessPolicyOutput: Swift.Equatable {
    /// Details about the requested access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init(
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

struct GetAccessPolicyOutputBody: Swift.Equatable {
    let accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?
}

extension GetAccessPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyDetail.self, forKey: .accessPolicyDetail)
        accessPolicyDetail = accessPolicyDetailDecoded
    }
}

enum GetAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAccountSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettingsDetail = output.accountSettingsDetail
        } else {
            self.accountSettingsDetail = nil
        }
    }
}

public struct GetAccountSettingsOutput: Swift.Equatable {
    /// OpenSearch Serverless-related details for the current account.
    public var accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?

    public init(
        accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail? = nil
    )
    {
        self.accountSettingsDetail = accountSettingsDetail
    }
}

struct GetAccountSettingsOutputBody: Swift.Equatable {
    let accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?
}

extension GetAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettingsDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccountSettingsDetail.self, forKey: .accountSettingsDetail)
        accountSettingsDetail = accountSettingsDetailDecoded
    }
}

enum GetAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPoliciesStatsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetPoliciesStatsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPoliciesStatsInput: Swift.Equatable {

    public init() { }
}

struct GetPoliciesStatsInputBody: Swift.Equatable {
}

extension GetPoliciesStatsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPoliciesStatsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPoliciesStatsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyStats = output.accessPolicyStats
            self.securityConfigStats = output.securityConfigStats
            self.securityPolicyStats = output.securityPolicyStats
            self.totalPolicyCount = output.totalPolicyCount
        } else {
            self.accessPolicyStats = nil
            self.securityConfigStats = nil
            self.securityPolicyStats = nil
            self.totalPolicyCount = nil
        }
    }
}

public struct GetPoliciesStatsOutput: Swift.Equatable {
    /// Information about the data access policies in your account.
    public var accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats?
    /// Information about the security configurations in your account.
    public var securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats?
    /// Information about the security policies in your account.
    public var securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats?
    /// The total number of OpenSearch Serverless security policies and configurations in your account.
    public var totalPolicyCount: Swift.Int?

    public init(
        accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats? = nil,
        securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats? = nil,
        securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats? = nil,
        totalPolicyCount: Swift.Int? = nil
    )
    {
        self.accessPolicyStats = accessPolicyStats
        self.securityConfigStats = securityConfigStats
        self.securityPolicyStats = securityPolicyStats
        self.totalPolicyCount = totalPolicyCount
    }
}

struct GetPoliciesStatsOutputBody: Swift.Equatable {
    let accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats?
    let securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats?
    let securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats?
    let totalPolicyCount: Swift.Int?
}

extension GetPoliciesStatsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyStats = "AccessPolicyStats"
        case securityConfigStats = "SecurityConfigStats"
        case securityPolicyStats = "SecurityPolicyStats"
        case totalPolicyCount = "TotalPolicyCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyStatsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyStats.self, forKey: .accessPolicyStats)
        accessPolicyStats = accessPolicyStatsDecoded
        let securityPolicyStatsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyStats.self, forKey: .securityPolicyStats)
        securityPolicyStats = securityPolicyStatsDecoded
        let securityConfigStatsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigStats.self, forKey: .securityConfigStats)
        securityConfigStats = securityConfigStatsDecoded
        let totalPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalPolicyCount)
        totalPolicyCount = totalPolicyCountDecoded
    }
}

enum GetPoliciesStatsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSecurityConfigInput: Swift.Equatable {
    /// The unique identifier of the security configuration.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSecurityConfigInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetSecurityConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSecurityConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityConfigDetail = output.securityConfigDetail
        } else {
            self.securityConfigDetail = nil
        }
    }
}

public struct GetSecurityConfigOutput: Swift.Equatable {
    /// Details of the requested security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init(
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

struct GetSecurityConfigOutputBody: Swift.Equatable {
    let securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?
}

extension GetSecurityConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityConfigDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigDetail.self, forKey: .securityConfigDetail)
        securityConfigDetail = securityConfigDetailDecoded
    }
}

enum GetSecurityConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSecurityPolicyInput: Swift.Equatable {
    /// The name of the security policy.
    /// This member is required.
    public var name: Swift.String?
    /// The type of security policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

struct GetSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
}

extension GetSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetSecurityPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSecurityPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicyDetail = output.securityPolicyDetail
        } else {
            self.securityPolicyDetail = nil
        }
    }
}

public struct GetSecurityPolicyOutput: Swift.Equatable {
    /// Details about the requested security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init(
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

struct GetSecurityPolicyOutputBody: Swift.Equatable {
    let securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?
}

extension GetSecurityPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyDetail.self, forKey: .securityPolicyDetail)
        securityPolicyDetail = securityPolicyDetailDecoded
    }
}

enum GetSecurityPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when an error internal to the service occurs while processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resource = resource {
            var resourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resource)
            for resource0 in resource {
                try resourceContainer.encode(resource0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListAccessPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessPoliciesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListAccessPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListAccessPolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters (can be collections or indexes) that policies can apply to.
    public var resource: [Swift.String]?
    /// The type of access policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resource: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resource = resource
        self.type = type
    }
}

struct ListAccessPoliciesInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let resource: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAccessPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let resourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resource)
        var resourceDecoded0:[Swift.String]? = nil
        if let resourceContainer = resourceContainer {
            resourceDecoded0 = [Swift.String]()
            for string0 in resourceContainer {
                if let string0 = string0 {
                    resourceDecoded0?.append(string0)
                }
            }
        }
        resource = resourceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAccessPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicySummaries = output.accessPolicySummaries
            self.nextToken = output.nextToken
        } else {
            self.accessPolicySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPoliciesOutput: Swift.Equatable {
    /// Details about the requested access policies.
    public var accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

struct ListAccessPoliciesOutputBody: Swift.Equatable {
    let accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]?
    let nextToken: Swift.String?
}

extension ListAccessPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicySummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicySummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.AccessPolicySummary?].self, forKey: .accessPolicySummaries)
        var accessPolicySummariesDecoded0:[OpenSearchServerlessClientTypes.AccessPolicySummary]? = nil
        if let accessPolicySummariesContainer = accessPolicySummariesContainer {
            accessPolicySummariesDecoded0 = [OpenSearchServerlessClientTypes.AccessPolicySummary]()
            for structure0 in accessPolicySummariesContainer {
                if let structure0 = structure0 {
                    accessPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        accessPolicySummaries = accessPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionFilters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionFilters = self.collectionFilters {
            try encodeContainer.encode(collectionFilters, forKey: .collectionFilters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCollectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCollectionsInput: Swift.Equatable {
    /// List of filter names and values that you can use for requests.
    public var collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters?
    /// The maximum number of results to return. Default is 20. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListCollections operation returns a nextToken, you can include the returned nextToken in subsequent ListCollections operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionFilters = collectionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollectionsInputBody: Swift.Equatable {
    let collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCollectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionFilters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionFiltersDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionFilters.self, forKey: .collectionFilters)
        collectionFilters = collectionFiltersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCollectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectionSummaries = output.collectionSummaries
            self.nextToken = output.nextToken
        } else {
            self.collectionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollectionsOutput: Swift.Equatable {
    /// Details about each collection.
    public var collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionSummaries = collectionSummaries
        self.nextToken = nextToken
    }
}

struct ListCollectionsOutputBody: Swift.Equatable {
    let collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]?
    let nextToken: Swift.String?
}

extension ListCollectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionSummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.CollectionSummary?].self, forKey: .collectionSummaries)
        var collectionSummariesDecoded0:[OpenSearchServerlessClientTypes.CollectionSummary]? = nil
        if let collectionSummariesContainer = collectionSummariesContainer {
            collectionSummariesDecoded0 = [OpenSearchServerlessClientTypes.CollectionSummary]()
            for structure0 in collectionSummariesContainer {
                if let structure0 = structure0 {
                    collectionSummariesDecoded0?.append(structure0)
                }
            }
        }
        collectionSummaries = collectionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCollectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListSecurityConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSecurityConfigsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListSecurityConfigs operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityConfigs operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The type of security configuration.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListSecurityConfigsInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityConfigType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSecurityConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSecurityConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityConfigSummaries = output.securityConfigSummaries
        } else {
            self.nextToken = nil
            self.securityConfigSummaries = nil
        }
    }
}

public struct ListSecurityConfigsOutput: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about the security configurations in your account.
    public var securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]?

    public init(
        nextToken: Swift.String? = nil,
        securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityConfigSummaries = securityConfigSummaries
    }
}

struct ListSecurityConfigsOutputBody: Swift.Equatable {
    let securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]?
    let nextToken: Swift.String?
}

extension ListSecurityConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityConfigSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigSummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.SecurityConfigSummary?].self, forKey: .securityConfigSummaries)
        var securityConfigSummariesDecoded0:[OpenSearchServerlessClientTypes.SecurityConfigSummary]? = nil
        if let securityConfigSummariesContainer = securityConfigSummariesContainer {
            securityConfigSummariesDecoded0 = [OpenSearchServerlessClientTypes.SecurityConfigSummary]()
            for structure0 in securityConfigSummariesContainer {
                if let structure0 = structure0 {
                    securityConfigSummariesDecoded0?.append(structure0)
                }
            }
        }
        securityConfigSummaries = securityConfigSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSecurityConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resource = resource {
            var resourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resource)
            for resource0 in resource {
                try resourceContainer.encode(resource0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListSecurityPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSecurityPoliciesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListSecurityPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityPolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters (can be collection or indexes) that policies can apply to.
    public var resource: [Swift.String]?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resource: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resource = resource
        self.type = type
    }
}

struct ListSecurityPoliciesInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let resource: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSecurityPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let resourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resource)
        var resourceDecoded0:[Swift.String]? = nil
        if let resourceContainer = resourceContainer {
            resourceDecoded0 = [Swift.String]()
            for string0 in resourceContainer {
                if let string0 = string0 {
                    resourceDecoded0?.append(string0)
                }
            }
        }
        resource = resourceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSecurityPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityPolicySummaries = output.securityPolicySummaries
        } else {
            self.nextToken = nil
            self.securityPolicySummaries = nil
        }
    }
}

public struct ListSecurityPoliciesOutput: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about the security policies in your account.
    public var securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]?

    public init(
        nextToken: Swift.String? = nil,
        securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicySummaries = securityPolicySummaries
    }
}

struct ListSecurityPoliciesOutputBody: Swift.Equatable {
    let securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]?
    let nextToken: Swift.String?
}

extension ListSecurityPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityPolicySummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicySummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.SecurityPolicySummary?].self, forKey: .securityPolicySummaries)
        var securityPolicySummariesDecoded0:[OpenSearchServerlessClientTypes.SecurityPolicySummary]? = nil
        if let securityPolicySummariesContainer = securityPolicySummariesContainer {
            securityPolicySummariesDecoded0 = [OpenSearchServerlessClientTypes.SecurityPolicySummary]()
            for structure0 in securityPolicySummariesContainer {
                if let structure0 = structure0 {
                    securityPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        securityPolicySummaries = securityPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSecurityPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?

    public init(
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [OpenSearchServerlessClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpenSearchServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpenSearchServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVpcEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case vpcEndpointFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let vpcEndpointFilters = self.vpcEndpointFilters {
            try encodeContainer.encode(vpcEndpointFilters, forKey: .vpcEndpointFilters)
        }
    }
}

extension ListVpcEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVpcEndpointsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Filter the results according to the current status of the VPC endpoint. Possible statuses are CREATING, DELETING, UPDATING, ACTIVE, and FAILED.
    public var vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcEndpointFilters = vpcEndpointFilters
    }
}

struct ListVpcEndpointsInputBody: Swift.Equatable {
    let vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListVpcEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case vpcEndpointFilters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointFiltersDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointFilters.self, forKey: .vpcEndpointFilters)
        vpcEndpointFilters = vpcEndpointFiltersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListVpcEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVpcEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpcEndpointSummaries = output.vpcEndpointSummaries
        } else {
            self.nextToken = nil
            self.vpcEndpointSummaries = nil
        }
    }
}

public struct ListVpcEndpointsOutput: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about each VPC endpoint, including the name and current status.
    public var vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcEndpointSummaries = vpcEndpointSummaries
    }
}

struct ListVpcEndpointsOutputBody: Swift.Equatable {
    let vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListVpcEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vpcEndpointSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointSummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.VpcEndpointSummary?].self, forKey: .vpcEndpointSummaries)
        var vpcEndpointSummariesDecoded0:[OpenSearchServerlessClientTypes.VpcEndpointSummary]? = nil
        if let vpcEndpointSummariesContainer = vpcEndpointSummariesContainer {
            vpcEndpointSummariesDecoded0 = [OpenSearchServerlessClientTypes.VpcEndpointSummary]()
            for structure0 in vpcEndpointSummariesContainer {
                if let structure0 = structure0 {
                    vpcEndpointSummariesDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpointSummaries = vpcEndpointSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVpcEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OcuLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OcuLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when the collection you're attempting to create results in a number of search or indexing OCUs that exceeds the account limit.
public struct OcuLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OcuLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OcuLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OcuLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when accessing or deleting a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchServerlessClientTypes.SamlConfigOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupAttribute
        case metadata
        case sessionTimeout
        case userAttribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupAttribute = self.groupAttribute {
            try encodeContainer.encode(groupAttribute, forKey: .groupAttribute)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let sessionTimeout = self.sessionTimeout {
            try encodeContainer.encode(sessionTimeout, forKey: .sessionTimeout)
        }
        if let userAttribute = self.userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let groupAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupAttribute)
        groupAttribute = groupAttributeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Describes SAML options for an OpenSearch Serverless security configuration in the form of a key-value map.
    public struct SamlConfigOptions: Swift.Equatable {
        /// The group attribute for this SAML integration.
        public var groupAttribute: Swift.String?
        /// The XML IdP metadata file generated from your identity provider.
        /// This member is required.
        public var metadata: Swift.String?
        /// The session timeout, in minutes. Default is 60 minutes (12 hours).
        public var sessionTimeout: Swift.Int?
        /// A user attribute for this SAML integration.
        public var userAttribute: Swift.String?

        public init(
            groupAttribute: Swift.String? = nil,
            metadata: Swift.String? = nil,
            sessionTimeout: Swift.Int? = nil,
            userAttribute: Swift.String? = nil
        )
        {
            self.groupAttribute = groupAttribute
            self.metadata = metadata
            self.sessionTimeout = sessionTimeout
            self.userAttribute = userAttribute
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityConfigDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configVersion
        case createdDate
        case description
        case id
        case lastModifiedDate
        case samlOptions
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configVersion = self.configVersion {
            try encodeContainer.encode(configVersion, forKey: .configVersion)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let samlOptions = self.samlOptions {
            try encodeContainer.encode(samlOptions, forKey: .samlOptions)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let configVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configVersion)
        configVersion = configVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let samlOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SamlConfigOptions.self, forKey: .samlOptions)
        samlOptions = samlOptionsDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about a security configuration for OpenSearch Serverless.
    public struct SecurityConfigDetail: Swift.Equatable {
        /// The version of the security configuration.
        public var configVersion: Swift.String?
        /// The date the configuration was created.
        public var createdDate: Swift.Int?
        /// The description of the security configuration.
        public var description: Swift.String?
        /// The unique identifier of the security configuration.
        public var id: Swift.String?
        /// The timestamp of when the configuration was last modified.
        public var lastModifiedDate: Swift.Int?
        /// SAML options for the security configuration in the form of a key-value map.
        public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
        /// The type of security configuration.
        public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

        public init(
            configVersion: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil,
            type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
        )
        {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.samlOptions = samlOptions
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityConfigStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlConfigCount = "SamlConfigCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samlConfigCount = self.samlConfigCount {
            try encodeContainer.encode(samlConfigCount, forKey: .samlConfigCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlConfigCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samlConfigCount)
        samlConfigCount = samlConfigCountDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Statistics for an OpenSearch Serverless security configuration.
    public struct SecurityConfigStats: Swift.Equatable {
        /// The number of security configurations in the current account.
        public var samlConfigCount: Swift.Int?

        public init(
            samlConfigCount: Swift.Int? = nil
        )
        {
            self.samlConfigCount = samlConfigCount
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityConfigSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configVersion
        case createdDate
        case description
        case id
        case lastModifiedDate
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configVersion = self.configVersion {
            try encodeContainer.encode(configVersion, forKey: .configVersion)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let configVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configVersion)
        configVersion = configVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A summary of a security configuration for OpenSearch Serverless.
    public struct SecurityConfigSummary: Swift.Equatable {
        /// The version of the security configuration.
        public var configVersion: Swift.String?
        /// The Epoch time when the security configuration was created.
        public var createdDate: Swift.Int?
        /// The description of the security configuration.
        public var description: Swift.String?
        /// The unique identifier of the security configuration.
        public var id: Swift.String?
        /// The timestamp of when the configuration was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The type of security configuration.
        public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

        public init(
            configVersion: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
        )
        {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum SecurityConfigType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// saml provider
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityConfigType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "saml"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityConfigType(rawValue: rawValue) ?? SecurityConfigType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.SecurityPolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .policy)
        policy = policyDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an OpenSearch Serverless security policy.
    public struct SecurityPolicyDetail: Swift.Equatable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the security policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: ClientRuntime.Document?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of security policy.
        public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: ClientRuntime.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityPolicyStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionPolicyCount = "EncryptionPolicyCount"
        case networkPolicyCount = "NetworkPolicyCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionPolicyCount = self.encryptionPolicyCount {
            try encodeContainer.encode(encryptionPolicyCount, forKey: .encryptionPolicyCount)
        }
        if let networkPolicyCount = self.networkPolicyCount {
            try encodeContainer.encode(networkPolicyCount, forKey: .networkPolicyCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .encryptionPolicyCount)
        encryptionPolicyCount = encryptionPolicyCountDecoded
        let networkPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkPolicyCount)
        networkPolicyCount = networkPolicyCountDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Statistics for an OpenSearch Serverless security policy.
    public struct SecurityPolicyStats: Swift.Equatable {
        /// The number of encryption policies in the current account.
        public var encryptionPolicyCount: Swift.Int?
        /// The number of network policies in the current account.
        public var networkPolicyCount: Swift.Int?

        public init(
            encryptionPolicyCount: Swift.Int? = nil,
            networkPolicyCount: Swift.Int? = nil
        )
        {
            self.encryptionPolicyCount = encryptionPolicyCount
            self.networkPolicyCount = networkPolicyCount
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A summary of a security policy for OpenSearch Serverless.
    public struct SecurityPolicySummary: Swift.Equatable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the security policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of security policy.
        public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum SecurityPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// encryption policy type
        case encryption
        /// network policy type
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyType] {
            return [
                .encryption,
                .network,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryption: return "encryption"
            case .network: return "network"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicyType(rawValue: rawValue) ?? SecurityPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when you attempt to create more resources than the service allows based on service quotas.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service Quotas requirement to identify originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension OpenSearchServerlessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A map of key-value pairs associated to an OpenSearch Serverless resource.
    public struct Tag: Swift.Equatable {
        /// The key to use in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags (key-value pairs) to add to the resource. All tag keys in the request must be unique.
    /// This member is required.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [OpenSearchServerlessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpenSearchServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpenSearchServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag or set of tags to remove from the resource. All tag keys in the request must be unique.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccessPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

struct UpdateAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
    let policyVersion: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccessPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyDetail = output.accessPolicyDetail
        } else {
            self.accessPolicyDetail = nil
        }
    }
}

public struct UpdateAccessPolicyOutput: Swift.Equatable {
    /// Details about the updated access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init(
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

struct UpdateAccessPolicyOutputBody: Swift.Equatable {
    let accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?
}

extension UpdateAccessPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyDetail.self, forKey: .accessPolicyDetail)
        accessPolicyDetail = accessPolicyDetailDecoded
    }
}

enum UpdateAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityLimits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityLimits = self.capacityLimits {
            try encodeContainer.encode(capacityLimits, forKey: .capacityLimits)
        }
    }
}

extension UpdateAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Managing capacity limits for Amazon OpenSearch Serverless](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-scaling.html).
    public var capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?

    public init(
        capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits? = nil
    )
    {
        self.capacityLimits = capacityLimits
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    let capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityLimits
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityLimitsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CapacityLimits.self, forKey: .capacityLimits)
        capacityLimits = capacityLimitsDecoded
    }
}

extension UpdateAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettingsDetail = output.accountSettingsDetail
        } else {
            self.accountSettingsDetail = nil
        }
    }
}

public struct UpdateAccountSettingsOutput: Swift.Equatable {
    /// OpenSearch Serverless-related settings for the current Amazon Web Services account.
    public var accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?

    public init(
        accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail? = nil
    )
    {
        self.accountSettingsDetail = accountSettingsDetail
    }
}

struct UpdateAccountSettingsOutputBody: Swift.Equatable {
    let accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?
}

extension UpdateAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettingsDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccountSettingsDetail.self, forKey: .accountSettingsDetail)
        accountSettingsDetail = accountSettingsDetailDecoded
    }
}

enum UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.UpdateCollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case description
        case id
        case lastModifiedDate
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an updated OpenSearch Serverless collection.
    public struct UpdateCollectionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The date and time when the collection was created.
        public var createdDate: Swift.Int?
        /// The description of the collection.
        public var description: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The collection type.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init(
            arn: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension UpdateCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UpdateCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCollectionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the collection.
    public var description: Swift.String?
    /// The unique identifier of the collection.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.id = id
    }
}

struct UpdateCollectionInputBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.updateCollectionDetail = output.updateCollectionDetail
        } else {
            self.updateCollectionDetail = nil
        }
    }
}

public struct UpdateCollectionOutput: Swift.Equatable {
    /// Details about the updated collection.
    public var updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail?

    public init(
        updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail? = nil
    )
    {
        self.updateCollectionDetail = updateCollectionDetail
    }
}

struct UpdateCollectionOutputBody: Swift.Equatable {
    let updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail?
}

extension UpdateCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateCollectionDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateCollectionDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.UpdateCollectionDetail.self, forKey: .updateCollectionDetail)
        updateCollectionDetail = updateCollectionDetailDecoded
    }
}

enum UpdateCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configVersion
        case description
        case id
        case samlOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configVersion = self.configVersion {
            try encodeContainer.encode(configVersion, forKey: .configVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let samlOptions = self.samlOptions {
            try encodeContainer.encode(samlOptions, forKey: .samlOptions)
        }
    }
}

extension UpdateSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSecurityConfigInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The version of the security configuration to be updated. You can find the most recent version of a security configuration using the GetSecurityPolicy command.
    /// This member is required.
    public var configVersion: Swift.String?
    /// A description of the security configuration.
    public var description: Swift.String?
    /// The security configuration identifier. For SAML the ID will be saml/<accountId>/<idpProviderName>. For example, saml/123456789123/OKTADev.
    /// This member is required.
    public var id: Swift.String?
    /// SAML options in in the form of a key-value map.
    public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?

    public init(
        clientToken: Swift.String? = nil,
        configVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil
    )
    {
        self.clientToken = clientToken
        self.configVersion = configVersion
        self.description = description
        self.id = id
        self.samlOptions = samlOptions
    }
}

struct UpdateSecurityConfigInputBody: Swift.Equatable {
    let id: Swift.String?
    let configVersion: Swift.String?
    let description: Swift.String?
    let samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    let clientToken: Swift.String?
}

extension UpdateSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configVersion
        case description
        case id
        case samlOptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let configVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configVersion)
        configVersion = configVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let samlOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SamlConfigOptions.self, forKey: .samlOptions)
        samlOptions = samlOptionsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateSecurityConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSecurityConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityConfigDetail = output.securityConfigDetail
        } else {
            self.securityConfigDetail = nil
        }
    }
}

public struct UpdateSecurityConfigOutput: Swift.Equatable {
    /// Details about the updated security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init(
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

struct UpdateSecurityConfigOutputBody: Swift.Equatable {
    let securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?
}

extension UpdateSecurityConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityConfigDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigDetail.self, forKey: .securityConfigDetail)
        securityConfigDetail = securityConfigDetailDecoded
    }
}

enum UpdateSecurityConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSecurityPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the new policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of access policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

struct UpdateSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
    let policyVersion: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateSecurityPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSecurityPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicyDetail = output.securityPolicyDetail
        } else {
            self.securityPolicyDetail = nil
        }
    }
}

public struct UpdateSecurityPolicyOutput: Swift.Equatable {
    /// Details about the updated security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init(
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

struct UpdateSecurityPolicyOutputBody: Swift.Equatable {
    let securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?
}

extension UpdateSecurityPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyDetail.self, forKey: .securityPolicyDetail)
        securityPolicyDetail = securityPolicyDetailDecoded
    }
}

enum UpdateSecurityPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case lastModifiedDate
        case name
        case securityGroupIds
        case status
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Update details for an OpenSearch Serverless-managed interface endpoint.
    public struct UpdateVpcEndpointDetail: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The timestamp of when the endpoint was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of the endpoint update process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public var subnetIds: [Swift.String]?

        public init(
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
        }
    }

}

extension UpdateVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSecurityGroupIds
        case addSubnetIds
        case clientToken
        case id
        case removeSecurityGroupIds
        case removeSubnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addSecurityGroupIds = addSecurityGroupIds {
            var addSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSecurityGroupIds)
            for securitygroupid0 in addSecurityGroupIds {
                try addSecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let addSubnetIds = addSubnetIds {
            var addSubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSubnetIds)
            for subnetid0 in addSubnetIds {
                try addSubnetIdsContainer.encode(subnetid0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let removeSecurityGroupIds = removeSecurityGroupIds {
            var removeSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSecurityGroupIds)
            for securitygroupid0 in removeSecurityGroupIds {
                try removeSecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let removeSubnetIds = removeSubnetIds {
            var removeSubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSubnetIds)
            for subnetid0 in removeSubnetIds {
                try removeSubnetIdsContainer.encode(subnetid0)
            }
        }
    }
}

extension UpdateVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVpcEndpointInput: Swift.Equatable {
    /// The unique identifiers of the security groups to add to the endpoint. Security groups define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var addSecurityGroupIds: [Swift.String]?
    /// The ID of one or more subnets to add to the endpoint.
    public var addSubnetIds: [Swift.String]?
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the interface endpoint to update.
    /// This member is required.
    public var id: Swift.String?
    /// The unique identifiers of the security groups to remove from the endpoint.
    public var removeSecurityGroupIds: [Swift.String]?
    /// The unique identifiers of the subnets to remove from the endpoint.
    public var removeSubnetIds: [Swift.String]?

    public init(
        addSecurityGroupIds: [Swift.String]? = nil,
        addSubnetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        removeSecurityGroupIds: [Swift.String]? = nil,
        removeSubnetIds: [Swift.String]? = nil
    )
    {
        self.addSecurityGroupIds = addSecurityGroupIds
        self.addSubnetIds = addSubnetIds
        self.clientToken = clientToken
        self.id = id
        self.removeSecurityGroupIds = removeSecurityGroupIds
        self.removeSubnetIds = removeSubnetIds
    }
}

struct UpdateVpcEndpointInputBody: Swift.Equatable {
    let id: Swift.String?
    let addSubnetIds: [Swift.String]?
    let removeSubnetIds: [Swift.String]?
    let addSecurityGroupIds: [Swift.String]?
    let removeSecurityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSecurityGroupIds
        case addSubnetIds
        case clientToken
        case id
        case removeSecurityGroupIds
        case removeSubnetIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let addSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSubnetIds)
        var addSubnetIdsDecoded0:[Swift.String]? = nil
        if let addSubnetIdsContainer = addSubnetIdsContainer {
            addSubnetIdsDecoded0 = [Swift.String]()
            for string0 in addSubnetIdsContainer {
                if let string0 = string0 {
                    addSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        addSubnetIds = addSubnetIdsDecoded0
        let removeSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSubnetIds)
        var removeSubnetIdsDecoded0:[Swift.String]? = nil
        if let removeSubnetIdsContainer = removeSubnetIdsContainer {
            removeSubnetIdsDecoded0 = [Swift.String]()
            for string0 in removeSubnetIdsContainer {
                if let string0 = string0 {
                    removeSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        removeSubnetIds = removeSubnetIdsDecoded0
        let addSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSecurityGroupIds)
        var addSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let addSecurityGroupIdsContainer = addSecurityGroupIdsContainer {
            addSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in addSecurityGroupIdsContainer {
                if let string0 = string0 {
                    addSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        addSecurityGroupIds = addSecurityGroupIdsDecoded0
        let removeSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSecurityGroupIds)
        var removeSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let removeSecurityGroupIdsContainer = removeSecurityGroupIdsContainer {
            removeSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in removeSecurityGroupIdsContainer {
                if let string0 = string0 {
                    removeSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        removeSecurityGroupIds = removeSecurityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVpcEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVpcEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.updateVpcEndpointDetail = output.updateVpcEndpointDetail
        } else {
            self.updateVpcEndpointDetail = nil
        }
    }
}

public struct UpdateVpcEndpointOutput: Swift.Equatable {
    /// Details about the updated VPC endpoint.
    public var updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail?

    public init(
        updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail? = nil
    )
    {
        self.updateVpcEndpointDetail = updateVpcEndpointDetail
    }
}

struct UpdateVpcEndpointOutputBody: Swift.Equatable {
    let updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail?
}

extension UpdateVpcEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateVpcEndpointDetail = "UpdateVpcEndpointDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateVpcEndpointDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail.self, forKey: .updateVpcEndpointDetail)
        updateVpcEndpointDetail = updateVpcEndpointDetailDecoded
    }
}

enum UpdateVpcEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when the HTTP request contains invalid input or is missing required input.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case id
        case name
        case securityGroupIds
        case status
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an OpenSearch Serverless-managed interface endpoint.
    public struct VpcEndpointDetail: Swift.Equatable {
        /// The date the endpoint was created.
        public var createdDate: Swift.Int?
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC from which you access OpenSearch Serverless.
        public var vpcId: Swift.String?

        public init(
            createdDate: Swift.Int? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.id = id
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension OpenSearchServerlessClientTypes.VpcEndpointErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Error information for a failed BatchGetVpcEndpoint request.
    public struct VpcEndpointErrorDetail: Swift.Equatable {
        /// The error code for the failed request.
        public var errorCode: Swift.String?
        /// An error message describing the reason for the failure.
        public var errorMessage: Swift.String?
        /// The unique identifier of the VPC endpoint.
        public var id: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

extension OpenSearchServerlessClientTypes.VpcEndpointFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Filter the results of a ListVpcEndpoints request.
    public struct VpcEndpointFilters: Swift.Equatable {
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum VpcEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// VPCEndpoint resource is ready to use
        case active
        /// Deleting VPCEndpoint resource
        case deleting
        /// VPCEndpoint resource create or delete failed
        case failed
        /// Pending VPCEndpoint resource
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcEndpointStatus(rawValue: rawValue) ?? VpcEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// The VPC endpoint object.
    public struct VpcEndpointSummary: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}
