//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document

extension OpenSearchServerlessClientTypes {

    public enum AccessPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// data policy type
        case data
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPolicyType] {
            return [
                .data
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .data: return "data"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// When creating a resource, thrown when a resource with the same name already exists or is being created. When deleting a resource, thrown when the resource is not in the ACTIVE or FAILED state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Thrown when an error internal to the service occurs while processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Thrown when you attempt to create more resources than the service allows based on service quotas.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service Quotas requirement to identify originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// Thrown when the HTTP request contains invalid input or is missing required input.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAccessPolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about an OpenSearch Serverless access policy.
    public struct AccessPolicyDetail: Swift.Sendable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: Smithy.Document?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of access policy.
        public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: Smithy.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }
}

public struct CreateAccessPolicyOutput: Swift.Sendable {
    /// Details about the created access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init(
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

/// Thrown when accessing or deleting a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAccessPolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

public struct DeleteAccessPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct GetAccessPolicyInput: Swift.Sendable {
    /// The name of the access policy.
    /// This member is required.
    public var name: Swift.String?
    /// Tye type of policy. Currently, the only supported value is data.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

public struct GetAccessPolicyOutput: Swift.Sendable {
    /// Details about the requested access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init(
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

public struct ListAccessPoliciesInput: Swift.Sendable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListAccessPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListAccessPolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters (can be collections or indexes) that policies can apply to.
    public var resource: [Swift.String]?
    /// The type of access policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resource: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resource = resource
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// A summary of the data access policy.
    public struct AccessPolicySummary: Swift.Sendable {
        /// The Epoch time when the access policy was created.
        public var createdDate: Swift.Int?
        /// The description of the access policy.
        public var description: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the access policy.
        public var name: Swift.String?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of access policy. Currently, the only available type is data.
        public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }
}

public struct ListAccessPoliciesOutput: Swift.Sendable {
    /// Details about the requested access policies.
    public var accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAccessPolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

public struct UpdateAccessPolicyOutput: Swift.Sendable {
    /// Details about the updated access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init(
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

extension OpenSearchServerlessClientTypes {

    /// Statistics for an OpenSearch Serverless access policy.
    public struct AccessPolicyStats: Swift.Sendable {
        /// The number of data access policies in the current account.
        public var dataPolicyCount: Swift.Int?

        public init(
            dataPolicyCount: Swift.Int? = nil
        )
        {
            self.dataPolicyCount = dataPolicyCount
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Managing capacity limits for Amazon OpenSearch Serverless](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-scaling.html).
    public struct CapacityLimits: Swift.Sendable {
        /// The maximum indexing capacity for collections.
        public var maxIndexingCapacityInOCU: Swift.Int?
        /// The maximum search capacity for collections.
        public var maxSearchCapacityInOCU: Swift.Int?

        public init(
            maxIndexingCapacityInOCU: Swift.Int? = nil,
            maxSearchCapacityInOCU: Swift.Int? = nil
        )
        {
            self.maxIndexingCapacityInOCU = maxIndexingCapacityInOCU
            self.maxSearchCapacityInOCU = maxSearchCapacityInOCU
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// OpenSearch Serverless-related information for the current account.
    public struct AccountSettingsDetail: Swift.Sendable {
        /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Managing capacity limits for Amazon OpenSearch Serverless](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-scaling.html).
        public var capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?

        public init(
            capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits? = nil
        )
        {
            self.capacityLimits = capacityLimits
        }
    }
}

public struct BatchGetCollectionInput: Swift.Sendable {
    /// A list of collection IDs. You can't provide names and IDs in the same request. The ID is part of the collection endpoint. You can also retrieve it using the [ListCollections](https://docs.aws.amazon.com/opensearch-service/latest/ServerlessAPIReference/API_ListCollections.html) API.
    public var ids: [Swift.String]?
    /// A list of collection names. You can't provide names and IDs in the same request.
    public var names: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.names = names
    }
}

extension OpenSearchServerlessClientTypes {

    public enum StandbyReplicas: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Standby replicas disabled
        case disabled
        /// Standby replicas enabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StandbyReplicas] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    public enum CollectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Collection resource is ready to use
        case active
        /// Creating collection resource
        case creating
        /// Deleting collection resource
        case deleting
        /// Collection resource create or delete failed
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    public enum CollectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Search collection type
        case search
        /// Timeseries collection type
        case timeseries
        /// Vectorsearch collection type
        case vectorsearch
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectionType] {
            return [
                .search,
                .timeseries,
                .vectorsearch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .search: return "SEARCH"
            case .timeseries: return "TIMESERIES"
            case .vectorsearch: return "VECTORSEARCH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about each OpenSearch Serverless collection, including the collection endpoint and the OpenSearch Dashboards endpoint.
    public struct CollectionDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// Collection-specific endpoint used to submit index, search, and data upload requests to an OpenSearch Serverless collection.
        public var collectionEndpoint: Swift.String?
        /// The Epoch time when the collection was created.
        public var createdDate: Swift.Int?
        /// Collection-specific endpoint used to access OpenSearch Dashboards.
        public var dashboardEndpoint: Swift.String?
        /// A description of the collection.
        public var description: Swift.String?
        /// A failure code associated with the request.
        public var failureCode: Swift.String?
        /// A message associated with the failure code.
        public var failureMessage: Swift.String?
        /// A unique identifier for the collection.
        public var id: Swift.String?
        /// The ARN of the Amazon Web Services KMS key used to encrypt the collection.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// Details about an OpenSearch Serverless collection.
        public var standbyReplicas: OpenSearchServerlessClientTypes.StandbyReplicas?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The type of collection.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init(
            arn: Swift.String? = nil,
            collectionEndpoint: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            dashboardEndpoint: Swift.String? = nil,
            description: Swift.String? = nil,
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            standbyReplicas: OpenSearchServerlessClientTypes.StandbyReplicas? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.collectionEndpoint = collectionEndpoint
            self.createdDate = createdDate
            self.dashboardEndpoint = dashboardEndpoint
            self.description = description
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.status = status
            self.type = type
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Error information for an OpenSearch Serverless request.
    public struct CollectionErrorDetail: Swift.Sendable {
        /// The error code for the request. For example, NOT_FOUND.
        public var errorCode: Swift.String?
        /// A description of the error. For example, The specified Collection is not found.
        public var errorMessage: Swift.String?
        /// If the request contains collection IDs, the response includes the IDs provided in the request.
        public var id: Swift.String?
        /// If the request contains collection names, the response includes the names provided in the request.
        public var name: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
        }
    }
}

public struct BatchGetCollectionOutput: Swift.Sendable {
    /// Details about each collection.
    public var collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]?
    /// Error information for the request.
    public var collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]?

    public init(
        collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]? = nil,
        collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]? = nil
    )
    {
        self.collectionDetails = collectionDetails
        self.collectionErrorDetails = collectionErrorDetails
    }
}

extension OpenSearchServerlessClientTypes {

    public enum LifecyclePolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// retention policy type
        case retention
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyType] {
            return [
                .retention
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .retention: return "retention"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// The unique identifiers of policy types and resource names.
    public struct LifecyclePolicyResourceIdentifier: Swift.Sendable {
        /// The name of the OpenSearch Serverless ilndex resource.
        /// This member is required.
        public var resource: Swift.String?
        /// The type of lifecycle policy.
        /// This member is required.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            resource: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.resource = resource
            self.type = type
        }
    }
}

public struct BatchGetEffectiveLifecyclePolicyInput: Swift.Sendable {
    /// The unique identifiers of policy types and resource names.
    /// This member is required.
    public var resourceIdentifiers: [OpenSearchServerlessClientTypes.LifecyclePolicyResourceIdentifier]?

    public init(
        resourceIdentifiers: [OpenSearchServerlessClientTypes.LifecyclePolicyResourceIdentifier]? = nil
    )
    {
        self.resourceIdentifiers = resourceIdentifiers
    }
}

extension OpenSearchServerlessClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// index resource type
        case index
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .index
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .index: return "index"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Error information for an OpenSearch Serverless request.
    public struct EffectiveLifecyclePolicyDetail: Swift.Sendable {
        /// The minimum number of index retention days set. That is an optional param that will return as true if the minimum number of days or hours is not set to a index resource.
        public var noMinRetentionPeriod: Swift.Bool?
        /// The name of the lifecycle policy.
        public var policyName: Swift.String?
        /// The name of the OpenSearch Serverless index resource.
        public var resource: Swift.String?
        /// The type of OpenSearch Serverless resource. Currently, the only supported resource is index.
        public var resourceType: OpenSearchServerlessClientTypes.ResourceType?
        /// The minimum number of index retention in days or hours. This is an optional parameter that will return only if it’s set.
        public var retentionPeriod: Swift.String?
        /// The type of lifecycle policy.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            noMinRetentionPeriod: Swift.Bool? = nil,
            policyName: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: OpenSearchServerlessClientTypes.ResourceType? = nil,
            retentionPeriod: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.noMinRetentionPeriod = noMinRetentionPeriod
            self.policyName = policyName
            self.resource = resource
            self.resourceType = resourceType
            self.retentionPeriod = retentionPeriod
            self.type = type
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Error information for an OpenSearch Serverless request.
    public struct EffectiveLifecyclePolicyErrorDetail: Swift.Sendable {
        /// The error code for the request.
        public var errorCode: Swift.String?
        /// A description of the error. For example, The specified Index resource is not found.
        public var errorMessage: Swift.String?
        /// The name of OpenSearch Serverless index resource.
        public var resource: Swift.String?
        /// The type of lifecycle policy.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            resource: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resource = resource
            self.type = type
        }
    }
}

public struct BatchGetEffectiveLifecyclePolicyOutput: Swift.Sendable {
    /// A list of lifecycle policies applied to the OpenSearch Serverless indexes.
    public var effectiveLifecyclePolicyDetails: [OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyDetail]?
    /// A list of resources for which retrieval failed.
    public var effectiveLifecyclePolicyErrorDetails: [OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyErrorDetail]?

    public init(
        effectiveLifecyclePolicyDetails: [OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyDetail]? = nil,
        effectiveLifecyclePolicyErrorDetails: [OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyErrorDetail]? = nil
    )
    {
        self.effectiveLifecyclePolicyDetails = effectiveLifecyclePolicyDetails
        self.effectiveLifecyclePolicyErrorDetails = effectiveLifecyclePolicyErrorDetails
    }
}

extension OpenSearchServerlessClientTypes {

    /// The unique identifiers of policy types and policy names.
    public struct LifecyclePolicyIdentifier: Swift.Sendable {
        /// The name of the lifecycle policy.
        /// This member is required.
        public var name: Swift.String?
        /// The type of lifecycle policy.
        /// This member is required.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            name: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

public struct BatchGetLifecyclePolicyInput: Swift.Sendable {
    /// The unique identifiers of policy types and policy names.
    /// This member is required.
    public var identifiers: [OpenSearchServerlessClientTypes.LifecyclePolicyIdentifier]?

    public init(
        identifiers: [OpenSearchServerlessClientTypes.LifecyclePolicyIdentifier]? = nil
    )
    {
        self.identifiers = identifiers
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about an OpenSearch Serverless lifecycle policy.
    public struct LifecyclePolicyDetail: Swift.Sendable {
        /// The date the lifecycle policy was created.
        public var createdDate: Swift.Int?
        /// The description of the lifecycle policy.
        public var description: Swift.String?
        /// The timestamp of when the lifecycle policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: Smithy.Document?
        /// The version of the lifecycle policy.
        public var policyVersion: Swift.String?
        /// The type of lifecycle policy.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: Smithy.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Error information for an OpenSearch Serverless request.
    public struct LifecyclePolicyErrorDetail: Swift.Sendable {
        /// The error code for the request. For example, NOT_FOUND.
        public var errorCode: Swift.String?
        /// A description of the error. For example, The specified Lifecycle Policy is not found.
        public var errorMessage: Swift.String?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The type of lifecycle policy.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.name = name
            self.type = type
        }
    }
}

public struct BatchGetLifecyclePolicyOutput: Swift.Sendable {
    /// A list of lifecycle policies matched to the input policy name and policy type.
    public var lifecyclePolicyDetails: [OpenSearchServerlessClientTypes.LifecyclePolicyDetail]?
    /// A list of lifecycle policy names and policy types for which retrieval failed.
    public var lifecyclePolicyErrorDetails: [OpenSearchServerlessClientTypes.LifecyclePolicyErrorDetail]?

    public init(
        lifecyclePolicyDetails: [OpenSearchServerlessClientTypes.LifecyclePolicyDetail]? = nil,
        lifecyclePolicyErrorDetails: [OpenSearchServerlessClientTypes.LifecyclePolicyErrorDetail]? = nil
    )
    {
        self.lifecyclePolicyDetails = lifecyclePolicyDetails
        self.lifecyclePolicyErrorDetails = lifecyclePolicyErrorDetails
    }
}

public struct BatchGetVpcEndpointInput: Swift.Sendable {
    /// A list of VPC endpoint identifiers.
    /// This member is required.
    public var ids: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

extension OpenSearchServerlessClientTypes {

    public enum VpcEndpointStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// VPCEndpoint resource is ready to use
        case active
        /// Deleting VPCEndpoint resource
        case deleting
        /// VPCEndpoint resource create or delete failed
        case failed
        /// Pending VPCEndpoint resource
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about an OpenSearch Serverless-managed interface endpoint.
    public struct VpcEndpointDetail: Swift.Sendable {
        /// The date the endpoint was created.
        public var createdDate: Swift.Int?
        /// A failure code associated with the request.
        public var failureCode: Swift.String?
        /// A message associated with the failure code.
        public var failureMessage: Swift.String?
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC from which you access OpenSearch Serverless.
        public var vpcId: Swift.String?

        public init(
            createdDate: Swift.Int? = nil,
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Error information for a failed BatchGetVpcEndpoint request.
    public struct VpcEndpointErrorDetail: Swift.Sendable {
        /// The error code for the failed request.
        public var errorCode: Swift.String?
        /// An error message describing the reason for the failure.
        public var errorMessage: Swift.String?
        /// The unique identifier of the VPC endpoint.
        public var id: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

public struct BatchGetVpcEndpointOutput: Swift.Sendable {
    /// Details about the specified VPC endpoint.
    public var vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]?
    /// Error information for a failed request.
    public var vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]?

    public init(
        vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]? = nil,
        vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]? = nil
    )
    {
        self.vpcEndpointDetails = vpcEndpointDetails
        self.vpcEndpointErrorDetails = vpcEndpointErrorDetails
    }
}

/// Thrown when the collection you're attempting to create results in a number of search or indexing OCUs that exceeds the account limit.
public struct OcuLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OcuLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpenSearchServerlessClientTypes {

    /// A map of key-value pairs associated to an OpenSearch Serverless resource.
    public struct Tag: Swift.Sendable {
        /// The key to use in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateCollectionInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// Description of the collection.
    public var description: Swift.String?
    /// Name of the collection.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates whether standby replicas should be used for a collection.
    public var standbyReplicas: OpenSearchServerlessClientTypes.StandbyReplicas?
    /// An arbitrary set of tags (key–value pairs) to associate with the OpenSearch Serverless collection.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?
    /// The type of collection.
    public var type: OpenSearchServerlessClientTypes.CollectionType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        standbyReplicas: OpenSearchServerlessClientTypes.StandbyReplicas? = nil,
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil,
        type: OpenSearchServerlessClientTypes.CollectionType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.standbyReplicas = standbyReplicas
        self.tags = tags
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about the created OpenSearch Serverless collection.
    public struct CreateCollectionDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The Epoch time when the collection was created.
        public var createdDate: Swift.Int?
        /// A description of the collection.
        public var description: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the collection.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// Creates details about an OpenSearch Serverless collection.
        public var standbyReplicas: OpenSearchServerlessClientTypes.StandbyReplicas?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The type of collection.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init(
            arn: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            standbyReplicas: OpenSearchServerlessClientTypes.StandbyReplicas? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.status = status
            self.type = type
        }
    }
}

public struct CreateCollectionOutput: Swift.Sendable {
    /// Details about the collection.
    public var createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail?

    public init(
        createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail? = nil
    )
    {
        self.createCollectionDetail = createCollectionDetail
    }
}

public struct DeleteCollectionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the collection. For example, 1iu5usc406kd. The ID is part of the collection endpoint. You can also retrieve it using the [ListCollections](https://docs.aws.amazon.com/opensearch-service/latest/ServerlessAPIReference/API_ListCollections.html) API.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about a deleted OpenSearch Serverless collection.
    public struct DeleteCollectionDetail: Swift.Sendable {
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct DeleteCollectionOutput: Swift.Sendable {
    /// Details of the deleted collection.
    public var deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail?

    public init(
        deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail? = nil
    )
    {
        self.deleteCollectionDetail = deleteCollectionDetail
    }
}

extension OpenSearchServerlessClientTypes {

    /// A list of filter keys that you can use for LIST, UPDATE, and DELETE requests to OpenSearch Serverless collections.
    public struct CollectionFilters: Swift.Sendable {
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init(
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }
}

public struct ListCollectionsInput: Swift.Sendable {
    /// A list of filter names and values that you can use for requests.
    public var collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters?
    /// The maximum number of results to return. Default is 20. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListCollections operation returns a nextToken, you can include the returned nextToken in subsequent ListCollections operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionFilters = collectionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about each OpenSearch Serverless collection.
    public struct CollectionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct ListCollectionsOutput: Swift.Sendable {
    /// Details about each collection.
    public var collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionSummaries = collectionSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateCollectionInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the collection.
    public var description: Swift.String?
    /// The unique identifier of the collection.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.id = id
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about an updated OpenSearch Serverless collection.
    public struct UpdateCollectionDetail: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The date and time when the collection was created.
        public var createdDate: Swift.Int?
        /// The description of the collection.
        public var description: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The collection type.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init(
            arn: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }
}

public struct UpdateCollectionOutput: Swift.Sendable {
    /// Details about the updated collection.
    public var updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail?

    public init(
        updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail? = nil
    )
    {
        self.updateCollectionDetail = updateCollectionDetail
    }
}

extension OpenSearchServerlessClientTypes {

    public enum IamIdentityCenterGroupAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Group ID
        case groupid
        /// Group Name
        case groupname
        case sdkUnknown(Swift.String)

        public static var allCases: [IamIdentityCenterGroupAttribute] {
            return [
                .groupid,
                .groupname
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .groupid: return "GroupId"
            case .groupname: return "GroupName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    public enum IamIdentityCenterUserAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Email
        case email
        /// User ID
        case userid
        /// User Name
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [IamIdentityCenterUserAttribute] {
            return [
                .email,
                .userid,
                .username
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "Email"
            case .userid: return "UserId"
            case .username: return "UserName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Describes IAM Identity Center options for creating an OpenSearch Serverless security configuration in the form of a key-value map.
    public struct CreateIamIdentityCenterConfigOptions: Swift.Sendable {
        /// The group attribute for this IAM Identity Center integration. Defaults to GroupId.
        public var groupAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterGroupAttribute?
        /// The ARN of the IAM Identity Center instance used to integrate with OpenSearch Serverless.
        /// This member is required.
        public var instanceArn: Swift.String?
        /// The user attribute for this IAM Identity Center integration. Defaults to UserId.
        public var userAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterUserAttribute?

        public init(
            groupAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterGroupAttribute? = nil,
            instanceArn: Swift.String? = nil,
            userAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterUserAttribute? = nil
        )
        {
            self.groupAttribute = groupAttribute
            self.instanceArn = instanceArn
            self.userAttribute = userAttribute
        }
    }
}

public struct CreateLifecyclePolicyInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the lifecycle policy.
    public var description: Swift.String?
    /// The name of the lifecycle policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the lifecycle policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of lifecycle policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

public struct CreateLifecyclePolicyOutput: Swift.Sendable {
    /// Details about the created lifecycle policy.
    public var lifecyclePolicyDetail: OpenSearchServerlessClientTypes.LifecyclePolicyDetail?

    public init(
        lifecyclePolicyDetail: OpenSearchServerlessClientTypes.LifecyclePolicyDetail? = nil
    )
    {
        self.lifecyclePolicyDetail = lifecyclePolicyDetail
    }
}

extension OpenSearchServerlessClientTypes {

    /// Describes SAML options for an OpenSearch Serverless security configuration in the form of a key-value map.
    public struct SamlConfigOptions: Swift.Sendable {
        /// The group attribute for this SAML integration.
        public var groupAttribute: Swift.String?
        /// The XML IdP metadata file generated from your identity provider.
        /// This member is required.
        public var metadata: Swift.String?
        /// The session timeout, in minutes. Default is 60 minutes (12 hours).
        public var sessionTimeout: Swift.Int?
        /// A user attribute for this SAML integration.
        public var userAttribute: Swift.String?

        public init(
            groupAttribute: Swift.String? = nil,
            metadata: Swift.String? = nil,
            sessionTimeout: Swift.Int? = nil,
            userAttribute: Swift.String? = nil
        )
        {
            self.groupAttribute = groupAttribute
            self.metadata = metadata
            self.sessionTimeout = sessionTimeout
            self.userAttribute = userAttribute
        }
    }
}

extension OpenSearchServerlessClientTypes {

    public enum SecurityConfigType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// iam identity center
        case iamidentitycenter
        /// saml provider
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityConfigType] {
            return [
                .iamidentitycenter,
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iamidentitycenter: return "iamidentitycenter"
            case .saml: return "saml"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSecurityConfigInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the security configuration.
    public var description: Swift.String?
    /// Describes IAM Identity Center options in the form of a key-value map. This field is required if you specify iamidentitycenter for the type parameter.
    public var iamIdentityCenterOptions: OpenSearchServerlessClientTypes.CreateIamIdentityCenterConfigOptions?
    /// The name of the security configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Describes SAML options in in the form of a key-value map. This field is required if you specify saml for the type parameter.
    public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    /// The type of security configuration.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        iamIdentityCenterOptions: OpenSearchServerlessClientTypes.CreateIamIdentityCenterConfigOptions? = nil,
        name: Swift.String? = nil,
        samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil,
        type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.iamIdentityCenterOptions = iamIdentityCenterOptions
        self.name = name
        self.samlOptions = samlOptions
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// Describes IAM Identity Center options for an OpenSearch Serverless security configuration in the form of a key-value map.
    public struct IamIdentityCenterConfigOptions: Swift.Sendable {
        /// The ARN of the IAM Identity Center application used to integrate with OpenSearch Serverless.
        public var applicationArn: Swift.String?
        /// The description of the IAM Identity Center application used to integrate with OpenSearch Serverless.
        public var applicationDescription: Swift.String?
        /// The name of the IAM Identity Center application used to integrate with OpenSearch Serverless.
        public var applicationName: Swift.String?
        /// The group attribute for this IAM Identity Center integration. Defaults to GroupId.
        public var groupAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterGroupAttribute?
        /// The ARN of the IAM Identity Center instance used to integrate with OpenSearch Serverless.
        public var instanceArn: Swift.String?
        /// The user attribute for this IAM Identity Center integration. Defaults to UserId
        public var userAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterUserAttribute?

        public init(
            applicationArn: Swift.String? = nil,
            applicationDescription: Swift.String? = nil,
            applicationName: Swift.String? = nil,
            groupAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterGroupAttribute? = nil,
            instanceArn: Swift.String? = nil,
            userAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterUserAttribute? = nil
        )
        {
            self.applicationArn = applicationArn
            self.applicationDescription = applicationDescription
            self.applicationName = applicationName
            self.groupAttribute = groupAttribute
            self.instanceArn = instanceArn
            self.userAttribute = userAttribute
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about a security configuration for OpenSearch Serverless.
    public struct SecurityConfigDetail: Swift.Sendable {
        /// The version of the security configuration.
        public var configVersion: Swift.String?
        /// The date the configuration was created.
        public var createdDate: Swift.Int?
        /// The description of the security configuration.
        public var description: Swift.String?
        /// Describes IAM Identity Center options in the form of a key-value map.
        public var iamIdentityCenterOptions: OpenSearchServerlessClientTypes.IamIdentityCenterConfigOptions?
        /// The unique identifier of the security configuration.
        public var id: Swift.String?
        /// The timestamp of when the configuration was last modified.
        public var lastModifiedDate: Swift.Int?
        /// SAML options for the security configuration in the form of a key-value map.
        public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
        /// The type of security configuration.
        public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

        public init(
            configVersion: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            iamIdentityCenterOptions: OpenSearchServerlessClientTypes.IamIdentityCenterConfigOptions? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil,
            type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
        )
        {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.iamIdentityCenterOptions = iamIdentityCenterOptions
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.samlOptions = samlOptions
            self.type = type
        }
    }
}

public struct CreateSecurityConfigOutput: Swift.Sendable {
    /// Details about the created security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init(
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

extension OpenSearchServerlessClientTypes {

    public enum SecurityPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// encryption policy type
        case encryption
        /// network policy type
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyType] {
            return [
                .encryption,
                .network
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .encryption: return "encryption"
            case .network: return "network"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSecurityPolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the new policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of security policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// Details about an OpenSearch Serverless security policy.
    public struct SecurityPolicyDetail: Swift.Sendable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the security policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: Smithy.Document?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of security policy.
        public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: Smithy.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }
}

public struct CreateSecurityPolicyOutput: Swift.Sendable {
    /// Details about the created security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init(
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

public struct CreateVpcEndpointInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the interface endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var securityGroupIds: [Swift.String]?
    /// The ID of one or more subnets from which you'll access OpenSearch Serverless.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC from which you'll access OpenSearch Serverless.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension OpenSearchServerlessClientTypes {

    /// Creation details for an OpenSearch Serverless-managed interface endpoint. For more information, see [Access Amazon OpenSearch Serverless using an interface endpoint](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-vpc.html).
    public struct CreateVpcEndpointDetail: Swift.Sendable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status in the endpoint creation process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct CreateVpcEndpointOutput: Swift.Sendable {
    /// Details about the created interface VPC endpoint.
    public var createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail?

    public init(
        createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail? = nil
    )
    {
        self.createVpcEndpointDetail = createVpcEndpointDetail
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of lifecycle policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSecurityConfigInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The security configuration identifier. For SAML the ID will be saml/<accountId>/<idpProviderName>. For example, saml/123456789123/OKTADev.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

public struct DeleteSecurityConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSecurityPolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

public struct DeleteSecurityPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteVpcEndpointInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The VPC endpoint identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

extension OpenSearchServerlessClientTypes {

    /// Deletion details for an OpenSearch Serverless-managed interface endpoint.
    public struct DeleteVpcEndpointDetail: Swift.Sendable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status of the endpoint deletion process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct DeleteVpcEndpointOutput: Swift.Sendable {
    /// Details about the deleted endpoint.
    public var deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail?

    public init(
        deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail? = nil
    )
    {
        self.deleteVpcEndpointDetail = deleteVpcEndpointDetail
    }
}

public struct GetAccountSettingsInput: Swift.Sendable {

    public init() { }
}

public struct GetAccountSettingsOutput: Swift.Sendable {
    /// OpenSearch Serverless-related details for the current account.
    public var accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?

    public init(
        accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail? = nil
    )
    {
        self.accountSettingsDetail = accountSettingsDetail
    }
}

public struct GetPoliciesStatsInput: Swift.Sendable {

    public init() { }
}

extension OpenSearchServerlessClientTypes {

    /// Statistics for an OpenSearch Serverless lifecycle policy.
    public struct LifecyclePolicyStats: Swift.Sendable {
        /// The number of retention lifecycle policies in the current account.
        public var retentionPolicyCount: Swift.Int?

        public init(
            retentionPolicyCount: Swift.Int? = nil
        )
        {
            self.retentionPolicyCount = retentionPolicyCount
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Statistics for an OpenSearch Serverless security configuration.
    public struct SecurityConfigStats: Swift.Sendable {
        /// The number of security configurations in the current account.
        public var samlConfigCount: Swift.Int?

        public init(
            samlConfigCount: Swift.Int? = nil
        )
        {
            self.samlConfigCount = samlConfigCount
        }
    }
}

extension OpenSearchServerlessClientTypes {

    /// Statistics for an OpenSearch Serverless security policy.
    public struct SecurityPolicyStats: Swift.Sendable {
        /// The number of encryption policies in the current account.
        public var encryptionPolicyCount: Swift.Int?
        /// The number of network policies in the current account.
        public var networkPolicyCount: Swift.Int?

        public init(
            encryptionPolicyCount: Swift.Int? = nil,
            networkPolicyCount: Swift.Int? = nil
        )
        {
            self.encryptionPolicyCount = encryptionPolicyCount
            self.networkPolicyCount = networkPolicyCount
        }
    }
}

public struct GetPoliciesStatsOutput: Swift.Sendable {
    /// Information about the data access policies in your account.
    public var accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats?
    /// Information about the lifecycle policies in your account.
    public var lifecyclePolicyStats: OpenSearchServerlessClientTypes.LifecyclePolicyStats?
    /// Information about the security configurations in your account.
    public var securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats?
    /// Information about the security policies in your account.
    public var securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats?
    /// The total number of OpenSearch Serverless security policies and configurations in your account.
    public var totalPolicyCount: Swift.Int?

    public init(
        accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats? = nil,
        lifecyclePolicyStats: OpenSearchServerlessClientTypes.LifecyclePolicyStats? = nil,
        securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats? = nil,
        securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats? = nil,
        totalPolicyCount: Swift.Int? = nil
    )
    {
        self.accessPolicyStats = accessPolicyStats
        self.lifecyclePolicyStats = lifecyclePolicyStats
        self.securityConfigStats = securityConfigStats
        self.securityPolicyStats = securityPolicyStats
        self.totalPolicyCount = totalPolicyCount
    }
}

public struct GetSecurityConfigInput: Swift.Sendable {
    /// The unique identifier of the security configuration.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetSecurityConfigOutput: Swift.Sendable {
    /// Details of the requested security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init(
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

public struct GetSecurityPolicyInput: Swift.Sendable {
    /// The name of the security policy.
    /// This member is required.
    public var name: Swift.String?
    /// The type of security policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

public struct GetSecurityPolicyOutput: Swift.Sendable {
    /// Details about the requested security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init(
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

public struct ListLifecyclePoliciesInput: Swift.Sendable {
    /// An optional parameter that specifies the maximum number of results to return. You can use use nextToken to get the next page of results. The default is 10.
    public var maxResults: Swift.Int?
    /// If your initial ListLifecyclePolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListLifecyclePolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters that policies can apply to. Currently, the only supported resource type is index.
    public var resources: [Swift.String]?
    /// The type of lifecycle policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resources: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resources = resources
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// A summary of the lifecycle policy.
    public struct LifecyclePolicySummary: Swift.Sendable {
        /// The Epoch time when the lifecycle policy was created.
        public var createdDate: Swift.Int?
        /// The description of the lifecycle policy.
        public var description: Swift.String?
        /// The date and time when the lifecycle policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the lifecycle policy.
        public var name: Swift.String?
        /// The version of the lifecycle policy.
        public var policyVersion: Swift.String?
        /// The type of lifecycle policy.
        public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }
}

public struct ListLifecyclePoliciesOutput: Swift.Sendable {
    /// Details about the requested lifecycle policies.
    public var lifecyclePolicySummaries: [OpenSearchServerlessClientTypes.LifecyclePolicySummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        lifecyclePolicySummaries: [OpenSearchServerlessClientTypes.LifecyclePolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lifecyclePolicySummaries = lifecyclePolicySummaries
        self.nextToken = nextToken
    }
}

public struct UpdateLifecyclePolicyInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the lifecycle policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the lifecycle policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of lifecycle policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.LifecyclePolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.LifecyclePolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

public struct UpdateLifecyclePolicyOutput: Swift.Sendable {
    /// Details about the updated lifecycle policy.
    public var lifecyclePolicyDetail: OpenSearchServerlessClientTypes.LifecyclePolicyDetail?

    public init(
        lifecyclePolicyDetail: OpenSearchServerlessClientTypes.LifecyclePolicyDetail? = nil
    )
    {
        self.lifecyclePolicyDetail = lifecyclePolicyDetail
    }
}

public struct ListSecurityConfigsInput: Swift.Sendable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListSecurityConfigs operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityConfigs operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The type of security configuration.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// A summary of a security configuration for OpenSearch Serverless.
    public struct SecurityConfigSummary: Swift.Sendable {
        /// The version of the security configuration.
        public var configVersion: Swift.String?
        /// The Epoch time when the security configuration was created.
        public var createdDate: Swift.Int?
        /// The description of the security configuration.
        public var description: Swift.String?
        /// The unique identifier of the security configuration.
        public var id: Swift.String?
        /// The timestamp of when the configuration was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The type of security configuration.
        public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

        public init(
            configVersion: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
        )
        {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.type = type
        }
    }
}

public struct ListSecurityConfigsOutput: Swift.Sendable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about the security configurations in your account.
    public var securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]?

    public init(
        nextToken: Swift.String? = nil,
        securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityConfigSummaries = securityConfigSummaries
    }
}

public struct ListSecurityPoliciesInput: Swift.Sendable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListSecurityPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityPolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters (can be collection or indexes) that policies can apply to.
    public var resource: [Swift.String]?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resource: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resource = resource
        self.type = type
    }
}

extension OpenSearchServerlessClientTypes {

    /// A summary of a security policy for OpenSearch Serverless.
    public struct SecurityPolicySummary: Swift.Sendable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the security policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of security policy.
        public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

        public init(
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }
}

public struct ListSecurityPoliciesOutput: Swift.Sendable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about the security policies in your account.
    public var securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]?

    public init(
        nextToken: Swift.String? = nil,
        securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicySummaries = securityPolicySummaries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags associated with the resource.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?

    public init(
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension OpenSearchServerlessClientTypes {

    /// Filter the results of a ListVpcEndpoints request.
    public struct VpcEndpointFilters: Swift.Sendable {
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.status = status
        }
    }
}

public struct ListVpcEndpointsInput: Swift.Sendable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Filter the results according to the current status of the VPC endpoint. Possible statuses are CREATING, DELETING, UPDATING, ACTIVE, and FAILED.
    public var vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcEndpointFilters = vpcEndpointFilters
    }
}

extension OpenSearchServerlessClientTypes {

    /// The VPC endpoint object.
    public struct VpcEndpointSummary: Swift.Sendable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct ListVpcEndpointsOutput: Swift.Sendable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about each VPC endpoint, including the name and current status.
    public var vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcEndpointSummaries = vpcEndpointSummaries
    }
}

extension OpenSearchServerlessClientTypes {

    /// Describes IAM Identity Center options for updating an OpenSearch Serverless security configuration in the form of a key-value map.
    public struct UpdateIamIdentityCenterConfigOptions: Swift.Sendable {
        /// The group attribute for this IAM Identity Center integration. Defaults to GroupId.
        public var groupAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterGroupAttribute?
        /// The user attribute for this IAM Identity Center integration. Defaults to UserId.
        public var userAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterUserAttribute?

        public init(
            groupAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterGroupAttribute? = nil,
            userAttribute: OpenSearchServerlessClientTypes.IamIdentityCenterUserAttribute? = nil
        )
        {
            self.groupAttribute = groupAttribute
            self.userAttribute = userAttribute
        }
    }
}

public struct UpdateSecurityConfigInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The version of the security configuration to be updated. You can find the most recent version of a security configuration using the GetSecurityPolicy command.
    /// This member is required.
    public var configVersion: Swift.String?
    /// A description of the security configuration.
    public var description: Swift.String?
    /// Describes IAM Identity Center options in the form of a key-value map.
    public var iamIdentityCenterOptionsUpdates: OpenSearchServerlessClientTypes.UpdateIamIdentityCenterConfigOptions?
    /// The security configuration identifier. For SAML the ID will be saml/<accountId>/<idpProviderName>. For example, saml/123456789123/OKTADev.
    /// This member is required.
    public var id: Swift.String?
    /// SAML options in in the form of a key-value map.
    public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?

    public init(
        clientToken: Swift.String? = nil,
        configVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        iamIdentityCenterOptionsUpdates: OpenSearchServerlessClientTypes.UpdateIamIdentityCenterConfigOptions? = nil,
        id: Swift.String? = nil,
        samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil
    )
    {
        self.clientToken = clientToken
        self.configVersion = configVersion
        self.description = description
        self.iamIdentityCenterOptionsUpdates = iamIdentityCenterOptionsUpdates
        self.id = id
        self.samlOptions = samlOptions
    }
}

public struct UpdateSecurityConfigOutput: Swift.Sendable {
    /// Details about the updated security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init(
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

public struct UpdateSecurityPolicyInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the new policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of access policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

public struct UpdateSecurityPolicyOutput: Swift.Sendable {
    /// Details about the updated security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init(
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags (key-value pairs) to add to the resource. All tag keys in the request must be unique.
    /// This member is required.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag or set of tags to remove from the resource. All tag keys in the request must be unique.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAccountSettingsInput: Swift.Sendable {
    /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Managing capacity limits for Amazon OpenSearch Serverless](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-scaling.html).
    public var capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?

    public init(
        capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits? = nil
    )
    {
        self.capacityLimits = capacityLimits
    }
}

public struct UpdateAccountSettingsOutput: Swift.Sendable {
    /// OpenSearch Serverless-related settings for the current Amazon Web Services account.
    public var accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?

    public init(
        accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail? = nil
    )
    {
        self.accountSettingsDetail = accountSettingsDetail
    }
}

public struct UpdateVpcEndpointInput: Swift.Sendable {
    /// The unique identifiers of the security groups to add to the endpoint. Security groups define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var addSecurityGroupIds: [Swift.String]?
    /// The ID of one or more subnets to add to the endpoint.
    public var addSubnetIds: [Swift.String]?
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the interface endpoint to update.
    /// This member is required.
    public var id: Swift.String?
    /// The unique identifiers of the security groups to remove from the endpoint.
    public var removeSecurityGroupIds: [Swift.String]?
    /// The unique identifiers of the subnets to remove from the endpoint.
    public var removeSubnetIds: [Swift.String]?

    public init(
        addSecurityGroupIds: [Swift.String]? = nil,
        addSubnetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        removeSecurityGroupIds: [Swift.String]? = nil,
        removeSubnetIds: [Swift.String]? = nil
    )
    {
        self.addSecurityGroupIds = addSecurityGroupIds
        self.addSubnetIds = addSubnetIds
        self.clientToken = clientToken
        self.id = id
        self.removeSecurityGroupIds = removeSecurityGroupIds
        self.removeSubnetIds = removeSubnetIds
    }
}

extension OpenSearchServerlessClientTypes {

    /// Update details for an OpenSearch Serverless-managed interface endpoint.
    public struct UpdateVpcEndpointDetail: Swift.Sendable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The timestamp of when the endpoint was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of the endpoint update process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public var subnetIds: [Swift.String]?

        public init(
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
        }
    }
}

public struct UpdateVpcEndpointOutput: Swift.Sendable {
    /// Details about the updated VPC endpoint.
    public var updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail?

    public init(
        updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail? = nil
    )
    {
        self.updateVpcEndpointDetail = updateVpcEndpointDetail
    }
}

extension BatchGetCollectionInput {

    static func urlPathProvider(_ value: BatchGetCollectionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetEffectiveLifecyclePolicyInput {

    static func urlPathProvider(_ value: BatchGetEffectiveLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetLifecyclePolicyInput {

    static func urlPathProvider(_ value: BatchGetLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetVpcEndpointInput {

    static func urlPathProvider(_ value: BatchGetVpcEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAccessPolicyInput {

    static func urlPathProvider(_ value: CreateAccessPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCollectionInput {

    static func urlPathProvider(_ value: CreateCollectionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLifecyclePolicyInput {

    static func urlPathProvider(_ value: CreateLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSecurityConfigInput {

    static func urlPathProvider(_ value: CreateSecurityConfigInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSecurityPolicyInput {

    static func urlPathProvider(_ value: CreateSecurityPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVpcEndpointInput {

    static func urlPathProvider(_ value: CreateVpcEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccessPolicyInput {

    static func urlPathProvider(_ value: DeleteAccessPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCollectionInput {

    static func urlPathProvider(_ value: DeleteCollectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLifecyclePolicyInput {

    static func urlPathProvider(_ value: DeleteLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSecurityConfigInput {

    static func urlPathProvider(_ value: DeleteSecurityConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSecurityPolicyInput {

    static func urlPathProvider(_ value: DeleteSecurityPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVpcEndpointInput {

    static func urlPathProvider(_ value: DeleteVpcEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccessPolicyInput {

    static func urlPathProvider(_ value: GetAccessPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountSettingsInput {

    static func urlPathProvider(_ value: GetAccountSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension GetPoliciesStatsInput {

    static func urlPathProvider(_ value: GetPoliciesStatsInput) -> Swift.String? {
        return "/"
    }
}

extension GetSecurityConfigInput {

    static func urlPathProvider(_ value: GetSecurityConfigInput) -> Swift.String? {
        return "/"
    }
}

extension GetSecurityPolicyInput {

    static func urlPathProvider(_ value: GetSecurityPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccessPoliciesInput {

    static func urlPathProvider(_ value: ListAccessPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListCollectionsInput {

    static func urlPathProvider(_ value: ListCollectionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLifecyclePoliciesInput {

    static func urlPathProvider(_ value: ListLifecyclePoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSecurityConfigsInput {

    static func urlPathProvider(_ value: ListSecurityConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSecurityPoliciesInput {

    static func urlPathProvider(_ value: ListSecurityPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListVpcEndpointsInput {

    static func urlPathProvider(_ value: ListVpcEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAccessPolicyInput {

    static func urlPathProvider(_ value: UpdateAccessPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAccountSettingsInput {

    static func urlPathProvider(_ value: UpdateAccountSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCollectionInput {

    static func urlPathProvider(_ value: UpdateCollectionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLifecyclePolicyInput {

    static func urlPathProvider(_ value: UpdateLifecyclePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSecurityConfigInput {

    static func urlPathProvider(_ value: UpdateSecurityConfigInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSecurityPolicyInput {

    static func urlPathProvider(_ value: UpdateSecurityPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVpcEndpointInput {

    static func urlPathProvider(_ value: UpdateVpcEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetCollectionInput {

    static func write(value: BatchGetCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetEffectiveLifecyclePolicyInput {

    static func write(value: BatchGetEffectiveLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceIdentifiers"].writeList(value.resourceIdentifiers, memberWritingClosure: OpenSearchServerlessClientTypes.LifecyclePolicyResourceIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetLifecyclePolicyInput {

    static func write(value: BatchGetLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifiers"].writeList(value.identifiers, memberWritingClosure: OpenSearchServerlessClientTypes.LifecyclePolicyIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetVpcEndpointInput {

    static func write(value: BatchGetVpcEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccessPolicyInput {

    static func write(value: CreateAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["type"].write(value.type)
    }
}

extension CreateCollectionInput {

    static func write(value: CreateCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["standbyReplicas"].write(value.standbyReplicas)
        try writer["tags"].writeList(value.tags, memberWritingClosure: OpenSearchServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateLifecyclePolicyInput {

    static func write(value: CreateLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["type"].write(value.type)
    }
}

extension CreateSecurityConfigInput {

    static func write(value: CreateSecurityConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["iamIdentityCenterOptions"].write(value.iamIdentityCenterOptions, with: OpenSearchServerlessClientTypes.CreateIamIdentityCenterConfigOptions.write(value:to:))
        try writer["name"].write(value.name)
        try writer["samlOptions"].write(value.samlOptions, with: OpenSearchServerlessClientTypes.SamlConfigOptions.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension CreateSecurityPolicyInput {

    static func write(value: CreateSecurityPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["type"].write(value.type)
    }
}

extension CreateVpcEndpointInput {

    static func write(value: CreateVpcEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension DeleteAccessPolicyInput {

    static func write(value: DeleteAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension DeleteCollectionInput {

    static func write(value: DeleteCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["id"].write(value.id)
    }
}

extension DeleteLifecyclePolicyInput {

    static func write(value: DeleteLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension DeleteSecurityConfigInput {

    static func write(value: DeleteSecurityConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["id"].write(value.id)
    }
}

extension DeleteSecurityPolicyInput {

    static func write(value: DeleteSecurityPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension DeleteVpcEndpointInput {

    static func write(value: DeleteVpcEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["id"].write(value.id)
    }
}

extension GetAccessPolicyInput {

    static func write(value: GetAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension GetAccountSettingsInput {

    static func write(value: GetAccountSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetPoliciesStatsInput {

    static func write(value: GetPoliciesStatsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetSecurityConfigInput {

    static func write(value: GetSecurityConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension GetSecurityPolicyInput {

    static func write(value: GetSecurityPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension ListAccessPoliciesInput {

    static func write(value: ListAccessPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resource"].writeList(value.resource, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension ListCollectionsInput {

    static func write(value: ListCollectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collectionFilters"].write(value.collectionFilters, with: OpenSearchServerlessClientTypes.CollectionFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListLifecyclePoliciesInput {

    static func write(value: ListLifecyclePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resources"].writeList(value.resources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension ListSecurityConfigsInput {

    static func write(value: ListSecurityConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["type"].write(value.type)
    }
}

extension ListSecurityPoliciesInput {

    static func write(value: ListSecurityPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resource"].writeList(value.resource, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension ListVpcEndpointsInput {

    static func write(value: ListVpcEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["vpcEndpointFilters"].write(value.vpcEndpointFilters, with: OpenSearchServerlessClientTypes.VpcEndpointFilters.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: OpenSearchServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAccessPolicyInput {

    static func write(value: UpdateAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["policyVersion"].write(value.policyVersion)
        try writer["type"].write(value.type)
    }
}

extension UpdateAccountSettingsInput {

    static func write(value: UpdateAccountSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capacityLimits"].write(value.capacityLimits, with: OpenSearchServerlessClientTypes.CapacityLimits.write(value:to:))
    }
}

extension UpdateCollectionInput {

    static func write(value: UpdateCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
    }
}

extension UpdateLifecyclePolicyInput {

    static func write(value: UpdateLifecyclePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["policyVersion"].write(value.policyVersion)
        try writer["type"].write(value.type)
    }
}

extension UpdateSecurityConfigInput {

    static func write(value: UpdateSecurityConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configVersion"].write(value.configVersion)
        try writer["description"].write(value.description)
        try writer["iamIdentityCenterOptionsUpdates"].write(value.iamIdentityCenterOptionsUpdates, with: OpenSearchServerlessClientTypes.UpdateIamIdentityCenterConfigOptions.write(value:to:))
        try writer["id"].write(value.id)
        try writer["samlOptions"].write(value.samlOptions, with: OpenSearchServerlessClientTypes.SamlConfigOptions.write(value:to:))
    }
}

extension UpdateSecurityPolicyInput {

    static func write(value: UpdateSecurityPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["policyVersion"].write(value.policyVersion)
        try writer["type"].write(value.type)
    }
}

extension UpdateVpcEndpointInput {

    static func write(value: UpdateVpcEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addSecurityGroupIds"].writeList(value.addSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["addSubnetIds"].writeList(value.addSubnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["id"].write(value.id)
        try writer["removeSecurityGroupIds"].writeList(value.removeSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["removeSubnetIds"].writeList(value.removeSubnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetCollectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCollectionOutput()
        value.collectionDetails = try reader["collectionDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.CollectionDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.collectionErrorDetails = try reader["collectionErrorDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.CollectionErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetEffectiveLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetEffectiveLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetEffectiveLifecyclePolicyOutput()
        value.effectiveLifecyclePolicyDetails = try reader["effectiveLifecyclePolicyDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.effectiveLifecyclePolicyErrorDetails = try reader["effectiveLifecyclePolicyErrorDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetLifecyclePolicyOutput()
        value.lifecyclePolicyDetails = try reader["lifecyclePolicyDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.LifecyclePolicyDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lifecyclePolicyErrorDetails = try reader["lifecyclePolicyErrorDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.LifecyclePolicyErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetVpcEndpointOutput()
        value.vpcEndpointDetails = try reader["vpcEndpointDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.VpcEndpointDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcEndpointErrorDetails = try reader["vpcEndpointErrorDetails"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.VpcEndpointErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessPolicyOutput()
        value.accessPolicyDetail = try reader["accessPolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.AccessPolicyDetail.read(from:))
        return value
    }
}

extension CreateCollectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCollectionOutput()
        value.createCollectionDetail = try reader["createCollectionDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.CreateCollectionDetail.read(from:))
        return value
    }
}

extension CreateLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLifecyclePolicyOutput()
        value.lifecyclePolicyDetail = try reader["lifecyclePolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.LifecyclePolicyDetail.read(from:))
        return value
    }
}

extension CreateSecurityConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSecurityConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSecurityConfigOutput()
        value.securityConfigDetail = try reader["securityConfigDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityConfigDetail.read(from:))
        return value
    }
}

extension CreateSecurityPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSecurityPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSecurityPolicyOutput()
        value.securityPolicyDetail = try reader["securityPolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityPolicyDetail.read(from:))
        return value
    }
}

extension CreateVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcEndpointOutput()
        value.createVpcEndpointDetail = try reader["createVpcEndpointDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail.read(from:))
        return value
    }
}

extension DeleteAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessPolicyOutput {
        return DeleteAccessPolicyOutput()
    }
}

extension DeleteCollectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCollectionOutput()
        value.deleteCollectionDetail = try reader["deleteCollectionDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.DeleteCollectionDetail.read(from:))
        return value
    }
}

extension DeleteLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLifecyclePolicyOutput {
        return DeleteLifecyclePolicyOutput()
    }
}

extension DeleteSecurityConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSecurityConfigOutput {
        return DeleteSecurityConfigOutput()
    }
}

extension DeleteSecurityPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSecurityPolicyOutput {
        return DeleteSecurityPolicyOutput()
    }
}

extension DeleteVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVpcEndpointOutput()
        value.deleteVpcEndpointDetail = try reader["deleteVpcEndpointDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail.read(from:))
        return value
    }
}

extension GetAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessPolicyOutput()
        value.accessPolicyDetail = try reader["accessPolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.AccessPolicyDetail.read(from:))
        return value
    }
}

extension GetAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountSettingsOutput()
        value.accountSettingsDetail = try reader["accountSettingsDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.AccountSettingsDetail.read(from:))
        return value
    }
}

extension GetPoliciesStatsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPoliciesStatsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPoliciesStatsOutput()
        value.accessPolicyStats = try reader["AccessPolicyStats"].readIfPresent(with: OpenSearchServerlessClientTypes.AccessPolicyStats.read(from:))
        value.lifecyclePolicyStats = try reader["LifecyclePolicyStats"].readIfPresent(with: OpenSearchServerlessClientTypes.LifecyclePolicyStats.read(from:))
        value.securityConfigStats = try reader["SecurityConfigStats"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityConfigStats.read(from:))
        value.securityPolicyStats = try reader["SecurityPolicyStats"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityPolicyStats.read(from:))
        value.totalPolicyCount = try reader["TotalPolicyCount"].readIfPresent()
        return value
    }
}

extension GetSecurityConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSecurityConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSecurityConfigOutput()
        value.securityConfigDetail = try reader["securityConfigDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityConfigDetail.read(from:))
        return value
    }
}

extension GetSecurityPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSecurityPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSecurityPolicyOutput()
        value.securityPolicyDetail = try reader["securityPolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityPolicyDetail.read(from:))
        return value
    }
}

extension ListAccessPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessPoliciesOutput()
        value.accessPolicySummaries = try reader["accessPolicySummaries"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.AccessPolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollectionsOutput()
        value.collectionSummaries = try reader["collectionSummaries"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.CollectionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLifecyclePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLifecyclePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLifecyclePoliciesOutput()
        value.lifecyclePolicySummaries = try reader["lifecyclePolicySummaries"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.LifecyclePolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSecurityConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityConfigsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.securityConfigSummaries = try reader["securityConfigSummaries"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.SecurityConfigSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSecurityPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityPoliciesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.securityPolicySummaries = try reader["securityPolicySummaries"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.SecurityPolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVpcEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVpcEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcEndpointsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vpcEndpointSummaries = try reader["vpcEndpointSummaries"].readListIfPresent(memberReadingClosure: OpenSearchServerlessClientTypes.VpcEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessPolicyOutput()
        value.accessPolicyDetail = try reader["accessPolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.AccessPolicyDetail.read(from:))
        return value
    }
}

extension UpdateAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccountSettingsOutput()
        value.accountSettingsDetail = try reader["accountSettingsDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.AccountSettingsDetail.read(from:))
        return value
    }
}

extension UpdateCollectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCollectionOutput()
        value.updateCollectionDetail = try reader["updateCollectionDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.UpdateCollectionDetail.read(from:))
        return value
    }
}

extension UpdateLifecyclePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLifecyclePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLifecyclePolicyOutput()
        value.lifecyclePolicyDetail = try reader["lifecyclePolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.LifecyclePolicyDetail.read(from:))
        return value
    }
}

extension UpdateSecurityConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSecurityConfigOutput()
        value.securityConfigDetail = try reader["securityConfigDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityConfigDetail.read(from:))
        return value
    }
}

extension UpdateSecurityPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSecurityPolicyOutput()
        value.securityPolicyDetail = try reader["securityPolicyDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.SecurityPolicyDetail.read(from:))
        return value
    }
}

extension UpdateVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcEndpointOutput()
        value.updateVpcEndpointDetail = try reader["UpdateVpcEndpointDetail"].readIfPresent(with: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail.read(from:))
        return value
    }
}

enum BatchGetCollectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetEffectiveLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCollectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OcuLimitExceededException": return try OcuLimitExceededException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSecurityConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSecurityPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCollectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSecurityConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSecurityPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPoliciesStatsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSecurityConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSecurityPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLifecyclePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVpcEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCollectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLifecyclePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OcuLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OcuLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = OcuLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpenSearchServerlessClientTypes.CollectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.CollectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.CollectionDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.standbyReplicas = try reader["standbyReplicas"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        value.collectionEndpoint = try reader["collectionEndpoint"].readIfPresent()
        value.dashboardEndpoint = try reader["dashboardEndpoint"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.CollectionErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.CollectionErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.CollectionErrorDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyDetail()
        value.type = try reader["type"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent()
        value.policyName = try reader["policyName"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.retentionPeriod = try reader["retentionPeriod"].readIfPresent()
        value.noMinRetentionPeriod = try reader["noMinRetentionPeriod"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.EffectiveLifecyclePolicyErrorDetail()
        value.type = try reader["type"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.LifecyclePolicyDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.LifecyclePolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.LifecyclePolicyDetail()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policyVersion = try reader["policyVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.LifecyclePolicyErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.LifecyclePolicyErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.LifecyclePolicyErrorDetail()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.VpcEndpointDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.VpcEndpointDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.VpcEndpointErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.VpcEndpointErrorDetail()
        value.id = try reader["id"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.AccessPolicyDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.AccessPolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.AccessPolicyDetail()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policyVersion = try reader["policyVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.CreateCollectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.CreateCollectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.CreateCollectionDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.standbyReplicas = try reader["standbyReplicas"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SecurityConfigDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SecurityConfigDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SecurityConfigDetail()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.configVersion = try reader["configVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.samlOptions = try reader["samlOptions"].readIfPresent(with: OpenSearchServerlessClientTypes.SamlConfigOptions.read(from:))
        value.iamIdentityCenterOptions = try reader["iamIdentityCenterOptions"].readIfPresent(with: OpenSearchServerlessClientTypes.IamIdentityCenterConfigOptions.read(from:))
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.IamIdentityCenterConfigOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.IamIdentityCenterConfigOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.IamIdentityCenterConfigOptions()
        value.instanceArn = try reader["instanceArn"].readIfPresent()
        value.applicationArn = try reader["applicationArn"].readIfPresent()
        value.applicationName = try reader["applicationName"].readIfPresent()
        value.applicationDescription = try reader["applicationDescription"].readIfPresent()
        value.userAttribute = try reader["userAttribute"].readIfPresent()
        value.groupAttribute = try reader["groupAttribute"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SamlConfigOptions {

    static func write(value: OpenSearchServerlessClientTypes.SamlConfigOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupAttribute"].write(value.groupAttribute)
        try writer["metadata"].write(value.metadata)
        try writer["sessionTimeout"].write(value.sessionTimeout)
        try writer["userAttribute"].write(value.userAttribute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SamlConfigOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SamlConfigOptions()
        value.metadata = try reader["metadata"].readIfPresent() ?? ""
        value.userAttribute = try reader["userAttribute"].readIfPresent()
        value.groupAttribute = try reader["groupAttribute"].readIfPresent()
        value.sessionTimeout = try reader["sessionTimeout"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SecurityPolicyDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SecurityPolicyDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SecurityPolicyDetail()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policyVersion = try reader["policyVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.CreateVpcEndpointDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.CreateVpcEndpointDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.CreateVpcEndpointDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.DeleteCollectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.DeleteCollectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.DeleteCollectionDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.AccountSettingsDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.AccountSettingsDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.AccountSettingsDetail()
        value.capacityLimits = try reader["capacityLimits"].readIfPresent(with: OpenSearchServerlessClientTypes.CapacityLimits.read(from:))
        return value
    }
}

extension OpenSearchServerlessClientTypes.CapacityLimits {

    static func write(value: OpenSearchServerlessClientTypes.CapacityLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxIndexingCapacityInOCU"].write(value.maxIndexingCapacityInOCU)
        try writer["maxSearchCapacityInOCU"].write(value.maxSearchCapacityInOCU)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.CapacityLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.CapacityLimits()
        value.maxIndexingCapacityInOCU = try reader["maxIndexingCapacityInOCU"].readIfPresent()
        value.maxSearchCapacityInOCU = try reader["maxSearchCapacityInOCU"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.AccessPolicyStats {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.AccessPolicyStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.AccessPolicyStats()
        value.dataPolicyCount = try reader["DataPolicyCount"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SecurityPolicyStats {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SecurityPolicyStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SecurityPolicyStats()
        value.encryptionPolicyCount = try reader["EncryptionPolicyCount"].readIfPresent()
        value.networkPolicyCount = try reader["NetworkPolicyCount"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SecurityConfigStats {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SecurityConfigStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SecurityConfigStats()
        value.samlConfigCount = try reader["SamlConfigCount"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.LifecyclePolicyStats {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.LifecyclePolicyStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.LifecyclePolicyStats()
        value.retentionPolicyCount = try reader["RetentionPolicyCount"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.AccessPolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.AccessPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.AccessPolicySummary()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policyVersion = try reader["policyVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.CollectionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.CollectionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.CollectionSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.LifecyclePolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.LifecyclePolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.LifecyclePolicySummary()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policyVersion = try reader["policyVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SecurityConfigSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SecurityConfigSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SecurityConfigSummary()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.configVersion = try reader["configVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.SecurityPolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.SecurityPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.SecurityPolicySummary()
        value.type = try reader["type"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policyVersion = try reader["policyVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.Tag {

    static func write(value: OpenSearchServerlessClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.VpcEndpointSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.VpcEndpointSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.UpdateCollectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.UpdateCollectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.UpdateCollectionDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdDate = try reader["createdDate"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedDate = try reader["lastModifiedDate"].readIfPresent()
        return value
    }
}

extension OpenSearchServerlessClientTypes.LifecyclePolicyResourceIdentifier {

    static func write(value: OpenSearchServerlessClientTypes.LifecyclePolicyResourceIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resource"].write(value.resource)
        try writer["type"].write(value.type)
    }
}

extension OpenSearchServerlessClientTypes.LifecyclePolicyIdentifier {

    static func write(value: OpenSearchServerlessClientTypes.LifecyclePolicyIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension OpenSearchServerlessClientTypes.CreateIamIdentityCenterConfigOptions {

    static func write(value: OpenSearchServerlessClientTypes.CreateIamIdentityCenterConfigOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupAttribute"].write(value.groupAttribute)
        try writer["instanceArn"].write(value.instanceArn)
        try writer["userAttribute"].write(value.userAttribute)
    }
}

extension OpenSearchServerlessClientTypes.CollectionFilters {

    static func write(value: OpenSearchServerlessClientTypes.CollectionFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["status"].write(value.status)
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointFilters {

    static func write(value: OpenSearchServerlessClientTypes.VpcEndpointFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension OpenSearchServerlessClientTypes.UpdateIamIdentityCenterConfigOptions {

    static func write(value: OpenSearchServerlessClientTypes.UpdateIamIdentityCenterConfigOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupAttribute"].write(value.groupAttribute)
        try writer["userAttribute"].write(value.userAttribute)
    }
}

public enum OpenSearchServerlessClientTypes {}
