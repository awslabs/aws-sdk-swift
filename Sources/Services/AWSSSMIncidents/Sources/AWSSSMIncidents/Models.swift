//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient access to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMIncidentsClientTypes {

    public enum VariableType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incidentRecordArn
        case involvedResources
        case sdkUnknown(Swift.String)

        public static var allCases: [VariableType] {
            return [
                .incidentRecordArn,
                .involvedResources
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incidentRecordArn: return "INCIDENT_RECORD_ARN"
            case .involvedResources: return "INVOLVED_RESOURCES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    /// The dynamic SSM parameter value.
    public enum DynamicSsmParameterValue: Swift.Sendable {
        /// Variable dynamic parameters. A parameter value is determined when an incident is created.
        case variable(SSMIncidentsClientTypes.VariableType)
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    public enum SsmTargetAccount: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case impactedAccount
        case responsePlanOwnerAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmTargetAccount] {
            return [
                .impactedAccount,
                .responsePlanOwnerAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .impactedAccount: return "IMPACTED_ACCOUNT"
            case .responsePlanOwnerAccount: return "RESPONSE_PLAN_OWNER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Details about the Systems Manager automation document that will be used as a runbook during an incident.
    public struct SsmAutomation: Swift.Sendable {
        /// The automation document's name.
        /// This member is required.
        public var documentName: Swift.String?
        /// The automation document's version to use when running.
        public var documentVersion: Swift.String?
        /// The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
        public var dynamicParameters: [Swift.String: SSMIncidentsClientTypes.DynamicSsmParameterValue]?
        /// The key-value pair parameters to use when running the automation document.
        public var parameters: [Swift.String: [Swift.String]]?
        /// The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The account that the automation document will be run in. This can be in either the management account or an application account.
        public var targetAccount: SSMIncidentsClientTypes.SsmTargetAccount?

        public init(
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            dynamicParameters: [Swift.String: SSMIncidentsClientTypes.DynamicSsmParameterValue]? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            roleArn: Swift.String? = nil,
            targetAccount: SSMIncidentsClientTypes.SsmTargetAccount? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.dynamicParameters = dynamicParameters
            self.parameters = parameters
            self.roleArn = roleArn
            self.targetAccount = targetAccount
        }
    }
}

extension SSMIncidentsClientTypes {

    /// The action that starts at the beginning of an incident. The response plan defines the action.
    public enum Action: Swift.Sendable {
        /// The Systems Manager automation document to start as the runbook at the beginning of the incident.
        case ssmautomation(SSMIncidentsClientTypes.SsmAutomation)
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// Defines the Amazon Web Services Region and KMS key to add to the replication set.
    public struct AddRegionAction: Swift.Sendable {
        /// The Amazon Web Services Region name to add to the replication set.
        /// This member is required.
        public var regionName: Swift.String?
        /// The KMS key ID to use to encrypt your replication set.
        public var sseKmsKeyId: Swift.String?

        public init(
            regionName: Swift.String? = nil,
            sseKmsKeyId: Swift.String? = nil
        )
        {
            self.regionName = regionName
            self.sseKmsKeyId = sseKmsKeyId
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Use the AttributeValueList to filter by string or integer values.
    public enum AttributeValueList: Swift.Sendable {
        /// The list of string values that the filter matches.
        case stringvalues([Swift.String])
        /// The list of integer values that the filter matches.
        case integervalues([Swift.Int])
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// The Systems Manager automation document process to start as the runbook at the beginning of the incident.
    public enum AutomationExecution: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the automation process.
        case ssmexecutionarn(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMIncidentsClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incidentRecord
        case replicationSet
        case resourcePolicy
        case responsePlan
        case timelineEvent
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .incidentRecord,
                .replicationSet,
                .resourcePolicy,
                .responsePlan,
                .timelineEvent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incidentRecord: return "INCIDENT_RECORD"
            case .replicationSet: return "REPLICATION_SET"
            case .resourcePolicy: return "RESOURCE_POLICY"
            case .responsePlan: return "RESPONSE_PLAN"
            case .timelineEvent: return "TIMELINE_EVENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Request references a resource which doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the requested resource
        public internal(set) var resourceIdentifier: Swift.String? = nil
        /// The resource type
        public internal(set) var resourceType: SSMIncidentsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: SSMIncidentsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceIdentifier = resourceIdentifier
        self.properties.resourceType = resourceType
    }
}

extension SSMIncidentsClientTypes {

    public enum ServiceCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ssmIncidents
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceCode] {
            return [
                .ssmIncidents
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssmIncidents: return "ssm-incidents"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Originating quota code
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Originating service code
        /// This member is required.
        public internal(set) var serviceCode: SSMIncidentsClientTypes.ServiceCode? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: SSMIncidentsClientTypes.ServiceCode? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetIncidentFindingsInput: Swift.Sendable {
    /// A list of IDs of findings for which you want to view details.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the incident for which you want to view finding details.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        findingIds: [Swift.String]? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.findingIds = findingIds
        self.incidentRecordArn = incidentRecordArn
    }
}

extension SSMIncidentsClientTypes {

    /// Details about an error returned for a [BatchGetIncidentFindings] operation.
    public struct BatchGetIncidentFindingsError: Swift.Sendable {
        /// The code associated with an error that was returned for a BatchGetIncidentFindings operation.
        /// This member is required.
        public var code: Swift.String?
        /// The ID of a specified finding for which an error was returned for a BatchGetIncidentFindings operation.
        /// This member is required.
        public var findingId: Swift.String?
        /// The description for an error that was returned for a BatchGetIncidentFindings operation.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            findingId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.findingId = findingId
            self.message = message
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Information about an CloudFormation stack creation or update that occurred around the time of an incident and could be a potential cause of the incident.
    public struct CloudFormationStackUpdate: Swift.Sendable {
        /// The timestamp for when the CloudFormation stack creation or update ended. Not reported for deployments that are still in progress.
        public var endTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the CloudFormation stack involved in the update.
        /// This member is required.
        public var stackArn: Swift.String?
        /// The timestamp for when the CloudFormation stack creation or update began.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            stackArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.stackArn = stackArn
            self.startTime = startTime
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Information about a CodeDeploy deployment that occurred around the time of an incident and could be a possible cause of the incident.
    public struct CodeDeployDeployment: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the CodeDeploy deployment group associated with the deployment.
        /// This member is required.
        public var deploymentGroupArn: Swift.String?
        /// The ID of the CodeDeploy deployment.
        /// This member is required.
        public var deploymentId: Swift.String?
        /// The timestamp for when the CodeDeploy deployment ended. Not reported for deployments that are still in progress.
        public var endTime: Foundation.Date?
        /// The timestamp for when the CodeDeploy deployment began.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            deploymentGroupArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.deploymentGroupArn = deploymentGroupArn
            self.deploymentId = deploymentId
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Extended textual information about the finding.
    public enum FindingDetails: Swift.Sendable {
        /// Information about the CodeDeploy deployment associated with the finding.
        case codedeploydeployment(SSMIncidentsClientTypes.CodeDeployDeployment)
        /// Information about the CloudFormation stack creation or update associated with the finding.
        case cloudformationstackupdate(SSMIncidentsClientTypes.CloudFormationStackUpdate)
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// Information about a specific CodeDeploy deployment or CloudFormation stack creation or update that occurred around the time of a reported incident. These activities can be investigated as a potential cause of the incident.
    public struct Finding: Swift.Sendable {
        /// The timestamp for when a finding was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Details about the finding.
        public var details: SSMIncidentsClientTypes.FindingDetails?
        /// The ID assigned to the finding.
        /// This member is required.
        public var id: Swift.String?
        /// The timestamp for when the finding was most recently updated with additional information.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            creationTime: Foundation.Date? = nil,
            details: SSMIncidentsClientTypes.FindingDetails? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.details = details
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct BatchGetIncidentFindingsOutput: Swift.Sendable {
    /// A list of errors encountered during the operation.
    /// This member is required.
    public var errors: [SSMIncidentsClientTypes.BatchGetIncidentFindingsError]?
    /// Information about the requested findings.
    /// This member is required.
    public var findings: [SSMIncidentsClientTypes.Finding]?

    public init(
        errors: [SSMIncidentsClientTypes.BatchGetIncidentFindingsError]? = nil,
        findings: [SSMIncidentsClientTypes.Finding]? = nil
    )
    {
        self.errors = errors
        self.findings = findings
    }
}

extension SSMIncidentsClientTypes {

    /// Used to remove the chat channel from an incident record or response plan.
    public struct EmptyChatChannel: Swift.Sendable {

        public init() { }
    }
}

extension SSMIncidentsClientTypes {

    /// The Chatbot chat channel used for collaboration during an incident.
    public enum ChatChannel: Swift.Sendable {
        /// Used to remove the chat channel from an incident record or response plan.
        case empty(SSMIncidentsClientTypes.EmptyChatChannel)
        /// The Amazon SNS targets that Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel by using the Amazon SNS topics.
        case chatbotsns([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// A conditional statement with which to compare a value, after a timestamp, before a timestamp, or equal to a string or integer. If multiple conditions are specified, the conditionals become an ANDed statement. If multiple values are specified for a conditional, the values are ORd.
    public enum Condition: Swift.Sendable {
        /// Before the specified timestamp
        case before(Foundation.Date)
        /// After the specified timestamp.
        case after(Foundation.Date)
        /// The value is equal to the provided string or integer.
        case equals(SSMIncidentsClientTypes.AttributeValueList)
        case sdkUnknown(Swift.String)
    }
}

/// Updating or deleting a resource causes an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the requested resource
        public internal(set) var resourceIdentifier: Swift.String? = nil
        /// The resource type
        public internal(set) var resourceType: SSMIncidentsClientTypes.ResourceType? = nil
        /// If present in the output, the operation can be retried after this time
        public internal(set) var retryAfter: Foundation.Date? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: SSMIncidentsClientTypes.ResourceType? = nil,
        retryAfter: Foundation.Date? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceIdentifier = resourceIdentifier
        self.properties.resourceType = resourceType
        self.properties.retryAfter = retryAfter
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Originating quota code
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier for the requested resource
        public internal(set) var resourceIdentifier: Swift.String? = nil
        /// The resource type
        public internal(set) var resourceType: SSMIncidentsClientTypes.ResourceType? = nil
        /// Originating service code
        /// This member is required.
        public internal(set) var serviceCode: SSMIncidentsClientTypes.ServiceCode? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: SSMIncidentsClientTypes.ResourceType? = nil,
        serviceCode: SSMIncidentsClientTypes.ServiceCode? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceIdentifier = resourceIdentifier
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension SSMIncidentsClientTypes {

    /// The mapping between a Amazon Web Services Region and the key that's used to encrypt the data.
    public struct RegionMapInputValue: Swift.Sendable {
        /// The KMS key used to encrypt the data in your replication set.
        public var sseKmsKeyId: Swift.String?

        public init(
            sseKmsKeyId: Swift.String? = nil
        )
        {
            self.sseKmsKeyId = sseKmsKeyId
        }
    }
}

public struct CreateReplicationSetInput: Swift.Sendable {
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The Regions that Incident Manager replicates your data to. You can have up to three Regions in your replication set.
    /// This member is required.
    public var regions: [Swift.String: SSMIncidentsClientTypes.RegionMapInputValue]?
    /// A list of tags to add to the replication set.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        regions: [Swift.String: SSMIncidentsClientTypes.RegionMapInputValue]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.regions = regions
        self.tags = tags
    }
}

public struct CreateReplicationSetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the replication set.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension SSMIncidentsClientTypes {

    /// The SNS targets that are notified when updates are made to an incident.
    public enum NotificationTargetItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the SNS topic.
        case snstopicarn(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// Basic details used in creating a response plan. The response plan is then used to create an incident record.
    public struct IncidentTemplate: Swift.Sendable {
        /// The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account. A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the dedupeString field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident. By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.
        public var dedupeString: Swift.String?
        /// The impact of the incident on your customers and applications. Supported impact codes
        ///
        /// * 1 - Critical
        ///
        /// * 2 - High
        ///
        /// * 3 - Medium
        ///
        /// * 4 - Low
        ///
        /// * 5 - No Impact
        /// This member is required.
        public var impact: Swift.Int?
        /// Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident.
        public var incidentTags: [Swift.String: Swift.String]?
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public var notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.
        public var summary: Swift.String?
        /// The title of the incident.
        /// This member is required.
        public var title: Swift.String?

        public init(
            dedupeString: Swift.String? = nil,
            impact: Swift.Int? = nil,
            incidentTags: [Swift.String: Swift.String]? = nil,
            notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
            summary: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentTags = incidentTags
            self.notificationTargets = notificationTargets
            self.summary = summary
            self.title = title
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Details about the PagerDuty service where the response plan creates an incident.
    public struct PagerDutyIncidentConfiguration: Swift.Sendable {
        /// The ID of the PagerDuty service that the response plan associates with an incident when it launches.
        /// This member is required.
        public var serviceId: Swift.String?

        public init(
            serviceId: Swift.String? = nil
        )
        {
            self.serviceId = serviceId
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Details about the PagerDuty configuration for a response plan.
    public struct PagerDutyConfiguration: Swift.Sendable {
        /// The name of the PagerDuty configuration.
        /// This member is required.
        public var name: Swift.String?
        /// Details about the PagerDuty service associated with the configuration.
        /// This member is required.
        public var pagerDutyIncidentConfiguration: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration?
        /// The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.
        /// This member is required.
        public var secretId: Swift.String?

        public init(
            name: Swift.String? = nil,
            pagerDutyIncidentConfiguration: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.name = name
            self.pagerDutyIncidentConfiguration = pagerDutyIncidentConfiguration
            self.secretId = secretId
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Information about third-party services integrated into a response plan.
    public enum Integration: Swift.Sendable {
        /// Information about the PagerDuty service where the response plan creates an incident.
        case pagerdutyconfiguration(SSMIncidentsClientTypes.PagerDutyConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateResponsePlanInput: Swift.Sendable {
    /// The actions that the response plan starts at the beginning of an incident.
    public var actions: [SSMIncidentsClientTypes.Action]?
    /// The Chatbot chat channel used for collaboration during an incident.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The long format of the response plan name. This field can contain spaces.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    public var engagements: [Swift.String]?
    /// Details used to create an incident when using this response plan.
    /// This member is required.
    public var incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate?
    /// Information about third-party services integrated into the response plan.
    public var integrations: [SSMIncidentsClientTypes.Integration]?
    /// The short format name of the response plan. Can't include spaces.
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags that you are adding to the response plan.
    public var tags: [Swift.String: Swift.String]?

    public init(
        actions: [SSMIncidentsClientTypes.Action]? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        engagements: [Swift.String]? = nil,
        incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate? = nil,
        integrations: [SSMIncidentsClientTypes.Integration]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.actions = actions
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplate = incidentTemplate
        self.integrations = integrations
        self.name = name
        self.tags = tags
    }
}

public struct CreateResponsePlanOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension SSMIncidentsClientTypes {

    /// An item referenced in a TimelineEvent that is involved in or somehow associated with an incident. You can specify an Amazon Resource Name (ARN) for an Amazon Web Services resource or a RelatedItem ID.
    public enum EventReference: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services resource referenced in a TimelineEvent.
        case resource(Swift.String)
        /// The ID of a RelatedItem referenced in a TimelineEvent.
        case relateditemid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateTimelineEventInput: Swift.Sendable {
    /// A token that ensures that a client calls the action only once with the specified details.
    public var clientToken: Swift.String?
    /// A short description of the event.
    /// This member is required.
    public var eventData: Swift.String?
    /// Adds one or more references to the TimelineEvent. A reference is an Amazon Web Services resource involved or associated with the incident. To specify a reference, enter its Amazon Resource Name (ARN). You can also specify a related item associated with a resource. For example, to specify an Amazon DynamoDB (DynamoDB) table as a resource, use the table's ARN. You can also specify an Amazon CloudWatch metric associated with the DynamoDB table as a related item.
    public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
    /// The timestamp for when the event occurred.
    /// This member is required.
    public var eventTime: Foundation.Date?
    /// The type of event. You can create timeline events of type Custom Event and Note. To make a Note-type event appear on the Incident notes panel in the console, specify eventType as Noteand enter the Amazon Resource Name (ARN) of the incident as the value for eventReference.
    /// This member is required.
    public var eventType: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident record that the action adds the incident to.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eventData: Swift.String? = nil,
        eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
        eventTime: Foundation.Date? = nil,
        eventType: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eventData = eventData
        self.eventReferences = eventReferences
        self.eventTime = eventTime
        self.eventType = eventType
        self.incidentRecordArn = incidentRecordArn
    }
}

public struct CreateTimelineEventOutput: Swift.Sendable {
    /// The ID of the event for easy reference later.
    /// This member is required.
    public var eventId: Swift.String?
    /// The ARN of the incident record that you added the event to.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

public struct DeleteIncidentRecordInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the incident record you are deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteIncidentRecordOutput: Swift.Sendable {

    public init() { }
}

extension SSMIncidentsClientTypes {

    /// Defines the information about the Amazon Web Services Region you're deleting from your replication set.
    public struct DeleteRegionAction: Swift.Sendable {
        /// The name of the Amazon Web Services Region you're deleting from the replication set.
        /// This member is required.
        public var regionName: Swift.String?

        public init(
            regionName: Swift.String? = nil
        )
        {
            self.regionName = regionName
        }
    }
}

public struct DeleteReplicationSetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the replication set you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteReplicationSetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The ID of the resource policy you're deleting.
    /// This member is required.
    public var policyId: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource you're deleting the policy from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policyId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyId = policyId
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResponsePlanInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteResponsePlanOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTimelineEventInput: Swift.Sendable {
    /// The ID of the event to update. You can use ListTimelineEvents to find an event's ID.
    /// This member is required.
    public var eventId: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

public struct DeleteTimelineEventOutput: Swift.Sendable {

    public init() { }
}

extension SSMIncidentsClientTypes {

    /// Details about a timeline event during an incident.
    public struct EventSummary: Swift.Sendable {
        /// The timeline event ID.
        /// This member is required.
        public var eventId: Swift.String?
        /// A list of references in a TimelineEvent.
        public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
        /// The timestamp for when the event occurred.
        /// This member is required.
        public var eventTime: Foundation.Date?
        /// The type of event. The timeline event must be Custom Event or Note.
        /// This member is required.
        public var eventType: Swift.String?
        /// The timestamp for when the timeline event was last updated.
        /// This member is required.
        public var eventUpdatedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the incident that the event happened during.
        /// This member is required.
        public var incidentRecordArn: Swift.String?

        public init(
            eventId: Swift.String? = nil,
            eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
            eventTime: Foundation.Date? = nil,
            eventType: Swift.String? = nil,
            eventUpdatedTime: Foundation.Date? = nil,
            incidentRecordArn: Swift.String? = nil
        )
        {
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Filter the selection by using a condition.
    public struct Filter: Swift.Sendable {
        /// The condition accepts before or after a specified time, equal to a string, or equal to an integer.
        /// This member is required.
        public var condition: SSMIncidentsClientTypes.Condition?
        /// The key that you're filtering on.
        /// This member is required.
        public var key: Swift.String?

        public init(
            condition: SSMIncidentsClientTypes.Condition? = nil,
            key: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Identifying information about the finding.
    public struct FindingSummary: Swift.Sendable {
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// The timestamp for when the finding was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct GetIncidentRecordInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the incident record.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension SSMIncidentsClientTypes {

    /// Details about what created the incident record and when it was created.
    public struct IncidentRecordSource: Swift.Sendable {
        /// The principal that started the incident.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The service principal that assumed the role specified in createdBy. If no service principal assumed the role this will be left blank.
        public var invokedBy: Swift.String?
        /// The resource that caused the incident to be created.
        public var resourceArn: Swift.String?
        /// The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.
        /// This member is required.
        public var source: Swift.String?

        public init(
            createdBy: Swift.String? = nil,
            invokedBy: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.invokedBy = invokedBy
            self.resourceArn = resourceArn
            self.source = source
        }
    }
}

extension SSMIncidentsClientTypes {

    public enum IncidentRecordStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `open`
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [IncidentRecordStatus] {
            return [
                .open,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .open: return "OPEN"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    /// The record of the incident that's created when an incident occurs.
    public struct IncidentRecord: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the incident record.
        /// This member is required.
        public var arn: Swift.String?
        /// The runbook, or automation document, that's run at the beginning of the incident.
        public var automationExecutions: [SSMIncidentsClientTypes.AutomationExecution]?
        /// The chat channel used for collaboration during an incident.
        public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
        /// The timestamp for when Incident Manager created the incident record.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
        /// This member is required.
        public var dedupeString: Swift.String?
        /// The impact of the incident on customers and applications. Supported impact codes
        ///
        /// * 1 - Critical
        ///
        /// * 2 - High
        ///
        /// * 3 - Medium
        ///
        /// * 4 - Low
        ///
        /// * 5 - No Impact
        /// This member is required.
        public var impact: Swift.Int?
        /// Details about the action that started the incident.
        /// This member is required.
        public var incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource?
        /// Who modified the incident most recently.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp for when the incident was most recently modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public var notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
        /// The timestamp for when the incident was resolved. This appears as a timeline event.
        public var resolvedTime: Foundation.Date?
        /// The current status of the incident.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.IncidentRecordStatus?
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.
        public var summary: Swift.String?
        /// The title of the incident.
        /// This member is required.
        public var title: Swift.String?

        public init(
            arn: Swift.String? = nil,
            automationExecutions: [SSMIncidentsClientTypes.AutomationExecution]? = nil,
            chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
            creationTime: Foundation.Date? = nil,
            dedupeString: Swift.String? = nil,
            impact: Swift.Int? = nil,
            incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
            resolvedTime: Foundation.Date? = nil,
            status: SSMIncidentsClientTypes.IncidentRecordStatus? = nil,
            summary: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.automationExecutions = automationExecutions
            self.chatChannel = chatChannel
            self.creationTime = creationTime
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notificationTargets = notificationTargets
            self.resolvedTime = resolvedTime
            self.status = status
            self.summary = summary
            self.title = title
        }
    }
}

public struct GetIncidentRecordOutput: Swift.Sendable {
    /// Details the structure of the incident record.
    /// This member is required.
    public var incidentRecord: SSMIncidentsClientTypes.IncidentRecord?

    public init(
        incidentRecord: SSMIncidentsClientTypes.IncidentRecord? = nil
    )
    {
        self.incidentRecord = incidentRecord
    }
}

public struct GetReplicationSetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the replication set you want to retrieve.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension SSMIncidentsClientTypes {

    public enum RegionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// All operations have completed successfully and the region is ready to use
        case active
        /// The region is in the process of being created.
        case creating
        /// The region is in the process of being deleted.
        case deleting
        /// The region is not healthy and we cannot automatically fix it.
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Information about a Amazon Web Services Region in your replication set.
    public struct RegionInfo: Swift.Sendable {
        /// The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.
        public var sseKmsKeyId: Swift.String?
        /// The status of the Amazon Web Services Region in the replication set.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.RegionStatus?
        /// Information displayed about the status of the Amazon Web Services Region.
        public var statusMessage: Swift.String?
        /// The timestamp for when Incident Manager updated the status of the Amazon Web Services Region.
        /// This member is required.
        public var statusUpdateDateTime: Foundation.Date?

        public init(
            sseKmsKeyId: Swift.String? = nil,
            status: SSMIncidentsClientTypes.RegionStatus? = nil,
            statusMessage: Swift.String? = nil,
            statusUpdateDateTime: Foundation.Date? = nil
        )
        {
            self.sseKmsKeyId = sseKmsKeyId
            self.status = status
            self.statusMessage = statusMessage
            self.statusUpdateDateTime = statusUpdateDateTime
        }
    }
}

extension SSMIncidentsClientTypes {

    public enum ReplicationSetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// All operations have completed successfully and the replication set is ready to use
        case active
        /// Replication set is in the process of being created.
        case creating
        /// Replication set is in the process of being deleted.
        case deleting
        /// Replication set is not healthy and we cannot fix it.
        case failed
        /// Replication set is in the process of being updated.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationSetStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    /// The set of Amazon Web Services Region that your Incident Manager data will be replicated to and the KMS key used to encrypt the data.
    public struct ReplicationSet: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the replication set.
        public var arn: Swift.String?
        /// Details about who created the replication set.
        /// This member is required.
        public var createdBy: Swift.String?
        /// When the replication set was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set.
        /// This member is required.
        public var deletionProtected: Swift.Bool?
        /// Who last modified the replication set.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// When the replication set was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.
        /// This member is required.
        public var regionMap: [Swift.String: SSMIncidentsClientTypes.RegionInfo]?
        /// The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.ReplicationSetStatus?

        public init(
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            deletionProtected: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            regionMap: [Swift.String: SSMIncidentsClientTypes.RegionInfo]? = nil,
            status: SSMIncidentsClientTypes.ReplicationSetStatus? = nil
        )
        {
            self.arn = arn
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.deletionProtected = deletionProtected
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.regionMap = regionMap
            self.status = status
        }
    }
}

public struct GetReplicationSetOutput: Swift.Sendable {
    /// Details of the replication set.
    /// This member is required.
    public var replicationSet: SSMIncidentsClientTypes.ReplicationSet?

    public init(
        replicationSet: SSMIncidentsClientTypes.ReplicationSet? = nil
    )
    {
        self.replicationSet = replicationSet
    }
}

public struct GetResourcePoliciesInput: Swift.Sendable {
    /// The maximum number of resource policies to display for each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the response plan with the attached resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension SSMIncidentsClientTypes {

    /// The resource policy that allows Incident Manager to perform actions on resources on your behalf.
    public struct ResourcePolicy: Swift.Sendable {
        /// The JSON blob that describes the policy.
        /// This member is required.
        public var policyDocument: Swift.String?
        /// The ID of the resource policy.
        /// This member is required.
        public var policyId: Swift.String?
        /// The Amazon Web Services Region that policy allows resources to be used in.
        /// This member is required.
        public var ramResourceShareRegion: Swift.String?

        public init(
            policyDocument: Swift.String? = nil,
            policyId: Swift.String? = nil,
            ramResourceShareRegion: Swift.String? = nil
        )
        {
            self.policyDocument = policyDocument
            self.policyId = policyId
            self.ramResourceShareRegion = ramResourceShareRegion
        }
    }
}

public struct GetResourcePoliciesOutput: Swift.Sendable {
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?
    /// Details about the resource policy attached to the response plan.
    /// This member is required.
    public var resourcePolicies: [SSMIncidentsClientTypes.ResourcePolicy]?

    public init(
        nextToken: Swift.String? = nil,
        resourcePolicies: [SSMIncidentsClientTypes.ResourcePolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourcePolicies = resourcePolicies
    }
}

public struct GetResponsePlanInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetResponsePlanOutput: Swift.Sendable {
    /// The actions that this response plan takes at the beginning of the incident.
    public var actions: [SSMIncidentsClientTypes.Action]?
    /// The ARN of the response plan.
    /// This member is required.
    public var arn: Swift.String?
    /// The Chatbot chat channel used for collaboration during an incident.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// The long format name of the response plan. Can contain spaces.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    public var engagements: [Swift.String]?
    /// Details used to create the incident when using this response plan.
    /// This member is required.
    public var incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate?
    /// Information about third-party services integrated into the Incident Manager response plan.
    public var integrations: [SSMIncidentsClientTypes.Integration]?
    /// The short format name of the response plan. The name can't contain spaces.
    /// This member is required.
    public var name: Swift.String?

    public init(
        actions: [SSMIncidentsClientTypes.Action]? = nil,
        arn: Swift.String? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        displayName: Swift.String? = nil,
        engagements: [Swift.String]? = nil,
        incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate? = nil,
        integrations: [SSMIncidentsClientTypes.Integration]? = nil,
        name: Swift.String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.chatChannel = chatChannel
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplate = incidentTemplate
        self.integrations = integrations
        self.name = name
    }
}

public struct GetTimelineEventInput: Swift.Sendable {
    /// The ID of the event. You can get an event's ID when you create it, or by using ListTimelineEvents.
    /// This member is required.
    public var eventId: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

extension SSMIncidentsClientTypes {

    /// A significant event that happened during the incident.
    public struct TimelineEvent: Swift.Sendable {
        /// A short description of the event.
        /// This member is required.
        public var eventData: Swift.String?
        /// The ID of the timeline event.
        /// This member is required.
        public var eventId: Swift.String?
        /// A list of references in a TimelineEvent.
        public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
        /// The timestamp for when the event occurred.
        /// This member is required.
        public var eventTime: Foundation.Date?
        /// The type of event that occurred. Currently Incident Manager supports only the Custom Event and Note types.
        /// This member is required.
        public var eventType: Swift.String?
        /// The timestamp for when the timeline event was last updated.
        /// This member is required.
        public var eventUpdatedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the incident that the event occurred during.
        /// This member is required.
        public var incidentRecordArn: Swift.String?

        public init(
            eventData: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
            eventTime: Foundation.Date? = nil,
            eventType: Swift.String? = nil,
            eventUpdatedTime: Foundation.Date? = nil,
            incidentRecordArn: Swift.String? = nil
        )
        {
            self.eventData = eventData
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }
    }
}

public struct GetTimelineEventOutput: Swift.Sendable {
    /// Details about the timeline event.
    /// This member is required.
    public var event: SSMIncidentsClientTypes.TimelineEvent?

    public init(
        event: SSMIncidentsClientTypes.TimelineEvent? = nil
    )
    {
        self.event = event
    }
}

extension SSMIncidentsClientTypes {

    /// Details describing an incident record.
    public struct IncidentRecordSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the incident.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp for when the incident was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Defines the impact to customers and applications.
        /// This member is required.
        public var impact: Swift.Int?
        /// What caused Incident Manager to create the incident.
        /// This member is required.
        public var incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource?
        /// The timestamp for when the incident was resolved.
        public var resolvedTime: Foundation.Date?
        /// The current status of the incident.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.IncidentRecordStatus?
        /// The title of the incident. This value is either provided by the response plan or overwritten on creation.
        /// This member is required.
        public var title: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            impact: Swift.Int? = nil,
            incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource? = nil,
            resolvedTime: Foundation.Date? = nil,
            status: SSMIncidentsClientTypes.IncidentRecordStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.resolvedTime = resolvedTime
            self.status = status
            self.title = title
        }
    }
}

extension SSMIncidentsClientTypes {

    public enum ItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysis
        case attachment
        case automation
        case incident
        case involvedResource
        case metric
        case other
        case parent
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemType] {
            return [
                .analysis,
                .attachment,
                .automation,
                .incident,
                .involvedResource,
                .metric,
                .other,
                .parent,
                .task
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysis: return "ANALYSIS"
            case .attachment: return "ATTACHMENT"
            case .automation: return "AUTOMATION"
            case .incident: return "INCIDENT"
            case .involvedResource: return "INVOLVED_RESOURCE"
            case .metric: return "METRIC"
            case .other: return "OTHER"
            case .parent: return "PARENT"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Details about the PagerDuty incident associated with an incident created by an Incident Manager response plan.
    public struct PagerDutyIncidentDetail: Swift.Sendable {
        /// Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.
        public var autoResolve: Swift.Bool?
        /// The ID of the incident associated with the PagerDuty service for the response plan.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.
        public var secretId: Swift.String?

        public init(
            autoResolve: Swift.Bool? = nil,
            id: Swift.String? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.autoResolve = autoResolve
            self.id = id
            self.secretId = secretId
        }
    }
}

extension SSMIncidentsClientTypes {

    /// Describes a related item.
    public enum ItemValue: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the related item, if the related item is an Amazon resource.
        case arn(Swift.String)
        /// The URL, if the related item is a non-Amazon Web Services resource.
        case url(Swift.String)
        /// The metric definition, if the related item is a metric in Amazon CloudWatch.
        case metricdefinition(Swift.String)
        /// Details about an incident that is associated with a PagerDuty incident.
        case pagerdutyincidentdetail(SSMIncidentsClientTypes.PagerDutyIncidentDetail)
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// Details and type of a related item.
    public struct ItemIdentifier: Swift.Sendable {
        /// The type of related item.
        /// This member is required.
        public var type: SSMIncidentsClientTypes.ItemType?
        /// Details about the related item.
        /// This member is required.
        public var value: SSMIncidentsClientTypes.ItemValue?

        public init(
            type: SSMIncidentsClientTypes.ItemType? = nil,
            value: SSMIncidentsClientTypes.ItemValue? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }
}

public struct ListIncidentFindingsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the incident for which you want to view associated findings.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// The maximum number of findings to retrieve per call.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        incidentRecordArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIncidentFindingsOutput: Swift.Sendable {
    /// A list of findings that represent deployments that might be the potential cause of the incident.
    /// This member is required.
    public var findings: [SSMIncidentsClientTypes.FindingSummary]?
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?

    public init(
        findings: [SSMIncidentsClientTypes.FindingSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct ListIncidentRecordsInput: Swift.Sendable {
    /// Filters the list of incident records you want to search through. You can filter on the following keys:
    ///
    /// * creationTime
    ///
    /// * impact
    ///
    /// * status
    ///
    /// * createdBy
    ///
    ///
    /// Note the following when when you use Filters:
    ///
    /// * If you don't specify a Filter, the response includes all incident records.
    ///
    /// * If you specify more than one filter in a single request, the response returns incident records that match all filters.
    ///
    /// * If you specify a filter with more than one value, the response returns incident records that match any of the values provided.
    public var filters: [SSMIncidentsClientTypes.Filter]?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMIncidentsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIncidentRecordsOutput: Swift.Sendable {
    /// The details of each listed incident record.
    /// This member is required.
    public var incidentRecordSummaries: [SSMIncidentsClientTypes.IncidentRecordSummary]?
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?

    public init(
        incidentRecordSummaries: [SSMIncidentsClientTypes.IncidentRecordSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.incidentRecordSummaries = incidentRecordSummaries
        self.nextToken = nextToken
    }
}

public struct ListRelatedItemsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the incident record containing the listed related items.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// The maximum number of related items per page.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        incidentRecordArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMIncidentsClientTypes {

    /// Resources that responders use to triage and mitigate the incident.
    public struct RelatedItem: Swift.Sendable {
        /// A unique ID for a RelatedItem. Don't specify this parameter when you add a RelatedItem by using the [UpdateRelatedItems] API action.
        public var generatedId: Swift.String?
        /// Details about the related item.
        /// This member is required.
        public var identifier: SSMIncidentsClientTypes.ItemIdentifier?
        /// The title of the related item.
        public var title: Swift.String?

        public init(
            generatedId: Swift.String? = nil,
            identifier: SSMIncidentsClientTypes.ItemIdentifier? = nil,
            title: Swift.String? = nil
        )
        {
            self.generatedId = generatedId
            self.identifier = identifier
            self.title = title
        }
    }
}

public struct ListRelatedItemsOutput: Swift.Sendable {
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?
    /// Details about each related item.
    /// This member is required.
    public var relatedItems: [SSMIncidentsClientTypes.RelatedItem]?

    public init(
        nextToken: Swift.String? = nil,
        relatedItems: [SSMIncidentsClientTypes.RelatedItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedItems = relatedItems
    }
}

public struct ListReplicationSetsInput: Swift.Sendable {
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReplicationSetsOutput: Swift.Sendable {
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the list replication set.
    /// This member is required.
    public var replicationSetArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        replicationSetArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationSetArns = replicationSetArns
    }
}

public struct ListResponsePlansInput: Swift.Sendable {
    /// The maximum number of response plans per page.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMIncidentsClientTypes {

    /// Details of the response plan that are used when creating an incident.
    public struct ResponsePlanSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the response plan.
        /// This member is required.
        public var arn: Swift.String?
        /// The human readable name of the response plan. This can include spaces.
        public var displayName: Swift.String?
        /// The name of the response plan. This can't include spaces.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.displayName = displayName
            self.name = name
        }
    }
}

public struct ListResponsePlansOutput: Swift.Sendable {
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?
    /// Details of each response plan.
    /// This member is required.
    public var responsePlanSummaries: [SSMIncidentsClientTypes.ResponsePlanSummary]?

    public init(
        nextToken: Swift.String? = nil,
        responsePlanSummaries: [SSMIncidentsClientTypes.ResponsePlanSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.responsePlanSummaries = responsePlanSummaries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the response plan or incident.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags for the response plan or incident.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension SSMIncidentsClientTypes {

    public enum TimelineEventSort: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventTime
        case sdkUnknown(Swift.String)

        public static var allCases: [TimelineEventSort] {
            return [
                .eventTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventTime: return "EVENT_TIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMIncidentsClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListTimelineEventsInput: Swift.Sendable {
    /// Filters the timeline events based on the provided conditional values. You can filter timeline events with the following keys:
    ///
    /// * eventReference
    ///
    /// * eventTime
    ///
    /// * eventType
    ///
    ///
    /// Note the following when deciding how to use Filters:
    ///
    /// * If you don't specify a Filter, the response includes all timeline events.
    ///
    /// * If you specify more than one filter in a single request, the response returns timeline events that match all filters.
    ///
    /// * If you specify a filter with more than one value, the response returns timeline events that match any of the values provided.
    public var filters: [SSMIncidentsClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// The pagination token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Sort timeline events by the specified key value pair.
    public var sortBy: SSMIncidentsClientTypes.TimelineEventSort?
    /// Sorts the order of timeline events by the value specified in the sortBy field.
    public var sortOrder: SSMIncidentsClientTypes.SortOrder?

    public init(
        filters: [SSMIncidentsClientTypes.Filter]? = nil,
        incidentRecordArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: SSMIncidentsClientTypes.TimelineEventSort? = nil,
        sortOrder: SSMIncidentsClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListTimelineEventsOutput: Swift.Sendable {
    /// Details about each event that occurred during the incident.
    /// This member is required.
    public var eventSummaries: [SSMIncidentsClientTypes.EventSummary]?
    /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
    public var nextToken: Swift.String?

    public init(
        eventSummaries: [SSMIncidentsClientTypes.EventSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSummaries = eventSummaries
        self.nextToken = nextToken
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// Details of the resource policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the response plan to add the resource policy to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {
    /// The ID of the resource policy.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

extension SSMIncidentsClientTypes {

    /// Details about the related item you're adding.
    public enum RelatedItemsUpdate: Swift.Sendable {
        /// Details about the related item you're adding.
        case itemtoadd(SSMIncidentsClientTypes.RelatedItem)
        /// Details about the related item you're deleting.
        case itemtoremove(SSMIncidentsClientTypes.ItemIdentifier)
        case sdkUnknown(Swift.String)
    }
}

extension SSMIncidentsClientTypes {

    /// Details about what caused the incident to be created in Incident Manager.
    public struct TriggerDetails: Swift.Sendable {
        /// Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.
        public var rawData: Swift.String?
        /// Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "aws." Customer-generated events can have any value here, as long as it doesn't begin with "aws." We recommend the use of Java package-name style reverse domain-name strings.
        /// This member is required.
        public var source: Swift.String?
        /// The timestamp for when the incident was detected.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the source that detected the incident.
        public var triggerArn: Swift.String?

        public init(
            rawData: Swift.String? = nil,
            source: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            triggerArn: Swift.String? = nil
        )
        {
            self.rawData = rawData
            self.source = source
            self.timestamp = timestamp
            self.triggerArn = triggerArn
        }
    }
}

public struct StartIncidentInput: Swift.Sendable {
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan. Supported impact codes
    ///
    /// * 1 - Critical
    ///
    /// * 2 - High
    ///
    /// * 3 - Medium
    ///
    /// * 4 - Low
    ///
    /// * 5 - No Impact
    public var impact: Swift.Int?
    /// Add related items to the incident for other responders to use. Related items are Amazon Web Services resources, external links, or files uploaded to an Amazon S3 bucket.
    public var relatedItems: [SSMIncidentsClientTypes.RelatedItem]?
    /// The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat channels, Amazon SNS topics, runbooks, title, and impact of the incident.
    /// This member is required.
    public var responsePlanArn: Swift.String?
    /// Provide a title for the incident. Providing a title overwrites the title provided by the response plan.
    public var title: Swift.String?
    /// Details of what created the incident record in Incident Manager.
    public var triggerDetails: SSMIncidentsClientTypes.TriggerDetails?

    public init(
        clientToken: Swift.String? = nil,
        impact: Swift.Int? = nil,
        relatedItems: [SSMIncidentsClientTypes.RelatedItem]? = nil,
        responsePlanArn: Swift.String? = nil,
        title: Swift.String? = nil,
        triggerDetails: SSMIncidentsClientTypes.TriggerDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.impact = impact
        self.relatedItems = relatedItems
        self.responsePlanArn = responsePlanArn
        self.title = title
        self.triggerDetails = triggerDetails
    }
}

public struct StartIncidentOutput: Swift.Sendable {
    /// The ARN of the newly created incident record.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the response plan you're adding the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to add to the response plan.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the response plan you're removing a tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the tag to remove from the response plan.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDeletionProtectionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the replication set to update.
    /// This member is required.
    public var arn: Swift.String?
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// Specifies if deletion protection is turned on or off in your account.
    /// This member is required.
    public var deletionProtected: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        deletionProtected: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.deletionProtected = deletionProtected
    }
}

public struct UpdateDeletionProtectionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateIncidentRecordInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the incident record you are updating.
    /// This member is required.
    public var arn: Swift.String?
    /// The Chatbot chat channel where responders can collaborate.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// A token that ensures that a client calls the operation only once with the specified details.
    public var clientToken: Swift.String?
    /// Defines the impact of the incident to customers and applications. If you provide an impact for an incident, it overwrites the impact provided by the response plan. Supported impact codes
    ///
    /// * 1 - Critical
    ///
    /// * 2 - High
    ///
    /// * 3 - Medium
    ///
    /// * 4 - Low
    ///
    /// * 5 - No Impact
    public var impact: Swift.Int?
    /// The Amazon SNS targets that Incident Manager notifies when a client updates an incident. Using multiple SNS topics creates redundancy in the event that a Region is down during the incident.
    public var notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
    /// The status of the incident. Possible statuses are Open or Resolved.
    public var status: SSMIncidentsClientTypes.IncidentRecordStatus?
    /// A longer description of what occurred during the incident.
    public var summary: Swift.String?
    /// A brief description of the incident.
    public var title: Swift.String?

    public init(
        arn: Swift.String? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        clientToken: Swift.String? = nil,
        impact: Swift.Int? = nil,
        notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
        status: SSMIncidentsClientTypes.IncidentRecordStatus? = nil,
        summary: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.arn = arn
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.impact = impact
        self.notificationTargets = notificationTargets
        self.status = status
        self.summary = summary
        self.title = title
    }
}

public struct UpdateIncidentRecordOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRelatedItemsInput: Swift.Sendable {
    /// A token that ensures that a client calls the operation only once with the specified details.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident record that contains the related items that you update.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// Details about the item that you are add to, or delete from, an incident.
    /// This member is required.
    public var relatedItemsUpdate: SSMIncidentsClientTypes.RelatedItemsUpdate?

    public init(
        clientToken: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil,
        relatedItemsUpdate: SSMIncidentsClientTypes.RelatedItemsUpdate? = nil
    )
    {
        self.clientToken = clientToken
        self.incidentRecordArn = incidentRecordArn
        self.relatedItemsUpdate = relatedItemsUpdate
    }
}

public struct UpdateRelatedItemsOutput: Swift.Sendable {

    public init() { }
}

extension SSMIncidentsClientTypes {

    /// Details used when updating the replication set.
    public enum UpdateReplicationSetAction: Swift.Sendable {
        /// Details about the Amazon Web Services Region that you're adding to the replication set.
        case addregionaction(SSMIncidentsClientTypes.AddRegionAction)
        /// Details about the Amazon Web Services Region that you're deleting to the replication set.
        case deleteregionaction(SSMIncidentsClientTypes.DeleteRegionAction)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdateReplicationSetInput: Swift.Sendable {
    /// An action to add or delete a Region.
    /// This member is required.
    public var actions: [SSMIncidentsClientTypes.UpdateReplicationSetAction]?
    /// The Amazon Resource Name (ARN) of the replication set you're updating.
    /// This member is required.
    public var arn: Swift.String?
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?

    public init(
        actions: [SSMIncidentsClientTypes.UpdateReplicationSetAction]? = nil,
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.clientToken = clientToken
    }
}

public struct UpdateReplicationSetOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateResponsePlanInput: Swift.Sendable {
    /// The actions that this response plan takes at the beginning of an incident.
    public var actions: [SSMIncidentsClientTypes.Action]?
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?
    /// The Chatbot chat channel used for collaboration during an incident. Use the empty structure to remove the chat channel from the response plan.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The long format name of the response plan. The display name can't contain spaces.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    public var engagements: [Swift.String]?
    /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
    public var incidentTemplateDedupeString: Swift.String?
    /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan. Supported impact codes
    ///
    /// * 1 - Critical
    ///
    /// * 2 - High
    ///
    /// * 3 - Medium
    ///
    /// * 4 - Low
    ///
    /// * 5 - No Impact
    public var incidentTemplateImpact: Swift.Int?
    /// The Amazon SNS targets that are notified when updates are made to an incident.
    public var incidentTemplateNotificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
    /// A brief summary of the incident. This typically contains what has happened, what's currently happening, and next steps.
    public var incidentTemplateSummary: Swift.String?
    /// Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident. To call this action, you must also have permission to call the TagResource API action for the incident record resource.
    public var incidentTemplateTags: [Swift.String: Swift.String]?
    /// The short format name of the incident. The title can't contain spaces.
    public var incidentTemplateTitle: Swift.String?
    /// Information about third-party services integrated into the response plan.
    public var integrations: [SSMIncidentsClientTypes.Integration]?

    public init(
        actions: [SSMIncidentsClientTypes.Action]? = nil,
        arn: Swift.String? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        engagements: [Swift.String]? = nil,
        incidentTemplateDedupeString: Swift.String? = nil,
        incidentTemplateImpact: Swift.Int? = nil,
        incidentTemplateNotificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
        incidentTemplateSummary: Swift.String? = nil,
        incidentTemplateTags: [Swift.String: Swift.String]? = nil,
        incidentTemplateTitle: Swift.String? = nil,
        integrations: [SSMIncidentsClientTypes.Integration]? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplateDedupeString = incidentTemplateDedupeString
        self.incidentTemplateImpact = incidentTemplateImpact
        self.incidentTemplateNotificationTargets = incidentTemplateNotificationTargets
        self.incidentTemplateSummary = incidentTemplateSummary
        self.incidentTemplateTags = incidentTemplateTags
        self.incidentTemplateTitle = incidentTemplateTitle
        self.integrations = integrations
    }
}

public struct UpdateResponsePlanOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateTimelineEventInput: Swift.Sendable {
    /// A token that ensures that a client calls the operation only once with the specified details.
    public var clientToken: Swift.String?
    /// A short description of the event.
    public var eventData: Swift.String?
    /// The ID of the event to update. You can use ListTimelineEvents to find an event's ID.
    /// This member is required.
    public var eventId: Swift.String?
    /// Updates all existing references in a TimelineEvent. A reference is an Amazon Web Services resource involved or associated with the incident. To specify a reference, enter its Amazon Resource Name (ARN). You can also specify a related item associated with that resource. For example, to specify an Amazon DynamoDB (DynamoDB) table as a resource, use its ARN. You can also specify an Amazon CloudWatch metric associated with the DynamoDB table as a related item. This update action overrides all existing references. If you want to keep existing references, you must specify them in the call. If you don't, this action removes any existing references and enters only new references.
    public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
    /// The timestamp for when the event occurred.
    public var eventTime: Foundation.Date?
    /// The type of event. You can update events of type Custom Event and Note.
    public var eventType: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eventData: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
        eventTime: Foundation.Date? = nil,
        eventType: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eventData = eventData
        self.eventId = eventId
        self.eventReferences = eventReferences
        self.eventTime = eventTime
        self.eventType = eventType
        self.incidentRecordArn = incidentRecordArn
    }
}

public struct UpdateTimelineEventOutput: Swift.Sendable {

    public init() { }
}

extension BatchGetIncidentFindingsInput {

    static func urlPathProvider(_ value: BatchGetIncidentFindingsInput) -> Swift.String? {
        return "/batchGetIncidentFindings"
    }
}

extension CreateReplicationSetInput {

    static func urlPathProvider(_ value: CreateReplicationSetInput) -> Swift.String? {
        return "/createReplicationSet"
    }
}

extension CreateResponsePlanInput {

    static func urlPathProvider(_ value: CreateResponsePlanInput) -> Swift.String? {
        return "/createResponsePlan"
    }
}

extension CreateTimelineEventInput {

    static func urlPathProvider(_ value: CreateTimelineEventInput) -> Swift.String? {
        return "/createTimelineEvent"
    }
}

extension DeleteIncidentRecordInput {

    static func urlPathProvider(_ value: DeleteIncidentRecordInput) -> Swift.String? {
        return "/deleteIncidentRecord"
    }
}

extension DeleteReplicationSetInput {

    static func urlPathProvider(_ value: DeleteReplicationSetInput) -> Swift.String? {
        return "/deleteReplicationSet"
    }
}

extension DeleteReplicationSetInput {

    static func queryItemProvider(_ value: DeleteReplicationSetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/deleteResourcePolicy"
    }
}

extension DeleteResponsePlanInput {

    static func urlPathProvider(_ value: DeleteResponsePlanInput) -> Swift.String? {
        return "/deleteResponsePlan"
    }
}

extension DeleteTimelineEventInput {

    static func urlPathProvider(_ value: DeleteTimelineEventInput) -> Swift.String? {
        return "/deleteTimelineEvent"
    }
}

extension GetIncidentRecordInput {

    static func urlPathProvider(_ value: GetIncidentRecordInput) -> Swift.String? {
        return "/getIncidentRecord"
    }
}

extension GetIncidentRecordInput {

    static func queryItemProvider(_ value: GetIncidentRecordInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension GetReplicationSetInput {

    static func urlPathProvider(_ value: GetReplicationSetInput) -> Swift.String? {
        return "/getReplicationSet"
    }
}

extension GetReplicationSetInput {

    static func queryItemProvider(_ value: GetReplicationSetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension GetResourcePoliciesInput {

    static func urlPathProvider(_ value: GetResourcePoliciesInput) -> Swift.String? {
        return "/getResourcePolicies"
    }
}

extension GetResourcePoliciesInput {

    static func queryItemProvider(_ value: GetResourcePoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension GetResponsePlanInput {

    static func urlPathProvider(_ value: GetResponsePlanInput) -> Swift.String? {
        return "/getResponsePlan"
    }
}

extension GetResponsePlanInput {

    static func queryItemProvider(_ value: GetResponsePlanInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension GetTimelineEventInput {

    static func urlPathProvider(_ value: GetTimelineEventInput) -> Swift.String? {
        return "/getTimelineEvent"
    }
}

extension GetTimelineEventInput {

    static func queryItemProvider(_ value: GetTimelineEventInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let eventId = value.eventId else {
            let message = "Creating a URL Query Item failed. eventId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let eventIdQueryItem = Smithy.URIQueryItem(name: "eventId".urlPercentEncoding(), value: Swift.String(eventId).urlPercentEncoding())
        items.append(eventIdQueryItem)
        guard let incidentRecordArn = value.incidentRecordArn else {
            let message = "Creating a URL Query Item failed. incidentRecordArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let incidentRecordArnQueryItem = Smithy.URIQueryItem(name: "incidentRecordArn".urlPercentEncoding(), value: Swift.String(incidentRecordArn).urlPercentEncoding())
        items.append(incidentRecordArnQueryItem)
        return items
    }
}

extension ListIncidentFindingsInput {

    static func urlPathProvider(_ value: ListIncidentFindingsInput) -> Swift.String? {
        return "/listIncidentFindings"
    }
}

extension ListIncidentRecordsInput {

    static func urlPathProvider(_ value: ListIncidentRecordsInput) -> Swift.String? {
        return "/listIncidentRecords"
    }
}

extension ListRelatedItemsInput {

    static func urlPathProvider(_ value: ListRelatedItemsInput) -> Swift.String? {
        return "/listRelatedItems"
    }
}

extension ListReplicationSetsInput {

    static func urlPathProvider(_ value: ListReplicationSetsInput) -> Swift.String? {
        return "/listReplicationSets"
    }
}

extension ListResponsePlansInput {

    static func urlPathProvider(_ value: ListResponsePlansInput) -> Swift.String? {
        return "/listResponsePlans"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTimelineEventsInput {

    static func urlPathProvider(_ value: ListTimelineEventsInput) -> Swift.String? {
        return "/listTimelineEvents"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/putResourcePolicy"
    }
}

extension StartIncidentInput {

    static func urlPathProvider(_ value: StartIncidentInput) -> Swift.String? {
        return "/startIncident"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDeletionProtectionInput {

    static func urlPathProvider(_ value: UpdateDeletionProtectionInput) -> Swift.String? {
        return "/updateDeletionProtection"
    }
}

extension UpdateIncidentRecordInput {

    static func urlPathProvider(_ value: UpdateIncidentRecordInput) -> Swift.String? {
        return "/updateIncidentRecord"
    }
}

extension UpdateRelatedItemsInput {

    static func urlPathProvider(_ value: UpdateRelatedItemsInput) -> Swift.String? {
        return "/updateRelatedItems"
    }
}

extension UpdateReplicationSetInput {

    static func urlPathProvider(_ value: UpdateReplicationSetInput) -> Swift.String? {
        return "/updateReplicationSet"
    }
}

extension UpdateResponsePlanInput {

    static func urlPathProvider(_ value: UpdateResponsePlanInput) -> Swift.String? {
        return "/updateResponsePlan"
    }
}

extension UpdateTimelineEventInput {

    static func urlPathProvider(_ value: UpdateTimelineEventInput) -> Swift.String? {
        return "/updateTimelineEvent"
    }
}

extension BatchGetIncidentFindingsInput {

    static func write(value: BatchGetIncidentFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingIds"].writeList(value.findingIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
    }
}

extension CreateReplicationSetInput {

    static func write(value: CreateReplicationSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["regions"].writeMap(value.regions, valueWritingClosure: SSMIncidentsClientTypes.RegionMapInputValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateResponsePlanInput {

    static func write(value: CreateResponsePlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SSMIncidentsClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["chatChannel"].write(value.chatChannel, with: SSMIncidentsClientTypes.ChatChannel.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["displayName"].write(value.displayName)
        try writer["engagements"].writeList(value.engagements, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["incidentTemplate"].write(value.incidentTemplate, with: SSMIncidentsClientTypes.IncidentTemplate.write(value:to:))
        try writer["integrations"].writeList(value.integrations, memberWritingClosure: SSMIncidentsClientTypes.Integration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTimelineEventInput {

    static func write(value: CreateTimelineEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["eventData"].write(value.eventData)
        try writer["eventReferences"].writeList(value.eventReferences, memberWritingClosure: SSMIncidentsClientTypes.EventReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTime"].writeTimestamp(value.eventTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["eventType"].write(value.eventType)
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
    }
}

extension DeleteIncidentRecordInput {

    static func write(value: DeleteIncidentRecordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyId"].write(value.policyId)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension DeleteResponsePlanInput {

    static func write(value: DeleteResponsePlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteTimelineEventInput {

    static func write(value: DeleteTimelineEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventId"].write(value.eventId)
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
    }
}

extension GetResourcePoliciesInput {

    static func write(value: GetResourcePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListIncidentFindingsInput {

    static func write(value: ListIncidentFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListIncidentRecordsInput {

    static func write(value: ListIncidentRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: SSMIncidentsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRelatedItemsInput {

    static func write(value: ListRelatedItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListReplicationSetsInput {

    static func write(value: ListReplicationSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListResponsePlansInput {

    static func write(value: ListResponsePlansInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTimelineEventsInput {

    static func write(value: ListTimelineEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: SSMIncidentsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension StartIncidentInput {

    static func write(value: StartIncidentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["impact"].write(value.impact)
        try writer["relatedItems"].writeList(value.relatedItems, memberWritingClosure: SSMIncidentsClientTypes.RelatedItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["responsePlanArn"].write(value.responsePlanArn)
        try writer["title"].write(value.title)
        try writer["triggerDetails"].write(value.triggerDetails, with: SSMIncidentsClientTypes.TriggerDetails.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDeletionProtectionInput {

    static func write(value: UpdateDeletionProtectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["clientToken"].write(value.clientToken)
        try writer["deletionProtected"].write(value.deletionProtected)
    }
}

extension UpdateIncidentRecordInput {

    static func write(value: UpdateIncidentRecordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["chatChannel"].write(value.chatChannel, with: SSMIncidentsClientTypes.ChatChannel.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["impact"].write(value.impact)
        try writer["notificationTargets"].writeList(value.notificationTargets, memberWritingClosure: SSMIncidentsClientTypes.NotificationTargetItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
        try writer["summary"].write(value.summary)
        try writer["title"].write(value.title)
    }
}

extension UpdateRelatedItemsInput {

    static func write(value: UpdateRelatedItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
        try writer["relatedItemsUpdate"].write(value.relatedItemsUpdate, with: SSMIncidentsClientTypes.RelatedItemsUpdate.write(value:to:))
    }
}

extension UpdateReplicationSetInput {

    static func write(value: UpdateReplicationSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SSMIncidentsClientTypes.UpdateReplicationSetAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["arn"].write(value.arn)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateResponsePlanInput {

    static func write(value: UpdateResponsePlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SSMIncidentsClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["arn"].write(value.arn)
        try writer["chatChannel"].write(value.chatChannel, with: SSMIncidentsClientTypes.ChatChannel.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["displayName"].write(value.displayName)
        try writer["engagements"].writeList(value.engagements, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["incidentTemplateDedupeString"].write(value.incidentTemplateDedupeString)
        try writer["incidentTemplateImpact"].write(value.incidentTemplateImpact)
        try writer["incidentTemplateNotificationTargets"].writeList(value.incidentTemplateNotificationTargets, memberWritingClosure: SSMIncidentsClientTypes.NotificationTargetItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["incidentTemplateSummary"].write(value.incidentTemplateSummary)
        try writer["incidentTemplateTags"].writeMap(value.incidentTemplateTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["incidentTemplateTitle"].write(value.incidentTemplateTitle)
        try writer["integrations"].writeList(value.integrations, memberWritingClosure: SSMIncidentsClientTypes.Integration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTimelineEventInput {

    static func write(value: UpdateTimelineEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["eventData"].write(value.eventData)
        try writer["eventId"].write(value.eventId)
        try writer["eventReferences"].writeList(value.eventReferences, memberWritingClosure: SSMIncidentsClientTypes.EventReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTime"].writeTimestamp(value.eventTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["eventType"].write(value.eventType)
        try writer["incidentRecordArn"].write(value.incidentRecordArn)
    }
}

extension BatchGetIncidentFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetIncidentFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetIncidentFindingsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.BatchGetIncidentFindingsError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.Finding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateReplicationSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationSetOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateResponsePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResponsePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResponsePlanOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTimelineEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTimelineEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTimelineEventOutput()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.incidentRecordArn = try reader["incidentRecordArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteIncidentRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIncidentRecordOutput {
        return DeleteIncidentRecordOutput()
    }
}

extension DeleteReplicationSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationSetOutput {
        return DeleteReplicationSetOutput()
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteResponsePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResponsePlanOutput {
        return DeleteResponsePlanOutput()
    }
}

extension DeleteTimelineEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTimelineEventOutput {
        return DeleteTimelineEventOutput()
    }
}

extension GetIncidentRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIncidentRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIncidentRecordOutput()
        value.incidentRecord = try reader["incidentRecord"].readIfPresent(with: SSMIncidentsClientTypes.IncidentRecord.read(from:))
        return value
    }
}

extension GetReplicationSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReplicationSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReplicationSetOutput()
        value.replicationSet = try reader["replicationSet"].readIfPresent(with: SSMIncidentsClientTypes.ReplicationSet.read(from:))
        return value
    }
}

extension GetResourcePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePoliciesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resourcePolicies = try reader["resourcePolicies"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.ResourcePolicy.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetResponsePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResponsePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResponsePlanOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.chatChannel = try reader["chatChannel"].readIfPresent(with: SSMIncidentsClientTypes.ChatChannel.read(from:))
        value.displayName = try reader["displayName"].readIfPresent()
        value.engagements = try reader["engagements"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.incidentTemplate = try reader["incidentTemplate"].readIfPresent(with: SSMIncidentsClientTypes.IncidentTemplate.read(from:))
        value.integrations = try reader["integrations"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.Integration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension GetTimelineEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTimelineEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTimelineEventOutput()
        value.event = try reader["event"].readIfPresent(with: SSMIncidentsClientTypes.TimelineEvent.read(from:))
        return value
    }
}

extension ListIncidentFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIncidentFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIncidentFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.FindingSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIncidentRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIncidentRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIncidentRecordsOutput()
        value.incidentRecordSummaries = try reader["incidentRecordSummaries"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.IncidentRecordSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRelatedItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRelatedItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRelatedItemsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.relatedItems = try reader["relatedItems"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.RelatedItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListReplicationSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReplicationSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReplicationSetsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.replicationSetArns = try reader["replicationSetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListResponsePlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResponsePlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResponsePlansOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.responsePlanSummaries = try reader["responsePlanSummaries"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.ResponsePlanSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ListTimelineEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTimelineEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTimelineEventsOutput()
        value.eventSummaries = try reader["eventSummaries"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.EventSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        return value
    }
}

extension StartIncidentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartIncidentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartIncidentOutput()
        value.incidentRecordArn = try reader["incidentRecordArn"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDeletionProtectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeletionProtectionOutput {
        return UpdateDeletionProtectionOutput()
    }
}

extension UpdateIncidentRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIncidentRecordOutput {
        return UpdateIncidentRecordOutput()
    }
}

extension UpdateRelatedItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRelatedItemsOutput {
        return UpdateRelatedItemsOutput()
    }
}

extension UpdateReplicationSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReplicationSetOutput {
        return UpdateReplicationSetOutput()
    }
}

extension UpdateResponsePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResponsePlanOutput {
        return UpdateResponsePlanOutput()
    }
}

extension UpdateTimelineEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTimelineEventOutput {
        return UpdateTimelineEventOutput()
    }
}

enum BatchGetIncidentFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResponsePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTimelineEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIncidentRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResponsePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTimelineEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIncidentRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReplicationSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResponsePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTimelineEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIncidentFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIncidentRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRelatedItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReplicationSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResponsePlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTimelineEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartIncidentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeletionProtectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIncidentRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRelatedItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReplicationSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResponsePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTimelineEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.retryAfter = try reader["retryAfter"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SSMIncidentsClientTypes.Finding {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.Finding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.Finding()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.details = try reader["details"].readIfPresent(with: SSMIncidentsClientTypes.FindingDetails.read(from:))
        return value
    }
}

extension SSMIncidentsClientTypes.FindingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.FindingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "codeDeployDeployment":
                return .codedeploydeployment(try reader["codeDeployDeployment"].read(with: SSMIncidentsClientTypes.CodeDeployDeployment.read(from:)))
            case "cloudFormationStackUpdate":
                return .cloudformationstackupdate(try reader["cloudFormationStackUpdate"].read(with: SSMIncidentsClientTypes.CloudFormationStackUpdate.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.CloudFormationStackUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.CloudFormationStackUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.CloudFormationStackUpdate()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stackArn = try reader["stackArn"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.CodeDeployDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.CodeDeployDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.CodeDeployDeployment()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentGroupArn = try reader["deploymentGroupArn"].readIfPresent() ?? ""
        value.deploymentId = try reader["deploymentId"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.BatchGetIncidentFindingsError {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.BatchGetIncidentFindingsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.BatchGetIncidentFindingsError()
        value.findingId = try reader["findingId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.IncidentRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.IncidentRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.IncidentRecord()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.summary = try reader["summary"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["impact"].readIfPresent() ?? 0
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resolvedTime = try reader["resolvedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent() ?? ""
        value.automationExecutions = try reader["automationExecutions"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.AutomationExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.incidentRecordSource = try reader["incidentRecordSource"].readIfPresent(with: SSMIncidentsClientTypes.IncidentRecordSource.read(from:))
        value.dedupeString = try reader["dedupeString"].readIfPresent() ?? ""
        value.chatChannel = try reader["chatChannel"].readIfPresent(with: SSMIncidentsClientTypes.ChatChannel.read(from:))
        value.notificationTargets = try reader["notificationTargets"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.NotificationTargetItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMIncidentsClientTypes.NotificationTargetItem {

    static func write(value: SSMIncidentsClientTypes.NotificationTargetItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .snstopicarn(snstopicarn):
                try writer["snsTopicArn"].write(snstopicarn)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.NotificationTargetItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "snsTopicArn":
                return .snstopicarn(try reader["snsTopicArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.ChatChannel {

    static func write(value: SSMIncidentsClientTypes.ChatChannel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .chatbotsns(chatbotsns):
                try writer["chatbotSns"].writeList(chatbotsns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .empty(empty):
                try writer["empty"].write(empty, with: SSMIncidentsClientTypes.EmptyChatChannel.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.ChatChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "empty":
                return .empty(try reader["empty"].read(with: SSMIncidentsClientTypes.EmptyChatChannel.read(from:)))
            case "chatbotSns":
                return .chatbotsns(try reader["chatbotSns"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.EmptyChatChannel {

    static func write(value: SSMIncidentsClientTypes.EmptyChatChannel?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.EmptyChatChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return SSMIncidentsClientTypes.EmptyChatChannel()
    }
}

extension SSMIncidentsClientTypes.IncidentRecordSource {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.IncidentRecordSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.IncidentRecordSource()
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.invokedBy = try reader["invokedBy"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.source = try reader["source"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.AutomationExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.AutomationExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ssmExecutionArn":
                return .ssmexecutionarn(try reader["ssmExecutionArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.ReplicationSet {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.ReplicationSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.ReplicationSet()
        value.arn = try reader["arn"].readIfPresent()
        value.regionMap = try reader["regionMap"].readMapIfPresent(valueReadingClosure: SSMIncidentsClientTypes.RegionInfo.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.deletionProtected = try reader["deletionProtected"].readIfPresent() ?? false
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.RegionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.RegionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.RegionInfo()
        value.sseKmsKeyId = try reader["sseKmsKeyId"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.statusUpdateDateTime = try reader["statusUpdateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SSMIncidentsClientTypes.ResourcePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.ResourcePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.ResourcePolicy()
        value.policyDocument = try reader["policyDocument"].readIfPresent() ?? ""
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.ramResourceShareRegion = try reader["ramResourceShareRegion"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.IncidentTemplate {

    static func write(value: SSMIncidentsClientTypes.IncidentTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dedupeString"].write(value.dedupeString)
        try writer["impact"].write(value.impact)
        try writer["incidentTags"].writeMap(value.incidentTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["notificationTargets"].writeList(value.notificationTargets, memberWritingClosure: SSMIncidentsClientTypes.NotificationTargetItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["summary"].write(value.summary)
        try writer["title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.IncidentTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.IncidentTemplate()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.impact = try reader["impact"].readIfPresent() ?? 0
        value.summary = try reader["summary"].readIfPresent()
        value.dedupeString = try reader["dedupeString"].readIfPresent()
        value.notificationTargets = try reader["notificationTargets"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.NotificationTargetItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.incidentTags = try reader["incidentTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMIncidentsClientTypes.Action {

    static func write(value: SSMIncidentsClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .ssmautomation(ssmautomation):
                try writer["ssmAutomation"].write(ssmautomation, with: SSMIncidentsClientTypes.SsmAutomation.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ssmAutomation":
                return .ssmautomation(try reader["ssmAutomation"].read(with: SSMIncidentsClientTypes.SsmAutomation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.SsmAutomation {

    static func write(value: SSMIncidentsClientTypes.SsmAutomation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["documentName"].write(value.documentName)
        try writer["documentVersion"].write(value.documentVersion)
        try writer["dynamicParameters"].writeMap(value.dynamicParameters, valueWritingClosure: SSMIncidentsClientTypes.DynamicSsmParameterValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["targetAccount"].write(value.targetAccount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.SsmAutomation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.SsmAutomation()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.documentName = try reader["documentName"].readIfPresent() ?? ""
        value.documentVersion = try reader["documentVersion"].readIfPresent()
        value.targetAccount = try reader["targetAccount"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dynamicParameters = try reader["dynamicParameters"].readMapIfPresent(valueReadingClosure: SSMIncidentsClientTypes.DynamicSsmParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMIncidentsClientTypes.DynamicSsmParameterValue {

    static func write(value: SSMIncidentsClientTypes.DynamicSsmParameterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .variable(variable):
                try writer["variable"].write(variable)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.DynamicSsmParameterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "variable":
                return .variable(try reader["variable"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.Integration {

    static func write(value: SSMIncidentsClientTypes.Integration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .pagerdutyconfiguration(pagerdutyconfiguration):
                try writer["pagerDutyConfiguration"].write(pagerdutyconfiguration, with: SSMIncidentsClientTypes.PagerDutyConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.Integration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "pagerDutyConfiguration":
                return .pagerdutyconfiguration(try reader["pagerDutyConfiguration"].read(with: SSMIncidentsClientTypes.PagerDutyConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.PagerDutyConfiguration {

    static func write(value: SSMIncidentsClientTypes.PagerDutyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["pagerDutyIncidentConfiguration"].write(value.pagerDutyIncidentConfiguration, with: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration.write(value:to:))
        try writer["secretId"].write(value.secretId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.PagerDutyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.PagerDutyConfiguration()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.secretId = try reader["secretId"].readIfPresent() ?? ""
        value.pagerDutyIncidentConfiguration = try reader["pagerDutyIncidentConfiguration"].readIfPresent(with: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration.read(from:))
        return value
    }
}

extension SSMIncidentsClientTypes.PagerDutyIncidentConfiguration {

    static func write(value: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serviceId"].write(value.serviceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.PagerDutyIncidentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.PagerDutyIncidentConfiguration()
        value.serviceId = try reader["serviceId"].readIfPresent() ?? ""
        return value
    }
}

extension SSMIncidentsClientTypes.TimelineEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.TimelineEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.TimelineEvent()
        value.incidentRecordArn = try reader["incidentRecordArn"].readIfPresent() ?? ""
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.eventUpdatedTime = try reader["eventUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        value.eventData = try reader["eventData"].readIfPresent() ?? ""
        value.eventReferences = try reader["eventReferences"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.EventReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMIncidentsClientTypes.EventReference {

    static func write(value: SSMIncidentsClientTypes.EventReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .relateditemid(relateditemid):
                try writer["relatedItemId"].write(relateditemid)
            case let .resource(resource):
                try writer["resource"].write(resource)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.EventReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "resource":
                return .resource(try reader["resource"].read())
            case "relatedItemId":
                return .relateditemid(try reader["relatedItemId"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.FindingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.FindingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.FindingSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SSMIncidentsClientTypes.IncidentRecordSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.IncidentRecordSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.IncidentRecordSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["impact"].readIfPresent() ?? 0
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resolvedTime = try reader["resolvedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.incidentRecordSource = try reader["incidentRecordSource"].readIfPresent(with: SSMIncidentsClientTypes.IncidentRecordSource.read(from:))
        return value
    }
}

extension SSMIncidentsClientTypes.RelatedItem {

    static func write(value: SSMIncidentsClientTypes.RelatedItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generatedId"].write(value.generatedId)
        try writer["identifier"].write(value.identifier, with: SSMIncidentsClientTypes.ItemIdentifier.write(value:to:))
        try writer["title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.RelatedItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.RelatedItem()
        value.identifier = try reader["identifier"].readIfPresent(with: SSMIncidentsClientTypes.ItemIdentifier.read(from:))
        value.title = try reader["title"].readIfPresent()
        value.generatedId = try reader["generatedId"].readIfPresent()
        return value
    }
}

extension SSMIncidentsClientTypes.ItemIdentifier {

    static func write(value: SSMIncidentsClientTypes.ItemIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["value"].write(value.value, with: SSMIncidentsClientTypes.ItemValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.ItemIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.ItemIdentifier()
        value.value = try reader["value"].readIfPresent(with: SSMIncidentsClientTypes.ItemValue.read(from:))
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSMIncidentsClientTypes.ItemValue {

    static func write(value: SSMIncidentsClientTypes.ItemValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .arn(arn):
                try writer["arn"].write(arn)
            case let .metricdefinition(metricdefinition):
                try writer["metricDefinition"].write(metricdefinition)
            case let .pagerdutyincidentdetail(pagerdutyincidentdetail):
                try writer["pagerDutyIncidentDetail"].write(pagerdutyincidentdetail, with: SSMIncidentsClientTypes.PagerDutyIncidentDetail.write(value:to:))
            case let .url(url):
                try writer["url"].write(url)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.ItemValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "arn":
                return .arn(try reader["arn"].read())
            case "url":
                return .url(try reader["url"].read())
            case "metricDefinition":
                return .metricdefinition(try reader["metricDefinition"].read())
            case "pagerDutyIncidentDetail":
                return .pagerdutyincidentdetail(try reader["pagerDutyIncidentDetail"].read(with: SSMIncidentsClientTypes.PagerDutyIncidentDetail.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSMIncidentsClientTypes.PagerDutyIncidentDetail {

    static func write(value: SSMIncidentsClientTypes.PagerDutyIncidentDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoResolve"].write(value.autoResolve)
        try writer["id"].write(value.id)
        try writer["secretId"].write(value.secretId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.PagerDutyIncidentDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.PagerDutyIncidentDetail()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.autoResolve = try reader["autoResolve"].readIfPresent()
        value.secretId = try reader["secretId"].readIfPresent()
        return value
    }
}

extension SSMIncidentsClientTypes.ResponsePlanSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.ResponsePlanSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.ResponsePlanSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension SSMIncidentsClientTypes.EventSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMIncidentsClientTypes.EventSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMIncidentsClientTypes.EventSummary()
        value.incidentRecordArn = try reader["incidentRecordArn"].readIfPresent() ?? ""
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.eventUpdatedTime = try reader["eventUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        value.eventReferences = try reader["eventReferences"].readListIfPresent(memberReadingClosure: SSMIncidentsClientTypes.EventReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMIncidentsClientTypes.RegionMapInputValue {

    static func write(value: SSMIncidentsClientTypes.RegionMapInputValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sseKmsKeyId"].write(value.sseKmsKeyId)
    }
}

extension SSMIncidentsClientTypes.Filter {

    static func write(value: SSMIncidentsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition, with: SSMIncidentsClientTypes.Condition.write(value:to:))
        try writer["key"].write(value.key)
    }
}

extension SSMIncidentsClientTypes.Condition {

    static func write(value: SSMIncidentsClientTypes.Condition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .after(after):
                try writer["after"].writeTimestamp(after, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .before(before):
                try writer["before"].writeTimestamp(before, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .equals(equals):
                try writer["equals"].write(equals, with: SSMIncidentsClientTypes.AttributeValueList.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension SSMIncidentsClientTypes.AttributeValueList {

    static func write(value: SSMIncidentsClientTypes.AttributeValueList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .integervalues(integervalues):
                try writer["integerValues"].writeList(integervalues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .stringvalues(stringvalues):
                try writer["stringValues"].writeList(stringvalues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension SSMIncidentsClientTypes.TriggerDetails {

    static func write(value: SSMIncidentsClientTypes.TriggerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rawData"].write(value.rawData)
        try writer["source"].write(value.source)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["triggerArn"].write(value.triggerArn)
    }
}

extension SSMIncidentsClientTypes.RelatedItemsUpdate {

    static func write(value: SSMIncidentsClientTypes.RelatedItemsUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .itemtoadd(itemtoadd):
                try writer["itemToAdd"].write(itemtoadd, with: SSMIncidentsClientTypes.RelatedItem.write(value:to:))
            case let .itemtoremove(itemtoremove):
                try writer["itemToRemove"].write(itemtoremove, with: SSMIncidentsClientTypes.ItemIdentifier.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension SSMIncidentsClientTypes.UpdateReplicationSetAction {

    static func write(value: SSMIncidentsClientTypes.UpdateReplicationSetAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .addregionaction(addregionaction):
                try writer["addRegionAction"].write(addregionaction, with: SSMIncidentsClientTypes.AddRegionAction.write(value:to:))
            case let .deleteregionaction(deleteregionaction):
                try writer["deleteRegionAction"].write(deleteregionaction, with: SSMIncidentsClientTypes.DeleteRegionAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension SSMIncidentsClientTypes.DeleteRegionAction {

    static func write(value: SSMIncidentsClientTypes.DeleteRegionAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["regionName"].write(value.regionName)
    }
}

extension SSMIncidentsClientTypes.AddRegionAction {

    static func write(value: SSMIncidentsClientTypes.AddRegionAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["regionName"].write(value.regionName)
        try writer["sseKmsKeyId"].write(value.sseKmsKeyId)
    }
}

public enum SSMIncidentsClientTypes {}
