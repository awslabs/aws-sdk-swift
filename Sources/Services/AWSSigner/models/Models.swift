// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension AddProfilePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case principal
        case profileVersion
        case revisionId
        case statementId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension AddProfilePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions"
    }
}

public struct AddProfilePermissionInput: Swift.Equatable {
    /// The AWS Signer action permitted as part of cross-account permissions.
    /// This member is required.
    public var action: Swift.String?
    /// The AWS principal receiving cross-account permissions. This may be an IAM role or another AWS account ID.
    /// This member is required.
    public var principal: Swift.String?
    /// The human-readable name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The version of the signing profile.
    public var profileVersion: Swift.String?
    /// A unique identifier for the current profile revision.
    public var revisionId: Swift.String?
    /// A unique identifier for the cross-account permission statement.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: Swift.String? = nil,
        principal: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.principal = principal
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct AddProfilePermissionInputBody: Swift.Equatable {
    let profileVersion: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let revisionId: Swift.String?
    let statementId: Swift.String?
}

extension AddProfilePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case principal
        case profileVersion
        case revisionId
        case statementId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension AddProfilePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddProfilePermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
        } else {
            self.revisionId = nil
        }
    }
}

public struct AddProfilePermissionOutput: Swift.Equatable {
    /// A unique identifier for the current profile revision.
    public var revisionId: Swift.String?

    public init(
        revisionId: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

struct AddProfilePermissionOutputBody: Swift.Equatable {
    let revisionId: Swift.String?
}

extension AddProfilePermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum AddProfilePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request contains invalid parameters for the ARN or tags. This exception also occurs when you call a tagging API on a cancelled signing profile.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CancelSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

public struct CancelSigningProfileInput: Swift.Equatable {
    /// The name of the signing profile to be canceled.
    /// This member is required.
    public var profileName: Swift.String?

    public init(
        profileName: Swift.String? = nil
    )
    {
        self.profileName = profileName
    }
}

struct CancelSigningProfileInputBody: Swift.Equatable {
}

extension CancelSigningProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelSigningProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelSigningProfileOutput: Swift.Equatable {

    public init() { }
}

enum CancelSigningProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SignerClientTypes {
    public enum Category: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsiot
        case sdkUnknown(Swift.String)

        public static var allCases: [Category] {
            return [
                .awsiot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsiot: return "AWSIoT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Category(rawValue: rawValue) ?? Category.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource encountered a conflicting state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DescribeSigningJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/signing-jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeSigningJobInput: Swift.Equatable {
    /// The ID of the signing job on input.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeSigningJobInputBody: Swift.Equatable {
}

extension DescribeSigningJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSigningJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSigningJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.completedAt = output.completedAt
            self.createdAt = output.createdAt
            self.jobId = output.jobId
            self.jobInvoker = output.jobInvoker
            self.jobOwner = output.jobOwner
            self.overrides = output.overrides
            self.platformDisplayName = output.platformDisplayName
            self.platformId = output.platformId
            self.profileName = output.profileName
            self.profileVersion = output.profileVersion
            self.requestedBy = output.requestedBy
            self.revocationRecord = output.revocationRecord
            self.signatureExpiresAt = output.signatureExpiresAt
            self.signedObject = output.signedObject
            self.signingMaterial = output.signingMaterial
            self.signingParameters = output.signingParameters
            self.source = output.source
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.completedAt = nil
            self.createdAt = nil
            self.jobId = nil
            self.jobInvoker = nil
            self.jobOwner = nil
            self.overrides = nil
            self.platformDisplayName = nil
            self.platformId = nil
            self.profileName = nil
            self.profileVersion = nil
            self.requestedBy = nil
            self.revocationRecord = nil
            self.signatureExpiresAt = nil
            self.signedObject = nil
            self.signingMaterial = nil
            self.signingParameters = nil
            self.source = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeSigningJobOutput: Swift.Equatable {
    /// Date and time that the signing job was completed.
    public var completedAt: ClientRuntime.Date?
    /// Date and time that the signing job was created.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the signing job on output.
    public var jobId: Swift.String?
    /// The IAM entity that initiated the signing job.
    public var jobInvoker: Swift.String?
    /// The AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// A list of any overrides that were applied to the signing operation.
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// A human-readable name for the signing platform associated with the signing job.
    public var platformDisplayName: Swift.String?
    /// The microcontroller platform to which your signed code image will be distributed.
    public var platformId: Swift.String?
    /// The name of the profile that initiated the signing operation.
    public var profileName: Swift.String?
    /// The version of the signing profile used to initiate the signing job.
    public var profileVersion: Swift.String?
    /// The IAM principal that requested the signing job.
    public var requestedBy: Swift.String?
    /// A revocation record if the signature generated by the signing job has been revoked. Contains a timestamp and the ID of the IAM entity that revoked the signature.
    public var revocationRecord: SignerClientTypes.SigningJobRevocationRecord?
    /// Thr expiration timestamp for the signature generated by the signing job.
    public var signatureExpiresAt: ClientRuntime.Date?
    /// Name of the S3 bucket where the signed code image is saved by code signing.
    public var signedObject: SignerClientTypes.SignedObject?
    /// The Amazon Resource Name (ARN) of your code signing certificate.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// Map of user-assigned key-value pairs used during signing. These values contain any information that you specified for use in your signing job.
    public var signingParameters: [Swift.String:Swift.String]?
    /// The object that contains the name of your S3 bucket or your raw code.
    public var source: SignerClientTypes.Source?
    /// Status of the signing job.
    public var status: SignerClientTypes.SigningStatus?
    /// String value that contains the status reason.
    public var statusReason: Swift.String?

    public init(
        completedAt: ClientRuntime.Date? = nil,
        createdAt: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobInvoker: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformDisplayName: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        requestedBy: Swift.String? = nil,
        revocationRecord: SignerClientTypes.SigningJobRevocationRecord? = nil,
        signatureExpiresAt: ClientRuntime.Date? = nil,
        signedObject: SignerClientTypes.SignedObject? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String:Swift.String]? = nil,
        source: SignerClientTypes.Source? = nil,
        status: SignerClientTypes.SigningStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.jobId = jobId
        self.jobInvoker = jobInvoker
        self.jobOwner = jobOwner
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.requestedBy = requestedBy
        self.revocationRecord = revocationRecord
        self.signatureExpiresAt = signatureExpiresAt
        self.signedObject = signedObject
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.source = source
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeSigningJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let source: SignerClientTypes.Source?
    let signingMaterial: SignerClientTypes.SigningMaterial?
    let platformId: Swift.String?
    let platformDisplayName: Swift.String?
    let profileName: Swift.String?
    let profileVersion: Swift.String?
    let overrides: SignerClientTypes.SigningPlatformOverrides?
    let signingParameters: [Swift.String:Swift.String]?
    let createdAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
    let signatureExpiresAt: ClientRuntime.Date?
    let requestedBy: Swift.String?
    let status: SignerClientTypes.SigningStatus?
    let statusReason: Swift.String?
    let revocationRecord: SignerClientTypes.SigningJobRevocationRecord?
    let signedObject: SignerClientTypes.SignedObject?
    let jobOwner: Swift.String?
    let jobInvoker: Swift.String?
}

extension DescribeSigningJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt
        case createdAt
        case jobId
        case jobInvoker
        case jobOwner
        case overrides
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case requestedBy
        case revocationRecord
        case signatureExpiresAt
        case signedObject
        case signingMaterial
        case signingParameters
        case source
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let signatureExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .signatureExpiresAt)
        signatureExpiresAt = signatureExpiresAtDecoded
        let requestedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestedBy)
        requestedBy = requestedByDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let revocationRecordDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningJobRevocationRecord.self, forKey: .revocationRecord)
        revocationRecord = revocationRecordDecoded
        let signedObjectDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignedObject.self, forKey: .signedObject)
        signedObject = signedObjectDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let jobInvokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobInvoker)
        jobInvoker = jobInvokerDecoded
    }
}

enum DescribeSigningJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SignerClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(SignerClientTypes.S3Destination.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignerClientTypes {
    /// Points to an S3Destination object that contains information about your S3 bucket.
    public struct Destination: Swift.Equatable {
        /// The S3Destination object.
        public var s3: SignerClientTypes.S3Destination?

        public init(
            s3: SignerClientTypes.S3Destination? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension SignerClientTypes {
    public enum EncryptionAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecdsa
        case rsa
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionAlgorithm] {
            return [
                .ecdsa,
                .rsa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecdsa: return "ECDSA"
            case .rsa: return "RSA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionAlgorithm(rawValue: rawValue) ?? EncryptionAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes.EncryptionAlgorithmOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for encryptionalgorithm0 in allowedValues {
                try allowedValuesContainer.encode(encryptionalgorithm0.rawValue)
            }
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue.rawValue, forKey: .defaultValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([SignerClientTypes.EncryptionAlgorithm?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[SignerClientTypes.EncryptionAlgorithm]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [SignerClientTypes.EncryptionAlgorithm]()
            for enum0 in allowedValuesContainer {
                if let enum0 = enum0 {
                    allowedValuesDecoded0?.append(enum0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(SignerClientTypes.EncryptionAlgorithm.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SignerClientTypes {
    /// The encryption algorithm options that are available to a code signing job.
    public struct EncryptionAlgorithmOptions: Swift.Equatable {
        /// The set of accepted encryption algorithms that are allowed in a code signing job.
        /// This member is required.
        public var allowedValues: [SignerClientTypes.EncryptionAlgorithm]?
        /// The default encryption algorithm that is used by a code signing job.
        /// This member is required.
        public var defaultValue: SignerClientTypes.EncryptionAlgorithm?

        public init(
            allowedValues: [SignerClientTypes.EncryptionAlgorithm]? = nil,
            defaultValue: SignerClientTypes.EncryptionAlgorithm? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }

}

extension GetRevocationStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let certificateHashes = certificateHashes else {
                let message = "Creating a URL Query Item failed. certificateHashes is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            certificateHashes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "certificateHashes".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let profileVersionArn = profileVersionArn else {
                let message = "Creating a URL Query Item failed. profileVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let profileVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "profileVersionArn".urlPercentEncoding(), value: Swift.String(profileVersionArn).urlPercentEncoding())
            items.append(profileVersionArnQueryItem)
            guard let platformId = platformId else {
                let message = "Creating a URL Query Item failed. platformId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let platformIdQueryItem = ClientRuntime.URLQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
            items.append(platformIdQueryItem)
            guard let jobArn = jobArn else {
                let message = "Creating a URL Query Item failed. jobArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let jobArnQueryItem = ClientRuntime.URLQueryItem(name: "jobArn".urlPercentEncoding(), value: Swift.String(jobArn).urlPercentEncoding())
            items.append(jobArnQueryItem)
            guard let signatureTimestamp = signatureTimestamp else {
                let message = "Creating a URL Query Item failed. signatureTimestamp is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let signatureTimestampQueryItem = ClientRuntime.URLQueryItem(name: "signatureTimestamp".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: signatureTimestamp)).urlPercentEncoding())
            items.append(signatureTimestampQueryItem)
            return items
        }
    }
}

extension GetRevocationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/revocations"
    }
}

public struct GetRevocationStatusInput: Swift.Equatable {
    /// A list of composite signed hashes that identify certificates. A certificate identifier consists of a subject certificate TBS hash (signed by the parent CA) combined with a parent CA TBS hash (signed by the parent CAâ€™s CA). Root certificates are defined as their own CA.
    /// This member is required.
    public var certificateHashes: [Swift.String]?
    /// The ARN of a signing job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The ID of a signing platform.
    /// This member is required.
    public var platformId: Swift.String?
    /// The version of a signing profile.
    /// This member is required.
    public var profileVersionArn: Swift.String?
    /// The timestamp of the signature that validates the profile or job.
    /// This member is required.
    public var signatureTimestamp: ClientRuntime.Date?

    public init(
        certificateHashes: [Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil,
        signatureTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.certificateHashes = certificateHashes
        self.jobArn = jobArn
        self.platformId = platformId
        self.profileVersionArn = profileVersionArn
        self.signatureTimestamp = signatureTimestamp
    }
}

struct GetRevocationStatusInputBody: Swift.Equatable {
}

extension GetRevocationStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRevocationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRevocationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.revokedEntities = output.revokedEntities
        } else {
            self.revokedEntities = nil
        }
    }
}

public struct GetRevocationStatusOutput: Swift.Equatable {
    /// A list of revoked entities (including one or more of the signing profile ARN, signing job ID, and certificate hash) supplied as input to the API.
    public var revokedEntities: [Swift.String]?

    public init(
        revokedEntities: [Swift.String]? = nil
    )
    {
        self.revokedEntities = revokedEntities
    }
}

struct GetRevocationStatusOutputBody: Swift.Equatable {
    let revokedEntities: [Swift.String]?
}

extension GetRevocationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revokedEntities
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revokedEntitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .revokedEntities)
        var revokedEntitiesDecoded0:[Swift.String]? = nil
        if let revokedEntitiesContainer = revokedEntitiesContainer {
            revokedEntitiesDecoded0 = [Swift.String]()
            for string0 in revokedEntitiesContainer {
                if let string0 = string0 {
                    revokedEntitiesDecoded0?.append(string0)
                }
            }
        }
        revokedEntities = revokedEntitiesDecoded0
    }
}

enum GetRevocationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSigningPlatformInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let platformId = platformId else {
            return nil
        }
        return "/signing-platforms/\(platformId.urlPercentEncoding())"
    }
}

public struct GetSigningPlatformInput: Swift.Equatable {
    /// The ID of the target signing platform.
    /// This member is required.
    public var platformId: Swift.String?

    public init(
        platformId: Swift.String? = nil
    )
    {
        self.platformId = platformId
    }
}

struct GetSigningPlatformInputBody: Swift.Equatable {
}

extension GetSigningPlatformInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSigningPlatformOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSigningPlatformOutputBody = try responseDecoder.decode(responseBody: data)
            self.category = output.category
            self.displayName = output.displayName
            self.maxSizeInMB = output.maxSizeInMB
            self.partner = output.partner
            self.platformId = output.platformId
            self.revocationSupported = output.revocationSupported
            self.signingConfiguration = output.signingConfiguration
            self.signingImageFormat = output.signingImageFormat
            self.target = output.target
        } else {
            self.category = nil
            self.displayName = nil
            self.maxSizeInMB = 0
            self.partner = nil
            self.platformId = nil
            self.revocationSupported = false
            self.signingConfiguration = nil
            self.signingImageFormat = nil
            self.target = nil
        }
    }
}

public struct GetSigningPlatformOutput: Swift.Equatable {
    /// The category type of the target signing platform.
    public var category: SignerClientTypes.Category?
    /// The display name of the target signing platform.
    public var displayName: Swift.String?
    /// The maximum size (in MB) of the payload that can be signed by the target platform.
    public var maxSizeInMB: Swift.Int
    /// A list of partner entities that use the target signing platform.
    public var partner: Swift.String?
    /// The ID of the target signing platform.
    public var platformId: Swift.String?
    /// A flag indicating whether signatures generated for the signing platform can be revoked.
    public var revocationSupported: Swift.Bool
    /// A list of configurations applied to the target platform at signing.
    public var signingConfiguration: SignerClientTypes.SigningConfiguration?
    /// The format of the target platform's signing image.
    public var signingImageFormat: SignerClientTypes.SigningImageFormat?
    /// The validation template that is used by the target signing platform.
    public var target: Swift.String?

    public init(
        category: SignerClientTypes.Category? = nil,
        displayName: Swift.String? = nil,
        maxSizeInMB: Swift.Int = 0,
        partner: Swift.String? = nil,
        platformId: Swift.String? = nil,
        revocationSupported: Swift.Bool = false,
        signingConfiguration: SignerClientTypes.SigningConfiguration? = nil,
        signingImageFormat: SignerClientTypes.SigningImageFormat? = nil,
        target: Swift.String? = nil
    )
    {
        self.category = category
        self.displayName = displayName
        self.maxSizeInMB = maxSizeInMB
        self.partner = partner
        self.platformId = platformId
        self.revocationSupported = revocationSupported
        self.signingConfiguration = signingConfiguration
        self.signingImageFormat = signingImageFormat
        self.target = target
    }
}

struct GetSigningPlatformOutputBody: Swift.Equatable {
    let platformId: Swift.String?
    let displayName: Swift.String?
    let partner: Swift.String?
    let target: Swift.String?
    let category: SignerClientTypes.Category?
    let signingConfiguration: SignerClientTypes.SigningConfiguration?
    let signingImageFormat: SignerClientTypes.SigningImageFormat?
    let maxSizeInMB: Swift.Int
    let revocationSupported: Swift.Bool
}

extension GetSigningPlatformOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case displayName
        case maxSizeInMB
        case partner
        case platformId
        case revocationSupported
        case signingConfiguration
        case signingImageFormat
        case target
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let partnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partner)
        partner = partnerDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Category.self, forKey: .category)
        category = categoryDecoded
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningConfiguration.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
        let maxSizeInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSizeInMB) ?? 0
        maxSizeInMB = maxSizeInMBDecoded
        let revocationSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revocationSupported) ?? false
        revocationSupported = revocationSupportedDecoded
    }
}

enum GetSigningPlatformOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSigningProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let profileOwner = profileOwner {
                let profileOwnerQueryItem = ClientRuntime.URLQueryItem(name: "profileOwner".urlPercentEncoding(), value: Swift.String(profileOwner).urlPercentEncoding())
                items.append(profileOwnerQueryItem)
            }
            return items
        }
    }
}

extension GetSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

public struct GetSigningProfileInput: Swift.Equatable {
    /// The name of the target signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the profile owner.
    public var profileOwner: Swift.String?

    public init(
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil
    )
    {
        self.profileName = profileName
        self.profileOwner = profileOwner
    }
}

struct GetSigningProfileInputBody: Swift.Equatable {
}

extension GetSigningProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSigningProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSigningProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.overrides = output.overrides
            self.platformDisplayName = output.platformDisplayName
            self.platformId = output.platformId
            self.profileName = output.profileName
            self.profileVersion = output.profileVersion
            self.profileVersionArn = output.profileVersionArn
            self.revocationRecord = output.revocationRecord
            self.signatureValidityPeriod = output.signatureValidityPeriod
            self.signingMaterial = output.signingMaterial
            self.signingParameters = output.signingParameters
            self.status = output.status
            self.statusReason = output.statusReason
            self.tags = output.tags
        } else {
            self.arn = nil
            self.overrides = nil
            self.platformDisplayName = nil
            self.platformId = nil
            self.profileName = nil
            self.profileVersion = nil
            self.profileVersionArn = nil
            self.revocationRecord = nil
            self.signatureValidityPeriod = nil
            self.signingMaterial = nil
            self.signingParameters = nil
            self.status = nil
            self.statusReason = nil
            self.tags = nil
        }
    }
}

public struct GetSigningProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    public var arn: Swift.String?
    /// A list of overrides applied by the target signing profile for signing operations.
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// A human-readable name for the signing platform associated with the signing profile.
    public var platformDisplayName: Swift.String?
    /// The ID of the platform that is used by the target signing profile.
    public var platformId: Swift.String?
    /// The name of the target signing profile.
    public var profileName: Swift.String?
    /// The current version of the signing profile.
    public var profileVersion: Swift.String?
    /// The signing profile ARN, including the profile version.
    public var profileVersionArn: Swift.String?
    /// Revocation information for a signing profile.
    public var revocationRecord: SignerClientTypes.SigningProfileRevocationRecord?
    /// The validity period for a signing job.
    public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    /// The ARN of the certificate that the target profile uses for signing operations.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// A map of key-value pairs for signing operations that is attached to the target signing profile.
    public var signingParameters: [Swift.String:Swift.String]?
    /// The status of the target signing profile.
    public var status: SignerClientTypes.SigningProfileStatus?
    /// Reason for the status of the target signing profile.
    public var statusReason: Swift.String?
    /// A list of tags associated with the signing profile.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformDisplayName: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil,
        revocationRecord: SignerClientTypes.SigningProfileRevocationRecord? = nil,
        signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String:Swift.String]? = nil,
        status: SignerClientTypes.SigningProfileStatus? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
        self.revocationRecord = revocationRecord
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
    }
}

struct GetSigningProfileOutputBody: Swift.Equatable {
    let profileName: Swift.String?
    let profileVersion: Swift.String?
    let profileVersionArn: Swift.String?
    let revocationRecord: SignerClientTypes.SigningProfileRevocationRecord?
    let signingMaterial: SignerClientTypes.SigningMaterial?
    let platformId: Swift.String?
    let platformDisplayName: Swift.String?
    let signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    let overrides: SignerClientTypes.SigningPlatformOverrides?
    let signingParameters: [Swift.String:Swift.String]?
    let status: SignerClientTypes.SigningProfileStatus?
    let statusReason: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSigningProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case overrides
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case profileVersionArn
        case revocationRecord
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case status
        case statusReason
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
        let revocationRecordDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningProfileRevocationRecord.self, forKey: .revocationRecord)
        revocationRecord = revocationRecordDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningProfileStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSigningProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SignerClientTypes {
    public enum HashAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [HashAlgorithm] {
            return [
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes.HashAlgorithmOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for hashalgorithm0 in allowedValues {
                try allowedValuesContainer.encode(hashalgorithm0.rawValue)
            }
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue.rawValue, forKey: .defaultValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([SignerClientTypes.HashAlgorithm?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[SignerClientTypes.HashAlgorithm]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [SignerClientTypes.HashAlgorithm]()
            for enum0 in allowedValuesContainer {
                if let enum0 = enum0 {
                    allowedValuesDecoded0?.append(enum0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(SignerClientTypes.HashAlgorithm.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension SignerClientTypes {
    /// The hash algorithms that are available to a code signing job.
    public struct HashAlgorithmOptions: Swift.Equatable {
        /// The set of accepted hash algorithms allowed in a code signing job.
        /// This member is required.
        public var allowedValues: [SignerClientTypes.HashAlgorithm]?
        /// The default hash algorithm that is used in a code signing job.
        /// This member is required.
        public var defaultValue: SignerClientTypes.HashAlgorithm?

        public init(
            allowedValues: [SignerClientTypes.HashAlgorithm]? = nil,
            defaultValue: SignerClientTypes.HashAlgorithm? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }

}

extension SignerClientTypes {
    public enum ImageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case jsondetached
        case jsonembedded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFormat] {
            return [
                .json,
                .jsondetached,
                .jsonembedded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .jsondetached: return "JSONDetached"
            case .jsonembedded: return "JSONEmbedded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFormat(rawValue: rawValue) ?? ImageFormat.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error occurred.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ListProfilePermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListProfilePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions"
    }
}

public struct ListProfilePermissionsInput: Swift.Equatable {
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?
    /// Name of the signing profile containing the cross-account permissions.
    /// This member is required.
    public var profileName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        profileName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.profileName = profileName
    }
}

struct ListProfilePermissionsInputBody: Swift.Equatable {
}

extension ListProfilePermissionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfilePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
            self.policySizeBytes = output.policySizeBytes
            self.revisionId = output.revisionId
        } else {
            self.nextToken = nil
            self.permissions = nil
            self.policySizeBytes = 0
            self.revisionId = nil
        }
    }
}

public struct ListProfilePermissionsOutput: Swift.Equatable {
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?
    /// List of permissions associated with the Signing Profile.
    public var permissions: [SignerClientTypes.Permission]?
    /// Total size of the policy associated with the Signing Profile in bytes.
    public var policySizeBytes: Swift.Int
    /// The identifier for the current revision of profile permissions.
    public var revisionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [SignerClientTypes.Permission]? = nil,
        policySizeBytes: Swift.Int = 0,
        revisionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
        self.policySizeBytes = policySizeBytes
        self.revisionId = revisionId
    }
}

struct ListProfilePermissionsOutputBody: Swift.Equatable {
    let revisionId: Swift.String?
    let policySizeBytes: Swift.Int
    let permissions: [SignerClientTypes.Permission]?
    let nextToken: Swift.String?
}

extension ListProfilePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
        case policySizeBytes
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let policySizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .policySizeBytes) ?? 0
        policySizeBytes = policySizeBytesDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([SignerClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[SignerClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [SignerClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfilePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSigningJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let isRevoked = isRevoked {
                let isRevokedQueryItem = ClientRuntime.URLQueryItem(name: "isRevoked".urlPercentEncoding(), value: Swift.String(isRevoked).urlPercentEncoding())
                items.append(isRevokedQueryItem)
            }
            if let requestedBy = requestedBy {
                let requestedByQueryItem = ClientRuntime.URLQueryItem(name: "requestedBy".urlPercentEncoding(), value: Swift.String(requestedBy).urlPercentEncoding())
                items.append(requestedByQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let signatureExpiresBefore = signatureExpiresBefore {
                let signatureExpiresBeforeQueryItem = ClientRuntime.URLQueryItem(name: "signatureExpiresBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: signatureExpiresBefore)).urlPercentEncoding())
                items.append(signatureExpiresBeforeQueryItem)
            }
            if let jobInvoker = jobInvoker {
                let jobInvokerQueryItem = ClientRuntime.URLQueryItem(name: "jobInvoker".urlPercentEncoding(), value: Swift.String(jobInvoker).urlPercentEncoding())
                items.append(jobInvokerQueryItem)
            }
            if let platformId = platformId {
                let platformIdQueryItem = ClientRuntime.URLQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
                items.append(platformIdQueryItem)
            }
            if let signatureExpiresAfter = signatureExpiresAfter {
                let signatureExpiresAfterQueryItem = ClientRuntime.URLQueryItem(name: "signatureExpiresAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: signatureExpiresAfter)).urlPercentEncoding())
                items.append(signatureExpiresAfterQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListSigningJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-jobs"
    }
}

public struct ListSigningJobsInput: Swift.Equatable {
    /// Filters results to return only signing jobs with revoked signatures.
    public var isRevoked: Swift.Bool?
    /// Filters results to return only signing jobs initiated by a specified IAM entity.
    public var jobInvoker: Swift.String?
    /// Specifies the maximum number of items to return in the response. Use this parameter when paginating results. If additional items exist beyond the number you specify, the nextToken element is set in the response. Use the nextToken value in a subsequent request to retrieve additional items.
    public var maxResults: Swift.Int?
    /// String for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// The ID of microcontroller platform that you specified for the distribution of your code image.
    public var platformId: Swift.String?
    /// The IAM principal that requested the signing job.
    public var requestedBy: Swift.String?
    /// Filters results to return only signing jobs with signatures expiring after a specified timestamp.
    public var signatureExpiresAfter: ClientRuntime.Date?
    /// Filters results to return only signing jobs with signatures expiring before a specified timestamp.
    public var signatureExpiresBefore: ClientRuntime.Date?
    /// A status value with which to filter your results.
    public var status: SignerClientTypes.SigningStatus?

    public init(
        isRevoked: Swift.Bool? = nil,
        jobInvoker: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        platformId: Swift.String? = nil,
        requestedBy: Swift.String? = nil,
        signatureExpiresAfter: ClientRuntime.Date? = nil,
        signatureExpiresBefore: ClientRuntime.Date? = nil,
        status: SignerClientTypes.SigningStatus? = nil
    )
    {
        self.isRevoked = isRevoked
        self.jobInvoker = jobInvoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.requestedBy = requestedBy
        self.signatureExpiresAfter = signatureExpiresAfter
        self.signatureExpiresBefore = signatureExpiresBefore
        self.status = status
    }
}

struct ListSigningJobsInputBody: Swift.Equatable {
}

extension ListSigningJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSigningJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSigningJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListSigningJobsOutput: Swift.Equatable {
    /// A list of your signing jobs.
    public var jobs: [SignerClientTypes.SigningJob]?
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        jobs: [SignerClientTypes.SigningJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListSigningJobsOutputBody: Swift.Equatable {
    let jobs: [SignerClientTypes.SigningJob]?
    let nextToken: Swift.String?
}

extension ListSigningJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([SignerClientTypes.SigningJob?].self, forKey: .jobs)
        var jobsDecoded0:[SignerClientTypes.SigningJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [SignerClientTypes.SigningJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSigningJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSigningPlatformsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let partner = partner {
                let partnerQueryItem = ClientRuntime.URLQueryItem(name: "partner".urlPercentEncoding(), value: Swift.String(partner).urlPercentEncoding())
                items.append(partnerQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let category = category {
                let categoryQueryItem = ClientRuntime.URLQueryItem(name: "category".urlPercentEncoding(), value: Swift.String(category).urlPercentEncoding())
                items.append(categoryQueryItem)
            }
            if let target = target {
                let targetQueryItem = ClientRuntime.URLQueryItem(name: "target".urlPercentEncoding(), value: Swift.String(target).urlPercentEncoding())
                items.append(targetQueryItem)
            }
            return items
        }
    }
}

extension ListSigningPlatformsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-platforms"
    }
}

public struct ListSigningPlatformsInput: Swift.Equatable {
    /// The category type of a signing platform.
    public var category: Swift.String?
    /// The maximum number of results to be returned by this operation.
    public var maxResults: Swift.Int?
    /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// Any partner entities connected to a signing platform.
    public var partner: Swift.String?
    /// The validation template that is used by the target signing platform.
    public var target: Swift.String?

    public init(
        category: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partner: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partner = partner
        self.target = target
    }
}

struct ListSigningPlatformsInputBody: Swift.Equatable {
}

extension ListSigningPlatformsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSigningPlatformsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSigningPlatformsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.platforms = output.platforms
        } else {
            self.nextToken = nil
            self.platforms = nil
        }
    }
}

public struct ListSigningPlatformsOutput: Swift.Equatable {
    /// Value for specifying the next set of paginated results to return.
    public var nextToken: Swift.String?
    /// A list of all platforms that match the request parameters.
    public var platforms: [SignerClientTypes.SigningPlatform]?

    public init(
        nextToken: Swift.String? = nil,
        platforms: [SignerClientTypes.SigningPlatform]? = nil
    )
    {
        self.nextToken = nextToken
        self.platforms = platforms
    }
}

struct ListSigningPlatformsOutputBody: Swift.Equatable {
    let platforms: [SignerClientTypes.SigningPlatform]?
    let nextToken: Swift.String?
}

extension ListSigningPlatformsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case platforms
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformsContainer = try containerValues.decodeIfPresent([SignerClientTypes.SigningPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[SignerClientTypes.SigningPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [SignerClientTypes.SigningPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSigningPlatformsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSigningProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeCanceled = includeCanceled {
                let includeCanceledQueryItem = ClientRuntime.URLQueryItem(name: "includeCanceled".urlPercentEncoding(), value: Swift.String(includeCanceled).urlPercentEncoding())
                items.append(includeCanceledQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let statuses = statuses {
                statuses.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "statuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let platformId = platformId {
                let platformIdQueryItem = ClientRuntime.URLQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
                items.append(platformIdQueryItem)
            }
            return items
        }
    }
}

extension ListSigningProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-profiles"
    }
}

public struct ListSigningProfilesInput: Swift.Equatable {
    /// Designates whether to include profiles with the status of CANCELED.
    public var includeCanceled: Swift.Bool?
    /// The maximum number of profiles to be returned.
    public var maxResults: Swift.Int?
    /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// Filters results to return only signing jobs initiated for a specified signing platform.
    public var platformId: Swift.String?
    /// Filters results to return only signing jobs with statuses in the specified list.
    public var statuses: [SignerClientTypes.SigningProfileStatus]?

    public init(
        includeCanceled: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        platformId: Swift.String? = nil,
        statuses: [SignerClientTypes.SigningProfileStatus]? = nil
    )
    {
        self.includeCanceled = includeCanceled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.statuses = statuses
    }
}

struct ListSigningProfilesInputBody: Swift.Equatable {
}

extension ListSigningProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSigningProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSigningProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListSigningProfilesOutput: Swift.Equatable {
    /// Value for specifying the next set of paginated results to return.
    public var nextToken: Swift.String?
    /// A list of profiles that are available in the AWS account. This includes profiles with the status of CANCELED if the includeCanceled parameter is set to true.
    public var profiles: [SignerClientTypes.SigningProfile]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [SignerClientTypes.SigningProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListSigningProfilesOutputBody: Swift.Equatable {
    let profiles: [SignerClientTypes.SigningProfile]?
    let nextToken: Swift.String?
}

extension ListSigningProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([SignerClientTypes.SigningProfile?].self, forKey: .profiles)
        var profilesDecoded0:[SignerClientTypes.SigningProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [SignerClientTypes.SigningProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSigningProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags associated with the signing profile.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The signing profile was not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignerClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case principal
        case profileVersion
        case statementId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
    }
}

extension SignerClientTypes {
    /// A cross-account permission for a signing profile.
    public struct Permission: Swift.Equatable {
        /// An AWS Signer action permitted as part of cross-account permissions.
        public var action: Swift.String?
        /// The AWS principal that has been granted a cross-account permission.
        public var principal: Swift.String?
        /// The signing profile version that a permission applies to.
        public var profileVersion: Swift.String?
        /// A unique identifier for a cross-account permission statement.
        public var statementId: Swift.String?

        public init(
            action: Swift.String? = nil,
            principal: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            statementId: Swift.String? = nil
        )
        {
            self.action = action
            self.principal = principal
            self.profileVersion = profileVersion
            self.statementId = statementId
        }
    }

}

extension PutSigningProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case platformId
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = self.overrides {
            try encodeContainer.encode(overrides, forKey: .overrides)
        }
        if let platformId = self.platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let signatureValidityPeriod = self.signatureValidityPeriod {
            try encodeContainer.encode(signatureValidityPeriod, forKey: .signatureValidityPeriod)
        }
        if let signingMaterial = self.signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let signingParameters = signingParameters {
            var signingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signingParameters)
            for (dictKey0, signingParameters0) in signingParameters {
                try signingParametersContainer.encode(signingParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PutSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

public struct PutSigningProfileInput: Swift.Equatable {
    /// A subfield of platform. This specifies any different configuration options that you want to apply to the chosen platform (such as a different hash-algorithm or signing-algorithm).
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// The ID of the signing platform to be created.
    /// This member is required.
    public var platformId: Swift.String?
    /// The name of the signing profile to be created.
    /// This member is required.
    public var profileName: Swift.String?
    /// The default validity period override for any signature generated using this signing profile. If unspecified, the default is 135 months.
    public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    /// The AWS Certificate Manager certificate that will be used to sign code with the new signing profile.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// Map of key-value pairs for signing. These can include any information that you want to use during signing.
    public var signingParameters: [Swift.String:Swift.String]?
    /// Tags to be associated with the signing profile that is being created.
    public var tags: [Swift.String:Swift.String]?

    public init(
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.overrides = overrides
        self.platformId = platformId
        self.profileName = profileName
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.tags = tags
    }
}

struct PutSigningProfileInputBody: Swift.Equatable {
    let signingMaterial: SignerClientTypes.SigningMaterial?
    let signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    let platformId: Swift.String?
    let overrides: SignerClientTypes.SigningPlatformOverrides?
    let signingParameters: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension PutSigningProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case platformId
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningPlatformOverrides.self, forKey: .overrides)
        overrides = overridesDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutSigningProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSigningProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.profileVersion = output.profileVersion
            self.profileVersionArn = output.profileVersionArn
        } else {
            self.arn = nil
            self.profileVersion = nil
            self.profileVersionArn = nil
        }
    }
}

public struct PutSigningProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signing profile created.
    public var arn: Swift.String?
    /// The version of the signing profile being created.
    public var profileVersion: Swift.String?
    /// The signing profile ARN, including the profile version.
    public var profileVersionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
    }
}

struct PutSigningProfileOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let profileVersion: Swift.String?
    let profileVersionArn: Swift.String?
}

extension PutSigningProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case profileVersion
        case profileVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
    }
}

enum PutSigningProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveProfilePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let revisionId = revisionId else {
                let message = "Creating a URL Query Item failed. revisionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
            return items
        }
    }
}

extension RemoveProfilePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions/\(statementId.urlPercentEncoding())"
    }
}

public struct RemoveProfilePermissionInput: Swift.Equatable {
    /// A human-readable name for the signing profile with permissions to be removed.
    /// This member is required.
    public var profileName: Swift.String?
    /// An identifier for the current revision of the signing profile permissions.
    /// This member is required.
    public var revisionId: Swift.String?
    /// A unique identifier for the cross-account permissions statement.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        profileName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.profileName = profileName
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemoveProfilePermissionInputBody: Swift.Equatable {
}

extension RemoveProfilePermissionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveProfilePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveProfilePermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
        } else {
            self.revisionId = nil
        }
    }
}

public struct RemoveProfilePermissionOutput: Swift.Equatable {
    /// An identifier for the current revision of the profile permissions.
    public var revisionId: Swift.String?

    public init(
        revisionId: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

struct RemoveProfilePermissionOutputBody: Swift.Equatable {
    let revisionId: Swift.String?
}

extension RemoveProfilePermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum RemoveProfilePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension RevokeSignatureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobOwner
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobOwner = self.jobOwner {
            try encodeContainer.encode(jobOwner, forKey: .jobOwner)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension RevokeSignatureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/signing-jobs/\(jobId.urlPercentEncoding())/revoke"
    }
}

public struct RevokeSignatureInput: Swift.Equatable {
    /// ID of the signing job to be revoked.
    /// This member is required.
    public var jobId: Swift.String?
    /// AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// The reason for revoking the signing job.
    /// This member is required.
    public var reason: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
        self.reason = reason
    }
}

struct RevokeSignatureInputBody: Swift.Equatable {
    let jobOwner: Swift.String?
    let reason: Swift.String?
}

extension RevokeSignatureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobOwner
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension RevokeSignatureOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RevokeSignatureOutput: Swift.Equatable {

    public init() { }
}

enum RevokeSignatureOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RevokeSigningProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveTime
        case profileVersion
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveTime = self.effectiveTime {
            try encodeContainer.encodeTimestamp(effectiveTime, format: .epochSeconds, forKey: .effectiveTime)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension RevokeSigningProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profileName = profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/revoke"
    }
}

public struct RevokeSigningProfileInput: Swift.Equatable {
    /// A timestamp for when revocation of a Signing Profile should become effective. Signatures generated using the signing profile after this timestamp are not trusted.
    /// This member is required.
    public var effectiveTime: ClientRuntime.Date?
    /// The name of the signing profile to be revoked.
    /// This member is required.
    public var profileName: Swift.String?
    /// The version of the signing profile to be revoked.
    /// This member is required.
    public var profileVersion: Swift.String?
    /// The reason for revoking a signing profile.
    /// This member is required.
    public var reason: Swift.String?

    public init(
        effectiveTime: ClientRuntime.Date? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.effectiveTime = effectiveTime
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.reason = reason
    }
}

struct RevokeSigningProfileInputBody: Swift.Equatable {
    let profileVersion: Swift.String?
    let reason: Swift.String?
    let effectiveTime: ClientRuntime.Date?
}

extension RevokeSigningProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveTime
        case profileVersion
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let effectiveTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .effectiveTime)
        effectiveTime = effectiveTimeDecoded
    }
}

extension RevokeSigningProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RevokeSigningProfileOutput: Swift.Equatable {

    public init() { }
}

enum RevokeSigningProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SignerClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension SignerClientTypes {
    /// The name and prefix of the S3 bucket where code signing saves your signed objects.
    public struct S3Destination: Swift.Equatable {
        /// Name of the S3 bucket.
        public var bucketName: Swift.String?
        /// An Amazon S3 prefix that you can use to limit responses to those that begin with the specified prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension SignerClientTypes.S3SignedObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension SignerClientTypes {
    /// The S3 bucket name and key where code signing saved your signed code image.
    public struct S3SignedObject: Swift.Equatable {
        /// Name of the S3 bucket.
        public var bucketName: Swift.String?
        /// Key name that uniquely identifies a signed code image in your bucket.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }

}

extension SignerClientTypes.S3Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case key
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SignerClientTypes {
    /// Information about the S3 bucket where you saved your unsigned code.
    public struct S3Source: Swift.Equatable {
        /// Name of the S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Key name of the bucket object that contains your unsigned code.
        /// This member is required.
        public var key: Swift.String?
        /// Version of your source image in your version enabled S3 bucket.
        /// This member is required.
        public var version: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
            self.version = version
        }
    }

}

extension ServiceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is making a request that exceeds service limits.
public struct ServiceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignPayloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case payloadFormat
        case profileName
        case profileOwner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let payloadFormat = self.payloadFormat {
            try encodeContainer.encode(payloadFormat, forKey: .payloadFormat)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileOwner = self.profileOwner {
            try encodeContainer.encode(profileOwner, forKey: .profileOwner)
        }
    }
}

extension SignPayloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-jobs/with-payload"
    }
}

public struct SignPayloadInput: Swift.Equatable {
    /// Specifies the object digest (hash) to sign.
    /// This member is required.
    public var payload: ClientRuntime.Data?
    /// Payload content type
    /// This member is required.
    public var payloadFormat: Swift.String?
    /// The name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the profile owner.
    public var profileOwner: Swift.String?

    public init(
        payload: ClientRuntime.Data? = nil,
        payloadFormat: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil
    )
    {
        self.payload = payload
        self.payloadFormat = payloadFormat
        self.profileName = profileName
        self.profileOwner = profileOwner
    }
}

struct SignPayloadInputBody: Swift.Equatable {
    let profileName: Swift.String?
    let profileOwner: Swift.String?
    let payload: ClientRuntime.Data?
    let payloadFormat: Swift.String?
}

extension SignPayloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case payloadFormat
        case profileName
        case profileOwner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileOwner)
        profileOwner = profileOwnerDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
        let payloadFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormat)
        payloadFormat = payloadFormatDecoded
    }
}

extension SignPayloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SignPayloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobOwner = output.jobOwner
            self.metadata = output.metadata
            self.signature = output.signature
        } else {
            self.jobId = nil
            self.jobOwner = nil
            self.metadata = nil
            self.signature = nil
        }
    }
}

public struct SignPayloadOutput: Swift.Equatable {
    /// Unique identifier of the signing job.
    public var jobId: Swift.String?
    /// The AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// Information including the signing profile ARN and the signing job ID. Clients use metadata to signature records, for example, as annotations added to the signature manifest inside an OCI registry.
    public var metadata: [Swift.String:Swift.String]?
    /// A cryptographic signature.
    public var signature: ClientRuntime.Data?

    public init(
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        signature: ClientRuntime.Data? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
        self.metadata = metadata
        self.signature = signature
    }
}

struct SignPayloadOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobOwner: Swift.String?
    let metadata: [Swift.String:Swift.String]?
    let signature: ClientRuntime.Data?
}

extension SignPayloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case jobOwner
        case metadata
        case signature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
        let signatureDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .signature)
        signature = signatureDecoded
    }
}

enum SignPayloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SignerClientTypes.SignatureValidityPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SignerClientTypes.ValidityType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SignerClientTypes {
    /// The validity period for a signing job.
    public struct SignatureValidityPeriod: Swift.Equatable {
        /// The time unit for signature validity.
        public var type: SignerClientTypes.ValidityType?
        /// The numerical value of the time unit for signature validity.
        public var value: Swift.Int

        public init(
            type: SignerClientTypes.ValidityType? = nil,
            value: Swift.Int = 0
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SignerClientTypes.SignedObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(SignerClientTypes.S3SignedObject.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignerClientTypes {
    /// Points to an S3SignedObject object that contains information about your signed code image.
    public struct SignedObject: Swift.Equatable {
        /// The S3SignedObject.
        public var s3: SignerClientTypes.S3SignedObject?

        public init(
            s3: SignerClientTypes.S3SignedObject? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension SignerClientTypes.SigningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAlgorithmOptions
        case hashAlgorithmOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithmOptions = self.encryptionAlgorithmOptions {
            try encodeContainer.encode(encryptionAlgorithmOptions, forKey: .encryptionAlgorithmOptions)
        }
        if let hashAlgorithmOptions = self.hashAlgorithmOptions {
            try encodeContainer.encode(hashAlgorithmOptions, forKey: .hashAlgorithmOptions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAlgorithmOptionsDecoded = try containerValues.decodeIfPresent(SignerClientTypes.EncryptionAlgorithmOptions.self, forKey: .encryptionAlgorithmOptions)
        encryptionAlgorithmOptions = encryptionAlgorithmOptionsDecoded
        let hashAlgorithmOptionsDecoded = try containerValues.decodeIfPresent(SignerClientTypes.HashAlgorithmOptions.self, forKey: .hashAlgorithmOptions)
        hashAlgorithmOptions = hashAlgorithmOptionsDecoded
    }
}

extension SignerClientTypes {
    /// The configuration of a code signing operation.
    public struct SigningConfiguration: Swift.Equatable {
        /// The encryption algorithm options that are available for a code signing job.
        /// This member is required.
        public var encryptionAlgorithmOptions: SignerClientTypes.EncryptionAlgorithmOptions?
        /// The hash algorithm options that are available for a code signing job.
        /// This member is required.
        public var hashAlgorithmOptions: SignerClientTypes.HashAlgorithmOptions?

        public init(
            encryptionAlgorithmOptions: SignerClientTypes.EncryptionAlgorithmOptions? = nil,
            hashAlgorithmOptions: SignerClientTypes.HashAlgorithmOptions? = nil
        )
        {
            self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
            self.hashAlgorithmOptions = hashAlgorithmOptions
        }
    }

}

extension SignerClientTypes.SigningConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAlgorithm
        case hashAlgorithm
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAlgorithm = self.encryptionAlgorithm {
            try encodeContainer.encode(encryptionAlgorithm.rawValue, forKey: .encryptionAlgorithm)
        }
        if let hashAlgorithm = self.hashAlgorithm {
            try encodeContainer.encode(hashAlgorithm.rawValue, forKey: .hashAlgorithm)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAlgorithmDecoded = try containerValues.decodeIfPresent(SignerClientTypes.EncryptionAlgorithm.self, forKey: .encryptionAlgorithm)
        encryptionAlgorithm = encryptionAlgorithmDecoded
        let hashAlgorithmDecoded = try containerValues.decodeIfPresent(SignerClientTypes.HashAlgorithm.self, forKey: .hashAlgorithm)
        hashAlgorithm = hashAlgorithmDecoded
    }
}

extension SignerClientTypes {
    /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
    public struct SigningConfigurationOverrides: Swift.Equatable {
        /// A specified override of the default encryption algorithm that is used in a code signing job.
        public var encryptionAlgorithm: SignerClientTypes.EncryptionAlgorithm?
        /// A specified override of the default hash algorithm that is used in a code signing job.
        public var hashAlgorithm: SignerClientTypes.HashAlgorithm?

        public init(
            encryptionAlgorithm: SignerClientTypes.EncryptionAlgorithm? = nil,
            hashAlgorithm: SignerClientTypes.HashAlgorithm? = nil
        )
        {
            self.encryptionAlgorithm = encryptionAlgorithm
            self.hashAlgorithm = hashAlgorithm
        }
    }

}

extension SignerClientTypes.SigningImageFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultFormat
        case supportedFormats
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultFormat = self.defaultFormat {
            try encodeContainer.encode(defaultFormat.rawValue, forKey: .defaultFormat)
        }
        if let supportedFormats = supportedFormats {
            var supportedFormatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedFormats)
            for imageformat0 in supportedFormats {
                try supportedFormatsContainer.encode(imageformat0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedFormatsContainer = try containerValues.decodeIfPresent([SignerClientTypes.ImageFormat?].self, forKey: .supportedFormats)
        var supportedFormatsDecoded0:[SignerClientTypes.ImageFormat]? = nil
        if let supportedFormatsContainer = supportedFormatsContainer {
            supportedFormatsDecoded0 = [SignerClientTypes.ImageFormat]()
            for enum0 in supportedFormatsContainer {
                if let enum0 = enum0 {
                    supportedFormatsDecoded0?.append(enum0)
                }
            }
        }
        supportedFormats = supportedFormatsDecoded0
        let defaultFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.ImageFormat.self, forKey: .defaultFormat)
        defaultFormat = defaultFormatDecoded
    }
}

extension SignerClientTypes {
    /// The image format of a code signing platform or profile.
    public struct SigningImageFormat: Swift.Equatable {
        /// The default format of a code signing image.
        /// This member is required.
        public var defaultFormat: SignerClientTypes.ImageFormat?
        /// The supported formats of a code signing image.
        /// This member is required.
        public var supportedFormats: [SignerClientTypes.ImageFormat]?

        public init(
            defaultFormat: SignerClientTypes.ImageFormat? = nil,
            supportedFormats: [SignerClientTypes.ImageFormat]? = nil
        )
        {
            self.defaultFormat = defaultFormat
            self.supportedFormats = supportedFormats
        }
    }

}

extension SignerClientTypes.SigningJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case isRevoked
        case jobId
        case jobInvoker
        case jobOwner
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case signatureExpiresAt
        case signedObject
        case signingMaterial
        case source
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if isRevoked != false {
            try encodeContainer.encode(isRevoked, forKey: .isRevoked)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobInvoker = self.jobInvoker {
            try encodeContainer.encode(jobInvoker, forKey: .jobInvoker)
        }
        if let jobOwner = self.jobOwner {
            try encodeContainer.encode(jobOwner, forKey: .jobOwner)
        }
        if let platformDisplayName = self.platformDisplayName {
            try encodeContainer.encode(platformDisplayName, forKey: .platformDisplayName)
        }
        if let platformId = self.platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let signatureExpiresAt = self.signatureExpiresAt {
            try encodeContainer.encodeTimestamp(signatureExpiresAt, format: .epochSeconds, forKey: .signatureExpiresAt)
        }
        if let signedObject = self.signedObject {
            try encodeContainer.encode(signedObject, forKey: .signedObject)
        }
        if let signingMaterial = self.signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let signedObjectDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignedObject.self, forKey: .signedObject)
        signedObject = signedObjectDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningStatus.self, forKey: .status)
        status = statusDecoded
        let isRevokedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRevoked) ?? false
        isRevoked = isRevokedDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signatureExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .signatureExpiresAt)
        signatureExpiresAt = signatureExpiresAtDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
        let jobInvokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobInvoker)
        jobInvoker = jobInvokerDecoded
    }
}

extension SignerClientTypes {
    /// Contains information about a signing job.
    public struct SigningJob: Swift.Equatable {
        /// The date and time that the signing job was created.
        public var createdAt: ClientRuntime.Date?
        /// Indicates whether the signing job is revoked.
        public var isRevoked: Swift.Bool
        /// The ID of the signing job.
        public var jobId: Swift.String?
        /// The AWS account ID of the job invoker.
        public var jobInvoker: Swift.String?
        /// The AWS account ID of the job owner.
        public var jobOwner: Swift.String?
        /// The name of a signing platform.
        public var platformDisplayName: Swift.String?
        /// The unique identifier for a signing platform.
        public var platformId: Swift.String?
        /// The name of the signing profile that created a signing job.
        public var profileName: Swift.String?
        /// The version of the signing profile that created a signing job.
        public var profileVersion: Swift.String?
        /// The time when the signature of a signing job expires.
        public var signatureExpiresAt: ClientRuntime.Date?
        /// A SignedObject structure that contains information about a signing job's signed code image.
        public var signedObject: SignerClientTypes.SignedObject?
        /// A SigningMaterial object that contains the Amazon Resource Name (ARN) of the certificate used for the signing job.
        public var signingMaterial: SignerClientTypes.SigningMaterial?
        /// A Source that contains information about a signing job's code image source.
        public var source: SignerClientTypes.Source?
        /// The status of the signing job.
        public var status: SignerClientTypes.SigningStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            isRevoked: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobInvoker: Swift.String? = nil,
            jobOwner: Swift.String? = nil,
            platformDisplayName: Swift.String? = nil,
            platformId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            signatureExpiresAt: ClientRuntime.Date? = nil,
            signedObject: SignerClientTypes.SignedObject? = nil,
            signingMaterial: SignerClientTypes.SigningMaterial? = nil,
            source: SignerClientTypes.Source? = nil,
            status: SignerClientTypes.SigningStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.isRevoked = isRevoked
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.source = source
            self.status = status
        }
    }

}

extension SignerClientTypes.SigningJobRevocationRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case revokedAt
        case revokedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let revokedAt = self.revokedAt {
            try encodeContainer.encodeTimestamp(revokedAt, format: .epochSeconds, forKey: .revokedAt)
        }
        if let revokedBy = self.revokedBy {
            try encodeContainer.encode(revokedBy, forKey: .revokedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revokedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revokedBy)
        revokedBy = revokedByDecoded
    }
}

extension SignerClientTypes {
    /// Revocation information for a signing job.
    public struct SigningJobRevocationRecord: Swift.Equatable {
        /// A caller-supplied reason for revocation.
        public var reason: Swift.String?
        /// The time of revocation.
        public var revokedAt: ClientRuntime.Date?
        /// The identity of the revoker.
        public var revokedBy: Swift.String?

        public init(
            reason: Swift.String? = nil,
            revokedAt: ClientRuntime.Date? = nil,
            revokedBy: Swift.String? = nil
        )
        {
            self.reason = reason
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }
    }

}

extension SignerClientTypes.SigningMaterial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension SignerClientTypes {
    /// The ACM certificate that is used to sign your code.
    public struct SigningMaterial: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificates that is used to sign your code.
        /// This member is required.
        public var certificateArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }

}

extension SignerClientTypes.SigningPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case displayName
        case maxSizeInMB
        case partner
        case platformId
        case revocationSupported
        case signingConfiguration
        case signingImageFormat
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if maxSizeInMB != 0 {
            try encodeContainer.encode(maxSizeInMB, forKey: .maxSizeInMB)
        }
        if let partner = self.partner {
            try encodeContainer.encode(partner, forKey: .partner)
        }
        if let platformId = self.platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if revocationSupported != false {
            try encodeContainer.encode(revocationSupported, forKey: .revocationSupported)
        }
        if let signingConfiguration = self.signingConfiguration {
            try encodeContainer.encode(signingConfiguration, forKey: .signingConfiguration)
        }
        if let signingImageFormat = self.signingImageFormat {
            try encodeContainer.encode(signingImageFormat, forKey: .signingImageFormat)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let partnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partner)
        partner = partnerDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Category.self, forKey: .category)
        category = categoryDecoded
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningConfiguration.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
        let maxSizeInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSizeInMB) ?? 0
        maxSizeInMB = maxSizeInMBDecoded
        let revocationSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revocationSupported) ?? false
        revocationSupported = revocationSupportedDecoded
    }
}

extension SignerClientTypes {
    /// Contains information about the signing configurations and parameters that are used to perform a code signing job.
    public struct SigningPlatform: Swift.Equatable {
        /// The category of a code signing platform.
        public var category: SignerClientTypes.Category?
        /// The display name of a code signing platform.
        public var displayName: Swift.String?
        /// The maximum size (in MB) of code that can be signed by a code signing platform.
        public var maxSizeInMB: Swift.Int
        /// Any partner entities linked to a code signing platform.
        public var partner: Swift.String?
        /// The ID of a code signing platform.
        public var platformId: Swift.String?
        /// Indicates whether revocation is supported for the platform.
        public var revocationSupported: Swift.Bool
        /// The configuration of a code signing platform. This includes the designated hash algorithm and encryption algorithm of a signing platform.
        public var signingConfiguration: SignerClientTypes.SigningConfiguration?
        /// The image format of a code signing platform or profile.
        public var signingImageFormat: SignerClientTypes.SigningImageFormat?
        /// The types of targets that can be signed by a code signing platform.
        public var target: Swift.String?

        public init(
            category: SignerClientTypes.Category? = nil,
            displayName: Swift.String? = nil,
            maxSizeInMB: Swift.Int = 0,
            partner: Swift.String? = nil,
            platformId: Swift.String? = nil,
            revocationSupported: Swift.Bool = false,
            signingConfiguration: SignerClientTypes.SigningConfiguration? = nil,
            signingImageFormat: SignerClientTypes.SigningImageFormat? = nil,
            target: Swift.String? = nil
        )
        {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }
    }

}

extension SignerClientTypes.SigningPlatformOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingConfiguration
        case signingImageFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingConfiguration = self.signingConfiguration {
            try encodeContainer.encode(signingConfiguration, forKey: .signingConfiguration)
        }
        if let signingImageFormat = self.signingImageFormat {
            try encodeContainer.encode(signingImageFormat.rawValue, forKey: .signingImageFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingConfigurationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningConfigurationOverrides.self, forKey: .signingConfiguration)
        signingConfiguration = signingConfigurationDecoded
        let signingImageFormatDecoded = try containerValues.decodeIfPresent(SignerClientTypes.ImageFormat.self, forKey: .signingImageFormat)
        signingImageFormat = signingImageFormatDecoded
    }
}

extension SignerClientTypes {
    /// Any overrides that are applied to the signing configuration of a code signing platform.
    public struct SigningPlatformOverrides: Swift.Equatable {
        /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
        public var signingConfiguration: SignerClientTypes.SigningConfigurationOverrides?
        /// A signed image is a JSON object. When overriding the default signing platform configuration, a customer can select either of two signing formats, JSONEmbedded or JSONDetached. (A third format value, JSON, is reserved for future use.) With JSONEmbedded, the signing image has the payload embedded in it. With JSONDetached, the payload is not be embedded in the signing image.
        public var signingImageFormat: SignerClientTypes.ImageFormat?

        public init(
            signingConfiguration: SignerClientTypes.SigningConfigurationOverrides? = nil,
            signingImageFormat: SignerClientTypes.ImageFormat? = nil
        )
        {
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
        }
    }

}

extension SignerClientTypes.SigningProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case platformDisplayName
        case platformId
        case profileName
        case profileVersion
        case profileVersionArn
        case signatureValidityPeriod
        case signingMaterial
        case signingParameters
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let platformDisplayName = self.platformDisplayName {
            try encodeContainer.encode(platformDisplayName, forKey: .platformDisplayName)
        }
        if let platformId = self.platformId {
            try encodeContainer.encode(platformId, forKey: .platformId)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let profileVersionArn = self.profileVersionArn {
            try encodeContainer.encode(profileVersionArn, forKey: .profileVersionArn)
        }
        if let signatureValidityPeriod = self.signatureValidityPeriod {
            try encodeContainer.encode(signatureValidityPeriod, forKey: .signatureValidityPeriod)
        }
        if let signingMaterial = self.signingMaterial {
            try encodeContainer.encode(signingMaterial, forKey: .signingMaterial)
        }
        if let signingParameters = signingParameters {
            var signingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signingParameters)
            for (dictKey0, signingParameters0) in signingParameters {
                try signingParametersContainer.encode(signingParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersionArn)
        profileVersionArn = profileVersionArnDecoded
        let signingMaterialDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningMaterial.self, forKey: .signingMaterial)
        signingMaterial = signingMaterialDecoded
        let signatureValidityPeriodDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SignatureValidityPeriod.self, forKey: .signatureValidityPeriod)
        signatureValidityPeriod = signatureValidityPeriodDecoded
        let platformIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformId)
        platformId = platformIdDecoded
        let platformDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDisplayName)
        platformDisplayName = platformDisplayNameDecoded
        let signingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signingParameters)
        var signingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let signingParametersContainer = signingParametersContainer {
            signingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, signingparametervalue0) in signingParametersContainer {
                if let signingparametervalue0 = signingparametervalue0 {
                    signingParametersDecoded0?[key0] = signingparametervalue0
                }
            }
        }
        signingParameters = signingParametersDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SignerClientTypes.SigningProfileStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SignerClientTypes {
    /// Contains information about the ACM certificates and code signing configuration parameters that can be used by a given code signing user.
    public struct SigningProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public var arn: Swift.String?
        /// The name of the signing platform.
        public var platformDisplayName: Swift.String?
        /// The ID of a platform that is available for use by a signing profile.
        public var platformId: Swift.String?
        /// The name of the signing profile.
        public var profileName: Swift.String?
        /// The version of a signing profile.
        public var profileVersion: Swift.String?
        /// The ARN of a signing profile, including the profile version.
        public var profileVersionArn: Swift.String?
        /// The validity period for a signing job created using this signing profile.
        public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
        /// The ACM certificate that is available for use by a signing profile.
        public var signingMaterial: SignerClientTypes.SigningMaterial?
        /// The parameters that are available for use by a code signing user.
        public var signingParameters: [Swift.String:Swift.String]?
        /// The status of a code signing profile.
        public var status: SignerClientTypes.SigningProfileStatus?
        /// A list of tags associated with the signing profile.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            platformDisplayName: Swift.String? = nil,
            platformId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            profileVersionArn: Swift.String? = nil,
            signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
            signingMaterial: SignerClientTypes.SigningMaterial? = nil,
            signingParameters: [Swift.String:Swift.String]? = nil,
            status: SignerClientTypes.SigningProfileStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.tags = tags
        }
    }

}

extension SignerClientTypes.SigningProfileRevocationRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revocationEffectiveFrom
        case revokedAt
        case revokedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revocationEffectiveFrom = self.revocationEffectiveFrom {
            try encodeContainer.encodeTimestamp(revocationEffectiveFrom, format: .epochSeconds, forKey: .revocationEffectiveFrom)
        }
        if let revokedAt = self.revokedAt {
            try encodeContainer.encodeTimestamp(revokedAt, format: .epochSeconds, forKey: .revokedAt)
        }
        if let revokedBy = self.revokedBy {
            try encodeContainer.encode(revokedBy, forKey: .revokedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revocationEffectiveFromDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .revocationEffectiveFrom)
        revocationEffectiveFrom = revocationEffectiveFromDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revokedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revokedBy)
        revokedBy = revokedByDecoded
    }
}

extension SignerClientTypes {
    /// Revocation information for a signing profile.
    public struct SigningProfileRevocationRecord: Swift.Equatable {
        /// The time when revocation becomes effective.
        public var revocationEffectiveFrom: ClientRuntime.Date?
        /// The time when the signing profile was revoked.
        public var revokedAt: ClientRuntime.Date?
        /// The identity of the revoker.
        public var revokedBy: Swift.String?

        public init(
            revocationEffectiveFrom: ClientRuntime.Date? = nil,
            revokedAt: ClientRuntime.Date? = nil,
            revokedBy: Swift.String? = nil
        )
        {
            self.revocationEffectiveFrom = revocationEffectiveFrom
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }
    }

}

extension SignerClientTypes {
    public enum SigningProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningProfileStatus] {
            return [
                .active,
                .canceled,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .canceled: return "Canceled"
            case .revoked: return "Revoked"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningProfileStatus(rawValue: rawValue) ?? SigningProfileStatus.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes {
    public enum SigningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningStatus] {
            return [
                .failed,
                .inprogress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningStatus(rawValue: rawValue) ?? SigningStatus.sdkUnknown(rawValue)
        }
    }
}

extension SignerClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(SignerClientTypes.S3Source.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension SignerClientTypes {
    /// An S3Source object that contains information about the S3 bucket where you saved your unsigned code.
    public struct Source: Swift.Equatable {
        /// The S3Source object.
        public var s3: SignerClientTypes.S3Source?

        public init(
            s3: SignerClientTypes.S3Source? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension StartSigningJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case destination
        case profileName
        case profileOwner
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileOwner = self.profileOwner {
            try encodeContainer.encode(profileOwner, forKey: .profileOwner)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension StartSigningJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signing-jobs"
    }
}

public struct StartSigningJobInput: Swift.Equatable {
    /// String that identifies the signing request. All calls after the first that use this token return the same response as the first call.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The S3 bucket in which to save your signed object. The destination contains the name of your bucket and an optional prefix.
    /// This member is required.
    public var destination: SignerClientTypes.Destination?
    /// The name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the signing profile owner.
    public var profileOwner: Swift.String?
    /// The S3 bucket that contains the object to sign or a BLOB that contains your raw code.
    /// This member is required.
    public var source: SignerClientTypes.Source?

    public init(
        clientRequestToken: Swift.String? = nil,
        destination: SignerClientTypes.Destination? = nil,
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil,
        source: SignerClientTypes.Source? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destination = destination
        self.profileName = profileName
        self.profileOwner = profileOwner
        self.source = source
    }
}

struct StartSigningJobInputBody: Swift.Equatable {
    let source: SignerClientTypes.Source?
    let destination: SignerClientTypes.Destination?
    let profileName: Swift.String?
    let clientRequestToken: Swift.String?
    let profileOwner: Swift.String?
}

extension StartSigningJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case destination
        case profileName
        case profileOwner
        case source
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(SignerClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let profileOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileOwner)
        profileOwner = profileOwnerDecoded
    }
}

extension StartSigningJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSigningJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobOwner = output.jobOwner
        } else {
            self.jobId = nil
            self.jobOwner = nil
        }
    }
}

public struct StartSigningJobOutput: Swift.Equatable {
    /// The ID of your signing job.
    public var jobId: Swift.String?
    /// The AWS account ID of the signing job owner.
    public var jobOwner: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
    }
}

struct StartSigningJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobOwner: Swift.String?
}

extension StartSigningJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case jobOwner
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOwner)
        jobOwner = jobOwnerDecoded
    }
}

enum StartSigningJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be associated with the signing profile.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling. Instead of this error, TooManyRequestsException should be used.
@available(*, deprecated, message: "Instead of this error, TooManyRequestsException should be used.")
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The allowed number of job-signing requests has been exceeded. This error supersedes the error ThrottlingException.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to be removed from the signing profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You signing certificate could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SignerClientTypes {
    public enum ValidityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case months
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidityType] {
            return [
                .days,
                .months,
                .years,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidityType(rawValue: rawValue) ?? ValidityType.sdkUnknown(rawValue)
        }
    }
}
