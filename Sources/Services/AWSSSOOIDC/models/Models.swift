// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension AuthorizationPendingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AuthorizationPendingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a request to authorize a client with an access user session token is pending.
public struct AuthorizationPendingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationPendingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct AuthorizationPendingExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension AuthorizationPendingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension CreateTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let deviceCode = self.deviceCode {
            try encodeContainer.encode(deviceCode, forKey: .deviceCode)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType, forKey: .grantType)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scope0 in scope {
                try scopeContainer.encode(scope0)
            }
        }
    }
}

extension CreateTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/token"
    }
}

public struct CreateTokenInput: Swift.Equatable {
    /// The unique identifier string for each client. This value should come from the persisted result of the [RegisterClient] API.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string generated for the client. This value should come from the persisted result of the [RegisterClient] API.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// The authorization code received from the authorization service. This parameter is required to perform an authorization grant request to get access to a token.
    public var code: Swift.String?
    /// Used only when calling this API for the device code grant type. This short-term code is used to identify this authentication attempt. This should come from an in-memory reference to the result of the [StartDeviceAuthorization] API.
    public var deviceCode: Swift.String?
    /// Supports grant types for the authorization code, refresh token, and device code request. For device code requests, specify the following value: urn:ietf:params:oauth:grant-type:device_code  For information about how to obtain the device code, see the [StartDeviceAuthorization] topic.
    /// This member is required.
    public var grantType: Swift.String?
    /// The location of the application that will receive the authorization code. Users authorize the service to send the request to this location.
    public var redirectUri: Swift.String?
    /// Currently, refreshToken is not yet implemented and is not supported. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html). The token used to obtain an access token in the event that the access token is invalid or expired.
    public var refreshToken: Swift.String?
    /// The list of scopes that is defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
    public var scope: [Swift.String]?

    public init(
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        code: Swift.String? = nil,
        deviceCode: Swift.String? = nil,
        grantType: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        scope: [Swift.String]? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.code = code
        self.deviceCode = deviceCode
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.scope = scope
    }
}

struct CreateTokenInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let grantType: Swift.String?
    let deviceCode: Swift.String?
    let code: Swift.String?
    let refreshToken: Swift.String?
    let scope: [Swift.String]?
    let redirectUri: Swift.String?
}

extension CreateTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let deviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let scopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scope)
        var scopeDecoded0:[Swift.String]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [Swift.String]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension CreateTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.idToken = output.idToken
            self.refreshToken = output.refreshToken
            self.tokenType = output.tokenType
        } else {
            self.accessToken = nil
            self.expiresIn = 0
            self.idToken = nil
            self.refreshToken = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutput: Swift.Equatable {
    /// An opaque token to access IAM Identity Center resources assigned to a user.
    public var accessToken: Swift.String?
    /// Indicates the time in seconds when an access token will expire.
    public var expiresIn: Swift.Int
    /// Currently, idToken is not yet implemented and is not supported. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html). The identifier of the user that associated with the access token, if present.
    public var idToken: Swift.String?
    /// Currently, refreshToken is not yet implemented and is not supported. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html). A token that, if present, can be used to refresh a previously issued access token that might have expired.
    public var refreshToken: Swift.String?
    /// Used to notify the client that the returned token is an access token. The supported type is BearerToken.
    public var tokenType: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        idToken: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        tokenType: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputBody: Swift.Equatable {
    let accessToken: Swift.String?
    let tokenType: Swift.String?
    let expiresIn: Swift.Int
    let refreshToken: Swift.String?
    let idToken: Swift.String?
}

extension CreateTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case idToken
        case refreshToken
        case tokenType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn) ?? 0
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idToken)
        idToken = idTokenDecoded
    }
}

enum CreateTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationPendingException": return try await AuthorizationPendingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredTokenException": return try await ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientException": return try await InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidGrantException": return try await InvalidGrantException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidScopeException": return try await InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SlowDownException": return try await SlowDownException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedGrantTypeException": return try await UnsupportedGrantTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExpiredTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the token issued by the service is expired and is no longer valid.
public struct ExpiredTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that an error from the service occurred while trying to process a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the clientId or clientSecret in the request is invalid. For example, this can occur when a client sends an incorrect clientId or an expired clientSecret.
public struct InvalidClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidClientExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientMetadataException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientMetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the client information sent in the request during registration is invalid.
public struct InvalidClientMetadataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientMetadataException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidClientMetadataExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidClientMetadataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidGrantException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidGrantExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a request contains an invalid grant. This can occur if a client makes a [CreateToken] request with an invalid grant type.
public struct InvalidGrantException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGrantException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidGrantExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidGrantExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter might be missing or out of range.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidScopeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidScopeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the scope provided in the request is invalid.
public struct InvalidScopeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidScopeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidScopeExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidScopeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension RegisterClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientName = self.clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let clientType = self.clientType {
            try encodeContainer.encode(clientType, forKey: .clientType)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scope0 in scopes {
                try scopesContainer.encode(scope0)
            }
        }
    }
}

extension RegisterClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/client/register"
    }
}

public struct RegisterClientInput: Swift.Equatable {
    /// The friendly name of the client.
    /// This member is required.
    public var clientName: Swift.String?
    /// The type of client. The service supports only public as a client type. Anything other than public will be rejected by the service.
    /// This member is required.
    public var clientType: Swift.String?
    /// The list of scopes that are defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
    public var scopes: [Swift.String]?

    public init(
        clientName: Swift.String? = nil,
        clientType: Swift.String? = nil,
        scopes: [Swift.String]? = nil
    )
    {
        self.clientName = clientName
        self.clientType = clientType
        self.scopes = scopes
    }
}

struct RegisterClientInputBody: Swift.Equatable {
    let clientName: Swift.String?
    let clientType: Swift.String?
    let scopes: [Swift.String]?
}

extension RegisterClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let clientTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientType)
        clientType = clientTypeDecoded
        let scopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scopes)
        var scopesDecoded0:[Swift.String]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [Swift.String]()
            for string0 in scopesContainer {
                if let string0 = string0 {
                    scopesDecoded0?.append(string0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension RegisterClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterClientOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizationEndpoint = output.authorizationEndpoint
            self.clientId = output.clientId
            self.clientIdIssuedAt = output.clientIdIssuedAt
            self.clientSecret = output.clientSecret
            self.clientSecretExpiresAt = output.clientSecretExpiresAt
            self.tokenEndpoint = output.tokenEndpoint
        } else {
            self.authorizationEndpoint = nil
            self.clientId = nil
            self.clientIdIssuedAt = 0
            self.clientSecret = nil
            self.clientSecretExpiresAt = 0
            self.tokenEndpoint = nil
        }
    }
}

public struct RegisterClientOutput: Swift.Equatable {
    /// The endpoint where the client can request authorization.
    public var authorizationEndpoint: Swift.String?
    /// The unique identifier string for each client. This client uses this identifier to get authenticated by the service in subsequent calls.
    public var clientId: Swift.String?
    /// Indicates the time at which the clientId and clientSecret were issued.
    public var clientIdIssuedAt: Swift.Int
    /// A secret string generated for the client. The client will use this string to get authenticated by the service in subsequent calls.
    public var clientSecret: Swift.String?
    /// Indicates the time at which the clientId and clientSecret will become invalid.
    public var clientSecretExpiresAt: Swift.Int
    /// The endpoint where the client can get an access token.
    public var tokenEndpoint: Swift.String?

    public init(
        authorizationEndpoint: Swift.String? = nil,
        clientId: Swift.String? = nil,
        clientIdIssuedAt: Swift.Int = 0,
        clientSecret: Swift.String? = nil,
        clientSecretExpiresAt: Swift.Int = 0,
        tokenEndpoint: Swift.String? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientIdIssuedAt = clientIdIssuedAt
        self.clientSecret = clientSecret
        self.clientSecretExpiresAt = clientSecretExpiresAt
        self.tokenEndpoint = tokenEndpoint
    }
}

struct RegisterClientOutputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let clientIdIssuedAt: Swift.Int
    let clientSecretExpiresAt: Swift.Int
    let authorizationEndpoint: Swift.String?
    let tokenEndpoint: Swift.String?
}

extension RegisterClientOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint
        case clientId
        case clientIdIssuedAt
        case clientSecret
        case clientSecretExpiresAt
        case tokenEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let clientIdIssuedAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientIdIssuedAt) ?? 0
        clientIdIssuedAt = clientIdIssuedAtDecoded
        let clientSecretExpiresAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientSecretExpiresAt) ?? 0
        clientSecretExpiresAt = clientSecretExpiresAtDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let tokenEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenEndpoint)
        tokenEndpoint = tokenEndpointDecoded
    }
}

enum RegisterClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientMetadataException": return try await InvalidClientMetadataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidScopeException": return try await InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SlowDownException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SlowDownExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the client is making the request too frequently and is more than the service can handle.
public struct SlowDownException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SlowDownException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct SlowDownExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension SlowDownExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension StartDeviceAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let startUrl = self.startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }
}

extension StartDeviceAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device_authorization"
    }
}

public struct StartDeviceAuthorizationInput: Swift.Equatable {
    /// The unique identifier string for the client that is registered with IAM Identity Center. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string that is generated for the client. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// The URL for the AWS access portal. For more information, see [Using the AWS access portal](https://docs.aws.amazon.com/singlesignon/latest/userguide/using-the-portal.html) in the IAM Identity Center User Guide.
    /// This member is required.
    public var startUrl: Swift.String?

    public init(
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        startUrl: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.startUrl = startUrl
    }
}

struct StartDeviceAuthorizationInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let startUrl: Swift.String?
}

extension StartDeviceAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension StartDeviceAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDeviceAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceCode = output.deviceCode
            self.expiresIn = output.expiresIn
            self.interval = output.interval
            self.userCode = output.userCode
            self.verificationUri = output.verificationUri
            self.verificationUriComplete = output.verificationUriComplete
        } else {
            self.deviceCode = nil
            self.expiresIn = 0
            self.interval = 0
            self.userCode = nil
            self.verificationUri = nil
            self.verificationUriComplete = nil
        }
    }
}

public struct StartDeviceAuthorizationOutput: Swift.Equatable {
    /// The short-lived code that is used by the device when polling for a session token.
    public var deviceCode: Swift.String?
    /// Indicates the number of seconds in which the verification code will become invalid.
    public var expiresIn: Swift.Int
    /// Indicates the number of seconds the client must wait between attempts when polling for a session.
    public var interval: Swift.Int
    /// A one-time user verification code. This is needed to authorize an in-use device.
    public var userCode: Swift.String?
    /// The URI of the verification page that takes the userCode to authorize the device.
    public var verificationUri: Swift.String?
    /// An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code.
    public var verificationUriComplete: Swift.String?

    public init(
        deviceCode: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        interval: Swift.Int = 0,
        userCode: Swift.String? = nil,
        verificationUri: Swift.String? = nil,
        verificationUriComplete: Swift.String? = nil
    )
    {
        self.deviceCode = deviceCode
        self.expiresIn = expiresIn
        self.interval = interval
        self.userCode = userCode
        self.verificationUri = verificationUri
        self.verificationUriComplete = verificationUriComplete
    }
}

struct StartDeviceAuthorizationOutputBody: Swift.Equatable {
    let deviceCode: Swift.String?
    let userCode: Swift.String?
    let verificationUri: Swift.String?
    let verificationUriComplete: Swift.String?
    let expiresIn: Swift.Int
    let interval: Swift.Int
}

extension StartDeviceAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCode
        case expiresIn
        case interval
        case userCode
        case verificationUri
        case verificationUriComplete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let verificationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationUri)
        verificationUri = verificationUriDecoded
        let verificationUriCompleteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationUriComplete)
        verificationUriComplete = verificationUriCompleteDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn) ?? 0
        expiresIn = expiresInDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval) ?? 0
        interval = intervalDecoded
    }
}

enum StartDeviceAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientException": return try await InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SlowDownException": return try await SlowDownException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the client is not currently authorized to make the request. This can happen when a clientId is not issued for a public client.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension UnsupportedGrantTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedGrantTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the grant type in the request is not supported by the service.
public struct UnsupportedGrantTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var error: Swift.String? = nil
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedGrantTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct UnsupportedGrantTypeExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension UnsupportedGrantTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}
