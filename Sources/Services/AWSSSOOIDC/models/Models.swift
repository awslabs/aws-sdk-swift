// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be access_denied.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension AuthorizationPendingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AuthorizationPendingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a request to authorize a client with an access user session token is pending.
public struct AuthorizationPendingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be authorization_pending.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationPendingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct AuthorizationPendingExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension AuthorizationPendingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension CreateTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenInput(clientId: \(Swift.String(describing: clientId)), code: \(Swift.String(describing: code)), deviceCode: \(Swift.String(describing: deviceCode)), grantType: \(Swift.String(describing: grantType)), redirectUri: \(Swift.String(describing: redirectUri)), scope: \(Swift.String(describing: scope)), clientSecret: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension CreateTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let deviceCode = self.deviceCode {
            try encodeContainer.encode(deviceCode, forKey: .deviceCode)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType, forKey: .grantType)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scope0 in scope {
                try scopeContainer.encode(scope0)
            }
        }
    }
}

extension CreateTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/token"
    }
}

public struct CreateTokenInput: Swift.Equatable {
    /// The unique identifier string for the client or application. This value comes from the result of the [RegisterClient] API.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string generated for the client. This value should come from the persisted result of the [RegisterClient] API.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. The short-term code is used to identify this authorization request. This grant type is currently unsupported for the [CreateToken] API.
    public var code: Swift.String?
    /// Used only when calling this API for the Device Code grant type. This short-term code is used to identify this authorization request. This comes from the result of the [StartDeviceAuthorization] API.
    public var deviceCode: Swift.String?
    /// Supports the following OAuth grant types: Device Code and Refresh Token. Specify either of the following values, depending on the grant type that you want: * Device Code - urn:ietf:params:oauth:grant-type:device_code * Refresh Token - refresh_token For information about how to obtain the device code, see the [StartDeviceAuthorization] topic.
    /// This member is required.
    public var grantType: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This value specifies the location of the client or application that has registered to receive the authorization code.
    public var redirectUri: Swift.String?
    /// Used only when calling this API for the Refresh Token grant type. This token is used to refresh short-term tokens, such as the access token, that might expire. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// The list of scopes for which authorization is requested. The access token that is issued is limited to the scopes that are granted. If this value is not specified, IAM Identity Center authorizes all scopes that are configured for the client during the call to [RegisterClient].
    public var scope: [Swift.String]?

    public init(
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        code: Swift.String? = nil,
        deviceCode: Swift.String? = nil,
        grantType: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        scope: [Swift.String]? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.code = code
        self.deviceCode = deviceCode
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.scope = scope
    }
}

struct CreateTokenInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let grantType: Swift.String?
    let deviceCode: Swift.String?
    let code: Swift.String?
    let refreshToken: Swift.String?
    let scope: [Swift.String]?
    let redirectUri: Swift.String?
}

extension CreateTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case code
        case deviceCode
        case grantType
        case redirectUri
        case refreshToken
        case scope
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let deviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let scopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scope)
        var scopeDecoded0:[Swift.String]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [Swift.String]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension CreateTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenOutput(expiresIn: \(Swift.String(describing: expiresIn)), tokenType: \(Swift.String(describing: tokenType)), accessToken: \"CONTENT_REDACTED\", idToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension CreateTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.idToken = output.idToken
            self.refreshToken = output.refreshToken
            self.tokenType = output.tokenType
        } else {
            self.accessToken = nil
            self.expiresIn = 0
            self.idToken = nil
            self.refreshToken = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutput: Swift.Equatable {
    /// A bearer token to access AWS accounts and applications assigned to a user.
    public var accessToken: Swift.String?
    /// Indicates the time in seconds when an access token will expire.
    public var expiresIn: Swift.Int
    /// The idToken is not implemented or supported. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html). A JSON Web Token (JWT) that identifies who is associated with the issued access token.
    public var idToken: Swift.String?
    /// A token that, if present, can be used to refresh a previously issued access token that might have expired. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// Used to notify the client that the returned token is an access token. The supported token type is Bearer.
    public var tokenType: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        idToken: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        tokenType: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputBody: Swift.Equatable {
    let accessToken: Swift.String?
    let tokenType: Swift.String?
    let expiresIn: Swift.Int
    let refreshToken: Swift.String?
    let idToken: Swift.String?
}

extension CreateTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case idToken
        case refreshToken
        case tokenType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn) ?? 0
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idToken)
        idToken = idTokenDecoded
    }
}

enum CreateTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationPendingException": return try await AuthorizationPendingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredTokenException": return try await ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientException": return try await InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidGrantException": return try await InvalidGrantException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidScopeException": return try await InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SlowDownException": return try await SlowDownException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedGrantTypeException": return try await UnsupportedGrantTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTokenWithIAMInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenWithIAMInput(clientId: \(Swift.String(describing: clientId)), code: \(Swift.String(describing: code)), grantType: \(Swift.String(describing: grantType)), redirectUri: \(Swift.String(describing: redirectUri)), requestedTokenType: \(Swift.String(describing: requestedTokenType)), scope: \(Swift.String(describing: scope)), subjectTokenType: \(Swift.String(describing: subjectTokenType)), assertion: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\", subjectToken: \"CONTENT_REDACTED\")"}
}

extension CreateTokenWithIAMInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assertion
        case clientId
        case code
        case grantType
        case redirectUri
        case refreshToken
        case requestedTokenType
        case scope
        case subjectToken
        case subjectTokenType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assertion = self.assertion {
            try encodeContainer.encode(assertion, forKey: .assertion)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType, forKey: .grantType)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let requestedTokenType = self.requestedTokenType {
            try encodeContainer.encode(requestedTokenType, forKey: .requestedTokenType)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scope0 in scope {
                try scopeContainer.encode(scope0)
            }
        }
        if let subjectToken = self.subjectToken {
            try encodeContainer.encode(subjectToken, forKey: .subjectToken)
        }
        if let subjectTokenType = self.subjectTokenType {
            try encodeContainer.encode(subjectTokenType, forKey: .subjectTokenType)
        }
    }
}

extension CreateTokenWithIAMInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "aws_iam", value: "t"))
            return items
        }
    }
}

extension CreateTokenWithIAMInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/token"
    }
}

public struct CreateTokenWithIAMInput: Swift.Equatable {
    /// Used only when calling this API for the JWT Bearer grant type. This value specifies the JSON Web Token (JWT) issued by a trusted token issuer. To authorize a trusted token issuer, configure the JWT Bearer GrantOptions for the application.
    public var assertion: Swift.String?
    /// The unique identifier string for the client or application. This value is an application ARN that has OAuth grants configured.
    /// This member is required.
    public var clientId: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This short-term code is used to identify this authorization request. The code is obtained through a redirect from IAM Identity Center to a redirect URI persisted in the Authorization Code GrantOptions for the application.
    public var code: Swift.String?
    /// Supports the following OAuth grant types: Authorization Code, Refresh Token, JWT Bearer, and Token Exchange. Specify one of the following values, depending on the grant type that you want: * Authorization Code - authorization_code * Refresh Token - refresh_token * JWT Bearer - urn:ietf:params:oauth:grant-type:jwt-bearer * Token Exchange - urn:ietf:params:oauth:grant-type:token-exchange
    /// This member is required.
    public var grantType: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This value specifies the location of the client or application that has registered to receive the authorization code.
    public var redirectUri: Swift.String?
    /// Used only when calling this API for the Refresh Token grant type. This token is used to refresh short-term tokens, such as the access token, that might expire. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// Used only when calling this API for the Token Exchange grant type. This value specifies the type of token that the requester can receive. The following values are supported: * Access Token - urn:ietf:params:oauth:token-type:access_token * Refresh Token - urn:ietf:params:oauth:token-type:refresh_token
    public var requestedTokenType: Swift.String?
    /// The list of scopes for which authorization is requested. The access token that is issued is limited to the scopes that are granted. If the value is not specified, IAM Identity Center authorizes all scopes configured for the application, including the following default scopes: openid, aws, sts:identity_context.
    public var scope: [Swift.String]?
    /// Used only when calling this API for the Token Exchange grant type. This value specifies the subject of the exchange. The value of the subject token must be an access token issued by IAM Identity Center to a different client or application. The access token must have authorized scopes that indicate the requested application as a target audience.
    public var subjectToken: Swift.String?
    /// Used only when calling this API for the Token Exchange grant type. This value specifies the type of token that is passed as the subject of the exchange. The following value is supported: * Access Token - urn:ietf:params:oauth:token-type:access_token
    public var subjectTokenType: Swift.String?

    public init(
        assertion: Swift.String? = nil,
        clientId: Swift.String? = nil,
        code: Swift.String? = nil,
        grantType: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        requestedTokenType: Swift.String? = nil,
        scope: [Swift.String]? = nil,
        subjectToken: Swift.String? = nil,
        subjectTokenType: Swift.String? = nil
    )
    {
        self.assertion = assertion
        self.clientId = clientId
        self.code = code
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.requestedTokenType = requestedTokenType
        self.scope = scope
        self.subjectToken = subjectToken
        self.subjectTokenType = subjectTokenType
    }
}

struct CreateTokenWithIAMInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let grantType: Swift.String?
    let code: Swift.String?
    let refreshToken: Swift.String?
    let assertion: Swift.String?
    let scope: [Swift.String]?
    let redirectUri: Swift.String?
    let subjectToken: Swift.String?
    let subjectTokenType: Swift.String?
    let requestedTokenType: Swift.String?
}

extension CreateTokenWithIAMInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assertion
        case clientId
        case code
        case grantType
        case redirectUri
        case refreshToken
        case requestedTokenType
        case scope
        case subjectToken
        case subjectTokenType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let assertionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assertion)
        assertion = assertionDecoded
        let scopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scope)
        var scopeDecoded0:[Swift.String]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [Swift.String]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
        let subjectTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectToken)
        subjectToken = subjectTokenDecoded
        let subjectTokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectTokenType)
        subjectTokenType = subjectTokenTypeDecoded
        let requestedTokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestedTokenType)
        requestedTokenType = requestedTokenTypeDecoded
    }
}

extension CreateTokenWithIAMOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenWithIAMOutput(expiresIn: \(Swift.String(describing: expiresIn)), issuedTokenType: \(Swift.String(describing: issuedTokenType)), scope: \(Swift.String(describing: scope)), tokenType: \(Swift.String(describing: tokenType)), accessToken: \"CONTENT_REDACTED\", idToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension CreateTokenWithIAMOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTokenWithIAMOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.idToken = output.idToken
            self.issuedTokenType = output.issuedTokenType
            self.refreshToken = output.refreshToken
            self.scope = output.scope
            self.tokenType = output.tokenType
        } else {
            self.accessToken = nil
            self.expiresIn = 0
            self.idToken = nil
            self.issuedTokenType = nil
            self.refreshToken = nil
            self.scope = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenWithIAMOutput: Swift.Equatable {
    /// A bearer token to access AWS accounts and applications assigned to a user.
    public var accessToken: Swift.String?
    /// Indicates the time in seconds when an access token will expire.
    public var expiresIn: Swift.Int
    /// A JSON Web Token (JWT) that identifies the user associated with the issued access token.
    public var idToken: Swift.String?
    /// Indicates the type of tokens that are issued by IAM Identity Center. The following values are supported: * Access Token - urn:ietf:params:oauth:token-type:access_token * Refresh Token - urn:ietf:params:oauth:token-type:refresh_token
    public var issuedTokenType: Swift.String?
    /// A token that, if present, can be used to refresh a previously issued access token that might have expired. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// The list of scopes for which authorization is granted. The access token that is issued is limited to the scopes that are granted.
    public var scope: [Swift.String]?
    /// Used to notify the requester that the returned token is an access token. The supported token type is Bearer.
    public var tokenType: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        idToken: Swift.String? = nil,
        issuedTokenType: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        scope: [Swift.String]? = nil,
        tokenType: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.issuedTokenType = issuedTokenType
        self.refreshToken = refreshToken
        self.scope = scope
        self.tokenType = tokenType
    }
}

struct CreateTokenWithIAMOutputBody: Swift.Equatable {
    let accessToken: Swift.String?
    let tokenType: Swift.String?
    let expiresIn: Swift.Int
    let refreshToken: Swift.String?
    let idToken: Swift.String?
    let issuedTokenType: Swift.String?
    let scope: [Swift.String]?
}

extension CreateTokenWithIAMOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case idToken
        case issuedTokenType
        case refreshToken
        case scope
        case tokenType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn) ?? 0
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idToken)
        idToken = idTokenDecoded
        let issuedTokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuedTokenType)
        issuedTokenType = issuedTokenTypeDecoded
        let scopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scope)
        var scopeDecoded0:[Swift.String]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [Swift.String]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
    }
}

enum CreateTokenWithIAMOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationPendingException": return try await AuthorizationPendingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredTokenException": return try await ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientException": return try await InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidGrantException": return try await InvalidGrantException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestRegionException": return try await InvalidRequestRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidScopeException": return try await InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SlowDownException": return try await SlowDownException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedGrantTypeException": return try await UnsupportedGrantTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExpiredTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the token issued by the service is expired and is no longer valid.
public struct ExpiredTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be expired_token.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that an error from the service occurred while trying to process a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be server_error.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the clientId or clientSecret in the request is invalid. For example, this can occur when a client sends an incorrect clientId or an expired clientSecret.
public struct InvalidClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_client.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidClientExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidClientMetadataException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientMetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the client information sent in the request during registration is invalid.
public struct InvalidClientMetadataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_client_metadata.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientMetadataException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidClientMetadataExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidClientMetadataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidGrantException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidGrantExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a request contains an invalid grant. This can occur if a client makes a [CreateToken] request with an invalid grant type.
public struct InvalidGrantException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_grant.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGrantException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidGrantExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidGrantExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter might be missing or out of range.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_request.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension InvalidRequestRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.endpoint = output.endpoint
            self.properties.error = output.error
            self.properties.error_description = output.error_description
            self.properties.region = output.region
        } else {
            self.properties.endpoint = nil
            self.properties.error = nil
            self.properties.error_description = nil
            self.properties.region = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a token provided as input to the request was issued by and is only usable by calling IAM Identity Center endpoints in another region.
public struct InvalidRequestRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Indicates the IAM Identity Center endpoint which the requester may call with this token.
        public internal(set) var endpoint: Swift.String? = nil
        /// Single error code. For this exception the value will be invalid_request.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
        /// Indicates the region which the requester may call with this token.
        public internal(set) var region: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        endpoint: Swift.String? = nil,
        error: Swift.String? = nil,
        error_description: Swift.String? = nil,
        region: Swift.String? = nil
    )
    {
        self.properties.endpoint = endpoint
        self.properties.error = error
        self.properties.error_description = error_description
        self.properties.region = region
    }
}

struct InvalidRequestRegionExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
    let endpoint: Swift.String?
    let region: Swift.String?
}

extension InvalidRequestRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case error
        case error_description
        case region
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension InvalidScopeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidScopeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the scope provided in the request is invalid.
public struct InvalidScopeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_scope.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidScopeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct InvalidScopeExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension InvalidScopeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension RegisterClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientName = self.clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let clientType = self.clientType {
            try encodeContainer.encode(clientType, forKey: .clientType)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scope0 in scopes {
                try scopesContainer.encode(scope0)
            }
        }
    }
}

extension RegisterClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/client/register"
    }
}

public struct RegisterClientInput: Swift.Equatable {
    /// The friendly name of the client.
    /// This member is required.
    public var clientName: Swift.String?
    /// The type of client. The service supports only public as a client type. Anything other than public will be rejected by the service.
    /// This member is required.
    public var clientType: Swift.String?
    /// The list of scopes that are defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
    public var scopes: [Swift.String]?

    public init(
        clientName: Swift.String? = nil,
        clientType: Swift.String? = nil,
        scopes: [Swift.String]? = nil
    )
    {
        self.clientName = clientName
        self.clientType = clientType
        self.scopes = scopes
    }
}

struct RegisterClientInputBody: Swift.Equatable {
    let clientName: Swift.String?
    let clientType: Swift.String?
    let scopes: [Swift.String]?
}

extension RegisterClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientName
        case clientType
        case scopes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let clientTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientType)
        clientType = clientTypeDecoded
        let scopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .scopes)
        var scopesDecoded0:[Swift.String]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [Swift.String]()
            for string0 in scopesContainer {
                if let string0 = string0 {
                    scopesDecoded0?.append(string0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension RegisterClientOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterClientOutput(authorizationEndpoint: \(Swift.String(describing: authorizationEndpoint)), clientId: \(Swift.String(describing: clientId)), clientIdIssuedAt: \(Swift.String(describing: clientIdIssuedAt)), clientSecretExpiresAt: \(Swift.String(describing: clientSecretExpiresAt)), tokenEndpoint: \(Swift.String(describing: tokenEndpoint)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension RegisterClientOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterClientOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizationEndpoint = output.authorizationEndpoint
            self.clientId = output.clientId
            self.clientIdIssuedAt = output.clientIdIssuedAt
            self.clientSecret = output.clientSecret
            self.clientSecretExpiresAt = output.clientSecretExpiresAt
            self.tokenEndpoint = output.tokenEndpoint
        } else {
            self.authorizationEndpoint = nil
            self.clientId = nil
            self.clientIdIssuedAt = 0
            self.clientSecret = nil
            self.clientSecretExpiresAt = 0
            self.tokenEndpoint = nil
        }
    }
}

public struct RegisterClientOutput: Swift.Equatable {
    /// An endpoint that the client can use to request authorization.
    public var authorizationEndpoint: Swift.String?
    /// The unique identifier string for each client. This client uses this identifier to get authenticated by the service in subsequent calls.
    public var clientId: Swift.String?
    /// Indicates the time at which the clientId and clientSecret were issued.
    public var clientIdIssuedAt: Swift.Int
    /// A secret string generated for the client. The client will use this string to get authenticated by the service in subsequent calls.
    public var clientSecret: Swift.String?
    /// Indicates the time at which the clientId and clientSecret will become invalid.
    public var clientSecretExpiresAt: Swift.Int
    /// An endpoint that the client can use to create tokens.
    public var tokenEndpoint: Swift.String?

    public init(
        authorizationEndpoint: Swift.String? = nil,
        clientId: Swift.String? = nil,
        clientIdIssuedAt: Swift.Int = 0,
        clientSecret: Swift.String? = nil,
        clientSecretExpiresAt: Swift.Int = 0,
        tokenEndpoint: Swift.String? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientIdIssuedAt = clientIdIssuedAt
        self.clientSecret = clientSecret
        self.clientSecretExpiresAt = clientSecretExpiresAt
        self.tokenEndpoint = tokenEndpoint
    }
}

struct RegisterClientOutputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let clientIdIssuedAt: Swift.Int
    let clientSecretExpiresAt: Swift.Int
    let authorizationEndpoint: Swift.String?
    let tokenEndpoint: Swift.String?
}

extension RegisterClientOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationEndpoint
        case clientId
        case clientIdIssuedAt
        case clientSecret
        case clientSecretExpiresAt
        case tokenEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let clientIdIssuedAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientIdIssuedAt) ?? 0
        clientIdIssuedAt = clientIdIssuedAtDecoded
        let clientSecretExpiresAtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientSecretExpiresAt) ?? 0
        clientSecretExpiresAt = clientSecretExpiresAtDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let tokenEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenEndpoint)
        tokenEndpoint = tokenEndpointDecoded
    }
}

enum RegisterClientOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientMetadataException": return try await InvalidClientMetadataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidScopeException": return try await InvalidScopeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SlowDownException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SlowDownExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the client is making the request too frequently and is more than the service can handle.
public struct SlowDownException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be slow_down.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SlowDownException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct SlowDownExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension SlowDownExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension StartDeviceAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeviceAuthorizationInput(clientId: \(Swift.String(describing: clientId)), startUrl: \(Swift.String(describing: startUrl)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension StartDeviceAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let startUrl = self.startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }
}

extension StartDeviceAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device_authorization"
    }
}

public struct StartDeviceAuthorizationInput: Swift.Equatable {
    /// The unique identifier string for the client that is registered with IAM Identity Center. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string that is generated for the client. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// The URL for the Amazon Web Services access portal. For more information, see [Using the Amazon Web Services access portal](https://docs.aws.amazon.com/singlesignon/latest/userguide/using-the-portal.html) in the IAM Identity Center User Guide.
    /// This member is required.
    public var startUrl: Swift.String?

    public init(
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        startUrl: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.startUrl = startUrl
    }
}

struct StartDeviceAuthorizationInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let clientSecret: Swift.String?
    let startUrl: Swift.String?
}

extension StartDeviceAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
        case startUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension StartDeviceAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDeviceAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceCode = output.deviceCode
            self.expiresIn = output.expiresIn
            self.interval = output.interval
            self.userCode = output.userCode
            self.verificationUri = output.verificationUri
            self.verificationUriComplete = output.verificationUriComplete
        } else {
            self.deviceCode = nil
            self.expiresIn = 0
            self.interval = 0
            self.userCode = nil
            self.verificationUri = nil
            self.verificationUriComplete = nil
        }
    }
}

public struct StartDeviceAuthorizationOutput: Swift.Equatable {
    /// The short-lived code that is used by the device when polling for a session token.
    public var deviceCode: Swift.String?
    /// Indicates the number of seconds in which the verification code will become invalid.
    public var expiresIn: Swift.Int
    /// Indicates the number of seconds the client must wait between attempts when polling for a session.
    public var interval: Swift.Int
    /// A one-time user verification code. This is needed to authorize an in-use device.
    public var userCode: Swift.String?
    /// The URI of the verification page that takes the userCode to authorize the device.
    public var verificationUri: Swift.String?
    /// An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code.
    public var verificationUriComplete: Swift.String?

    public init(
        deviceCode: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        interval: Swift.Int = 0,
        userCode: Swift.String? = nil,
        verificationUri: Swift.String? = nil,
        verificationUriComplete: Swift.String? = nil
    )
    {
        self.deviceCode = deviceCode
        self.expiresIn = expiresIn
        self.interval = interval
        self.userCode = userCode
        self.verificationUri = verificationUri
        self.verificationUriComplete = verificationUriComplete
    }
}

struct StartDeviceAuthorizationOutputBody: Swift.Equatable {
    let deviceCode: Swift.String?
    let userCode: Swift.String?
    let verificationUri: Swift.String?
    let verificationUriComplete: Swift.String?
    let expiresIn: Swift.Int
    let interval: Swift.Int
}

extension StartDeviceAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceCode
        case expiresIn
        case interval
        case userCode
        case verificationUri
        case verificationUriComplete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCode)
        deviceCode = deviceCodeDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let verificationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationUri)
        verificationUri = verificationUriDecoded
        let verificationUriCompleteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationUriComplete)
        verificationUriComplete = verificationUriCompleteDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn) ?? 0
        expiresIn = expiresInDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval) ?? 0
        interval = intervalDecoded
    }
}

enum StartDeviceAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientException": return try await InvalidClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SlowDownException": return try await SlowDownException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the client is not currently authorized to make the request. This can happen when a clientId is not issued for a public client.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be unauthorized_client.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}

extension UnsupportedGrantTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedGrantTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.error_description = output.error_description
        } else {
            self.properties.error = nil
            self.properties.error_description = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the grant type in the request is not supported by the service.
public struct UnsupportedGrantTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be unsupported_grant_type.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedGrantTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

struct UnsupportedGrantTypeExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let error_description: Swift.String?
}

extension UnsupportedGrantTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case error_description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let error_descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error_description)
        error_description = error_descriptionDecoded
    }
}
