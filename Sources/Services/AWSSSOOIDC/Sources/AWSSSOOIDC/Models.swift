//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be access_denied.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that a request to authorize a client with an access user session token is pending.
public struct AuthorizationPendingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be authorization_pending.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationPendingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that the token issued by the service is expired and is no longer valid.
public struct ExpiredTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be expired_token.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that an error from the service occurred while trying to process a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be server_error.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that the clientId or clientSecret in the request is invalid. For example, this can occur when a client sends an incorrect clientId or an expired clientSecret.
public struct InvalidClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_client.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that a request contains an invalid grant. This can occur if a client makes a [CreateToken] request with an invalid grant type.
public struct InvalidGrantException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_grant.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGrantException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter might be missing or out of range.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_request.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that the scope provided in the request is invalid.
public struct InvalidScopeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_scope.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidScopeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that the client is making the request too frequently and is more than the service can handle.
public struct SlowDownException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be slow_down.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SlowDownException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that the client is not currently authorized to make the request. This can happen when a clientId is not issued for a public client.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be unauthorized_client.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that the grant type in the request is not supported by the service.
public struct UnsupportedGrantTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be unsupported_grant_type.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedGrantTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

public struct CreateTokenInput {
    /// The unique identifier string for the client or application. This value comes from the result of the [RegisterClient] API.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string generated for the client. This value should come from the persisted result of the [RegisterClient] API.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. The short-term code is used to identify this authorization request. This grant type is currently unsupported for the [CreateToken] API.
    public var code: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This value is generated by the client and presented to validate the original code challenge value the client passed at authorization time.
    public var codeVerifier: Swift.String?
    /// Used only when calling this API for the Device Code grant type. This short-term code is used to identify this authorization request. This comes from the result of the [StartDeviceAuthorization] API.
    public var deviceCode: Swift.String?
    /// Supports the following OAuth grant types: Device Code and Refresh Token. Specify either of the following values, depending on the grant type that you want: * Device Code - urn:ietf:params:oauth:grant-type:device_code * Refresh Token - refresh_token For information about how to obtain the device code, see the [StartDeviceAuthorization] topic.
    /// This member is required.
    public var grantType: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This value specifies the location of the client or application that has registered to receive the authorization code.
    public var redirectUri: Swift.String?
    /// Used only when calling this API for the Refresh Token grant type. This token is used to refresh short-term tokens, such as the access token, that might expire. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// The list of scopes for which authorization is requested. The access token that is issued is limited to the scopes that are granted. If this value is not specified, IAM Identity Center authorizes all scopes that are configured for the client during the call to [RegisterClient].
    public var scope: [Swift.String]?

    public init(
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        code: Swift.String? = nil,
        codeVerifier: Swift.String? = nil,
        deviceCode: Swift.String? = nil,
        grantType: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        scope: [Swift.String]? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.code = code
        self.codeVerifier = codeVerifier
        self.deviceCode = deviceCode
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.scope = scope
    }
}

extension CreateTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenInput(clientId: \(Swift.String(describing: clientId)), code: \(Swift.String(describing: code)), deviceCode: \(Swift.String(describing: deviceCode)), grantType: \(Swift.String(describing: grantType)), redirectUri: \(Swift.String(describing: redirectUri)), scope: \(Swift.String(describing: scope)), clientSecret: \"CONTENT_REDACTED\", codeVerifier: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

public struct CreateTokenOutput {
    /// A bearer token to access Amazon Web Services accounts and applications assigned to a user.
    public var accessToken: Swift.String?
    /// Indicates the time in seconds when an access token will expire.
    public var expiresIn: Swift.Int
    /// The idToken is not implemented or supported. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html). A JSON Web Token (JWT) that identifies who is associated with the issued access token.
    public var idToken: Swift.String?
    /// A token that, if present, can be used to refresh a previously issued access token that might have expired. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// Used to notify the client that the returned token is an access token. The supported token type is Bearer.
    public var tokenType: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        idToken: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        tokenType: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
    }
}

extension CreateTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenOutput(expiresIn: \(Swift.String(describing: expiresIn)), tokenType: \(Swift.String(describing: tokenType)), accessToken: \"CONTENT_REDACTED\", idToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

/// Indicates that a token provided as input to the request was issued by and is only usable by calling IAM Identity Center endpoints in another region.
public struct InvalidRequestRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Indicates the IAM Identity Center endpoint which the requester may call with this token.
        public internal(set) var endpoint: Swift.String? = nil
        /// Single error code. For this exception the value will be invalid_request.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
        /// Indicates the region which the requester may call with this token.
        public internal(set) var region: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestRegionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        endpoint: Swift.String? = nil,
        error: Swift.String? = nil,
        error_description: Swift.String? = nil,
        region: Swift.String? = nil
    )
    {
        self.properties.endpoint = endpoint
        self.properties.error = error
        self.properties.error_description = error_description
        self.properties.region = region
    }
}

public struct CreateTokenWithIAMInput {
    /// Used only when calling this API for the JWT Bearer grant type. This value specifies the JSON Web Token (JWT) issued by a trusted token issuer. To authorize a trusted token issuer, configure the JWT Bearer GrantOptions for the application.
    public var assertion: Swift.String?
    /// The unique identifier string for the client or application. This value is an application ARN that has OAuth grants configured.
    /// This member is required.
    public var clientId: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This short-term code is used to identify this authorization request. The code is obtained through a redirect from IAM Identity Center to a redirect URI persisted in the Authorization Code GrantOptions for the application.
    public var code: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This value is generated by the client and presented to validate the original code challenge value the client passed at authorization time.
    public var codeVerifier: Swift.String?
    /// Supports the following OAuth grant types: Authorization Code, Refresh Token, JWT Bearer, and Token Exchange. Specify one of the following values, depending on the grant type that you want: * Authorization Code - authorization_code * Refresh Token - refresh_token * JWT Bearer - urn:ietf:params:oauth:grant-type:jwt-bearer * Token Exchange - urn:ietf:params:oauth:grant-type:token-exchange
    /// This member is required.
    public var grantType: Swift.String?
    /// Used only when calling this API for the Authorization Code grant type. This value specifies the location of the client or application that has registered to receive the authorization code.
    public var redirectUri: Swift.String?
    /// Used only when calling this API for the Refresh Token grant type. This token is used to refresh short-term tokens, such as the access token, that might expire. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// Used only when calling this API for the Token Exchange grant type. This value specifies the type of token that the requester can receive. The following values are supported: * Access Token - urn:ietf:params:oauth:token-type:access_token * Refresh Token - urn:ietf:params:oauth:token-type:refresh_token
    public var requestedTokenType: Swift.String?
    /// The list of scopes for which authorization is requested. The access token that is issued is limited to the scopes that are granted. If the value is not specified, IAM Identity Center authorizes all scopes configured for the application, including the following default scopes: openid, aws, sts:identity_context.
    public var scope: [Swift.String]?
    /// Used only when calling this API for the Token Exchange grant type. This value specifies the subject of the exchange. The value of the subject token must be an access token issued by IAM Identity Center to a different client or application. The access token must have authorized scopes that indicate the requested application as a target audience.
    public var subjectToken: Swift.String?
    /// Used only when calling this API for the Token Exchange grant type. This value specifies the type of token that is passed as the subject of the exchange. The following value is supported: * Access Token - urn:ietf:params:oauth:token-type:access_token
    public var subjectTokenType: Swift.String?

    public init(
        assertion: Swift.String? = nil,
        clientId: Swift.String? = nil,
        code: Swift.String? = nil,
        codeVerifier: Swift.String? = nil,
        grantType: Swift.String? = nil,
        redirectUri: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        requestedTokenType: Swift.String? = nil,
        scope: [Swift.String]? = nil,
        subjectToken: Swift.String? = nil,
        subjectTokenType: Swift.String? = nil
    )
    {
        self.assertion = assertion
        self.clientId = clientId
        self.code = code
        self.codeVerifier = codeVerifier
        self.grantType = grantType
        self.redirectUri = redirectUri
        self.refreshToken = refreshToken
        self.requestedTokenType = requestedTokenType
        self.scope = scope
        self.subjectToken = subjectToken
        self.subjectTokenType = subjectTokenType
    }
}

extension CreateTokenWithIAMInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenWithIAMInput(clientId: \(Swift.String(describing: clientId)), code: \(Swift.String(describing: code)), grantType: \(Swift.String(describing: grantType)), redirectUri: \(Swift.String(describing: redirectUri)), requestedTokenType: \(Swift.String(describing: requestedTokenType)), scope: \(Swift.String(describing: scope)), subjectTokenType: \(Swift.String(describing: subjectTokenType)), assertion: \"CONTENT_REDACTED\", codeVerifier: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\", subjectToken: \"CONTENT_REDACTED\")"}
}

public struct CreateTokenWithIAMOutput {
    /// A bearer token to access Amazon Web Services accounts and applications assigned to a user.
    public var accessToken: Swift.String?
    /// Indicates the time in seconds when an access token will expire.
    public var expiresIn: Swift.Int
    /// A JSON Web Token (JWT) that identifies the user associated with the issued access token.
    public var idToken: Swift.String?
    /// Indicates the type of tokens that are issued by IAM Identity Center. The following values are supported: * Access Token - urn:ietf:params:oauth:token-type:access_token * Refresh Token - urn:ietf:params:oauth:token-type:refresh_token
    public var issuedTokenType: Swift.String?
    /// A token that, if present, can be used to refresh a previously issued access token that might have expired. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the [IAM Identity Center OIDC API Reference](https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html).
    public var refreshToken: Swift.String?
    /// The list of scopes for which authorization is granted. The access token that is issued is limited to the scopes that are granted.
    public var scope: [Swift.String]?
    /// Used to notify the requester that the returned token is an access token. The supported token type is Bearer.
    public var tokenType: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        idToken: Swift.String? = nil,
        issuedTokenType: Swift.String? = nil,
        refreshToken: Swift.String? = nil,
        scope: [Swift.String]? = nil,
        tokenType: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.issuedTokenType = issuedTokenType
        self.refreshToken = refreshToken
        self.scope = scope
        self.tokenType = tokenType
    }
}

extension CreateTokenWithIAMOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenWithIAMOutput(expiresIn: \(Swift.String(describing: expiresIn)), issuedTokenType: \(Swift.String(describing: issuedTokenType)), scope: \(Swift.String(describing: scope)), tokenType: \(Swift.String(describing: tokenType)), accessToken: \"CONTENT_REDACTED\", idToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

/// Indicates that the client information sent in the request during registration is invalid.
public struct InvalidClientMetadataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_client_metadata.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientMetadataException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

/// Indicates that one or more redirect URI in the request is not supported for this operation.
public struct InvalidRedirectUriException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Single error code. For this exception the value will be invalid_redirect_uri.
        public internal(set) var error: Swift.String? = nil
        /// Human-readable text providing additional information, used to assist the client developer in understanding the error that occurred.
        public internal(set) var error_description: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRedirectUriException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        error_description: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.error_description = error_description
    }
}

public struct RegisterClientInput {
    /// The friendly name of the client.
    /// This member is required.
    public var clientName: Swift.String?
    /// The type of client. The service supports only public as a client type. Anything other than public will be rejected by the service.
    /// This member is required.
    public var clientType: Swift.String?
    /// This IAM Identity Center application ARN is used to define administrator-managed configuration for public client access to resources. At authorization, the scopes, grants, and redirect URI available to this client will be restricted by this application resource.
    public var entitledApplicationArn: Swift.String?
    /// The list of OAuth 2.0 grant types that are defined by the client. This list is used to restrict the token granting flows available to the client.
    public var grantTypes: [Swift.String]?
    /// The IAM Identity Center Issuer URL associated with an instance of IAM Identity Center. This value is needed for user access to resources through the client.
    public var issuerUrl: Swift.String?
    /// The list of redirect URI that are defined by the client. At completion of authorization, this list is used to restrict what locations the user agent can be redirected back to.
    public var redirectUris: [Swift.String]?
    /// The list of scopes that are defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
    public var scopes: [Swift.String]?

    public init(
        clientName: Swift.String? = nil,
        clientType: Swift.String? = nil,
        entitledApplicationArn: Swift.String? = nil,
        grantTypes: [Swift.String]? = nil,
        issuerUrl: Swift.String? = nil,
        redirectUris: [Swift.String]? = nil,
        scopes: [Swift.String]? = nil
    )
    {
        self.clientName = clientName
        self.clientType = clientType
        self.entitledApplicationArn = entitledApplicationArn
        self.grantTypes = grantTypes
        self.issuerUrl = issuerUrl
        self.redirectUris = redirectUris
        self.scopes = scopes
    }
}

public struct RegisterClientOutput {
    /// An endpoint that the client can use to request authorization.
    public var authorizationEndpoint: Swift.String?
    /// The unique identifier string for each client. This client uses this identifier to get authenticated by the service in subsequent calls.
    public var clientId: Swift.String?
    /// Indicates the time at which the clientId and clientSecret were issued.
    public var clientIdIssuedAt: Swift.Int
    /// A secret string generated for the client. The client will use this string to get authenticated by the service in subsequent calls.
    public var clientSecret: Swift.String?
    /// Indicates the time at which the clientId and clientSecret will become invalid.
    public var clientSecretExpiresAt: Swift.Int
    /// An endpoint that the client can use to create tokens.
    public var tokenEndpoint: Swift.String?

    public init(
        authorizationEndpoint: Swift.String? = nil,
        clientId: Swift.String? = nil,
        clientIdIssuedAt: Swift.Int = 0,
        clientSecret: Swift.String? = nil,
        clientSecretExpiresAt: Swift.Int = 0,
        tokenEndpoint: Swift.String? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientIdIssuedAt = clientIdIssuedAt
        self.clientSecret = clientSecret
        self.clientSecretExpiresAt = clientSecretExpiresAt
        self.tokenEndpoint = tokenEndpoint
    }
}

extension RegisterClientOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterClientOutput(authorizationEndpoint: \(Swift.String(describing: authorizationEndpoint)), clientId: \(Swift.String(describing: clientId)), clientIdIssuedAt: \(Swift.String(describing: clientIdIssuedAt)), clientSecretExpiresAt: \(Swift.String(describing: clientSecretExpiresAt)), tokenEndpoint: \(Swift.String(describing: tokenEndpoint)), clientSecret: \"CONTENT_REDACTED\")"}
}

public struct StartDeviceAuthorizationInput {
    /// The unique identifier string for the client that is registered with IAM Identity Center. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientId: Swift.String?
    /// A secret string that is generated for the client. This value should come from the persisted result of the [RegisterClient] API operation.
    /// This member is required.
    public var clientSecret: Swift.String?
    /// The URL for the Amazon Web Services access portal. For more information, see [Using the Amazon Web Services access portal](https://docs.aws.amazon.com/singlesignon/latest/userguide/using-the-portal.html) in the IAM Identity Center User Guide.
    /// This member is required.
    public var startUrl: Swift.String?

    public init(
        clientId: Swift.String? = nil,
        clientSecret: Swift.String? = nil,
        startUrl: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.startUrl = startUrl
    }
}

extension StartDeviceAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeviceAuthorizationInput(clientId: \(Swift.String(describing: clientId)), startUrl: \(Swift.String(describing: startUrl)), clientSecret: \"CONTENT_REDACTED\")"}
}

public struct StartDeviceAuthorizationOutput {
    /// The short-lived code that is used by the device when polling for a session token.
    public var deviceCode: Swift.String?
    /// Indicates the number of seconds in which the verification code will become invalid.
    public var expiresIn: Swift.Int
    /// Indicates the number of seconds the client must wait between attempts when polling for a session.
    public var interval: Swift.Int
    /// A one-time user verification code. This is needed to authorize an in-use device.
    public var userCode: Swift.String?
    /// The URI of the verification page that takes the userCode to authorize the device.
    public var verificationUri: Swift.String?
    /// An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code.
    public var verificationUriComplete: Swift.String?

    public init(
        deviceCode: Swift.String? = nil,
        expiresIn: Swift.Int = 0,
        interval: Swift.Int = 0,
        userCode: Swift.String? = nil,
        verificationUri: Swift.String? = nil,
        verificationUriComplete: Swift.String? = nil
    )
    {
        self.deviceCode = deviceCode
        self.expiresIn = expiresIn
        self.interval = interval
        self.userCode = userCode
        self.verificationUri = verificationUri
        self.verificationUriComplete = verificationUriComplete
    }
}

extension CreateTokenInput {

    static func urlPathProvider(_ value: CreateTokenInput) -> Swift.String? {
        return "/token"
    }
}

extension CreateTokenWithIAMInput {

    static func urlPathProvider(_ value: CreateTokenWithIAMInput) -> Swift.String? {
        return "/token"
    }
}

extension CreateTokenWithIAMInput {

    static func queryItemProvider(_ value: CreateTokenWithIAMInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "aws_iam", value: "t"))
        return items
    }
}

extension RegisterClientInput {

    static func urlPathProvider(_ value: RegisterClientInput) -> Swift.String? {
        return "/client/register"
    }
}

extension StartDeviceAuthorizationInput {

    static func urlPathProvider(_ value: StartDeviceAuthorizationInput) -> Swift.String? {
        return "/device_authorization"
    }
}

extension CreateTokenInput {

    static func write(value: CreateTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["code"].write(value.code)
        try writer["codeVerifier"].write(value.codeVerifier)
        try writer["deviceCode"].write(value.deviceCode)
        try writer["grantType"].write(value.grantType)
        try writer["redirectUri"].write(value.redirectUri)
        try writer["refreshToken"].write(value.refreshToken)
        try writer["scope"].writeList(value.scope, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTokenWithIAMInput {

    static func write(value: CreateTokenWithIAMInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assertion"].write(value.assertion)
        try writer["clientId"].write(value.clientId)
        try writer["code"].write(value.code)
        try writer["codeVerifier"].write(value.codeVerifier)
        try writer["grantType"].write(value.grantType)
        try writer["redirectUri"].write(value.redirectUri)
        try writer["refreshToken"].write(value.refreshToken)
        try writer["requestedTokenType"].write(value.requestedTokenType)
        try writer["scope"].writeList(value.scope, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subjectToken"].write(value.subjectToken)
        try writer["subjectTokenType"].write(value.subjectTokenType)
    }
}

extension RegisterClientInput {

    static func write(value: RegisterClientInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientName"].write(value.clientName)
        try writer["clientType"].write(value.clientType)
        try writer["entitledApplicationArn"].write(value.entitledApplicationArn)
        try writer["grantTypes"].writeList(value.grantTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["issuerUrl"].write(value.issuerUrl)
        try writer["redirectUris"].writeList(value.redirectUris, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scopes"].writeList(value.scopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartDeviceAuthorizationInput {

    static func write(value: StartDeviceAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["startUrl"].write(value.startUrl)
    }
}

extension CreateTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTokenOutput()
        value.accessToken = try reader["accessToken"].readIfPresent()
        value.expiresIn = try reader["expiresIn"].readIfPresent() ?? 0
        value.idToken = try reader["idToken"].readIfPresent()
        value.refreshToken = try reader["refreshToken"].readIfPresent()
        value.tokenType = try reader["tokenType"].readIfPresent()
        return value
    }
}

extension CreateTokenWithIAMOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTokenWithIAMOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTokenWithIAMOutput()
        value.accessToken = try reader["accessToken"].readIfPresent()
        value.expiresIn = try reader["expiresIn"].readIfPresent() ?? 0
        value.idToken = try reader["idToken"].readIfPresent()
        value.issuedTokenType = try reader["issuedTokenType"].readIfPresent()
        value.refreshToken = try reader["refreshToken"].readIfPresent()
        value.scope = try reader["scope"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tokenType = try reader["tokenType"].readIfPresent()
        return value
    }
}

extension RegisterClientOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterClientOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterClientOutput()
        value.authorizationEndpoint = try reader["authorizationEndpoint"].readIfPresent()
        value.clientId = try reader["clientId"].readIfPresent()
        value.clientIdIssuedAt = try reader["clientIdIssuedAt"].readIfPresent() ?? 0
        value.clientSecret = try reader["clientSecret"].readIfPresent()
        value.clientSecretExpiresAt = try reader["clientSecretExpiresAt"].readIfPresent() ?? 0
        value.tokenEndpoint = try reader["tokenEndpoint"].readIfPresent()
        return value
    }
}

extension StartDeviceAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDeviceAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDeviceAuthorizationOutput()
        value.deviceCode = try reader["deviceCode"].readIfPresent()
        value.expiresIn = try reader["expiresIn"].readIfPresent() ?? 0
        value.interval = try reader["interval"].readIfPresent() ?? 0
        value.userCode = try reader["userCode"].readIfPresent()
        value.verificationUri = try reader["verificationUri"].readIfPresent()
        value.verificationUriComplete = try reader["verificationUriComplete"].readIfPresent()
        return value
    }
}

enum CreateTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationPendingException": return try AuthorizationPendingException.makeError(baseError: baseError)
            case "ExpiredTokenException": return try ExpiredTokenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidClientException": return try InvalidClientException.makeError(baseError: baseError)
            case "InvalidGrantException": return try InvalidGrantException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidScopeException": return try InvalidScopeException.makeError(baseError: baseError)
            case "SlowDownException": return try SlowDownException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            case "UnsupportedGrantTypeException": return try UnsupportedGrantTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTokenWithIAMOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationPendingException": return try AuthorizationPendingException.makeError(baseError: baseError)
            case "ExpiredTokenException": return try ExpiredTokenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidClientException": return try InvalidClientException.makeError(baseError: baseError)
            case "InvalidGrantException": return try InvalidGrantException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidRequestRegionException": return try InvalidRequestRegionException.makeError(baseError: baseError)
            case "InvalidScopeException": return try InvalidScopeException.makeError(baseError: baseError)
            case "SlowDownException": return try SlowDownException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            case "UnsupportedGrantTypeException": return try UnsupportedGrantTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterClientOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidClientMetadataException": return try InvalidClientMetadataException.makeError(baseError: baseError)
            case "InvalidRedirectUriException": return try InvalidRedirectUriException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidScopeException": return try InvalidScopeException.makeError(baseError: baseError)
            case "UnsupportedGrantTypeException": return try UnsupportedGrantTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDeviceAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidClientException": return try InvalidClientException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "SlowDownException": return try SlowDownException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExpiredTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ExpiredTokenException {
        let reader = baseError.errorBodyReader
        var value = ExpiredTokenException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SlowDownException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SlowDownException {
        let reader = baseError.errorBodyReader
        var value = SlowDownException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedClientException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedClientException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidGrantException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidGrantException {
        let reader = baseError.errorBodyReader
        var value = InvalidGrantException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AuthorizationPendingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AuthorizationPendingException {
        let reader = baseError.errorBodyReader
        var value = AuthorizationPendingException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidScopeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidScopeException {
        let reader = baseError.errorBodyReader
        var value = InvalidScopeException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedGrantTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedGrantTypeException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedGrantTypeException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidClientException {
        let reader = baseError.errorBodyReader
        var value = InvalidClientException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestRegionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestRegionException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestRegionException()
        value.properties.endpoint = try reader["endpoint"].readIfPresent()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.properties.region = try reader["region"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidClientMetadataException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidClientMetadataException {
        let reader = baseError.errorBodyReader
        var value = InvalidClientMetadataException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRedirectUriException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRedirectUriException {
        let reader = baseError.errorBodyReader
        var value = InvalidRedirectUriException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.error_description = try reader["error_description"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public enum SSOOIDCClientTypes {}
