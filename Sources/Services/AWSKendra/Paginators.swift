// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetSnapshotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetSnapshotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetSnapshotsOutputResponse`
extension KendraClient {
    public func getSnapshotsPaginated(input: GetSnapshotsInput) -> ClientRuntime.PaginatorSequence<GetSnapshotsInput, GetSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetSnapshotsInput, GetSnapshotsOutputResponse>(input: input, inputKey: \GetSnapshotsInput.nextToken, outputKey: \GetSnapshotsOutputResponse.nextToken, paginationFunction: self.getSnapshots(input:))
    }
}

extension GetSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSnapshotsInput {
        return GetSnapshotsInput(
            indexId: self.indexId,
            interval: self.interval,
            maxResults: self.maxResults,
            metricType: self.metricType,
            nextToken: token
        )}
}

/// Paginate over `[ListAccessControlConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAccessControlConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAccessControlConfigurationsOutputResponse`
extension KendraClient {
    public func listAccessControlConfigurationsPaginated(input: ListAccessControlConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListAccessControlConfigurationsInput, ListAccessControlConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAccessControlConfigurationsInput, ListAccessControlConfigurationsOutputResponse>(input: input, inputKey: \ListAccessControlConfigurationsInput.nextToken, outputKey: \ListAccessControlConfigurationsOutputResponse.nextToken, paginationFunction: self.listAccessControlConfigurations(input:))
    }
}

extension ListAccessControlConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccessControlConfigurationsInput {
        return ListAccessControlConfigurationsInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListDataSourcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDataSourcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDataSourcesOutputResponse`
extension KendraClient {
    public func listDataSourcesPaginated(input: ListDataSourcesInput) -> ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse>(input: input, inputKey: \ListDataSourcesInput.nextToken, outputKey: \ListDataSourcesOutputResponse.nextToken, paginationFunction: self.listDataSources(input:))
    }
}

extension ListDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourcesInput {
        return ListDataSourcesInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListDataSourceSyncJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDataSourceSyncJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDataSourceSyncJobsOutputResponse`
extension KendraClient {
    public func listDataSourceSyncJobsPaginated(input: ListDataSourceSyncJobsInput) -> ClientRuntime.PaginatorSequence<ListDataSourceSyncJobsInput, ListDataSourceSyncJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSourceSyncJobsInput, ListDataSourceSyncJobsOutputResponse>(input: input, inputKey: \ListDataSourceSyncJobsInput.nextToken, outputKey: \ListDataSourceSyncJobsOutputResponse.nextToken, paginationFunction: self.listDataSourceSyncJobs(input:))
    }
}

extension ListDataSourceSyncJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourceSyncJobsInput {
        return ListDataSourceSyncJobsInput(
            id: self.id,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            startTimeFilter: self.startTimeFilter,
            statusFilter: self.statusFilter
        )}
}

/// Paginate over `[ListEntityPersonasOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEntityPersonasInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEntityPersonasOutputResponse`
extension KendraClient {
    public func listEntityPersonasPaginated(input: ListEntityPersonasInput) -> ClientRuntime.PaginatorSequence<ListEntityPersonasInput, ListEntityPersonasOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEntityPersonasInput, ListEntityPersonasOutputResponse>(input: input, inputKey: \ListEntityPersonasInput.nextToken, outputKey: \ListEntityPersonasOutputResponse.nextToken, paginationFunction: self.listEntityPersonas(input:))
    }
}

extension ListEntityPersonasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEntityPersonasInput {
        return ListEntityPersonasInput(
            id: self.id,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListExperienceEntitiesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListExperienceEntitiesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListExperienceEntitiesOutputResponse`
extension KendraClient {
    public func listExperienceEntitiesPaginated(input: ListExperienceEntitiesInput) -> ClientRuntime.PaginatorSequence<ListExperienceEntitiesInput, ListExperienceEntitiesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExperienceEntitiesInput, ListExperienceEntitiesOutputResponse>(input: input, inputKey: \ListExperienceEntitiesInput.nextToken, outputKey: \ListExperienceEntitiesOutputResponse.nextToken, paginationFunction: self.listExperienceEntities(input:))
    }
}

extension ListExperienceEntitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExperienceEntitiesInput {
        return ListExperienceEntitiesInput(
            id: self.id,
            indexId: self.indexId,
            nextToken: token
        )}
}

/// Paginate over `[ListExperiencesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListExperiencesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListExperiencesOutputResponse`
extension KendraClient {
    public func listExperiencesPaginated(input: ListExperiencesInput) -> ClientRuntime.PaginatorSequence<ListExperiencesInput, ListExperiencesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExperiencesInput, ListExperiencesOutputResponse>(input: input, inputKey: \ListExperiencesInput.nextToken, outputKey: \ListExperiencesOutputResponse.nextToken, paginationFunction: self.listExperiences(input:))
    }
}

extension ListExperiencesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExperiencesInput {
        return ListExperiencesInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListFaqsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFaqsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFaqsOutputResponse`
extension KendraClient {
    public func listFaqsPaginated(input: ListFaqsInput) -> ClientRuntime.PaginatorSequence<ListFaqsInput, ListFaqsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFaqsInput, ListFaqsOutputResponse>(input: input, inputKey: \ListFaqsInput.nextToken, outputKey: \ListFaqsOutputResponse.nextToken, paginationFunction: self.listFaqs(input:))
    }
}

extension ListFaqsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFaqsInput {
        return ListFaqsInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListGroupsOlderThanOrderingIdOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGroupsOlderThanOrderingIdInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOlderThanOrderingIdOutputResponse`
extension KendraClient {
    public func listGroupsOlderThanOrderingIdPaginated(input: ListGroupsOlderThanOrderingIdInput) -> ClientRuntime.PaginatorSequence<ListGroupsOlderThanOrderingIdInput, ListGroupsOlderThanOrderingIdOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGroupsOlderThanOrderingIdInput, ListGroupsOlderThanOrderingIdOutputResponse>(input: input, inputKey: \ListGroupsOlderThanOrderingIdInput.nextToken, outputKey: \ListGroupsOlderThanOrderingIdOutputResponse.nextToken, paginationFunction: self.listGroupsOlderThanOrderingId(input:))
    }
}

extension ListGroupsOlderThanOrderingIdInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsOlderThanOrderingIdInput {
        return ListGroupsOlderThanOrderingIdInput(
            dataSourceId: self.dataSourceId,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            orderingId: self.orderingId
        )}
}

/// Paginate over `[ListIndicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIndicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIndicesOutputResponse`
extension KendraClient {
    public func listIndicesPaginated(input: ListIndicesInput) -> ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutputResponse>(input: input, inputKey: \ListIndicesInput.nextToken, outputKey: \ListIndicesOutputResponse.nextToken, paginationFunction: self.listIndices(input:))
    }
}

extension ListIndicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIndicesInput {
        return ListIndicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListQuerySuggestionsBlockListsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQuerySuggestionsBlockListsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQuerySuggestionsBlockListsOutputResponse`
extension KendraClient {
    public func listQuerySuggestionsBlockListsPaginated(input: ListQuerySuggestionsBlockListsInput) -> ClientRuntime.PaginatorSequence<ListQuerySuggestionsBlockListsInput, ListQuerySuggestionsBlockListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQuerySuggestionsBlockListsInput, ListQuerySuggestionsBlockListsOutputResponse>(input: input, inputKey: \ListQuerySuggestionsBlockListsInput.nextToken, outputKey: \ListQuerySuggestionsBlockListsOutputResponse.nextToken, paginationFunction: self.listQuerySuggestionsBlockLists(input:))
    }
}

extension ListQuerySuggestionsBlockListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQuerySuggestionsBlockListsInput {
        return ListQuerySuggestionsBlockListsInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListThesauriOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThesauriInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThesauriOutputResponse`
extension KendraClient {
    public func listThesauriPaginated(input: ListThesauriInput) -> ClientRuntime.PaginatorSequence<ListThesauriInput, ListThesauriOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThesauriInput, ListThesauriOutputResponse>(input: input, inputKey: \ListThesauriInput.nextToken, outputKey: \ListThesauriOutputResponse.nextToken, paginationFunction: self.listThesauri(input:))
    }
}

extension ListThesauriInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThesauriInput {
        return ListThesauriInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
