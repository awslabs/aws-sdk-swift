// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MarketplaceAgreementClientTypes.AcceptedTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byolpricingterm = "byolPricingTerm"
        case configurableupfrontpricingterm = "configurableUpfrontPricingTerm"
        case fixedupfrontpricingterm = "fixedUpfrontPricingTerm"
        case freetrialpricingterm = "freeTrialPricingTerm"
        case legalterm = "legalTerm"
        case paymentscheduleterm = "paymentScheduleTerm"
        case recurringpaymentterm = "recurringPaymentTerm"
        case renewalterm = "renewalTerm"
        case sdkUnknown
        case supportterm = "supportTerm"
        case usagebasedpricingterm = "usageBasedPricingTerm"
        case validityterm = "validityTerm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .byolpricingterm(byolpricingterm):
                try container.encode(byolpricingterm, forKey: .byolpricingterm)
            case let .configurableupfrontpricingterm(configurableupfrontpricingterm):
                try container.encode(configurableupfrontpricingterm, forKey: .configurableupfrontpricingterm)
            case let .fixedupfrontpricingterm(fixedupfrontpricingterm):
                try container.encode(fixedupfrontpricingterm, forKey: .fixedupfrontpricingterm)
            case let .freetrialpricingterm(freetrialpricingterm):
                try container.encode(freetrialpricingterm, forKey: .freetrialpricingterm)
            case let .legalterm(legalterm):
                try container.encode(legalterm, forKey: .legalterm)
            case let .paymentscheduleterm(paymentscheduleterm):
                try container.encode(paymentscheduleterm, forKey: .paymentscheduleterm)
            case let .recurringpaymentterm(recurringpaymentterm):
                try container.encode(recurringpaymentterm, forKey: .recurringpaymentterm)
            case let .renewalterm(renewalterm):
                try container.encode(renewalterm, forKey: .renewalterm)
            case let .supportterm(supportterm):
                try container.encode(supportterm, forKey: .supportterm)
            case let .usagebasedpricingterm(usagebasedpricingterm):
                try container.encode(usagebasedpricingterm, forKey: .usagebasedpricingterm)
            case let .validityterm(validityterm):
                try container.encode(validityterm, forKey: .validityterm)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let legaltermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.LegalTerm.self, forKey: .legalterm)
        if let legalterm = legaltermDecoded {
            self = .legalterm(legalterm)
            return
        }
        let supporttermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.SupportTerm.self, forKey: .supportterm)
        if let supportterm = supporttermDecoded {
            self = .supportterm(supportterm)
            return
        }
        let renewaltermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.RenewalTerm.self, forKey: .renewalterm)
        if let renewalterm = renewaltermDecoded {
            self = .renewalterm(renewalterm)
            return
        }
        let usagebasedpricingtermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.UsageBasedPricingTerm.self, forKey: .usagebasedpricingterm)
        if let usagebasedpricingterm = usagebasedpricingtermDecoded {
            self = .usagebasedpricingterm(usagebasedpricingterm)
            return
        }
        let configurableupfrontpricingtermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTerm.self, forKey: .configurableupfrontpricingterm)
        if let configurableupfrontpricingterm = configurableupfrontpricingtermDecoded {
            self = .configurableupfrontpricingterm(configurableupfrontpricingterm)
            return
        }
        let byolpricingtermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.ByolPricingTerm.self, forKey: .byolpricingterm)
        if let byolpricingterm = byolpricingtermDecoded {
            self = .byolpricingterm(byolpricingterm)
            return
        }
        let recurringpaymenttermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.RecurringPaymentTerm.self, forKey: .recurringpaymentterm)
        if let recurringpaymentterm = recurringpaymenttermDecoded {
            self = .recurringpaymentterm(recurringpaymentterm)
            return
        }
        let validitytermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.ValidityTerm.self, forKey: .validityterm)
        if let validityterm = validitytermDecoded {
            self = .validityterm(validityterm)
            return
        }
        let paymentscheduletermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.PaymentScheduleTerm.self, forKey: .paymentscheduleterm)
        if let paymentscheduleterm = paymentscheduletermDecoded {
            self = .paymentscheduleterm(paymentscheduleterm)
            return
        }
        let freetrialpricingtermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.FreeTrialPricingTerm.self, forKey: .freetrialpricingterm)
        if let freetrialpricingterm = freetrialpricingtermDecoded {
            self = .freetrialpricingterm(freetrialpricingterm)
            return
        }
        let fixedupfrontpricingtermDecoded = try values.decodeIfPresent(MarketplaceAgreementClientTypes.FixedUpfrontPricingTerm.self, forKey: .fixedupfrontpricingterm)
        if let fixedupfrontpricingterm = fixedupfrontpricingtermDecoded {
            self = .fixedupfrontpricingterm(fixedupfrontpricingterm)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MarketplaceAgreementClientTypes {
    /// A subset of terms proposed by the proposer, which have been accepted by the acceptor as part of agreement creation.
    public enum AcceptedTerm: Swift.Equatable {
        /// Defines the list of text agreements proposed to the acceptors. An example is the end user license agreement (EULA).
        case legalterm(MarketplaceAgreementClientTypes.LegalTerm)
        /// Defines the customer support available for the acceptors when they purchase the software.
        case supportterm(MarketplaceAgreementClientTypes.SupportTerm)
        /// Defines that on graceful expiration of the agreement (when the agreement ends on its pre-defined end date), a new agreement will be created using the accepted terms on the existing agreement. In other words, the agreement will be renewed. Presence of RenewalTerm in the offer document means that auto-renewal is allowed. Buyers will have the option to accept or decline auto-renewal at the offer acceptance/agreement creation. Buyers can also change this flag from True to False or False to True at anytime during the agreement's lifecycle.
        case renewalterm(MarketplaceAgreementClientTypes.RenewalTerm)
        /// Defines a usage-based pricing model (typically, pay-as-you-go pricing), where the customers are charged based on product usage.
        case usagebasedpricingterm(MarketplaceAgreementClientTypes.UsageBasedPricingTerm)
        /// Defines a prepaid payment model that allows buyers to configure the entitlements they want to purchase and the duration.
        case configurableupfrontpricingterm(MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTerm)
        /// Enables you and your customers to move your existing agreements to AWS Marketplace. The customer won't be charged for product usage in AWS Marketplace because they already paid for the product outside of AWS Marketplace.
        case byolpricingterm(MarketplaceAgreementClientTypes.ByolPricingTerm)
        /// Defines a pricing model where customers are charged a fixed recurring price at the end of each billing period.
        case recurringpaymentterm(MarketplaceAgreementClientTypes.RecurringPaymentTerm)
        /// Defines the conditions that will keep an agreement created from this offer valid.
        case validityterm(MarketplaceAgreementClientTypes.ValidityTerm)
        /// Defines an installment-based pricing model where customers are charged a fixed price on different dates during the agreement validity period. This is used most commonly for flexible payment schedule pricing.
        case paymentscheduleterm(MarketplaceAgreementClientTypes.PaymentScheduleTerm)
        /// Defines a short-term free pricing model where the buyers aren’t charged anything within a specified limit.
        case freetrialpricingterm(MarketplaceAgreementClientTypes.FreeTrialPricingTerm)
        /// Defines a pre-paid pricing model where the customers are charged a fixed upfront amount.
        case fixedupfrontpricingterm(MarketplaceAgreementClientTypes.FixedUpfrontPricingTerm)
        case sdkUnknown(Swift.String)
    }

}

extension MarketplaceAgreementClientTypes.Acceptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// The details of the party accepting the agreement terms. This is commonly the buyer for PurchaseAgreement.
    public struct Acceptor: Swift.Equatable {
        /// The AWS account ID of the acceptor.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the error.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let requestId: Swift.String?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    public enum AgreementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case cancelled
        case expired
        case renewed
        case replaced
        case rolledBack
        case superseded
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [AgreementStatus] {
            return [
                .active,
                .archived,
                .cancelled,
                .expired,
                .renewed,
                .replaced,
                .rolledBack,
                .superseded,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .cancelled: return "CANCELLED"
            case .expired: return "EXPIRED"
            case .renewed: return "RENEWED"
            case .replaced: return "REPLACED"
            case .rolledBack: return "ROLLED_BACK"
            case .superseded: return "SUPERSEDED"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgreementStatus(rawValue: rawValue) ?? AgreementStatus.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceAgreementClientTypes.AgreementViewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceTime
        case acceptor
        case agreementId
        case agreementType
        case endTime
        case proposalSummary
        case proposer
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptanceTime = self.acceptanceTime {
            try encodeContainer.encodeTimestamp(acceptanceTime, format: .epochSeconds, forKey: .acceptanceTime)
        }
        if let acceptor = self.acceptor {
            try encodeContainer.encode(acceptor, forKey: .acceptor)
        }
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let agreementType = self.agreementType {
            try encodeContainer.encode(agreementType, forKey: .agreementType)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let proposalSummary = self.proposalSummary {
            try encodeContainer.encode(proposalSummary, forKey: .proposalSummary)
        }
        if let proposer = self.proposer {
            try encodeContainer.encode(proposer, forKey: .proposer)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let acceptanceTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .acceptanceTime)
        acceptanceTime = acceptanceTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let agreementTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementType)
        agreementType = agreementTypeDecoded
        let acceptorDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Acceptor.self, forKey: .acceptor)
        acceptor = acceptorDecoded
        let proposerDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Proposer.self, forKey: .proposer)
        proposer = proposerDecoded
        let proposalSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.ProposalSummary.self, forKey: .proposalSummary)
        proposalSummary = proposalSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.AgreementStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// A summary of the agreement, including top-level attributes (for example, the agreement ID, version, proposer, and acceptor).
    public struct AgreementViewSummary: Swift.Equatable {
        /// The date and time that the agreement was accepted.
        public var acceptanceTime: ClientRuntime.Date?
        /// Details of the party accepting the agreement terms. This is commonly the buyer for PurchaseAgreement.
        public var acceptor: MarketplaceAgreementClientTypes.Acceptor?
        /// The unique identifier of the agreement.
        public var agreementId: Swift.String?
        /// The type of agreement. Values are PurchaseAgreement or VendorInsightsAgreement.
        public var agreementType: Swift.String?
        /// The date and time when the agreement ends. The field is null for pay-as-you-go agreements, which don’t have end dates.
        public var endTime: ClientRuntime.Date?
        /// A summary of the proposal
        public var proposalSummary: MarketplaceAgreementClientTypes.ProposalSummary?
        /// Details of the party proposing the agreement terms, most commonly the seller for PurchaseAgreement.
        public var proposer: MarketplaceAgreementClientTypes.Proposer?
        /// The date and time when the agreement starts.
        public var startTime: ClientRuntime.Date?
        /// The current status of the agreement.
        public var status: MarketplaceAgreementClientTypes.AgreementStatus?

        public init(
            acceptanceTime: ClientRuntime.Date? = nil,
            acceptor: MarketplaceAgreementClientTypes.Acceptor? = nil,
            agreementId: Swift.String? = nil,
            agreementType: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            proposalSummary: MarketplaceAgreementClientTypes.ProposalSummary? = nil,
            proposer: MarketplaceAgreementClientTypes.Proposer? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MarketplaceAgreementClientTypes.AgreementStatus? = nil
        )
        {
            self.acceptanceTime = acceptanceTime
            self.acceptor = acceptor
            self.agreementId = agreementId
            self.agreementType = agreementType
            self.endTime = endTime
            self.proposalSummary = proposalSummary
            self.proposer = proposer
            self.startTime = startTime
            self.status = status
        }
    }

}

extension MarketplaceAgreementClientTypes.ByolPricingTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Enables you and your customers to move your existing agreements to AWS Marketplace. The customer won't be charged for product usage in AWS Marketplace because they already paid for the product outside of AWS Marketplace.
    public struct ByolPricingTerm: Swift.Equatable {
        /// Type of the term being updated.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case currencyCode
        case rateCards
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let rateCards = rateCards {
            var rateCardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rateCards)
            for configurableupfrontratecarditem0 in rateCards {
                try rateCardsContainer.encode(configurableupfrontratecarditem0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let rateCardsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.ConfigurableUpfrontRateCardItem?].self, forKey: .rateCards)
        var rateCardsDecoded0:[MarketplaceAgreementClientTypes.ConfigurableUpfrontRateCardItem]? = nil
        if let rateCardsContainer = rateCardsContainer {
            rateCardsDecoded0 = [MarketplaceAgreementClientTypes.ConfigurableUpfrontRateCardItem]()
            for structure0 in rateCardsContainer {
                if let structure0 = structure0 {
                    rateCardsDecoded0?.append(structure0)
                }
            }
        }
        rateCards = rateCardsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTermConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines a prepaid payment model that allows buyers to configure the entitlements they want to purchase and the duration.
    public struct ConfigurableUpfrontPricingTerm: Swift.Equatable {
        /// Additional parameters specified by the acceptor while accepting the term.
        public var configuration: MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTermConfiguration?
        /// Defines the currency for the prices mentioned in the term.
        public var currencyCode: Swift.String?
        /// A rate card defines the per unit rates for product dimensions.
        public var rateCards: [MarketplaceAgreementClientTypes.ConfigurableUpfrontRateCardItem]?
        /// Category of selector.
        public var type: Swift.String?

        public init(
            configuration: MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTermConfiguration? = nil,
            currencyCode: Swift.String? = nil,
            rateCards: [MarketplaceAgreementClientTypes.ConfigurableUpfrontRateCardItem]? = nil,
            type: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.currencyCode = currencyCode
            self.rateCards = rateCards
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.ConfigurableUpfrontPricingTermConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions
        case selectorValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimension0 in dimensions {
                try dimensionsContainer.encode(dimension0)
            }
        }
        if let selectorValue = self.selectorValue {
            try encodeContainer.encode(selectorValue, forKey: .selectorValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectorValue)
        selectorValue = selectorValueDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[MarketplaceAgreementClientTypes.Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [MarketplaceAgreementClientTypes.Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines a prepaid payment model that allows buyers to configure the entitlements they want to purchase and the duration.
    public struct ConfigurableUpfrontPricingTermConfiguration: Swift.Equatable {
        /// Defines the dimensions that the acceptor has purchased from the overall set of dimensions presented in the rate card.
        /// This member is required.
        public var dimensions: [MarketplaceAgreementClientTypes.Dimension]?
        /// Defines the length of time for which the particular pricing/dimension is being purchased by the acceptor.
        /// This member is required.
        public var selectorValue: Swift.String?

        public init(
            dimensions: [MarketplaceAgreementClientTypes.Dimension]? = nil,
            selectorValue: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.selectorValue = selectorValue
        }
    }

}

extension MarketplaceAgreementClientTypes.ConfigurableUpfrontRateCardItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraints
        case rateCard
        case selector
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = self.constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let rateCard = rateCard {
            var rateCardContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rateCard)
            for ratecarditem0 in rateCard {
                try rateCardContainer.encode(ratecarditem0)
            }
        }
        if let selector = self.selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Selector.self, forKey: .selector)
        selector = selectorDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Constraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let rateCardContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.RateCardItem?].self, forKey: .rateCard)
        var rateCardDecoded0:[MarketplaceAgreementClientTypes.RateCardItem]? = nil
        if let rateCardContainer = rateCardContainer {
            rateCardDecoded0 = [MarketplaceAgreementClientTypes.RateCardItem]()
            for structure0 in rateCardContainer {
                if let structure0 = structure0 {
                    rateCardDecoded0?.append(structure0)
                }
            }
        }
        rateCard = rateCardDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Within the prepaid payment model defined under ConfigurableUpfrontPricingTerm, the RateCardItem defines all the various rate cards (including pricing and dimensions) that have been proposed.
    public struct ConfigurableUpfrontRateCardItem: Swift.Equatable {
        /// Defines limits on how the term can be configured by acceptors.
        public var constraints: MarketplaceAgreementClientTypes.Constraints?
        /// Defines the per unit rates for product dimensions.
        public var rateCard: [MarketplaceAgreementClientTypes.RateCardItem]?
        /// Differentiates between the mutually exclusive rate cards in the same pricing term to be selected by the buyer.
        public var selector: MarketplaceAgreementClientTypes.Selector?

        public init(
            constraints: MarketplaceAgreementClientTypes.Constraints? = nil,
            rateCard: [MarketplaceAgreementClientTypes.RateCardItem]? = nil,
            selector: MarketplaceAgreementClientTypes.Selector? = nil
        )
        {
            self.constraints = constraints
            self.rateCard = rateCard
            self.selector = selector
        }
    }

}

extension MarketplaceAgreementClientTypes.Constraints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multipleDimensionSelection
        case quantityConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multipleDimensionSelection = self.multipleDimensionSelection {
            try encodeContainer.encode(multipleDimensionSelection, forKey: .multipleDimensionSelection)
        }
        if let quantityConfiguration = self.quantityConfiguration {
            try encodeContainer.encode(quantityConfiguration, forKey: .quantityConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipleDimensionSelectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multipleDimensionSelection)
        multipleDimensionSelection = multipleDimensionSelectionDecoded
        let quantityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quantityConfiguration)
        quantityConfiguration = quantityConfigurationDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines limits on how the term can be configured by acceptors.
    public struct Constraints: Swift.Equatable {
        /// Determines if buyers are allowed to select multiple dimensions in the rate card. The possible values are Allowed and Disallowed. The default value is Allowed.
        public var multipleDimensionSelection: Swift.String?
        /// Determines if acceptors are allowed to configure quantity for each dimension in rate card. The possible values are Allowed and Disallowed. The default value is Allowed.
        public var quantityConfiguration: Swift.String?

        public init(
            multipleDimensionSelection: Swift.String? = nil,
            quantityConfiguration: Swift.String? = nil
        )
        {
            self.multipleDimensionSelection = multipleDimensionSelection
            self.quantityConfiguration = quantityConfiguration
        }
    }

}

extension DescribeAgreementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
    }
}

extension DescribeAgreementInput {

    static func urlPathProvider(_ value: DescribeAgreementInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeAgreementInput: Swift.Equatable {
    /// The unique identifier of the agreement.
    /// This member is required.
    public var agreementId: Swift.String?

    public init(
        agreementId: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
    }
}

struct DescribeAgreementInputBody: Swift.Equatable {
    let agreementId: Swift.String?
}

extension DescribeAgreementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
    }
}

extension DescribeAgreementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAgreementOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceptanceTime = output.acceptanceTime
            self.acceptor = output.acceptor
            self.agreementId = output.agreementId
            self.agreementType = output.agreementType
            self.endTime = output.endTime
            self.estimatedCharges = output.estimatedCharges
            self.proposalSummary = output.proposalSummary
            self.proposer = output.proposer
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.acceptanceTime = nil
            self.acceptor = nil
            self.agreementId = nil
            self.agreementType = nil
            self.endTime = nil
            self.estimatedCharges = nil
            self.proposalSummary = nil
            self.proposer = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAgreementOutput: Swift.Equatable {
    /// The date and time the offer was accepted or the agreement was created. AcceptanceTime and StartTime can differ for future dated agreements (FDAs).
    public var acceptanceTime: ClientRuntime.Date?
    /// The details of the party accepting the agreement terms. This is commonly the buyer for PurchaseAgreement.
    public var acceptor: MarketplaceAgreementClientTypes.Acceptor?
    /// The unique identifier of the agreement.
    public var agreementId: Swift.String?
    /// The type of agreement. Values are PurchaseAgreement or VendorInsightsAgreement.
    public var agreementType: Swift.String?
    /// The date and time when the agreement ends. The field is null for pay-as-you-go agreements, which don’t have end dates.
    public var endTime: ClientRuntime.Date?
    /// The estimated cost of the agreement.
    public var estimatedCharges: MarketplaceAgreementClientTypes.EstimatedCharges?
    /// A summary of the proposal received from the proposer.
    public var proposalSummary: MarketplaceAgreementClientTypes.ProposalSummary?
    /// The details of the party proposing the agreement terms. This is commonly the seller for PurchaseAgreement.
    public var proposer: MarketplaceAgreementClientTypes.Proposer?
    /// The date and time when the agreement starts.
    public var startTime: ClientRuntime.Date?
    /// The current status of the agreement. Statuses include:
    ///
    /// * ACTIVE – The terms of the agreement are active.
    ///
    /// * ARCHIVED – The agreement ended without a specified reason.
    ///
    /// * CANCELLED – The acceptor ended the agreement before the defined end date.
    ///
    /// * EXPIRED – The agreement ended on the defined end date.
    ///
    /// * RENEWED – The agreement was renewed into a new agreement (for example, an auto-renewal).
    ///
    /// * REPLACED – The agreement was replaced using an agreement replacement offer.
    ///
    /// * ROLLED_BACK (Only applicable to inactive agreement revisions) – The agreement revision has been rolled back because of an error. An earlier revision is now active.
    ///
    /// * SUPERCEDED (Only applicable to inactive agreement revisions) – The agreement revision is no longer active and another agreement revision is now active.
    ///
    /// * TERMINATED – The agreement ended before the defined end date because of an AWS termination (for example, a payment failure).
    public var status: MarketplaceAgreementClientTypes.AgreementStatus?

    public init(
        acceptanceTime: ClientRuntime.Date? = nil,
        acceptor: MarketplaceAgreementClientTypes.Acceptor? = nil,
        agreementId: Swift.String? = nil,
        agreementType: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        estimatedCharges: MarketplaceAgreementClientTypes.EstimatedCharges? = nil,
        proposalSummary: MarketplaceAgreementClientTypes.ProposalSummary? = nil,
        proposer: MarketplaceAgreementClientTypes.Proposer? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: MarketplaceAgreementClientTypes.AgreementStatus? = nil
    )
    {
        self.acceptanceTime = acceptanceTime
        self.acceptor = acceptor
        self.agreementId = agreementId
        self.agreementType = agreementType
        self.endTime = endTime
        self.estimatedCharges = estimatedCharges
        self.proposalSummary = proposalSummary
        self.proposer = proposer
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeAgreementOutputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let acceptor: MarketplaceAgreementClientTypes.Acceptor?
    let proposer: MarketplaceAgreementClientTypes.Proposer?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let acceptanceTime: ClientRuntime.Date?
    let agreementType: Swift.String?
    let estimatedCharges: MarketplaceAgreementClientTypes.EstimatedCharges?
    let proposalSummary: MarketplaceAgreementClientTypes.ProposalSummary?
    let status: MarketplaceAgreementClientTypes.AgreementStatus?
}

extension DescribeAgreementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceTime
        case acceptor
        case agreementId
        case agreementType
        case endTime
        case estimatedCharges
        case proposalSummary
        case proposer
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let acceptorDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Acceptor.self, forKey: .acceptor)
        acceptor = acceptorDecoded
        let proposerDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Proposer.self, forKey: .proposer)
        proposer = proposerDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let acceptanceTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .acceptanceTime)
        acceptanceTime = acceptanceTimeDecoded
        let agreementTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementType)
        agreementType = agreementTypeDecoded
        let estimatedChargesDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.EstimatedCharges.self, forKey: .estimatedCharges)
        estimatedCharges = estimatedChargesDecoded
        let proposalSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.ProposalSummary.self, forKey: .proposalSummary)
        proposalSummary = proposalSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.AgreementStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeAgreementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceAgreementClientTypes.Dimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionKey
        case dimensionValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionKey = self.dimensionKey {
            try encodeContainer.encode(dimensionKey, forKey: .dimensionKey)
        }
        if dimensionValue != 0 {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionKey)
        dimensionKey = dimensionKeyDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dimensionValue) ?? 0
        dimensionValue = dimensionValueDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines the dimensions that the acceptor has purchased from the overall set of dimensions presented in the rate card.
    public struct Dimension: Swift.Equatable {
        /// The name of key value of the dimension.
        /// This member is required.
        public var dimensionKey: Swift.String?
        /// The number of units of the dimension the acceptor has purchased. For Agreements with ConfigurableUpfrontPricingTerm, the RateCard section will define the prices and dimensions defined by the seller (proposer), whereas the Configuration section will define the actual dimensions, prices, and units the buyer has chosen to accept.
        /// This member is required.
        public var dimensionValue: Swift.Int

        public init(
            dimensionKey: Swift.String? = nil,
            dimensionValue: Swift.Int = 0
        )
        {
            self.dimensionKey = dimensionKey
            self.dimensionValue = dimensionValue
        }
    }

}

extension MarketplaceAgreementClientTypes.DocumentItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case url
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Includes the list of references to legal resources proposed by the proposer to the acceptor. Each DocumentItem refers to an individual reference.
    public struct DocumentItem: Swift.Equatable {
        /// Category of the document. Document types include:
        ///
        /// * CustomEula – A custom EULA provided by you as seller. A URL for a EULA stored in an accessible Amazon S3 bucket is required for this document type.
        ///
        /// * CustomDsa – A custom Data Subscription Agreement (DSA) provided by you as seller. A URL for a DSA stored in an accessible Amazon S3 bucket is required for this document type.
        ///
        /// * StandardEula – The Standard Contract for AWS Marketplace (SCMP). For more information about SCMP, see the AWS Marketplace Seller Guide. You don’t provide a URL for this type because it’s managed by AWS Marketplace.
        ///
        /// * StandardDsa – DSA for AWS Marketplace. For more information about the DSA, see the AWS Data Exchange User Guide. You don’t provide a URL for this type because it’s managed by AWS Marketplace.
        public var type: Swift.String?
        /// A URL to the legal document for buyers to read. Required when Type is CustomEula.
        public var url: Swift.String?
        /// Version of standard contracts provided by AWS Marketplace. Required when Type is StandardEula or StandardDsa.
        public var version: Swift.String?

        public init(
            type: Swift.String? = nil,
            url: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.type = type
            self.url = url
            self.version = version
        }
    }

}

extension MarketplaceAgreementClientTypes.EstimatedCharges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementValue
        case currencyCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementValue = self.agreementValue {
            try encodeContainer.encode(agreementValue, forKey: .agreementValue)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let agreementValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementValue)
        agreementValue = agreementValueDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Estimated cost of the agreement.
    public struct EstimatedCharges: Swift.Equatable {
        /// The total known amount customer has to pay across the lifecycle of the agreement. This is the total contract value if accepted terms contain ConfigurableUpfrontPricingTerm or FixedUpfrontPricingTerm. In the case of pure contract pricing, this will be the total value of the contract. In the case of contracts with consumption pricing, this will only include the committed value and not include any overages that occur. If the accepted terms contain PaymentScheduleTerm, it will be the total payment schedule amount. This occurs when flexible payment schedule is used, and is the sum of all invoice charges in the payment schedule. In case a customer has amended an agreement, by purchasing more units of any dimension, this will include both the original cost as well as the added cost incurred due to addition of new units. This is 0 if the accepted terms contain UsageBasedPricingTerm without ConfigurableUpfrontPricingTerm or RecurringPaymentTerm. This occurs for usage-based pricing (such as SaaS metered or AMI/container hourly or monthly), because the exact usage is not known upfront.
        public var agreementValue: Swift.String?
        /// Defines the currency code for the charge.
        public var currencyCode: Swift.String?

        public init(
            agreementValue: Swift.String? = nil,
            currencyCode: Swift.String? = nil
        )
        {
            self.agreementValue = agreementValue
            self.currencyCode = currencyCode
        }
    }

}

extension MarketplaceAgreementClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// The filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria, such as offerId or productId.
    public struct Filter: Swift.Equatable {
        /// The name of the filter.
        public var name: Swift.String?
        /// The filter value.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension MarketplaceAgreementClientTypes.FixedUpfrontPricingTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode
        case duration
        case grants
        case price
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let grants = grants {
            var grantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grants)
            for grantitem0 in grants {
                try grantsContainer.encode(grantitem0)
            }
        }
        if let price = self.price {
            try encodeContainer.encode(price, forKey: .price)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let priceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .price)
        price = priceDecoded
        let grantsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.GrantItem?].self, forKey: .grants)
        var grantsDecoded0:[MarketplaceAgreementClientTypes.GrantItem]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [MarketplaceAgreementClientTypes.GrantItem]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines a prepaid pricing model where the customers are charged a fixed upfront amount.
    public struct FixedUpfrontPricingTerm: Swift.Equatable {
        /// Defines the currency for the prices mentioned in this term.
        public var currencyCode: Swift.String?
        /// Contract duration for the terms.
        public var duration: Swift.String?
        /// Entitlements granted to the acceptor of fixed upfront as part of agreement execution.
        public var grants: [MarketplaceAgreementClientTypes.GrantItem]?
        /// Fixed amount to be charged to the customer when this term is accepted.
        public var price: Swift.String?
        /// Category of the term being updated.
        public var type: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.String? = nil,
            grants: [MarketplaceAgreementClientTypes.GrantItem]? = nil,
            price: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.grants = grants
            self.price = price
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.FreeTrialPricingTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration
        case grants
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let grants = grants {
            var grantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grants)
            for grantitem0 in grants {
                try grantsContainer.encode(grantitem0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
        let grantsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.GrantItem?].self, forKey: .grants)
        var grantsDecoded0:[MarketplaceAgreementClientTypes.GrantItem]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [MarketplaceAgreementClientTypes.GrantItem]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines a short-term free pricing model where the buyers aren’t charged anything within a specified limit.
    public struct FreeTrialPricingTerm: Swift.Equatable {
        /// Duration of the free trial period (5–31 days).
        public var duration: Swift.String?
        /// Entitlements granted to the acceptor of a free trial as part of an agreement execution.
        public var grants: [MarketplaceAgreementClientTypes.GrantItem]?
        /// Category of the term.
        public var type: Swift.String?

        public init(
            duration: Swift.String? = nil,
            grants: [MarketplaceAgreementClientTypes.GrantItem]? = nil,
            type: Swift.String? = nil
        )
        {
            self.duration = duration
            self.grants = grants
            self.type = type
        }
    }

}

extension GetAgreementTermsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementId = self.agreementId {
            try encodeContainer.encode(agreementId, forKey: .agreementId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetAgreementTermsInput {

    static func urlPathProvider(_ value: GetAgreementTermsInput) -> Swift.String? {
        return "/"
    }
}

public struct GetAgreementTermsInput: Swift.Equatable {
    /// The unique identifier of the agreement.
    /// This member is required.
    public var agreementId: Swift.String?
    /// The maximum number of agreements to return in the response.
    public var maxResults: Swift.Int?
    /// A token to specify where to start pagination
    public var nextToken: Swift.String?

    public init(
        agreementId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agreementId = agreementId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetAgreementTermsInputBody: Swift.Equatable {
    let agreementId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetAgreementTermsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementId)
        agreementId = agreementIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAgreementTermsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgreementTermsOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceptedTerms = output.acceptedTerms
            self.nextToken = output.nextToken
        } else {
            self.acceptedTerms = nil
            self.nextToken = nil
        }
    }
}

public struct GetAgreementTermsOutput: Swift.Equatable {
    /// A subset of terms proposed by the proposer that have been accepted by the acceptor as part of the agreement creation.
    public var acceptedTerms: [MarketplaceAgreementClientTypes.AcceptedTerm]?
    /// A token to specify where to start pagination
    public var nextToken: Swift.String?

    public init(
        acceptedTerms: [MarketplaceAgreementClientTypes.AcceptedTerm]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceptedTerms = acceptedTerms
        self.nextToken = nextToken
    }
}

struct GetAgreementTermsOutputBody: Swift.Equatable {
    let acceptedTerms: [MarketplaceAgreementClientTypes.AcceptedTerm]?
    let nextToken: Swift.String?
}

extension GetAgreementTermsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedTerms
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedTermsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.AcceptedTerm?].self, forKey: .acceptedTerms)
        var acceptedTermsDecoded0:[MarketplaceAgreementClientTypes.AcceptedTerm]? = nil
        if let acceptedTermsContainer = acceptedTermsContainer {
            acceptedTermsDecoded0 = [MarketplaceAgreementClientTypes.AcceptedTerm]()
            for union0 in acceptedTermsContainer {
                if let union0 = union0 {
                    acceptedTermsDecoded0?.append(union0)
                }
            }
        }
        acceptedTerms = acceptedTermsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetAgreementTermsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceAgreementClientTypes.GrantItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionKey
        case maxQuantity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionKey = self.dimensionKey {
            try encodeContainer.encode(dimensionKey, forKey: .dimensionKey)
        }
        if let maxQuantity = self.maxQuantity {
            try encodeContainer.encode(maxQuantity, forKey: .maxQuantity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionKey)
        dimensionKey = dimensionKeyDecoded
        let maxQuantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxQuantity)
        maxQuantity = maxQuantityDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Entitlements granted to the acceptor of fixed upfront as part of agreement execution.
    public struct GrantItem: Swift.Equatable {
        /// Unique dimension key defined in the product document. Dimensions represent categories of capacity in a product and are specified when the product is listed in AWS Marketplace.
        public var dimensionKey: Swift.String?
        /// Maximum amount of capacity that the buyer can be entitled to the given dimension of the product. If MaxQuantity is not provided, the buyer will be able to use an unlimited amount of the given dimension.
        public var maxQuantity: Swift.Int?

        public init(
            dimensionKey: Swift.String? = nil,
            maxQuantity: Swift.Int? = nil
        )
        {
            self.dimensionKey = dimensionKey
            self.maxQuantity = maxQuantity
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the error.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let requestId: Swift.String?
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceAgreementClientTypes.LegalTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documents = documents {
            var documentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documents)
            for documentitem0 in documents {
                try documentsContainer.encode(documentitem0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let documentsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.DocumentItem?].self, forKey: .documents)
        var documentsDecoded0:[MarketplaceAgreementClientTypes.DocumentItem]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [MarketplaceAgreementClientTypes.DocumentItem]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines the list of text agreements proposed to the acceptors. An example is the end user license agreement (EULA).
    public struct LegalTerm: Swift.Equatable {
        /// List of references to legal resources proposed to the buyers. An example is the EULA.
        public var documents: [MarketplaceAgreementClientTypes.DocumentItem]?
        /// Category of the term being updated.
        public var type: Swift.String?

        public init(
            documents: [MarketplaceAgreementClientTypes.DocumentItem]? = nil,
            type: Swift.String? = nil
        )
        {
            self.documents = documents
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.PaymentScheduleTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode
        case schedule
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let schedule = schedule {
            var scheduleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schedule)
            for scheduleitem0 in schedule {
                try scheduleContainer.encode(scheduleitem0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let scheduleContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.ScheduleItem?].self, forKey: .schedule)
        var scheduleDecoded0:[MarketplaceAgreementClientTypes.ScheduleItem]? = nil
        if let scheduleContainer = scheduleContainer {
            scheduleDecoded0 = [MarketplaceAgreementClientTypes.ScheduleItem]()
            for structure0 in scheduleContainer {
                if let structure0 = structure0 {
                    scheduleDecoded0?.append(structure0)
                }
            }
        }
        schedule = scheduleDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines an installment-based pricing model where customers are charged a fixed price on different dates during the agreement validity period. This is used most commonly for flexible payment schedule pricing.
    public struct PaymentScheduleTerm: Swift.Equatable {
        /// Defines the currency for the prices mentioned in the term.
        public var currencyCode: Swift.String?
        /// List of the payment schedule where each element defines one installment of payment. It contains the information necessary for calculating the price.
        public var schedule: [MarketplaceAgreementClientTypes.ScheduleItem]?
        /// Type of the term.
        public var type: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            schedule: [MarketplaceAgreementClientTypes.ScheduleItem]? = nil,
            type: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.schedule = schedule
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.ProposalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offerId
        case resources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offerId = self.offerId {
            try encodeContainer.encode(offerId, forKey: .offerId)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[MarketplaceAgreementClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [MarketplaceAgreementClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let offerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offerId)
        offerId = offerIdDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// A summary of the proposal received from the proposer.
    public struct ProposalSummary: Swift.Equatable {
        /// The unique identifier of the offer in AWS Marketplace.
        public var offerId: Swift.String?
        /// The list of resources involved in the agreement.
        public var resources: [MarketplaceAgreementClientTypes.Resource]?

        public init(
            offerId: Swift.String? = nil,
            resources: [MarketplaceAgreementClientTypes.Resource]? = nil
        )
        {
            self.offerId = offerId
            self.resources = resources
        }
    }

}

extension MarketplaceAgreementClientTypes.Proposer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Details of the party proposing the agreement terms,. This is commonly the seller for PurchaseAgreement.
    public struct Proposer: Swift.Equatable {
        /// The AWS account ID of the proposer.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension MarketplaceAgreementClientTypes.RateCardItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionKey
        case price
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionKey = self.dimensionKey {
            try encodeContainer.encode(dimensionKey, forKey: .dimensionKey)
        }
        if let price = self.price {
            try encodeContainer.encode(price, forKey: .price)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionKey)
        dimensionKey = dimensionKeyDecoded
        let priceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .price)
        price = priceDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines the per unit rates for each individual product dimension.
    public struct RateCardItem: Swift.Equatable {
        /// Dimension for which the given entitlement applies. Dimensions represent categories of capacity in a product and are specified when the product is listed in AWS Marketplace.
        public var dimensionKey: Swift.String?
        /// Per unit price for the product dimension that’s used for calculating the amount to be charged.
        public var price: Swift.String?

        public init(
            dimensionKey: Swift.String? = nil,
            price: Swift.String? = nil
        )
        {
            self.dimensionKey = dimensionKey
            self.price = price
        }
    }

}

extension MarketplaceAgreementClientTypes.RecurringPaymentTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod
        case currencyCode
        case price
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let price = self.price {
            try encodeContainer.encode(price, forKey: .price)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let priceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .price)
        price = priceDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines a pricing model where customers are charged a fixed recurring price at the end of each billing period.
    public struct RecurringPaymentTerm: Swift.Equatable {
        /// Defines the recurrence at which buyers are charged.
        public var billingPeriod: Swift.String?
        /// Defines the currency for the prices mentioned in this term.
        public var currencyCode: Swift.String?
        /// Amount charged to the buyer every billing period.
        public var price: Swift.String?
        /// Type of the term being updated.
        public var type: Swift.String?

        public init(
            billingPeriod: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            price: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.billingPeriod = billingPeriod
            self.currencyCode = currencyCode
            self.price = price
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.RenewalTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.RenewalTermConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines that on graceful expiration of the agreement (when the agreement ends on its pre-defined end date), a new agreement will be created using the accepted terms on the existing agreement. In other words, the agreement will be renewed. The presence of RenewalTerm in the offer document means that auto-renewal is allowed. Buyers will have the option to accept or decline auto-renewal at the offer acceptance/agreement creation. Buyers can also change this flag from True to False or False to True at anytime during the agreement's lifecycle.
    public struct RenewalTerm: Swift.Equatable {
        /// Additional parameters specified by the acceptor while accepting the term.
        public var configuration: MarketplaceAgreementClientTypes.RenewalTermConfiguration?
        /// Category of the term being updated.
        public var type: Swift.String?

        public init(
            configuration: MarketplaceAgreementClientTypes.RenewalTermConfiguration? = nil,
            type: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.RenewalTermConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableAutoRenew
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableAutoRenew = self.enableAutoRenew {
            try encodeContainer.encode(enableAutoRenew, forKey: .enableAutoRenew)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoRenew)
        enableAutoRenew = enableAutoRenewDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Additional parameters specified by the acceptor while accepting the term.
    public struct RenewalTermConfiguration: Swift.Equatable {
        /// Defines whether the acceptor has chosen to auto-renew the agreement at the end of its lifecycle. Can be set to True or False.
        /// This member is required.
        public var enableAutoRenew: Swift.Bool?

        public init(
            enableAutoRenew: Swift.Bool? = nil
        )
        {
            self.enableAutoRenew = enableAutoRenew
        }
    }

}

extension MarketplaceAgreementClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// The list of resources involved in the agreement.
    public struct Resource: Swift.Equatable {
        /// The unique identifier of the resource. We mention the term resource, which is most commonly a product, so a resourceId is also a productId.
        public var id: Swift.String?
        /// Type of the resource, which is the product. Values include SaaSProduct or AmiProduct.
        public var type: Swift.String?

        public init(
            id: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the error.
        public internal(set) var requestId: Swift.String? = nil
        /// The unique identifier for the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: MarketplaceAgreementClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: MarketplaceAgreementClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let requestId: Swift.String?
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: MarketplaceAgreementClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case requestId
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agreement
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .agreement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agreement: return "Agreement"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceAgreementClientTypes.ScheduleItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeAmount
        case chargeDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeAmount = self.chargeAmount {
            try encodeContainer.encode(chargeAmount, forKey: .chargeAmount)
        }
        if let chargeDate = self.chargeDate {
            try encodeContainer.encodeTimestamp(chargeDate, format: .epochSeconds, forKey: .chargeDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .chargeDate)
        chargeDate = chargeDateDecoded
        let chargeAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chargeAmount)
        chargeAmount = chargeAmountDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// An individual installment of the payment that includes the date and amount of the charge.
    public struct ScheduleItem: Swift.Equatable {
        /// The price that the customer would pay on the scheduled date (chargeDate).
        public var chargeAmount: Swift.String?
        /// The date that the customer would pay the price defined in this payment schedule term. Invoices are generated on the date provided.
        public var chargeDate: ClientRuntime.Date?

        public init(
            chargeAmount: Swift.String? = nil,
            chargeDate: ClientRuntime.Date? = nil
        )
        {
            self.chargeAmount = chargeAmount
            self.chargeDate = chargeDate
        }
    }

}

extension SearchAgreementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog
        case filters
        case maxResults
        case nextToken
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension SearchAgreementsInput {

    static func urlPathProvider(_ value: SearchAgreementsInput) -> Swift.String? {
        return "/"
    }
}

public struct SearchAgreementsInput: Swift.Equatable {
    /// The catalog in which the agreement was created.
    public var catalog: Swift.String?
    /// The filter name and value pair used to return a specific list of results. The following filters are supported:
    ///
    /// * ResourceIdentifier – The unique identifier of the resource.
    ///
    /// * ResourceType – Type of the resource, which is the product (AmiProduct, ContainerProduct, or SaaSProduct).
    ///
    /// * PartyType – The party type (either Acceptor or Proposer) of the caller. For agreements where the caller is the proposer, use the Proposer filter. For agreements where the caller is the acceptor, use the Acceptor filter.
    ///
    /// * AcceptorAccountId – The AWS account ID of the party accepting the agreement terms.
    ///
    /// * OfferId – The unique identifier of the offer in which the terms are registered in the agreement token.
    ///
    /// * Status – The current status of the agreement. Values include ACTIVE, ARCHIVED, CANCELLED, EXPIRED, RENEWED, REPLACED, and TERMINATED.
    ///
    /// * BeforeEndTime – A date used to filter agreements with a date before the endTime of an agreement.
    ///
    /// * AfterEndTime – A date used to filter agreements with a date after the endTime of an agreement.
    ///
    /// * AgreementType – The type of agreement. Values include PurchaseAgreement or VendorInsightsAgreement.
    public var filters: [MarketplaceAgreementClientTypes.Filter]?
    /// The maximum number of agreements to return in the response.
    public var maxResults: Swift.Int?
    /// A token to specify where to start pagination.
    public var nextToken: Swift.String?
    /// An object that contains the SortBy and SortOrder attributes.
    public var sort: MarketplaceAgreementClientTypes.Sort?

    public init(
        catalog: Swift.String? = nil,
        filters: [MarketplaceAgreementClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MarketplaceAgreementClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct SearchAgreementsInputBody: Swift.Equatable {
    let catalog: Swift.String?
    let filters: [MarketplaceAgreementClientTypes.Filter]?
    let sort: MarketplaceAgreementClientTypes.Sort?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension SearchAgreementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog
        case filters
        case maxResults
        case nextToken
        case sort
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[MarketplaceAgreementClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MarketplaceAgreementClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.Sort.self, forKey: .sort)
        sort = sortDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchAgreementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAgreementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agreementViewSummaries = output.agreementViewSummaries
            self.nextToken = output.nextToken
        } else {
            self.agreementViewSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAgreementsOutput: Swift.Equatable {
    /// A summary of the agreement, including top-level attributes (for example, the agreement ID, version, proposer, and acceptor).
    public var agreementViewSummaries: [MarketplaceAgreementClientTypes.AgreementViewSummary]?
    /// The token used for pagination. The field is null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        agreementViewSummaries: [MarketplaceAgreementClientTypes.AgreementViewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agreementViewSummaries = agreementViewSummaries
        self.nextToken = nextToken
    }
}

struct SearchAgreementsOutputBody: Swift.Equatable {
    let agreementViewSummaries: [MarketplaceAgreementClientTypes.AgreementViewSummary]?
    let nextToken: Swift.String?
}

extension SearchAgreementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementViewSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agreementViewSummariesContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.AgreementViewSummary?].self, forKey: .agreementViewSummaries)
        var agreementViewSummariesDecoded0:[MarketplaceAgreementClientTypes.AgreementViewSummary]? = nil
        if let agreementViewSummariesContainer = agreementViewSummariesContainer {
            agreementViewSummariesDecoded0 = [MarketplaceAgreementClientTypes.AgreementViewSummary]()
            for structure0 in agreementViewSummariesContainer {
                if let structure0 = structure0 {
                    agreementViewSummariesDecoded0?.append(structure0)
                }
            }
        }
        agreementViewSummaries = agreementViewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchAgreementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceAgreementClientTypes.Selector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Differentiates between the mutually exclusive rate cards in the same pricing term to be selected by the buyer.
    public struct Selector: Swift.Equatable {
        /// Category of selector.
        public var type: Swift.String?
        /// Contract duration. This field supports the ISO 8601 format.
        public var value: Swift.String?

        public init(
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension MarketplaceAgreementClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// An object that contains the SortBy and SortOrder attributes.
    public struct Sort: Swift.Equatable {
        /// The attribute on which the data is grouped, which can be by StartTime and EndTime. The default value is EndTime.
        public var sortBy: Swift.String?
        /// The sorting order, which can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceAgreementClientTypes.SortOrder?

        public init(
            sortBy: Swift.String? = nil,
            sortOrder: MarketplaceAgreementClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceAgreementClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceAgreementClientTypes.SupportTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refundPolicy
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let refundPolicy = self.refundPolicy {
            try encodeContainer.encode(refundPolicy, forKey: .refundPolicy)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let refundPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refundPolicy)
        refundPolicy = refundPolicyDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines the customer support available for the acceptors when they purchase the software.
    public struct SupportTerm: Swift.Equatable {
        /// Free-text field about the refund policy description that will be shown to customers as is on the website and console.
        public var refundPolicy: Swift.String?
        /// Category of the term being updated.
        public var type: Swift.String?

        public init(
            refundPolicy: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.refundPolicy = refundPolicy
            self.type = type
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the error.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let requestId: Swift.String?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceAgreementClientTypes.UsageBasedPricingTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode
        case rateCards
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let rateCards = rateCards {
            var rateCardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rateCards)
            for usagebasedratecarditem0 in rateCards {
                try rateCardsContainer.encode(usagebasedratecarditem0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let rateCardsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.UsageBasedRateCardItem?].self, forKey: .rateCards)
        var rateCardsDecoded0:[MarketplaceAgreementClientTypes.UsageBasedRateCardItem]? = nil
        if let rateCardsContainer = rateCardsContainer {
            rateCardsDecoded0 = [MarketplaceAgreementClientTypes.UsageBasedRateCardItem]()
            for structure0 in rateCardsContainer {
                if let structure0 = structure0 {
                    rateCardsDecoded0?.append(structure0)
                }
            }
        }
        rateCards = rateCardsDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines a usage-based pricing model (typically, pay-as-you-go pricing), where the customers are charged based on product usage.
    public struct UsageBasedPricingTerm: Swift.Equatable {
        /// Defines the currency for the prices mentioned in the term.
        public var currencyCode: Swift.String?
        /// List of rate cards.
        public var rateCards: [MarketplaceAgreementClientTypes.UsageBasedRateCardItem]?
        /// Category of the term.
        public var type: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            rateCards: [MarketplaceAgreementClientTypes.UsageBasedRateCardItem]? = nil,
            type: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.rateCards = rateCards
            self.type = type
        }
    }

}

extension MarketplaceAgreementClientTypes.UsageBasedRateCardItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rateCard
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rateCard = rateCard {
            var rateCardContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rateCard)
            for ratecarditem0 in rateCard {
                try rateCardContainer.encode(ratecarditem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rateCardContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.RateCardItem?].self, forKey: .rateCard)
        var rateCardDecoded0:[MarketplaceAgreementClientTypes.RateCardItem]? = nil
        if let rateCardContainer = rateCardContainer {
            rateCardDecoded0 = [MarketplaceAgreementClientTypes.RateCardItem]()
            for structure0 in rateCardContainer {
                if let structure0 = structure0 {
                    rateCardDecoded0?.append(structure0)
                }
            }
        }
        rateCard = rateCardDecoded0
    }
}

extension MarketplaceAgreementClientTypes {
    /// Within the pay-as-you-go model defined under UsageBasedPricingTerm, the UsageBasedRateCardItem defines an individual rate for a product dimension.
    public struct UsageBasedRateCardItem: Swift.Equatable {
        /// Defines the per unit rates for product dimensions.
        public var rateCard: [MarketplaceAgreementClientTypes.RateCardItem]?

        public init(
            rateCard: [MarketplaceAgreementClientTypes.RateCardItem]? = nil
        )
        {
            self.rateCard = rateCard
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.requestId = output.requestId
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by the service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields associated with the error.
        public internal(set) var fields: [MarketplaceAgreementClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason associated with the error.
        public internal(set) var reason: MarketplaceAgreementClientTypes.ValidationExceptionReason? = nil
        /// The unique identifier associated with the error.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [MarketplaceAgreementClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: MarketplaceAgreementClientTypes.ValidationExceptionReason? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
        self.properties.requestId = requestId
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let requestId: Swift.String?
    let message: Swift.String?
    let reason: MarketplaceAgreementClientTypes.ValidationExceptionReason?
    let fields: [MarketplaceAgreementClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
        case requestId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MarketplaceAgreementClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([MarketplaceAgreementClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[MarketplaceAgreementClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [MarketplaceAgreementClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension MarketplaceAgreementClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// The input fails to satisfy the constraints specified by the service.
    public struct ValidationExceptionField: Swift.Equatable {
        /// See applicable actions.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field associated with the error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension MarketplaceAgreementClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidAgreementId
        case invalidCatalog
        case invalidFilterName
        case invalidFilterValues
        case invalidMaxResults
        case invalidNextToken
        case invalidSortBy
        case invalidSortOrder
        case missingAgreementId
        case other
        case unsupportedFilters
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidAgreementId,
                .invalidCatalog,
                .invalidFilterName,
                .invalidFilterValues,
                .invalidMaxResults,
                .invalidNextToken,
                .invalidSortBy,
                .invalidSortOrder,
                .missingAgreementId,
                .other,
                .unsupportedFilters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidAgreementId: return "INVALID_AGREEMENT_ID"
            case .invalidCatalog: return "INVALID_CATALOG"
            case .invalidFilterName: return "INVALID_FILTER_NAME"
            case .invalidFilterValues: return "INVALID_FILTER_VALUES"
            case .invalidMaxResults: return "INVALID_MAX_RESULTS"
            case .invalidNextToken: return "INVALID_NEXT_TOKEN"
            case .invalidSortBy: return "INVALID_SORT_BY"
            case .invalidSortOrder: return "INVALID_SORT_ORDER"
            case .missingAgreementId: return "MISSING_AGREEMENT_ID"
            case .other: return "OTHER"
            case .unsupportedFilters: return "UNSUPPORTED_FILTERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceAgreementClientTypes.ValidityTerm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agreementDuration
        case agreementEndDate
        case agreementStartDate
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agreementDuration = self.agreementDuration {
            try encodeContainer.encode(agreementDuration, forKey: .agreementDuration)
        }
        if let agreementEndDate = self.agreementEndDate {
            try encodeContainer.encodeTimestamp(agreementEndDate, format: .epochSeconds, forKey: .agreementEndDate)
        }
        if let agreementStartDate = self.agreementStartDate {
            try encodeContainer.encodeTimestamp(agreementStartDate, format: .epochSeconds, forKey: .agreementStartDate)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let agreementDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agreementDuration)
        agreementDuration = agreementDurationDecoded
        let agreementStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .agreementStartDate)
        agreementStartDate = agreementStartDateDecoded
        let agreementEndDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .agreementEndDate)
        agreementEndDate = agreementEndDateDecoded
    }
}

extension MarketplaceAgreementClientTypes {
    /// Defines the conditions that will keep an agreement created from this offer valid.
    public struct ValidityTerm: Swift.Equatable {
        /// Defines the duration that the agreement remains active. If AgreementStartDate isn’t provided, the agreement duration is relative to the agreement signature time. The duration is represented in the ISO_8601 format.
        public var agreementDuration: Swift.String?
        /// Defines the date when the agreement ends. The agreement ends at 23:59:59.999 UTC on the date provided. If AgreementEndDate isn’t provided, the agreement end date is determined by the validity of individual terms.
        public var agreementEndDate: ClientRuntime.Date?
        /// Defines the date when agreement starts. The agreement starts at 00:00:00.000 UTC on the date provided. If AgreementStartDate isn’t provided, the agreement start date is determined based on agreement signature time.
        public var agreementStartDate: ClientRuntime.Date?
        /// Category of the term being updated.
        public var type: Swift.String?

        public init(
            agreementDuration: Swift.String? = nil,
            agreementEndDate: ClientRuntime.Date? = nil,
            agreementStartDate: ClientRuntime.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.agreementDuration = agreementDuration
            self.agreementEndDate = agreementEndDate
            self.agreementStartDate = agreementStartDate
            self.type = type
        }
    }

}
