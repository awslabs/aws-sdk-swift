// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised in case of an authentication or authorization failure.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelImportTaskInput {

    static func urlPathProvider(_ value: CancelImportTaskInput) -> Swift.String? {
        guard let taskIdentifier = value.taskIdentifier else {
            return nil
        }
        return "/importtasks/\(taskIdentifier.urlPercentEncoding())"
    }
}

public struct CancelImportTaskInput: Swift.Equatable {
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskIdentifier: Swift.String?

    public init(
        taskIdentifier: Swift.String? = nil
    )
    {
        self.taskIdentifier = taskIdentifier
    }
}

struct CancelImportTaskInputBody: Swift.Equatable {
}

extension CancelImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.graphId = output.graphId
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.taskId = output.taskId
        } else {
            self.format = nil
            self.graphId = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.taskId = nil
        }
    }
}

public struct CancelImportTaskOutput: Swift.Equatable {
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// Current status of the task. Status is CANCELLING when the import task is cancelled.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

struct CancelImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
}

extension CancelImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case roleArn
        case source
        case status
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelQueryInput {

    static func headerProvider(_ value: CancelQueryInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension CancelQueryInput {

    static func urlPathProvider(_ value: CancelQueryInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/queries/\(queryId.urlPercentEncoding())"
    }
}

public struct CancelQueryInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The unique identifier of the query to cancel.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.queryId = queryId
    }
}

struct CancelQueryInputBody: Swift.Equatable {
}

extension CancelQueryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelQueryOutput: Swift.Equatable {

    public init() { }
}

enum CancelQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a conflict is encountered.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        public internal(set) var reason: NeptuneGraphClientTypes.ConflictExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.ConflictExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: NeptuneGraphClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentModification
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case kmsKeyIdentifier
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
        case vectorSearchConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let graphName = self.graphName {
            try encodeContainer.encode(graphName, forKey: .graphName)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vectorSearchConfiguration = self.vectorSearchConfiguration {
            try encodeContainer.encode(vectorSearchConfiguration, forKey: .vectorSearchConfiguration)
        }
    }
}

extension CreateGraphInput {

    static func urlPathProvider(_ value: CreateGraphInput) -> Swift.String? {
        return "/graphs"
    }
}

public struct CreateGraphInput: Swift.Equatable {
    /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
    public var deletionProtection: Swift.Bool?
    /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// Specifies a KMS key to use to encrypt data in the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    /// This member is required.
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Min =0, Max = 2, Default = 1. Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    public var replicaCount: Swift.Int?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphName: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphName = graphName
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.tags = tags
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct CreateGraphInputBody: Swift.Equatable {
    let graphName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let publicConnectivity: Swift.Bool?
    let kmsKeyIdentifier: Swift.String?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let deletionProtection: Swift.Bool?
    let provisionedMemory: Swift.Int?
}

extension CreateGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case kmsKeyIdentifier
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphName)
        graphName = graphNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
    }
}

extension CreateGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct CreateGraphOutput: Swift.Equatable {
    /// The ARN of the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph software.
    public var buildNumber: Swift.String?
    /// The time when the graph was created.
    public var createTime: ClientRuntime.Date?
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The ID of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the KMS key used to encrypt data in the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. If enabling public connectivity for the first time, there will be a delay while it is enabled.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Default: If not specified, the default value is 1.
    public var replicaCount: Swift.Int?
    /// The ID of the source graph.
    public var sourceSnapshotId: Swift.String?
    /// The current status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason the status was given.
    public var statusReason: Swift.String?
    /// The vector-search configuration for the graph, which specifies the vector dimension to use in the vector index, if any.
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct CreateGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension CreateGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum CreateGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGraphSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphIdentifier
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphIdentifier = self.graphIdentifier {
            try encodeContainer.encode(graphIdentifier, forKey: .graphIdentifier)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGraphSnapshotInput {

    static func urlPathProvider(_ value: CreateGraphSnapshotInput) -> Swift.String? {
        return "/snapshots"
    }
}

public struct CreateGraphSnapshotInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?

    public init(
        graphIdentifier: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct CreateGraphSnapshotInputBody: Swift.Equatable {
    let graphIdentifier: Swift.String?
    let snapshotName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGraphSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphIdentifier
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphIdentifier)
        graphIdentifier = graphIdentifierDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGraphSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.snapshotCreateTime = output.snapshotCreateTime
            self.sourceGraphId = output.sourceGraphId
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.snapshotCreateTime = nil
            self.sourceGraphId = nil
            self.status = nil
        }
    }
}

public struct CreateGraphSnapshotOutput: Swift.Equatable {
    /// The ARN of the snapshot created.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the snapshot created.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the snapshot created.
    /// This member is required.
    public var name: Swift.String?
    /// The snapshot creation time
    public var snapshotCreateTime: ClientRuntime.Date?
    /// The Id of the Neptune Analytics graph from which the snapshot is created.
    public var sourceGraphId: Swift.String?
    /// The current state of the snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: ClientRuntime.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

struct CreateGraphSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let sourceGraphId: Swift.String?
    let snapshotCreateTime: ClientRuntime.Date?
    let status: NeptuneGraphClientTypes.SnapshotStatus?
    let kmsKeyIdentifier: Swift.String?
}

extension CreateGraphSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum CreateGraphSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGraphUsingImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case failOnError
        case format
        case graphName
        case importOptions
        case kmsKeyIdentifier
        case maxProvisionedMemory
        case minProvisionedMemory
        case publicConnectivity
        case replicaCount
        case roleArn
        case source
        case tags
        case vectorSearchConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let failOnError = self.failOnError {
            try encodeContainer.encode(failOnError, forKey: .failOnError)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let graphName = self.graphName {
            try encodeContainer.encode(graphName, forKey: .graphName)
        }
        if let importOptions = self.importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let maxProvisionedMemory = self.maxProvisionedMemory {
            try encodeContainer.encode(maxProvisionedMemory, forKey: .maxProvisionedMemory)
        }
        if let minProvisionedMemory = self.minProvisionedMemory {
            try encodeContainer.encode(minProvisionedMemory, forKey: .minProvisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vectorSearchConfiguration = self.vectorSearchConfiguration {
            try encodeContainer.encode(vectorSearchConfiguration, forKey: .vectorSearchConfiguration)
        }
    }
}

extension CreateGraphUsingImportTaskInput {

    static func urlPathProvider(_ value: CreateGraphUsingImportTaskInput) -> Swift.String? {
        return "/importtasks"
    }
}

public struct CreateGraphUsingImportTaskInput: Swift.Equatable {
    /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
    public var deletionProtection: Swift.Bool?
    /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
    public var failOnError: Swift.Bool?
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// Specifies a KMS key to use to encrypt data imported into the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The maximum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 1024, or the approved upper limit for your account. If both the minimum and maximum values are specified, the max of the min-provisioned-memory and max-provisioned memory is used to create the graph. If neither value is specified 128 m-NCUs are used.
    public var maxProvisionedMemory: Swift.Int?
    /// The minimum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 128
    public var minProvisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs to provision on the new graph after import. Default = 0, Min = 0, Max = 2. Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    public var replicaCount: Swift.Int?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        deletionProtection: Swift.Bool? = nil,
        failOnError: Swift.Bool? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphName: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        maxProvisionedMemory: Swift.Int? = nil,
        minProvisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.failOnError = failOnError
        self.format = format
        self.graphName = graphName
        self.importOptions = importOptions
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.maxProvisionedMemory = maxProvisionedMemory
        self.minProvisionedMemory = minProvisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.roleArn = roleArn
        self.source = source
        self.tags = tags
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct CreateGraphUsingImportTaskInputBody: Swift.Equatable {
    let graphName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let publicConnectivity: Swift.Bool?
    let kmsKeyIdentifier: Swift.String?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let deletionProtection: Swift.Bool?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
    let maxProvisionedMemory: Swift.Int?
    let minProvisionedMemory: Swift.Int?
    let failOnError: Swift.Bool?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
}

extension CreateGraphUsingImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case failOnError
        case format
        case graphName
        case importOptions
        case kmsKeyIdentifier
        case maxProvisionedMemory
        case minProvisionedMemory
        case publicConnectivity
        case replicaCount
        case roleArn
        case source
        case tags
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphName)
        graphName = graphNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let maxProvisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxProvisionedMemory)
        maxProvisionedMemory = maxProvisionedMemoryDecoded
        let minProvisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedMemory)
        minProvisionedMemory = minProvisionedMemoryDecoded
        let failOnErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failOnError)
        failOnError = failOnErrorDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateGraphUsingImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphUsingImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.graphId = output.graphId
            self.importOptions = output.importOptions
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.taskId = output.taskId
        } else {
            self.format = nil
            self.graphId = nil
            self.importOptions = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.taskId = nil
        }
    }
}

public struct CreateGraphUsingImportTaskOutput: Swift.Equatable {
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

struct CreateGraphUsingImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
}

extension CreateGraphUsingImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case importOptions
        case roleArn
        case source
        case status
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
    }
}

enum CreateGraphUsingImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePrivateGraphEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetIds
        case vpcId
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for securitygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
    }
}

extension CreatePrivateGraphEndpointInput {

    static func urlPathProvider(_ value: CreatePrivateGraphEndpointInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints"
    }
}

public struct CreatePrivateGraphEndpointInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Subnets in which private graph endpoint ENIs are created.
    public var subnetIds: [Swift.String]?
    /// The VPC in which the private graph endpoint needs to be created.
    public var vpcId: Swift.String?
    /// Security groups to be attached to the private graph endpoint..
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        graphIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.subnetIds = subnetIds
        self.vpcId = vpcId
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreatePrivateGraphEndpointInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
}

extension CreatePrivateGraphEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetIds
        case vpcId
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
    }
}

extension CreatePrivateGraphEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePrivateGraphEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.subnetIds = output.subnetIds
            self.vpcEndpointId = output.vpcEndpointId
            self.vpcId = output.vpcId
        } else {
            self.status = nil
            self.subnetIds = nil
            self.vpcEndpointId = nil
            self.vpcId = nil
        }
    }
}

public struct CreatePrivateGraphEndpointOutput: Swift.Equatable {
    /// Status of the private graph endpoint.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// Subnets in which the private graph endpoint ENIs are created.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Endpoint ID of the prviate grpah endpoint.
    public var vpcEndpointId: Swift.String?
    /// VPC in which the private graph endpoint is created.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

struct CreatePrivateGraphEndpointOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    let vpcEndpointId: Swift.String?
}

extension CreatePrivateGraphEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

enum CreatePrivateGraphEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGraphInput {

    static func queryItemProvider(_ value: DeleteGraphInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let skipSnapshot = value.skipSnapshot else {
            let message = "Creating a URL Query Item failed. skipSnapshot is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let skipSnapshotQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipSnapshot".urlPercentEncoding(), value: Swift.String(skipSnapshot).urlPercentEncoding())
        items.append(skipSnapshotQueryItem)
        return items
    }
}

extension DeleteGraphInput {

    static func urlPathProvider(_ value: DeleteGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteGraphInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Determines whether a final graph snapshot is created before the graph is deleted. If true is specified, no graph snapshot is created. If false is specified, a graph snapshot is created before the graph is deleted.
    /// This member is required.
    public var skipSnapshot: Swift.Bool?

    public init(
        graphIdentifier: Swift.String? = nil,
        skipSnapshot: Swift.Bool? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.skipSnapshot = skipSnapshot
    }
}

struct DeleteGraphInputBody: Swift.Equatable {
}

extension DeleteGraphInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct DeleteGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number associated with the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection was enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if the graph was recovered from a snapshot.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason for the status of the graph.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct DeleteGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension DeleteGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum DeleteGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGraphSnapshotInput {

    static func urlPathProvider(_ value: DeleteGraphSnapshotInput) -> Swift.String? {
        guard let snapshotIdentifier = value.snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteGraphSnapshotInput: Swift.Equatable {
    /// ID of the graph snapshot to be deleted.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?

    public init(
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotIdentifier = snapshotIdentifier
    }
}

struct DeleteGraphSnapshotInputBody: Swift.Equatable {
}

extension DeleteGraphSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGraphSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.snapshotCreateTime = output.snapshotCreateTime
            self.sourceGraphId = output.sourceGraphId
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.snapshotCreateTime = nil
            self.sourceGraphId = nil
            self.status = nil
        }
    }
}

public struct DeleteGraphSnapshotOutput: Swift.Equatable {
    /// The ARN of the graph snapshot.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the graph snapshot.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt the snapshot.
    public var kmsKeyIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The time when the snapshot was created.
    public var snapshotCreateTime: ClientRuntime.Date?
    /// The graph identifier for the graph from which the snapshot was created.
    public var sourceGraphId: Swift.String?
    /// The status of the graph snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: ClientRuntime.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

struct DeleteGraphSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let sourceGraphId: Swift.String?
    let snapshotCreateTime: ClientRuntime.Date?
    let status: NeptuneGraphClientTypes.SnapshotStatus?
    let kmsKeyIdentifier: Swift.String?
}

extension DeleteGraphSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum DeleteGraphSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePrivateGraphEndpointInput {

    static func urlPathProvider(_ value: DeletePrivateGraphEndpointInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        guard let vpcId = value.vpcId else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints/\(vpcId.urlPercentEncoding())"
    }
}

public struct DeletePrivateGraphEndpointInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.vpcId = vpcId
    }
}

struct DeletePrivateGraphEndpointInputBody: Swift.Equatable {
}

extension DeletePrivateGraphEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePrivateGraphEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePrivateGraphEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.subnetIds = output.subnetIds
            self.vpcEndpointId = output.vpcEndpointId
            self.vpcId = output.vpcId
        } else {
            self.status = nil
            self.subnetIds = nil
            self.vpcEndpointId = nil
            self.vpcId = nil
        }
    }
}

public struct DeletePrivateGraphEndpointOutput: Swift.Equatable {
    /// The status of the delete operation.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// The subnet IDs involved.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC endpoint that was deleted.
    public var vpcEndpointId: Swift.String?
    /// The ID of the VPC where the private endpoint was deleted.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

struct DeletePrivateGraphEndpointOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    let vpcEndpointId: Swift.String?
}

extension DeletePrivateGraphEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

enum DeletePrivateGraphEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptuneGraphClientTypes.EdgeStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case edgeProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let edgeProperties = edgeProperties {
            var edgePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeProperties)
            for string0 in edgeProperties {
                try edgePropertiesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let edgePropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeProperties)
        var edgePropertiesDecoded0:[Swift.String]? = nil
        if let edgePropertiesContainer = edgePropertiesContainer {
            edgePropertiesDecoded0 = [Swift.String]()
            for string0 in edgePropertiesContainer {
                if let string0 = string0 {
                    edgePropertiesDecoded0?.append(string0)
                }
            }
        }
        edgeProperties = edgePropertiesDecoded0
    }
}

extension NeptuneGraphClientTypes {
    /// Contains information about an edge in a Neptune Analytics graph.
    public struct EdgeStructure: Swift.Equatable {
        /// The number of instances of the edge in the graph.
        public var count: Swift.Int?
        /// A list of the properties associated with the edge.
        public var edgeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            edgeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.edgeProperties = edgeProperties
        }
    }

}

extension ExecuteQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainMode = "explain"
        case language
        case parameters
        case planCache
        case queryString = "query"
        case queryTimeoutMilliseconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainMode = self.explainMode {
            try encodeContainer.encode(explainMode.rawValue, forKey: .explainMode)
        }
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, documentValuedMap0) in parameters {
                try parametersContainer.encode(documentValuedMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let planCache = self.planCache {
            try encodeContainer.encode(planCache.rawValue, forKey: .planCache)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryTimeoutMilliseconds = self.queryTimeoutMilliseconds {
            try encodeContainer.encode(queryTimeoutMilliseconds, forKey: .queryTimeoutMilliseconds)
        }
    }
}

extension ExecuteQueryInput {

    static func headerProvider(_ value: ExecuteQueryInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension ExecuteQueryInput {

    static func urlPathProvider(_ value: ExecuteQueryInput) -> Swift.String? {
        return "/queries"
    }
}

public struct ExecuteQueryInput: Swift.Equatable {
    /// The explain mode parameter returns a query explain instead of the actual query results. A query explain can be used to gather insights about the query execution such as planning decisions, time spent on each operator, solutions flowing etc.
    public var explainMode: NeptuneGraphClientTypes.ExplainMode?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The query language the query is written in. Currently only openCypher is supported.
    /// This member is required.
    public var language: NeptuneGraphClientTypes.QueryLanguage?
    /// The data parameters the query can use in JSON format. For example: {"name": "john", "age": 20}. (optional)
    public var parameters: [Swift.String:ClientRuntime.Document]?
    /// Query plan cache is a feature that saves the query plan and reuses it on successive executions of the same query. This reduces query latency, and works for both READ and UPDATE queries. The plan cache is an LRU cache with a 5 minute TTL and a capacity of 1000.
    public var planCache: NeptuneGraphClientTypes.PlanCacheType?
    /// The query string to be executed.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies the query timeout duration, in milliseconds. (optional)
    public var queryTimeoutMilliseconds: Swift.Int?

    public init(
        explainMode: NeptuneGraphClientTypes.ExplainMode? = nil,
        graphIdentifier: Swift.String? = nil,
        language: NeptuneGraphClientTypes.QueryLanguage? = nil,
        parameters: [Swift.String:ClientRuntime.Document]? = nil,
        planCache: NeptuneGraphClientTypes.PlanCacheType? = nil,
        queryString: Swift.String? = nil,
        queryTimeoutMilliseconds: Swift.Int? = nil
    )
    {
        self.explainMode = explainMode
        self.graphIdentifier = graphIdentifier
        self.language = language
        self.parameters = parameters
        self.planCache = planCache
        self.queryString = queryString
        self.queryTimeoutMilliseconds = queryTimeoutMilliseconds
    }
}

struct ExecuteQueryInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let language: NeptuneGraphClientTypes.QueryLanguage?
    let parameters: [Swift.String:ClientRuntime.Document]?
    let planCache: NeptuneGraphClientTypes.PlanCacheType?
    let explainMode: NeptuneGraphClientTypes.ExplainMode?
    let queryTimeoutMilliseconds: Swift.Int?
}

extension ExecuteQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainMode = "explain"
        case language
        case parameters
        case planCache
        case queryString = "query"
        case queryTimeoutMilliseconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let languageDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.QueryLanguage.self, forKey: .language)
        language = languageDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: ClientRuntime.Document?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:ClientRuntime.Document]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:ClientRuntime.Document]()
            for (key0, document0) in parametersContainer {
                if let document0 = document0 {
                    parametersDecoded0?[key0] = document0
                }
            }
        }
        parameters = parametersDecoded0
        let planCacheDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PlanCacheType.self, forKey: .planCache)
        planCache = planCacheDecoded
        let explainModeDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ExplainMode.self, forKey: .explainMode)
        explainMode = explainModeDecoded
        let queryTimeoutMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryTimeoutMilliseconds)
        queryTimeoutMilliseconds = queryTimeoutMillisecondsDecoded
    }
}

extension ExecuteQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.payload = .data(data)
        case .stream(let stream):
            self.payload = .stream(stream)
        case .noStream:
            self.payload = nil
        }
    }
}

public struct ExecuteQueryOutput: Swift.Equatable {
    /// The query results.
    /// This member is required.
    public var payload: ClientRuntime.ByteStream?

    public init(
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

struct ExecuteQueryOutputBody: Swift.Equatable {
    let payload: ClientRuntime.ByteStream?
}

extension ExecuteQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum ExecuteQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableException": return try await UnprocessableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptuneGraphClientTypes {
    public enum ExplainMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case details
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [ExplainMode] {
            return [
                .details,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .details: return "DETAILS"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExplainMode(rawValue: rawValue) ?? ExplainMode.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case openCypher
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .openCypher,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .openCypher: return "OPEN_CYPHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetGraphInput {

    static func urlPathProvider(_ value: GetGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct GetGraphInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
    }
}

struct GetGraphInputBody: Swift.Equatable {
}

extension GetGraphInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct GetGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if it was created from a snapshot.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct GetGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension GetGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum GetGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGraphSnapshotInput {

    static func urlPathProvider(_ value: GetGraphSnapshotInput) -> Swift.String? {
        guard let snapshotIdentifier = value.snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())"
    }
}

public struct GetGraphSnapshotInput: Swift.Equatable {
    /// The ID of the snapshot to retrieve.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?

    public init(
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotIdentifier = snapshotIdentifier
    }
}

struct GetGraphSnapshotInputBody: Swift.Equatable {
}

extension GetGraphSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGraphSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.snapshotCreateTime = output.snapshotCreateTime
            self.sourceGraphId = output.sourceGraphId
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.snapshotCreateTime = nil
            self.sourceGraphId = nil
            self.status = nil
        }
    }
}

public struct GetGraphSnapshotOutput: Swift.Equatable {
    /// The ARN of the graph snapshot.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the graph snapshot.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt the snapshot.
    public var kmsKeyIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The time when the snapshot was created.
    public var snapshotCreateTime: ClientRuntime.Date?
    /// The graph identifier for the graph for which a snapshot is to be created.
    public var sourceGraphId: Swift.String?
    /// The status of the graph snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: ClientRuntime.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

struct GetGraphSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let sourceGraphId: Swift.String?
    let snapshotCreateTime: ClientRuntime.Date?
    let status: NeptuneGraphClientTypes.SnapshotStatus?
    let kmsKeyIdentifier: Swift.String?
}

extension GetGraphSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum GetGraphSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGraphSummaryInput {

    static func headerProvider(_ value: GetGraphSummaryInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension GetGraphSummaryInput {

    static func queryItemProvider(_ value: GetGraphSummaryInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let mode = value.mode {
            let modeQueryItem = ClientRuntime.SDKURLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        return items
    }
}

extension GetGraphSummaryInput {

    static func urlPathProvider(_ value: GetGraphSummaryInput) -> Swift.String? {
        return "/summary"
    }
}

public struct GetGraphSummaryInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The summary mode can take one of two values: basic (the default), and detailed.
    public var mode: NeptuneGraphClientTypes.GraphSummaryMode?

    public init(
        graphIdentifier: Swift.String? = nil,
        mode: NeptuneGraphClientTypes.GraphSummaryMode? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.mode = mode
    }
}

struct GetGraphSummaryInputBody: Swift.Equatable {
}

extension GetGraphSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGraphSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphSummary = output.graphSummary
            self.lastStatisticsComputationTime = output.lastStatisticsComputationTime
            self.version = output.version
        } else {
            self.graphSummary = nil
            self.lastStatisticsComputationTime = nil
            self.version = nil
        }
    }
}

public struct GetGraphSummaryOutput: Swift.Equatable {
    /// The graph summary.
    public var graphSummary: NeptuneGraphClientTypes.GraphDataSummary?
    /// The timestamp, in ISO 8601 format, of the time at which Neptune Analytics last computed statistics.
    public var lastStatisticsComputationTime: ClientRuntime.Date?
    /// Display the version of this tool.
    public var version: Swift.String?

    public init(
        graphSummary: NeptuneGraphClientTypes.GraphDataSummary? = nil,
        lastStatisticsComputationTime: ClientRuntime.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.graphSummary = graphSummary
        self.lastStatisticsComputationTime = lastStatisticsComputationTime
        self.version = version
    }
}

struct GetGraphSummaryOutputBody: Swift.Equatable {
    let version: Swift.String?
    let lastStatisticsComputationTime: ClientRuntime.Date?
    let graphSummary: NeptuneGraphClientTypes.GraphDataSummary?
}

extension GetGraphSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphSummary
        case lastStatisticsComputationTime
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lastStatisticsComputationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastStatisticsComputationTime)
        lastStatisticsComputationTime = lastStatisticsComputationTimeDecoded
        let graphSummaryDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphDataSummary.self, forKey: .graphSummary)
        graphSummary = graphSummaryDecoded
    }
}

enum GetGraphSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImportTaskInput {

    static func urlPathProvider(_ value: GetImportTaskInput) -> Swift.String? {
        guard let taskIdentifier = value.taskIdentifier else {
            return nil
        }
        return "/importtasks/\(taskIdentifier.urlPercentEncoding())"
    }
}

public struct GetImportTaskInput: Swift.Equatable {
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskIdentifier: Swift.String?

    public init(
        taskIdentifier: Swift.String? = nil
    )
    {
        self.taskIdentifier = taskIdentifier
    }
}

struct GetImportTaskInputBody: Swift.Equatable {
}

extension GetImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.attemptNumber = output.attemptNumber
            self.format = output.format
            self.graphId = output.graphId
            self.importOptions = output.importOptions
            self.importTaskDetails = output.importTaskDetails
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.statusReason = output.statusReason
            self.taskId = output.taskId
        } else {
            self.attemptNumber = nil
            self.format = nil
            self.graphId = nil
            self.importOptions = nil
            self.importTaskDetails = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.statusReason = nil
            self.taskId = nil
        }
    }
}

public struct GetImportTaskOutput: Swift.Equatable {
    /// The number of the current attempt to execute the import task.
    public var attemptNumber: Swift.Int?
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// Contains details about the specified import task.
    public var importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task:
    ///
    /// * INITIALIZING – The necessary resources needed to create the graph are being prepared.
    ///
    /// * ANALYZING_DATA – The data is being analyzed to determine the optimal infrastructure configuration for the new graph.
    ///
    /// * RE_PROVISIONING – The data did not fit into the provisioned graph, so it is being re-provisioned with more capacity.
    ///
    /// * IMPORTING – The data is being loaded.
    ///
    /// * ERROR_ENCOUNTERED – An error has been encountered while trying to create the graph and import the data.
    ///
    /// * ERROR_ENCOUNTERED_ROLLING_BACK – Because of the error that was encountered, the graph is being rolled back and all its resources released.
    ///
    /// * SUCCEEDED – Graph creation and data loading succeeded.
    ///
    /// * FAILED – Graph creation or data loading failed. When the status is FAILED, you can use get-graphs to get more information about the state of the graph.
    ///
    /// * CANCELLING – Because you cancelled the import task, cancellation is in progress.
    ///
    /// * CANCELLED – You have successfully cancelled the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The reason that the import task has this status value.
    public var statusReason: Swift.String?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        attemptNumber: Swift.Int? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        statusReason: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.attemptNumber = attemptNumber
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.importTaskDetails = importTaskDetails
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.statusReason = statusReason
        self.taskId = taskId
    }
}

struct GetImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
    let importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails?
    let attemptNumber: Swift.Int?
    let statusReason: Swift.String?
}

extension GetImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attemptNumber
        case format
        case graphId
        case importOptions
        case importTaskDetails
        case roleArn
        case source
        case status
        case statusReason
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let importTaskDetailsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskDetails.self, forKey: .importTaskDetails)
        importTaskDetails = importTaskDetailsDecoded
        let attemptNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attemptNumber)
        attemptNumber = attemptNumberDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

enum GetImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPrivateGraphEndpointInput {

    static func urlPathProvider(_ value: GetPrivateGraphEndpointInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        guard let vpcId = value.vpcId else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints/\(vpcId.urlPercentEncoding())"
    }
}

public struct GetPrivateGraphEndpointInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.vpcId = vpcId
    }
}

struct GetPrivateGraphEndpointInputBody: Swift.Equatable {
}

extension GetPrivateGraphEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPrivateGraphEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPrivateGraphEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.subnetIds = output.subnetIds
            self.vpcEndpointId = output.vpcEndpointId
            self.vpcId = output.vpcId
        } else {
            self.status = nil
            self.subnetIds = nil
            self.vpcEndpointId = nil
            self.vpcId = nil
        }
    }
}

public struct GetPrivateGraphEndpointOutput: Swift.Equatable {
    /// The current status of the private endpoint.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// The subnet IDs involved.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the private endpoint.
    public var vpcEndpointId: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

struct GetPrivateGraphEndpointOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    let vpcEndpointId: Swift.String?
}

extension GetPrivateGraphEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

enum GetPrivateGraphEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryInput {

    static func headerProvider(_ value: GetQueryInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension GetQueryInput {

    static func urlPathProvider(_ value: GetQueryInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/queries/\(queryId.urlPercentEncoding())"
    }
}

public struct GetQueryInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the query in question.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.queryId = queryId
    }
}

struct GetQueryInputBody: Swift.Equatable {
}

extension GetQueryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.elapsed = output.elapsed
            self.id = output.id
            self.queryString = output.queryString
            self.state = output.state
            self.waited = output.waited
        } else {
            self.elapsed = nil
            self.id = nil
            self.queryString = nil
            self.state = nil
            self.waited = nil
        }
    }
}

public struct GetQueryOutput: Swift.Equatable {
    /// The number of milliseconds the query has been running.
    public var elapsed: Swift.Int?
    /// The ID of the query in question.
    public var id: Swift.String?
    /// The query in question.
    public var queryString: Swift.String?
    /// State of the query.
    public var state: NeptuneGraphClientTypes.QueryState?
    /// Indicates how long the query waited, in milliseconds.
    public var waited: Swift.Int?

    public init(
        elapsed: Swift.Int? = nil,
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        state: NeptuneGraphClientTypes.QueryState? = nil,
        waited: Swift.Int? = nil
    )
    {
        self.elapsed = elapsed
        self.id = id
        self.queryString = queryString
        self.state = state
        self.waited = waited
    }
}

struct GetQueryOutputBody: Swift.Equatable {
    let id: Swift.String?
    let queryString: Swift.String?
    let waited: Swift.Int?
    let elapsed: Swift.Int?
    let state: NeptuneGraphClientTypes.QueryState?
}

extension GetQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsed
        case id
        case queryString
        case state
        case waited
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let waitedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .waited)
        waited = waitedDecoded
        let elapsedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsed)
        elapsed = elapsedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.QueryState.self, forKey: .state)
        state = stateDecoded
    }
}

enum GetQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptuneGraphClientTypes.GraphDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeLabels
        case edgeProperties
        case edgeStructures
        case nodeLabels
        case nodeProperties
        case nodeStructures
        case numEdgeLabels
        case numEdgeProperties
        case numEdges
        case numNodeLabels
        case numNodeProperties
        case numNodes
        case totalEdgePropertyValues
        case totalNodePropertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeLabels = edgeLabels {
            var edgeLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeLabels)
            for string0 in edgeLabels {
                try edgeLabelsContainer.encode(string0)
            }
        }
        if let edgeProperties = edgeProperties {
            var edgePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeProperties)
            for longvaluedmap0 in edgeProperties {
                var longvaluedmap0Container = edgePropertiesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, longValuedMap1) in longvaluedmap0 {
                    try longvaluedmap0Container.encode(longValuedMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let edgeStructures = edgeStructures {
            var edgeStructuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edgeStructures)
            for edgestructure0 in edgeStructures {
                try edgeStructuresContainer.encode(edgestructure0)
            }
        }
        if let nodeLabels = nodeLabels {
            var nodeLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeLabels)
            for string0 in nodeLabels {
                try nodeLabelsContainer.encode(string0)
            }
        }
        if let nodeProperties = nodeProperties {
            var nodePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeProperties)
            for longvaluedmap0 in nodeProperties {
                var longvaluedmap0Container = nodePropertiesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, longValuedMap1) in longvaluedmap0 {
                    try longvaluedmap0Container.encode(longValuedMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let nodeStructures = nodeStructures {
            var nodeStructuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeStructures)
            for nodestructure0 in nodeStructures {
                try nodeStructuresContainer.encode(nodestructure0)
            }
        }
        if let numEdgeLabels = self.numEdgeLabels {
            try encodeContainer.encode(numEdgeLabels, forKey: .numEdgeLabels)
        }
        if let numEdgeProperties = self.numEdgeProperties {
            try encodeContainer.encode(numEdgeProperties, forKey: .numEdgeProperties)
        }
        if let numEdges = self.numEdges {
            try encodeContainer.encode(numEdges, forKey: .numEdges)
        }
        if let numNodeLabels = self.numNodeLabels {
            try encodeContainer.encode(numNodeLabels, forKey: .numNodeLabels)
        }
        if let numNodeProperties = self.numNodeProperties {
            try encodeContainer.encode(numNodeProperties, forKey: .numNodeProperties)
        }
        if let numNodes = self.numNodes {
            try encodeContainer.encode(numNodes, forKey: .numNodes)
        }
        if let totalEdgePropertyValues = self.totalEdgePropertyValues {
            try encodeContainer.encode(totalEdgePropertyValues, forKey: .totalEdgePropertyValues)
        }
        if let totalNodePropertyValues = self.totalNodePropertyValues {
            try encodeContainer.encode(totalNodePropertyValues, forKey: .totalNodePropertyValues)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodes)
        numNodes = numNodesDecoded
        let numEdgesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numEdges)
        numEdges = numEdgesDecoded
        let numNodeLabelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodeLabels)
        numNodeLabels = numNodeLabelsDecoded
        let numEdgeLabelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numEdgeLabels)
        numEdgeLabels = numEdgeLabelsDecoded
        let nodeLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeLabels)
        var nodeLabelsDecoded0:[Swift.String]? = nil
        if let nodeLabelsContainer = nodeLabelsContainer {
            nodeLabelsDecoded0 = [Swift.String]()
            for string0 in nodeLabelsContainer {
                if let string0 = string0 {
                    nodeLabelsDecoded0?.append(string0)
                }
            }
        }
        nodeLabels = nodeLabelsDecoded0
        let edgeLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .edgeLabels)
        var edgeLabelsDecoded0:[Swift.String]? = nil
        if let edgeLabelsContainer = edgeLabelsContainer {
            edgeLabelsDecoded0 = [Swift.String]()
            for string0 in edgeLabelsContainer {
                if let string0 = string0 {
                    edgeLabelsDecoded0?.append(string0)
                }
            }
        }
        edgeLabels = edgeLabelsDecoded0
        let numNodePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodeProperties)
        numNodeProperties = numNodePropertiesDecoded
        let numEdgePropertiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numEdgeProperties)
        numEdgeProperties = numEdgePropertiesDecoded
        let nodePropertiesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.Int?]?].self, forKey: .nodeProperties)
        var nodePropertiesDecoded0:[[Swift.String:Swift.Int]]? = nil
        if let nodePropertiesContainer = nodePropertiesContainer {
            nodePropertiesDecoded0 = [[Swift.String:Swift.Int]]()
            for map0 in nodePropertiesContainer {
                var nodePropertiesContainerDecoded0: [Swift.String: Swift.Int]? = nil
                if let map0 = map0 {
                    nodePropertiesContainerDecoded0 = [Swift.String: Swift.Int]()
                    for (key1, long1) in map0 {
                        if let long1 = long1 {
                            nodePropertiesContainerDecoded0?[key1] = long1
                        }
                    }
                }
                if let nodePropertiesContainerDecoded0 = nodePropertiesContainerDecoded0 {
                    nodePropertiesDecoded0?.append(nodePropertiesContainerDecoded0)
                }
            }
        }
        nodeProperties = nodePropertiesDecoded0
        let edgePropertiesContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.Int?]?].self, forKey: .edgeProperties)
        var edgePropertiesDecoded0:[[Swift.String:Swift.Int]]? = nil
        if let edgePropertiesContainer = edgePropertiesContainer {
            edgePropertiesDecoded0 = [[Swift.String:Swift.Int]]()
            for map0 in edgePropertiesContainer {
                var edgePropertiesContainerDecoded0: [Swift.String: Swift.Int]? = nil
                if let map0 = map0 {
                    edgePropertiesContainerDecoded0 = [Swift.String: Swift.Int]()
                    for (key1, long1) in map0 {
                        if let long1 = long1 {
                            edgePropertiesContainerDecoded0?[key1] = long1
                        }
                    }
                }
                if let edgePropertiesContainerDecoded0 = edgePropertiesContainerDecoded0 {
                    edgePropertiesDecoded0?.append(edgePropertiesContainerDecoded0)
                }
            }
        }
        edgeProperties = edgePropertiesDecoded0
        let totalNodePropertyValuesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodePropertyValues)
        totalNodePropertyValues = totalNodePropertyValuesDecoded
        let totalEdgePropertyValuesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalEdgePropertyValues)
        totalEdgePropertyValues = totalEdgePropertyValuesDecoded
        let nodeStructuresContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.NodeStructure?].self, forKey: .nodeStructures)
        var nodeStructuresDecoded0:[NeptuneGraphClientTypes.NodeStructure]? = nil
        if let nodeStructuresContainer = nodeStructuresContainer {
            nodeStructuresDecoded0 = [NeptuneGraphClientTypes.NodeStructure]()
            for structure0 in nodeStructuresContainer {
                if let structure0 = structure0 {
                    nodeStructuresDecoded0?.append(structure0)
                }
            }
        }
        nodeStructures = nodeStructuresDecoded0
        let edgeStructuresContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.EdgeStructure?].self, forKey: .edgeStructures)
        var edgeStructuresDecoded0:[NeptuneGraphClientTypes.EdgeStructure]? = nil
        if let edgeStructuresContainer = edgeStructuresContainer {
            edgeStructuresDecoded0 = [NeptuneGraphClientTypes.EdgeStructure]()
            for structure0 in edgeStructuresContainer {
                if let structure0 = structure0 {
                    edgeStructuresDecoded0?.append(structure0)
                }
            }
        }
        edgeStructures = edgeStructuresDecoded0
    }
}

extension NeptuneGraphClientTypes {
    /// Summary information about the graph.
    public struct GraphDataSummary: Swift.Equatable {
        /// A list of the edge labels in the graph.
        public var edgeLabels: [Swift.String]?
        /// A list of the distinct edge properties in the graph, along with the count of edges where each property is used.
        public var edgeProperties: [[Swift.String:Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of edge structures.
        public var edgeStructures: [NeptuneGraphClientTypes.EdgeStructure]?
        /// A list of distinct node labels in the graph.
        public var nodeLabels: [Swift.String]?
        /// A list of the distinct node properties in the graph, along with the count of nodes where each property is used.
        public var nodeProperties: [[Swift.String:Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of node structures.
        public var nodeStructures: [NeptuneGraphClientTypes.NodeStructure]?
        /// The number of unique edge labels in the graph.
        public var numEdgeLabels: Swift.Int?
        /// The number of edge properties in the graph.
        public var numEdgeProperties: Swift.Int?
        /// The number of edges in the graph.
        public var numEdges: Swift.Int?
        /// The number of distinct node labels in the graph.
        public var numNodeLabels: Swift.Int?
        /// The number of distinct node properties in the graph.
        public var numNodeProperties: Swift.Int?
        /// The number of nodes in the graph.
        public var numNodes: Swift.Int?
        /// The total number of usages of all edge properties.
        public var totalEdgePropertyValues: Swift.Int?
        /// The total number of usages of all node properties.
        public var totalNodePropertyValues: Swift.Int?

        public init(
            edgeLabels: [Swift.String]? = nil,
            edgeProperties: [[Swift.String:Swift.Int]]? = nil,
            edgeStructures: [NeptuneGraphClientTypes.EdgeStructure]? = nil,
            nodeLabels: [Swift.String]? = nil,
            nodeProperties: [[Swift.String:Swift.Int]]? = nil,
            nodeStructures: [NeptuneGraphClientTypes.NodeStructure]? = nil,
            numEdgeLabels: Swift.Int? = nil,
            numEdgeProperties: Swift.Int? = nil,
            numEdges: Swift.Int? = nil,
            numNodeLabels: Swift.Int? = nil,
            numNodeProperties: Swift.Int? = nil,
            numNodes: Swift.Int? = nil,
            totalEdgePropertyValues: Swift.Int? = nil,
            totalNodePropertyValues: Swift.Int? = nil
        )
        {
            self.edgeLabels = edgeLabels
            self.edgeProperties = edgeProperties
            self.edgeStructures = edgeStructures
            self.nodeLabels = nodeLabels
            self.nodeProperties = nodeProperties
            self.nodeStructures = nodeStructures
            self.numEdgeLabels = numEdgeLabels
            self.numEdgeProperties = numEdgeProperties
            self.numEdges = numEdges
            self.numNodeLabels = numNodeLabels
            self.numNodeProperties = numNodeProperties
            self.numNodes = numNodes
            self.totalEdgePropertyValues = totalEdgePropertyValues
            self.totalNodePropertyValues = totalNodePropertyValues
        }
    }

}

extension NeptuneGraphClientTypes.GraphSnapshotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snapshotCreateTime = self.snapshotCreateTime {
            try encodeContainer.encodeTimestamp(snapshotCreateTime, format: .epochSeconds, forKey: .snapshotCreateTime)
        }
        if let sourceGraphId = self.sourceGraphId {
            try encodeContainer.encode(sourceGraphId, forKey: .sourceGraphId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details about a graph snapshot.
    public struct GraphSnapshotSummary: Swift.Equatable {
        /// The ARN of the graph snapshot.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique identifier of the graph snapshot.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public var kmsKeyIdentifier: Swift.String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        /// This member is required.
        public var name: Swift.String?
        /// The time when the snapshot was created.
        public var snapshotCreateTime: ClientRuntime.Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public var sourceGraphId: Swift.String?
        /// The status of the graph snapshot.
        public var status: NeptuneGraphClientTypes.SnapshotStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyIdentifier: Swift.String? = nil,
            name: Swift.String? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            sourceGraphId: Swift.String? = nil,
            status: NeptuneGraphClientTypes.SnapshotStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum GraphStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case importing
        case resetting
        case snapshotting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .importing,
                .resetting,
                .snapshotting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .resetting: return "RESETTING"
            case .snapshotting: return "SNAPSHOTTING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GraphStatus(rawValue: rawValue) ?? GraphStatus.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.GraphSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Summary details about a graph.
    public struct GraphSummary: Swift.Equatable {
        /// The ARN associated with the graph.
        /// This member is required.
        public var arn: Swift.String?
        /// If true, deletion protection is enabled for the graph.
        public var deletionProtection: Swift.Bool?
        /// The graph endpoint.
        public var endpoint: Swift.String?
        /// The unique identifier of the graph.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public var kmsKeyIdentifier: Swift.String?
        /// The name of the graph.
        /// This member is required.
        public var name: Swift.String?
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public var provisionedMemory: Swift.Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public var publicConnectivity: Swift.Bool?
        /// The number of replicas for the graph.
        public var replicaCount: Swift.Int?
        /// The status of the graph.
        public var status: NeptuneGraphClientTypes.GraphStatus?

        public init(
            arn: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyIdentifier: Swift.String? = nil,
            name: Swift.String? = nil,
            provisionedMemory: Swift.Int? = nil,
            publicConnectivity: Swift.Bool? = nil,
            replicaCount: Swift.Int? = nil,
            status: NeptuneGraphClientTypes.GraphStatus? = nil
        )
        {
            self.arn = arn
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.status = status
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum GraphSummaryMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case detailed
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphSummaryMode] {
            return [
                .basic,
                .detailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .detailed: return "DETAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GraphSummaryMode(rawValue: rawValue) ?? GraphSummaryMode.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.ImportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case neptune
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .neptune(neptune):
                try container.encode(neptune, forKey: .neptune)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let neptuneDecoded = try values.decodeIfPresent(NeptuneGraphClientTypes.NeptuneImportOptions.self, forKey: .neptune)
        if let neptune = neptuneDecoded {
            self = .neptune(neptune)
            return
        }
        self = .sdkUnknown("")
    }
}

extension NeptuneGraphClientTypes {
    /// Options for how to perform an import.
    public enum ImportOptions: Swift.Equatable {
        /// Options for importing data from a Neptune database.
        case neptune(NeptuneGraphClientTypes.NeptuneImportOptions)
        case sdkUnknown(Swift.String)
    }

}

extension NeptuneGraphClientTypes.ImportTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dictionaryEntryCount
        case errorCount
        case errorDetails
        case progressPercentage
        case startTime
        case statementCount
        case status
        case timeElapsedSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dictionaryEntryCount = self.dictionaryEntryCount {
            try encodeContainer.encode(dictionaryEntryCount, forKey: .dictionaryEntryCount)
        }
        if let errorCount = self.errorCount {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let progressPercentage = self.progressPercentage {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statementCount = self.statementCount {
            try encodeContainer.encode(statementCount, forKey: .statementCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timeElapsedSeconds = self.timeElapsedSeconds {
            try encodeContainer.encode(timeElapsedSeconds, forKey: .timeElapsedSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let timeElapsedSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeElapsedSeconds)
        timeElapsedSeconds = timeElapsedSecondsDecoded
        let progressPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercentage)
        progressPercentage = progressPercentageDecoded
        let errorCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let statementCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statementCount)
        statementCount = statementCountDecoded
        let dictionaryEntryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dictionaryEntryCount)
        dictionaryEntryCount = dictionaryEntryCountDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Contains details about an import task.
    public struct ImportTaskDetails: Swift.Equatable {
        /// The number of dictionary entries in the import task.
        /// This member is required.
        public var dictionaryEntryCount: Swift.Int?
        /// The number of errors encountered so far.
        /// This member is required.
        public var errorCount: Swift.Int?
        /// Details about the errors that have been encountered.
        public var errorDetails: Swift.String?
        /// The percentage progress so far.
        /// This member is required.
        public var progressPercentage: Swift.Int?
        /// Time at which the import task started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The number of statements in the import task.
        /// This member is required.
        public var statementCount: Swift.Int?
        /// Status of the import task.
        /// This member is required.
        public var status: Swift.String?
        /// Seconds elapsed since the import task started.
        /// This member is required.
        public var timeElapsedSeconds: Swift.Int?

        public init(
            dictionaryEntryCount: Swift.Int? = nil,
            errorCount: Swift.Int? = nil,
            errorDetails: Swift.String? = nil,
            progressPercentage: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            statementCount: Swift.Int? = nil,
            status: Swift.String? = nil,
            timeElapsedSeconds: Swift.Int? = nil
        )
        {
            self.dictionaryEntryCount = dictionaryEntryCount
            self.errorCount = errorCount
            self.errorDetails = errorDetails
            self.progressPercentage = progressPercentage
            self.startTime = startTime
            self.statementCount = statementCount
            self.status = status
            self.timeElapsedSeconds = timeElapsedSeconds
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum ImportTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analyzingData
        case cancelled
        case cancelling
        case exporting
        case failed
        case importing
        case initializing
        case reprovisioning
        case rollingBack
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskStatus] {
            return [
                .analyzingData,
                .cancelled,
                .cancelling,
                .exporting,
                .failed,
                .importing,
                .initializing,
                .reprovisioning,
                .rollingBack,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analyzingData: return "ANALYZING_DATA"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .exporting: return "EXPORTING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .initializing: return "INITIALIZING"
            case .reprovisioning: return "REPROVISIONING"
            case .rollingBack: return "ROLLING_BACK"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportTaskStatus(rawValue: rawValue) ?? ImportTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.ImportTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case roleArn
        case source
        case status
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let graphId = self.graphId {
            try encodeContainer.encode(graphId, forKey: .graphId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details about an import task.
    public struct ImportTaskSummary: Swift.Equatable {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
        public var format: NeptuneGraphClientTypes.Format?
        /// The unique identifier of the Neptune Analytics graph.
        public var graphId: Swift.String?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        /// This member is required.
        public var source: Swift.String?
        /// Status of the import task.
        /// This member is required.
        public var status: NeptuneGraphClientTypes.ImportTaskStatus?
        /// The unique identifier of the import task.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            format: NeptuneGraphClientTypes.Format? = nil,
            graphId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            source: Swift.String? = nil,
            status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.format = format
            self.graphId = graphId
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A failure occurred on the server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListGraphSnapshotsInput {

    static func queryItemProvider(_ value: ListGraphSnapshotsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let graphIdentifier = value.graphIdentifier {
            let graphIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "graphIdentifier".urlPercentEncoding(), value: Swift.String(graphIdentifier).urlPercentEncoding())
            items.append(graphIdentifierQueryItem)
        }
        return items
    }
}

extension ListGraphSnapshotsInput {

    static func urlPathProvider(_ value: ListGraphSnapshotsInput) -> Swift.String? {
        return "/snapshots"
    }
}

public struct ListGraphSnapshotsInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    public var graphIdentifier: Swift.String?
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphSnapshotsInputBody: Swift.Equatable {
}

extension ListGraphSnapshotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGraphSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphSnapshots = output.graphSnapshots
            self.nextToken = output.nextToken
        } else {
            self.graphSnapshots = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphSnapshotsOutput: Swift.Equatable {
    /// The requested list of snapshots.
    /// This member is required.
    public var graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphSnapshots = graphSnapshots
        self.nextToken = nextToken
    }
}

struct ListGraphSnapshotsOutputBody: Swift.Equatable {
    let graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]?
    let nextToken: Swift.String?
}

extension ListGraphSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphSnapshots
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphSnapshotsContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.GraphSnapshotSummary?].self, forKey: .graphSnapshots)
        var graphSnapshotsDecoded0:[NeptuneGraphClientTypes.GraphSnapshotSummary]? = nil
        if let graphSnapshotsContainer = graphSnapshotsContainer {
            graphSnapshotsDecoded0 = [NeptuneGraphClientTypes.GraphSnapshotSummary]()
            for structure0 in graphSnapshotsContainer {
                if let structure0 = structure0 {
                    graphSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        graphSnapshots = graphSnapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGraphSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGraphsInput {

    static func queryItemProvider(_ value: ListGraphsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGraphsInput {

    static func urlPathProvider(_ value: ListGraphsInput) -> Swift.String? {
        return "/graphs"
    }
}

public struct ListGraphsInput: Swift.Equatable {
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphsInputBody: Swift.Equatable {
}

extension ListGraphsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGraphsOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphs = output.graphs
            self.nextToken = output.nextToken
        } else {
            self.graphs = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphsOutput: Swift.Equatable {
    /// A list of the graphs.
    /// This member is required.
    public var graphs: [NeptuneGraphClientTypes.GraphSummary]?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphs: [NeptuneGraphClientTypes.GraphSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphs = graphs
        self.nextToken = nextToken
    }
}

struct ListGraphsOutputBody: Swift.Equatable {
    let graphs: [NeptuneGraphClientTypes.GraphSummary]?
    let nextToken: Swift.String?
}

extension ListGraphsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphsContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.GraphSummary?].self, forKey: .graphs)
        var graphsDecoded0:[NeptuneGraphClientTypes.GraphSummary]? = nil
        if let graphsContainer = graphsContainer {
            graphsDecoded0 = [NeptuneGraphClientTypes.GraphSummary]()
            for structure0 in graphsContainer {
                if let structure0 = structure0 {
                    graphsDecoded0?.append(structure0)
                }
            }
        }
        graphs = graphsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGraphsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportTasksInput {

    static func queryItemProvider(_ value: ListImportTasksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListImportTasksInput {

    static func urlPathProvider(_ value: ListImportTasksInput) -> Swift.String? {
        return "/importtasks"
    }
}

public struct ListImportTasksInput: Swift.Equatable {
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportTasksInputBody: Swift.Equatable {
}

extension ListImportTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListImportTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListImportTasksOutput: Swift.Equatable {
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?
    /// The requested list of import tasks.
    /// This member is required.
    public var tasks: [NeptuneGraphClientTypes.ImportTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [NeptuneGraphClientTypes.ImportTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListImportTasksOutputBody: Swift.Equatable {
    let tasks: [NeptuneGraphClientTypes.ImportTaskSummary]?
    let nextToken: Swift.String?
}

extension ListImportTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.ImportTaskSummary?].self, forKey: .tasks)
        var tasksDecoded0:[NeptuneGraphClientTypes.ImportTaskSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [NeptuneGraphClientTypes.ImportTaskSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrivateGraphEndpointsInput {

    static func queryItemProvider(_ value: ListPrivateGraphEndpointsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPrivateGraphEndpointsInput {

    static func urlPathProvider(_ value: ListPrivateGraphEndpointsInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints"
    }
}

public struct ListPrivateGraphEndpointsInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPrivateGraphEndpointsInputBody: Swift.Equatable {
}

extension ListPrivateGraphEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPrivateGraphEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrivateGraphEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.privateGraphEndpoints = output.privateGraphEndpoints
        } else {
            self.nextToken = nil
            self.privateGraphEndpoints = nil
        }
    }
}

public struct ListPrivateGraphEndpointsOutput: Swift.Equatable {
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?
    /// A list of private endpoints for the specified Neptune Analytics graph.
    /// This member is required.
    public var privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privateGraphEndpoints = privateGraphEndpoints
    }
}

struct ListPrivateGraphEndpointsOutputBody: Swift.Equatable {
    let privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListPrivateGraphEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case privateGraphEndpoints
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateGraphEndpointsContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.PrivateGraphEndpointSummary?].self, forKey: .privateGraphEndpoints)
        var privateGraphEndpointsDecoded0:[NeptuneGraphClientTypes.PrivateGraphEndpointSummary]? = nil
        if let privateGraphEndpointsContainer = privateGraphEndpointsContainer {
            privateGraphEndpointsDecoded0 = [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]()
            for structure0 in privateGraphEndpointsContainer {
                if let structure0 = structure0 {
                    privateGraphEndpointsDecoded0?.append(structure0)
                }
            }
        }
        privateGraphEndpoints = privateGraphEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPrivateGraphEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueriesInput {

    static func headerProvider(_ value: ListQueriesInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension ListQueriesInput {

    static func queryItemProvider(_ value: ListQueriesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let maxResults = value.maxResults else {
            let message = "Creating a URL Query Item failed. maxResults is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
        items.append(maxResultsQueryItem)
        if let state = value.state {
            let stateQueryItem = ClientRuntime.SDKURLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        return items
    }
}

extension ListQueriesInput {

    static func urlPathProvider(_ value: ListQueriesInput) -> Swift.String? {
        return "/queries"
    }
}

public struct ListQueriesInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The maximum number of results to be fetched by the API.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// Filtered list of queries based on state.
    public var state: NeptuneGraphClientTypes.QueryStateInput?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        state: NeptuneGraphClientTypes.QueryStateInput? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.state = state
    }
}

struct ListQueriesInputBody: Swift.Equatable {
}

extension ListQueriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQueriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.queries = output.queries
        } else {
            self.queries = nil
        }
    }
}

public struct ListQueriesOutput: Swift.Equatable {
    /// A list of current openCypher queries.
    /// This member is required.
    public var queries: [NeptuneGraphClientTypes.QuerySummary]?

    public init(
        queries: [NeptuneGraphClientTypes.QuerySummary]? = nil
    )
    {
        self.queries = queries
    }
}

struct ListQueriesOutputBody: Swift.Equatable {
    let queries: [NeptuneGraphClientTypes.QuerySummary]?
}

extension ListQueriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queriesContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.QuerySummary?].self, forKey: .queries)
        var queriesDecoded0:[NeptuneGraphClientTypes.QuerySummary]? = nil
        if let queriesContainer = queriesContainer {
            queriesDecoded0 = [NeptuneGraphClientTypes.QuerySummary]()
            for structure0 in queriesContainer {
                if let structure0 = structure0 {
                    queriesDecoded0?.append(structure0)
                }
            }
        }
        queries = queriesDecoded0
    }
}

enum ListQueriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of metadata tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum NeptuneGraphClientTypes {}

extension NeptuneGraphClientTypes.NeptuneImportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preserveDefaultVertexLabels
        case preserveEdgeIds
        case s3ExportKmsKeyId
        case s3ExportPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preserveDefaultVertexLabels = self.preserveDefaultVertexLabels {
            try encodeContainer.encode(preserveDefaultVertexLabels, forKey: .preserveDefaultVertexLabels)
        }
        if let preserveEdgeIds = self.preserveEdgeIds {
            try encodeContainer.encode(preserveEdgeIds, forKey: .preserveEdgeIds)
        }
        if let s3ExportKmsKeyId = self.s3ExportKmsKeyId {
            try encodeContainer.encode(s3ExportKmsKeyId, forKey: .s3ExportKmsKeyId)
        }
        if let s3ExportPath = self.s3ExportPath {
            try encodeContainer.encode(s3ExportPath, forKey: .s3ExportPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ExportPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ExportPath)
        s3ExportPath = s3ExportPathDecoded
        let s3ExportKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ExportKmsKeyId)
        s3ExportKmsKeyId = s3ExportKmsKeyIdDecoded
        let preserveDefaultVertexLabelsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveDefaultVertexLabels)
        preserveDefaultVertexLabels = preserveDefaultVertexLabelsDecoded
        let preserveEdgeIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveEdgeIds)
        preserveEdgeIds = preserveEdgeIdsDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Options for how to import Neptune data.
    public struct NeptuneImportOptions: Swift.Equatable {
        /// Neptune Analytics supports label-less vertices and no labels are assigned unless one is explicitly provided. Neptune assigns default labels when none is explicitly provided. When importing the data into Neptune Analytics, the default vertex labels can be omitted by setting preserveDefaultVertexLabels to false. Note that if the vertex only has default labels, and has no other properties or edges, then the vertex will effectively not get imported into Neptune Analytics when preserveDefaultVertexLabels is set to false.
        public var preserveDefaultVertexLabels: Swift.Bool?
        /// Neptune Analytics currently does not support user defined edge ids. The edge ids are not imported by default. They are imported if preserveEdgeIds is set to true, and ids are stored as properties on the relationships with the property name neptuneEdgeId.
        public var preserveEdgeIds: Swift.Bool?
        /// The KMS key to use to encrypt data in the S3 bucket where the graph data is exported
        /// This member is required.
        public var s3ExportKmsKeyId: Swift.String?
        /// The path to an S3 bucket from which to import data.
        /// This member is required.
        public var s3ExportPath: Swift.String?

        public init(
            preserveDefaultVertexLabels: Swift.Bool? = nil,
            preserveEdgeIds: Swift.Bool? = nil,
            s3ExportKmsKeyId: Swift.String? = nil,
            s3ExportPath: Swift.String? = nil
        )
        {
            self.preserveDefaultVertexLabels = preserveDefaultVertexLabels
            self.preserveEdgeIds = preserveEdgeIds
            self.s3ExportKmsKeyId = s3ExportKmsKeyId
            self.s3ExportPath = s3ExportPath
        }
    }

}

extension NeptuneGraphClientTypes.NodeStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case distinctOutgoingEdgeLabels
        case nodeProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels {
            var distinctOutgoingEdgeLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distinctOutgoingEdgeLabels)
            for string0 in distinctOutgoingEdgeLabels {
                try distinctOutgoingEdgeLabelsContainer.encode(string0)
            }
        }
        if let nodeProperties = nodeProperties {
            var nodePropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeProperties)
            for string0 in nodeProperties {
                try nodePropertiesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let nodePropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeProperties)
        var nodePropertiesDecoded0:[Swift.String]? = nil
        if let nodePropertiesContainer = nodePropertiesContainer {
            nodePropertiesDecoded0 = [Swift.String]()
            for string0 in nodePropertiesContainer {
                if let string0 = string0 {
                    nodePropertiesDecoded0?.append(string0)
                }
            }
        }
        nodeProperties = nodePropertiesDecoded0
        let distinctOutgoingEdgeLabelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .distinctOutgoingEdgeLabels)
        var distinctOutgoingEdgeLabelsDecoded0:[Swift.String]? = nil
        if let distinctOutgoingEdgeLabelsContainer = distinctOutgoingEdgeLabelsContainer {
            distinctOutgoingEdgeLabelsDecoded0 = [Swift.String]()
            for string0 in distinctOutgoingEdgeLabelsContainer {
                if let string0 = string0 {
                    distinctOutgoingEdgeLabelsDecoded0?.append(string0)
                }
            }
        }
        distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabelsDecoded0
    }
}

extension NeptuneGraphClientTypes {
    /// Information about a node.
    public struct NodeStructure: Swift.Equatable {
        /// The number of instances of this node.
        public var count: Swift.Int?
        /// The outgoing edge labels associated with this node.
        public var distinctOutgoingEdgeLabels: [Swift.String]?
        /// Properties associated with this node.
        public var nodeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            distinctOutgoingEdgeLabels: [Swift.String]? = nil,
            nodeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels
            self.nodeProperties = nodeProperties
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum PlanCacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PlanCacheType] {
            return [
                .auto,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlanCacheType(rawValue: rawValue) ?? PlanCacheType.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes {
    public enum PrivateGraphEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateGraphEndpointStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivateGraphEndpointStatus(rawValue: rawValue) ?? PrivateGraphEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.PrivateGraphEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details about a private graph endpoint.
    public struct PrivateGraphEndpointSummary: Swift.Equatable {
        /// The status of the private graph endpoint.
        /// This member is required.
        public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
        /// The subnet IDs associated with the private graph endpoint.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC endpoint.
        public var vpcEndpointId: Swift.String?
        /// The ID of the VPC in which the private graph endpoint is located.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum QueryLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case openCypher
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryLanguage] {
            return [
                .openCypher,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .openCypher: return "OPEN_CYPHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryLanguage(rawValue: rawValue) ?? QueryLanguage.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes {
    public enum QueryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelling
        case running
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryState] {
            return [
                .cancelling,
                .running,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelling: return "CANCELLING"
            case .running: return "RUNNING"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryState(rawValue: rawValue) ?? QueryState.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes {
    public enum QueryStateInput: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case cancelling
        case running
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStateInput] {
            return [
                .all,
                .cancelling,
                .running,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .cancelling: return "CANCELLING"
            case .running: return "RUNNING"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryStateInput(rawValue: rawValue) ?? QueryStateInput.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.QuerySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsed
        case id
        case queryString
        case state
        case waited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elapsed = self.elapsed {
            try encodeContainer.encode(elapsed, forKey: .elapsed)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let waited = self.waited {
            try encodeContainer.encode(waited, forKey: .waited)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let waitedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .waited)
        waited = waitedDecoded
        let elapsedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsed)
        elapsed = elapsedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.QueryState.self, forKey: .state)
        state = stateDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details of the query listed.
    public struct QuerySummary: Swift.Equatable {
        /// The running time of the query, in milliseconds.
        public var elapsed: Swift.Int?
        /// A string representation of the id of the query.
        public var id: Swift.String?
        /// The actual query text. The queryString may be truncated if the actual query string is too long.
        public var queryString: Swift.String?
        /// State of the query.
        public var state: NeptuneGraphClientTypes.QueryState?
        /// The amount of time, in milliseconds, the query has waited in the queue before being picked up by a worker thread.
        public var waited: Swift.Int?

        public init(
            elapsed: Swift.Int? = nil,
            id: Swift.String? = nil,
            queryString: Swift.String? = nil,
            state: NeptuneGraphClientTypes.QueryState? = nil,
            waited: Swift.Int? = nil
        )
        {
            self.elapsed = elapsed
            self.id = id
            self.queryString = queryString
            self.state = state
            self.waited = waited
        }
    }

}

extension ResetGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skipSnapshot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skipSnapshot = self.skipSnapshot {
            try encodeContainer.encode(skipSnapshot, forKey: .skipSnapshot)
        }
    }
}

extension ResetGraphInput {

    static func urlPathProvider(_ value: ResetGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct ResetGraphInput: Swift.Equatable {
    /// ID of the graph to reset.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Determines whether a final graph snapshot is created before the graph data is deleted. If set to true, no graph snapshot is created. If set to false, a graph snapshot is created before the data is deleted.
    /// This member is required.
    public var skipSnapshot: Swift.Bool?

    public init(
        graphIdentifier: Swift.String? = nil,
        skipSnapshot: Swift.Bool? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.skipSnapshot = skipSnapshot
    }
}

struct ResetGraphInputBody: Swift.Equatable {
    let skipSnapshot: Swift.Bool?
}

extension ResetGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skipSnapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skipSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipSnapshot)
        skipSnapshot = skipSnapshotDecoded
    }
}

extension ResetGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct ResetGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct ResetGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension ResetGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum ResetGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified resource could not be located.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreGraphFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let graphName = self.graphName {
            try encodeContainer.encode(graphName, forKey: .graphName)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension RestoreGraphFromSnapshotInput {

    static func urlPathProvider(_ value: RestoreGraphFromSnapshotInput) -> Swift.String? {
        guard let snapshotIdentifier = value.snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())/restore"
    }
}

public struct RestoreGraphFromSnapshotInput: Swift.Equatable {
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// A name for the new Neptune Analytics graph to be created from the snapshot. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Min =0, Max = 2, Default =1 Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot in question.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?
    /// Adds metadata tags to the snapshot. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphName: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        snapshotIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphName = graphName
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
    }
}

struct RestoreGraphFromSnapshotInputBody: Swift.Equatable {
    let graphName: Swift.String?
    let provisionedMemory: Swift.Int?
    let deletionProtection: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let replicaCount: Swift.Int?
    let publicConnectivity: Swift.Bool?
}

extension RestoreGraphFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphName)
        graphName = graphNameDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
    }
}

extension RestoreGraphFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreGraphFromSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct RestoreGraphFromSnapshotOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct RestoreGraphFromSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension RestoreGraphFromSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum RestoreGraphFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service quota was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quota code of the resource for which quota was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeded quota. Ex: Graph, Snapshot
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code that exceeded quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failOnError
        case format
        case importOptions
        case roleArn
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failOnError = self.failOnError {
            try encodeContainer.encode(failOnError, forKey: .failOnError)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let importOptions = self.importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

extension StartImportTaskInput {

    static func urlPathProvider(_ value: StartImportTaskInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/importtasks"
    }
}

public struct StartImportTaskInput: Swift.Equatable {
    /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
    public var failOnError: Swift.Bool?
    /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Options for how to perform an import.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?

    public init(
        failOnError: Swift.Bool? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphIdentifier: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.failOnError = failOnError
        self.format = format
        self.graphIdentifier = graphIdentifier
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
    }
}

struct StartImportTaskInputBody: Swift.Equatable {
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
    let failOnError: Swift.Bool?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
}

extension StartImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failOnError
        case format
        case importOptions
        case roleArn
        case source
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let failOnErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failOnError)
        failOnError = failOnErrorDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension StartImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.graphId = output.graphId
            self.importOptions = output.importOptions
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.taskId = output.taskId
        } else {
            self.format = nil
            self.graphId = nil
            self.importOptions = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.taskId = nil
        }
    }
}

public struct StartImportTaskOutput: Swift.Equatable {
    /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Options for how to perform an import.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

struct StartImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
}

extension StartImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case importOptions
        case roleArn
        case source
        case status
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
    }
}

enum StartImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags need to be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Neptune Analytics resource. The tags are metadata that are specified as a list of key-value pairs: Key (string) – A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$"). Value (string) – A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The exception was interrupted by throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request cannot be processed due to known reasons. Eg. partition full.
public struct UnprocessableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the unprocessable exception.
        /// This member is required.
        public internal(set) var reason: NeptuneGraphClientTypes.UnprocessableExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.UnprocessableExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct UnprocessableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: NeptuneGraphClientTypes.UnprocessableExceptionReason?
}

extension UnprocessableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.UnprocessableExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum UnprocessableExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalLimitExceeded
        case memoryLimitExceeded
        case partitionFull
        case queryTimeout
        case storageLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UnprocessableExceptionReason] {
            return [
                .internalLimitExceeded,
                .memoryLimitExceeded,
                .partitionFull,
                .queryTimeout,
                .storageLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalLimitExceeded: return "INTERNAL_LIMIT_EXCEEDED"
            case .memoryLimitExceeded: return "MEMORY_LIMIT_EXCEEDED"
            case .partitionFull: return "PARTITION_FULL"
            case .queryTimeout: return "QUERY_TIMEOUT"
            case .storageLimitExceeded: return "STORAGE_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnprocessableExceptionReason(rawValue: rawValue) ?? UnprocessableExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource whose tag needs to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys for the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case provisionedMemory
        case publicConnectivity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
    }
}

extension UpdateGraphInput {

    static func urlPathProvider(_ value: UpdateGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateGraphInput: Swift.Equatable {
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphIdentifier: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphIdentifier = graphIdentifier
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
    }
}

struct UpdateGraphInputBody: Swift.Equatable {
    let publicConnectivity: Swift.Bool?
    let provisionedMemory: Swift.Int?
    let deletionProtection: Swift.Bool?
}

extension UpdateGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case provisionedMemory
        case publicConnectivity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension UpdateGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct UpdateGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct UpdateGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension UpdateGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum UpdateGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the resource could not be validated.
        public internal(set) var reason: NeptuneGraphClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: NeptuneGraphClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badRequest
        case constraintViolation
        case illegalArgument
        case malformedQuery
        case queryCancelled
        case queryTooLarge
        case unsupportedOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .badRequest,
                .constraintViolation,
                .illegalArgument,
                .malformedQuery,
                .queryCancelled,
                .queryTooLarge,
                .unsupportedOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .constraintViolation: return "CONSTRAINT_VIOLATION"
            case .illegalArgument: return "ILLEGAL_ARGUMENT"
            case .malformedQuery: return "MALFORMED_QUERY"
            case .queryCancelled: return "QUERY_CANCELLED"
            case .queryTooLarge: return "QUERY_TOO_LARGE"
            case .unsupportedOperation: return "UNSUPPORTED_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.VectorSearchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dimension)
        dimension = dimensionDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public struct VectorSearchConfiguration: Swift.Equatable {
        /// The number of dimensions.
        /// This member is required.
        public var dimension: Swift.Int?

        public init(
            dimension: Swift.Int? = nil
        )
        {
            self.dimension = dimension
        }
    }

}
