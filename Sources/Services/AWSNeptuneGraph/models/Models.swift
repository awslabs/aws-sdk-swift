// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskIdentifier = taskIdentifier else {
            return nil
        }
        return "/importtasks/\(taskIdentifier.urlPercentEncoding())"
    }
}

public struct CancelImportTaskInput: Swift.Equatable {
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskIdentifier: Swift.String?

    public init(
        taskIdentifier: Swift.String? = nil
    )
    {
        self.taskIdentifier = taskIdentifier
    }
}

struct CancelImportTaskInputBody: Swift.Equatable {
}

extension CancelImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.graphId = output.graphId
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.taskId = output.taskId
        } else {
            self.format = nil
            self.graphId = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.taskId = nil
        }
    }
}

public struct CancelImportTaskOutput: Swift.Equatable {
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
    /// This member is required.
    public var source: Swift.String?
    /// Current status of the task. Status is CANCELLING when the import task is cancelled.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

struct CancelImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
}

extension CancelImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case roleArn
        case source
        case status
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a conflict is encountered.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        public internal(set) var reason: NeptuneGraphClientTypes.ConflictExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.ConflictExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: NeptuneGraphClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentModification
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case kmsKeyIdentifier
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
        case vectorSearchConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let graphName = self.graphName {
            try encodeContainer.encode(graphName, forKey: .graphName)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vectorSearchConfiguration = self.vectorSearchConfiguration {
            try encodeContainer.encode(vectorSearchConfiguration, forKey: .vectorSearchConfiguration)
        }
    }
}

extension CreateGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graphs"
    }
}

public struct CreateGraphInput: Swift.Equatable {
    /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
    public var deletionProtection: Swift.Bool?
    /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// Specifies a KMS key to use to encrypt data in the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    /// This member is required.
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Min =0, Max = 2, Default =1
    public var replicaCount: Swift.Int?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphName: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphName = graphName
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.tags = tags
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct CreateGraphInputBody: Swift.Equatable {
    let graphName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let publicConnectivity: Swift.Bool?
    let kmsKeyIdentifier: Swift.String?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let deletionProtection: Swift.Bool?
    let provisionedMemory: Swift.Int?
}

extension CreateGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case kmsKeyIdentifier
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphName)
        graphName = graphNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
    }
}

extension CreateGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct CreateGraphOutput: Swift.Equatable {
    /// The ARN of the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph software.
    public var buildNumber: Swift.String?
    /// The time when the graph was created.
    public var createTime: ClientRuntime.Date?
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The ID of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the KMS key used to encrypt data in the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs IAM authenticated.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs.
    public var replicaCount: Swift.Int?
    /// The ID of the source graph.
    public var sourceSnapshotId: Swift.String?
    /// The current status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason the status was given.
    public var statusReason: Swift.String?
    /// The vector-search configuration for the graph, which specifies the vector dimension to use in the vector index, if any.
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct CreateGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension CreateGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum CreateGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGraphSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphIdentifier
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphIdentifier = self.graphIdentifier {
            try encodeContainer.encode(graphIdentifier, forKey: .graphIdentifier)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGraphSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/snapshots"
    }
}

public struct CreateGraphSnapshotInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?

    public init(
        graphIdentifier: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct CreateGraphSnapshotInputBody: Swift.Equatable {
    let graphIdentifier: Swift.String?
    let snapshotName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGraphSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphIdentifier
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphIdentifier)
        graphIdentifier = graphIdentifierDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGraphSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.snapshotCreateTime = output.snapshotCreateTime
            self.sourceGraphId = output.sourceGraphId
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.snapshotCreateTime = nil
            self.sourceGraphId = nil
            self.status = nil
        }
    }
}

public struct CreateGraphSnapshotOutput: Swift.Equatable {
    /// The ARN of the snapshot created.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the snapshot created.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the snapshot created.
    /// This member is required.
    public var name: Swift.String?
    /// The snapshot creation time
    public var snapshotCreateTime: ClientRuntime.Date?
    /// The Id of the Neptune Analytics graph from which the snapshot is created.
    public var sourceGraphId: Swift.String?
    /// The current state of the snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: ClientRuntime.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

struct CreateGraphSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let sourceGraphId: Swift.String?
    let snapshotCreateTime: ClientRuntime.Date?
    let status: NeptuneGraphClientTypes.SnapshotStatus?
    let kmsKeyIdentifier: Swift.String?
}

extension CreateGraphSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum CreateGraphSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGraphUsingImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case failOnError
        case format
        case graphName
        case importOptions
        case kmsKeyIdentifier
        case maxProvisionedMemory
        case minProvisionedMemory
        case publicConnectivity
        case replicaCount
        case roleArn
        case source
        case tags
        case vectorSearchConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let failOnError = self.failOnError {
            try encodeContainer.encode(failOnError, forKey: .failOnError)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let graphName = self.graphName {
            try encodeContainer.encode(graphName, forKey: .graphName)
        }
        if let importOptions = self.importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let maxProvisionedMemory = self.maxProvisionedMemory {
            try encodeContainer.encode(maxProvisionedMemory, forKey: .maxProvisionedMemory)
        }
        if let minProvisionedMemory = self.minProvisionedMemory {
            try encodeContainer.encode(minProvisionedMemory, forKey: .minProvisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vectorSearchConfiguration = self.vectorSearchConfiguration {
            try encodeContainer.encode(vectorSearchConfiguration, forKey: .vectorSearchConfiguration)
        }
    }
}

extension CreateGraphUsingImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/importtasks"
    }
}

public struct CreateGraphUsingImportTaskInput: Swift.Equatable {
    /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
    public var deletionProtection: Swift.Bool?
    /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
    public var failOnError: Swift.Bool?
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// Specifies a KMS key to use to encrypt data imported into the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The maximum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 1024, or the approved upper limit for your account. If both the minimum and maximum values are specified, the max of the min-provisioned-memory and max-provisioned memory is used to create the graph. If neither value is specified 128 m-NCUs are used.
    public var maxProvisionedMemory: Swift.Int?
    /// The minimum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 128
    public var minProvisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs to provision on the new graph after import. Default = 0, Min = 0, Max = 2.
    public var replicaCount: Swift.Int?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        deletionProtection: Swift.Bool? = nil,
        failOnError: Swift.Bool? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphName: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        maxProvisionedMemory: Swift.Int? = nil,
        minProvisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.failOnError = failOnError
        self.format = format
        self.graphName = graphName
        self.importOptions = importOptions
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.maxProvisionedMemory = maxProvisionedMemory
        self.minProvisionedMemory = minProvisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.roleArn = roleArn
        self.source = source
        self.tags = tags
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct CreateGraphUsingImportTaskInputBody: Swift.Equatable {
    let graphName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let publicConnectivity: Swift.Bool?
    let kmsKeyIdentifier: Swift.String?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let deletionProtection: Swift.Bool?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
    let maxProvisionedMemory: Swift.Int?
    let minProvisionedMemory: Swift.Int?
    let failOnError: Swift.Bool?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
}

extension CreateGraphUsingImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case failOnError
        case format
        case graphName
        case importOptions
        case kmsKeyIdentifier
        case maxProvisionedMemory
        case minProvisionedMemory
        case publicConnectivity
        case replicaCount
        case roleArn
        case source
        case tags
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphName)
        graphName = graphNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let maxProvisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxProvisionedMemory)
        maxProvisionedMemory = maxProvisionedMemoryDecoded
        let minProvisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedMemory)
        minProvisionedMemory = minProvisionedMemoryDecoded
        let failOnErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failOnError)
        failOnError = failOnErrorDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateGraphUsingImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGraphUsingImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.graphId = output.graphId
            self.importOptions = output.importOptions
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.taskId = output.taskId
        } else {
            self.format = nil
            self.graphId = nil
            self.importOptions = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.taskId = nil
        }
    }
}

public struct CreateGraphUsingImportTaskOutput: Swift.Equatable {
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

struct CreateGraphUsingImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
}

extension CreateGraphUsingImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case importOptions
        case roleArn
        case source
        case status
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
    }
}

enum CreateGraphUsingImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePrivateGraphEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetIds
        case vpcId
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for securitygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
    }
}

extension CreatePrivateGraphEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints"
    }
}

public struct CreatePrivateGraphEndpointInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Subnets in which private graph endpoint ENIs are created.
    public var subnetIds: [Swift.String]?
    /// The VPC in which the private graph endpoint needs to be created.
    public var vpcId: Swift.String?
    /// Security groups to be attached to the private graph endpoint..
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        graphIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.subnetIds = subnetIds
        self.vpcId = vpcId
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreatePrivateGraphEndpointInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
}

extension CreatePrivateGraphEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetIds
        case vpcId
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
    }
}

extension CreatePrivateGraphEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePrivateGraphEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.subnetIds = output.subnetIds
            self.vpcEndpointId = output.vpcEndpointId
            self.vpcId = output.vpcId
        } else {
            self.status = nil
            self.subnetIds = nil
            self.vpcEndpointId = nil
            self.vpcId = nil
        }
    }
}

public struct CreatePrivateGraphEndpointOutput: Swift.Equatable {
    /// Status of the private graph endpoint.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// Subnets in which the private graph endpoint ENIs are created.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Endpoint ID of the prviate grpah endpoint.
    public var vpcEndpointId: Swift.String?
    /// VPC in which the private graph endpoint is created.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

struct CreatePrivateGraphEndpointOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    let vpcEndpointId: Swift.String?
}

extension CreatePrivateGraphEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

enum CreatePrivateGraphEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGraphInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let skipSnapshot = skipSnapshot else {
                let message = "Creating a URL Query Item failed. skipSnapshot is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let skipSnapshotQueryItem = ClientRuntime.URLQueryItem(name: "skipSnapshot".urlPercentEncoding(), value: Swift.String(skipSnapshot).urlPercentEncoding())
            items.append(skipSnapshotQueryItem)
            return items
        }
    }
}

extension DeleteGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteGraphInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Determines whether a final graph snapshot is created before the graph is deleted. If true is specified, no graph snapshot is created. If false is specified, a graph snapshot is created before the graph is deleted.
    /// This member is required.
    public var skipSnapshot: Swift.Bool?

    public init(
        graphIdentifier: Swift.String? = nil,
        skipSnapshot: Swift.Bool? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.skipSnapshot = skipSnapshot
    }
}

struct DeleteGraphInputBody: Swift.Equatable {
}

extension DeleteGraphInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct DeleteGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number associated with the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection was enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if the graph was recovered from a snapshot.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason for the status of the graph.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct DeleteGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension DeleteGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum DeleteGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGraphSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotIdentifier = snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteGraphSnapshotInput: Swift.Equatable {
    /// ID of the graph snapshot to be deleted.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?

    public init(
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotIdentifier = snapshotIdentifier
    }
}

struct DeleteGraphSnapshotInputBody: Swift.Equatable {
}

extension DeleteGraphSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGraphSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGraphSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.snapshotCreateTime = output.snapshotCreateTime
            self.sourceGraphId = output.sourceGraphId
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.snapshotCreateTime = nil
            self.sourceGraphId = nil
            self.status = nil
        }
    }
}

public struct DeleteGraphSnapshotOutput: Swift.Equatable {
    /// The ARN of the graph snapshot.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the graph snapshot.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt the snapshot.
    public var kmsKeyIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The time when the snapshot was created.
    public var snapshotCreateTime: ClientRuntime.Date?
    /// The graph identifier for the graph from which the snapshot was created.
    public var sourceGraphId: Swift.String?
    /// The status of the graph snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: ClientRuntime.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

struct DeleteGraphSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let sourceGraphId: Swift.String?
    let snapshotCreateTime: ClientRuntime.Date?
    let status: NeptuneGraphClientTypes.SnapshotStatus?
    let kmsKeyIdentifier: Swift.String?
}

extension DeleteGraphSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum DeleteGraphSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePrivateGraphEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        guard let vpcId = vpcId else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints/\(vpcId.urlPercentEncoding())"
    }
}

public struct DeletePrivateGraphEndpointInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.vpcId = vpcId
    }
}

struct DeletePrivateGraphEndpointInputBody: Swift.Equatable {
}

extension DeletePrivateGraphEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePrivateGraphEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePrivateGraphEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.subnetIds = output.subnetIds
            self.vpcEndpointId = output.vpcEndpointId
            self.vpcId = output.vpcId
        } else {
            self.status = nil
            self.subnetIds = nil
            self.vpcEndpointId = nil
            self.vpcId = nil
        }
    }
}

public struct DeletePrivateGraphEndpointOutput: Swift.Equatable {
    /// The status of the delete operation.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// The subnet IDs involved.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC endpoint that was deleted.
    public var vpcEndpointId: Swift.String?
    /// The ID of the VPC where the private endpoint was deleted.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

struct DeletePrivateGraphEndpointOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    let vpcEndpointId: Swift.String?
}

extension DeletePrivateGraphEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

enum DeletePrivateGraphEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptuneGraphClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case openCypher
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .openCypher,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .openCypher: return "OPEN_CYPHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct GetGraphInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
    }
}

struct GetGraphInputBody: Swift.Equatable {
}

extension GetGraphInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct GetGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if it was created from a snapshot.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct GetGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension GetGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum GetGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGraphSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotIdentifier = snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())"
    }
}

public struct GetGraphSnapshotInput: Swift.Equatable {
    /// The ID of the snapshot to retrieve.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?

    public init(
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotIdentifier = snapshotIdentifier
    }
}

struct GetGraphSnapshotInputBody: Swift.Equatable {
}

extension GetGraphSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGraphSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGraphSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.snapshotCreateTime = output.snapshotCreateTime
            self.sourceGraphId = output.sourceGraphId
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.snapshotCreateTime = nil
            self.sourceGraphId = nil
            self.status = nil
        }
    }
}

public struct GetGraphSnapshotOutput: Swift.Equatable {
    /// The ARN of the graph snapshot.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the graph snapshot.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt the snapshot.
    public var kmsKeyIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The time when the snapshot was created.
    public var snapshotCreateTime: ClientRuntime.Date?
    /// The graph identifier for the graph for which a snapshot is to be created.
    public var sourceGraphId: Swift.String?
    /// The status of the graph snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: ClientRuntime.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

struct GetGraphSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let sourceGraphId: Swift.String?
    let snapshotCreateTime: ClientRuntime.Date?
    let status: NeptuneGraphClientTypes.SnapshotStatus?
    let kmsKeyIdentifier: Swift.String?
}

extension GetGraphSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

enum GetGraphSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskIdentifier = taskIdentifier else {
            return nil
        }
        return "/importtasks/\(taskIdentifier.urlPercentEncoding())"
    }
}

public struct GetImportTaskInput: Swift.Equatable {
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskIdentifier: Swift.String?

    public init(
        taskIdentifier: Swift.String? = nil
    )
    {
        self.taskIdentifier = taskIdentifier
    }
}

struct GetImportTaskInputBody: Swift.Equatable {
}

extension GetImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.attemptNumber = output.attemptNumber
            self.format = output.format
            self.graphId = output.graphId
            self.importOptions = output.importOptions
            self.importTaskDetails = output.importTaskDetails
            self.roleArn = output.roleArn
            self.source = output.source
            self.status = output.status
            self.statusReason = output.statusReason
            self.taskId = output.taskId
        } else {
            self.attemptNumber = nil
            self.format = nil
            self.graphId = nil
            self.importOptions = nil
            self.importTaskDetails = nil
            self.roleArn = nil
            self.source = nil
            self.status = nil
            self.statusReason = nil
            self.taskId = nil
        }
    }
}

public struct GetImportTaskOutput: Swift.Equatable {
    /// The number of the current attempt to execute the import task.
    public var attemptNumber: Swift.Int?
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// Contains details about the specified import task.
    public var importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task:
    ///
    /// * INITIALIZING – The necessary resources needed to create the graph are being prepared.
    ///
    /// * ANALYZING_DATA – The data is being analyzed to determine the optimal infrastructure configuration for the new graph.
    ///
    /// * RE_PROVISIONING – The data did not fit into the provisioned graph, so it is being re-provisioned with more capacity.
    ///
    /// * IMPORTING – The data is being loaded.
    ///
    /// * ERROR_ENCOUNTERED – An error has been encountered while trying to create the graph and import the data.
    ///
    /// * ERROR_ENCOUNTERED_ROLLING_BACK – Because of the error that was encountered, the graph is being rolled back and all its resources released.
    ///
    /// * SUCCEEDED – Graph creation and data loading succeeded.
    ///
    /// * FAILED – Graph creation or data loading failed. When the status is FAILED, you can use get-graphs to get more information about the state of the graph.
    ///
    /// * CANCELLING – Because you cancelled the import task, cancellation is in progress.
    ///
    /// * CANCELLED – You have successfully cancelled the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The reason that the import task has this status value.
    public var statusReason: Swift.String?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        attemptNumber: Swift.Int? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        statusReason: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.attemptNumber = attemptNumber
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.importTaskDetails = importTaskDetails
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.statusReason = statusReason
        self.taskId = taskId
    }
}

struct GetImportTaskOutputBody: Swift.Equatable {
    let graphId: Swift.String?
    let taskId: Swift.String?
    let source: Swift.String?
    let format: NeptuneGraphClientTypes.Format?
    let roleArn: Swift.String?
    let status: NeptuneGraphClientTypes.ImportTaskStatus?
    let importOptions: NeptuneGraphClientTypes.ImportOptions?
    let importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails?
    let attemptNumber: Swift.Int?
    let statusReason: Swift.String?
}

extension GetImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attemptNumber
        case format
        case graphId
        case importOptions
        case importTaskDetails
        case roleArn
        case source
        case status
        case statusReason
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let importTaskDetailsDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskDetails.self, forKey: .importTaskDetails)
        importTaskDetails = importTaskDetailsDecoded
        let attemptNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attemptNumber)
        attemptNumber = attemptNumberDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

enum GetImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPrivateGraphEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        guard let vpcId = vpcId else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints/\(vpcId.urlPercentEncoding())"
    }
}

public struct GetPrivateGraphEndpointInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.vpcId = vpcId
    }
}

struct GetPrivateGraphEndpointInputBody: Swift.Equatable {
}

extension GetPrivateGraphEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPrivateGraphEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPrivateGraphEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.subnetIds = output.subnetIds
            self.vpcEndpointId = output.vpcEndpointId
            self.vpcId = output.vpcId
        } else {
            self.status = nil
            self.subnetIds = nil
            self.vpcEndpointId = nil
            self.vpcId = nil
        }
    }
}

public struct GetPrivateGraphEndpointOutput: Swift.Equatable {
    /// The current status of the private endpoint.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// The subnet IDs involved.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the private endpoint.
    public var vpcEndpointId: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

struct GetPrivateGraphEndpointOutputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    let vpcEndpointId: Swift.String?
}

extension GetPrivateGraphEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

enum GetPrivateGraphEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptuneGraphClientTypes.GraphSnapshotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case kmsKeyIdentifier
        case name
        case snapshotCreateTime
        case sourceGraphId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snapshotCreateTime = self.snapshotCreateTime {
            try encodeContainer.encodeTimestamp(snapshotCreateTime, format: .epochSeconds, forKey: .snapshotCreateTime)
        }
        if let sourceGraphId = self.sourceGraphId {
            try encodeContainer.encode(sourceGraphId, forKey: .sourceGraphId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceGraphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGraphId)
        sourceGraphId = sourceGraphIdDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details about a graph snapshot.
    public struct GraphSnapshotSummary: Swift.Equatable {
        /// The ARN of the graph snapshot.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique identifier of the graph snapshot.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public var kmsKeyIdentifier: Swift.String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        /// This member is required.
        public var name: Swift.String?
        /// The time when the snapshot was created.
        public var snapshotCreateTime: ClientRuntime.Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public var sourceGraphId: Swift.String?
        /// The status of the graph snapshot.
        public var status: NeptuneGraphClientTypes.SnapshotStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyIdentifier: Swift.String? = nil,
            name: Swift.String? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            sourceGraphId: Swift.String? = nil,
            status: NeptuneGraphClientTypes.SnapshotStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum GraphStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case resetting
        case snapshotting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .resetting,
                .snapshotting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .resetting: return "RESETTING"
            case .snapshotting: return "SNAPSHOTTING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GraphStatus(rawValue: rawValue) ?? GraphStatus.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.GraphSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Summary details about a graph.
    public struct GraphSummary: Swift.Equatable {
        /// The ARN associated with the graph.
        /// This member is required.
        public var arn: Swift.String?
        /// If true, deletion protection is enabled for the graph.
        public var deletionProtection: Swift.Bool?
        /// The graph endpoint.
        public var endpoint: Swift.String?
        /// The unique identifier of the graph.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public var kmsKeyIdentifier: Swift.String?
        /// The name of the graph.
        /// This member is required.
        public var name: Swift.String?
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public var provisionedMemory: Swift.Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public var publicConnectivity: Swift.Bool?
        /// The number of replicas for the graph.
        public var replicaCount: Swift.Int?
        /// The status of the graph.
        public var status: NeptuneGraphClientTypes.GraphStatus?

        public init(
            arn: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyIdentifier: Swift.String? = nil,
            name: Swift.String? = nil,
            provisionedMemory: Swift.Int? = nil,
            publicConnectivity: Swift.Bool? = nil,
            replicaCount: Swift.Int? = nil,
            status: NeptuneGraphClientTypes.GraphStatus? = nil
        )
        {
            self.arn = arn
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.status = status
        }
    }

}

extension NeptuneGraphClientTypes.ImportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case neptune
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .neptune(neptune):
                try container.encode(neptune, forKey: .neptune)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let neptuneDecoded = try values.decodeIfPresent(NeptuneGraphClientTypes.NeptuneImportOptions.self, forKey: .neptune)
        if let neptune = neptuneDecoded {
            self = .neptune(neptune)
            return
        }
        self = .sdkUnknown("")
    }
}

extension NeptuneGraphClientTypes {
    /// Options for how to perform an import.
    public enum ImportOptions: Swift.Equatable {
        /// Options for importing data from a Neptune database.
        case neptune(NeptuneGraphClientTypes.NeptuneImportOptions)
        case sdkUnknown(Swift.String)
    }

}

extension NeptuneGraphClientTypes.ImportTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dictionaryEntryCount
        case errorCount
        case errorDetails
        case progressPercentage
        case startTime
        case statementCount
        case status
        case timeElapsedSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dictionaryEntryCount = self.dictionaryEntryCount {
            try encodeContainer.encode(dictionaryEntryCount, forKey: .dictionaryEntryCount)
        }
        if let errorCount = self.errorCount {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let progressPercentage = self.progressPercentage {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statementCount = self.statementCount {
            try encodeContainer.encode(statementCount, forKey: .statementCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timeElapsedSeconds = self.timeElapsedSeconds {
            try encodeContainer.encode(timeElapsedSeconds, forKey: .timeElapsedSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let timeElapsedSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeElapsedSeconds)
        timeElapsedSeconds = timeElapsedSecondsDecoded
        let progressPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercentage)
        progressPercentage = progressPercentageDecoded
        let errorCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let statementCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statementCount)
        statementCount = statementCountDecoded
        let dictionaryEntryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dictionaryEntryCount)
        dictionaryEntryCount = dictionaryEntryCountDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Contains details about an import task.
    public struct ImportTaskDetails: Swift.Equatable {
        /// The number of dictionary entries in the import task.
        /// This member is required.
        public var dictionaryEntryCount: Swift.Int?
        /// The number of errors encountered so far.
        /// This member is required.
        public var errorCount: Swift.Int?
        /// Details about the errors that have been encountered.
        public var errorDetails: Swift.String?
        /// The percentage progress so far.
        /// This member is required.
        public var progressPercentage: Swift.Int?
        /// Time at which the import task started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The number of statements in the import task.
        /// This member is required.
        public var statementCount: Swift.Int?
        /// Status of the import task.
        /// This member is required.
        public var status: Swift.String?
        /// Seconds elapsed since the import task started.
        /// This member is required.
        public var timeElapsedSeconds: Swift.Int?

        public init(
            dictionaryEntryCount: Swift.Int? = nil,
            errorCount: Swift.Int? = nil,
            errorDetails: Swift.String? = nil,
            progressPercentage: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            statementCount: Swift.Int? = nil,
            status: Swift.String? = nil,
            timeElapsedSeconds: Swift.Int? = nil
        )
        {
            self.dictionaryEntryCount = dictionaryEntryCount
            self.errorCount = errorCount
            self.errorDetails = errorDetails
            self.progressPercentage = progressPercentage
            self.startTime = startTime
            self.statementCount = statementCount
            self.status = status
            self.timeElapsedSeconds = timeElapsedSeconds
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum ImportTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analyzingData
        case cancelled
        case cancelling
        case exporting
        case failed
        case importing
        case initializing
        case reprovisioning
        case rollingBack
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskStatus] {
            return [
                .analyzingData,
                .cancelled,
                .cancelling,
                .exporting,
                .failed,
                .importing,
                .initializing,
                .reprovisioning,
                .rollingBack,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analyzingData: return "ANALYZING_DATA"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .exporting: return "EXPORTING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .initializing: return "INITIALIZING"
            case .reprovisioning: return "REPROVISIONING"
            case .rollingBack: return "ROLLING_BACK"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportTaskStatus(rawValue: rawValue) ?? ImportTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.ImportTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case graphId
        case roleArn
        case source
        case status
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let graphId = self.graphId {
            try encodeContainer.encode(graphId, forKey: .graphId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphId)
        graphId = graphIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let formatDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ImportTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details about an import task.
    public struct ImportTaskSummary: Swift.Equatable {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
        public var format: NeptuneGraphClientTypes.Format?
        /// The unique identifier of the Neptune Analytics graph.
        public var graphId: Swift.String?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        /// This member is required.
        public var source: Swift.String?
        /// Status of the import task.
        /// This member is required.
        public var status: NeptuneGraphClientTypes.ImportTaskStatus?
        /// The unique identifier of the import task.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            format: NeptuneGraphClientTypes.Format? = nil,
            graphId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            source: Swift.String? = nil,
            status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.format = format
            self.graphId = graphId
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A failure occurred on the server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListGraphSnapshotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let graphIdentifier = graphIdentifier {
                let graphIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "graphIdentifier".urlPercentEncoding(), value: Swift.String(graphIdentifier).urlPercentEncoding())
                items.append(graphIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListGraphSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/snapshots"
    }
}

public struct ListGraphSnapshotsInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    public var graphIdentifier: Swift.String?
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphSnapshotsInputBody: Swift.Equatable {
}

extension ListGraphSnapshotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGraphSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphSnapshots = output.graphSnapshots
            self.nextToken = output.nextToken
        } else {
            self.graphSnapshots = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphSnapshotsOutput: Swift.Equatable {
    /// The requested list of snapshots.
    /// This member is required.
    public var graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphSnapshots = graphSnapshots
        self.nextToken = nextToken
    }
}

struct ListGraphSnapshotsOutputBody: Swift.Equatable {
    let graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]?
    let nextToken: Swift.String?
}

extension ListGraphSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphSnapshots
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphSnapshotsContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.GraphSnapshotSummary?].self, forKey: .graphSnapshots)
        var graphSnapshotsDecoded0:[NeptuneGraphClientTypes.GraphSnapshotSummary]? = nil
        if let graphSnapshotsContainer = graphSnapshotsContainer {
            graphSnapshotsDecoded0 = [NeptuneGraphClientTypes.GraphSnapshotSummary]()
            for structure0 in graphSnapshotsContainer {
                if let structure0 = structure0 {
                    graphSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        graphSnapshots = graphSnapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGraphSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGraphsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGraphsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graphs"
    }
}

public struct ListGraphsInput: Swift.Equatable {
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphsInputBody: Swift.Equatable {
}

extension ListGraphsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGraphsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGraphsOutputBody = try responseDecoder.decode(responseBody: data)
            self.graphs = output.graphs
            self.nextToken = output.nextToken
        } else {
            self.graphs = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphsOutput: Swift.Equatable {
    /// A list of the graphs.
    /// This member is required.
    public var graphs: [NeptuneGraphClientTypes.GraphSummary]?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphs: [NeptuneGraphClientTypes.GraphSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphs = graphs
        self.nextToken = nextToken
    }
}

struct ListGraphsOutputBody: Swift.Equatable {
    let graphs: [NeptuneGraphClientTypes.GraphSummary]?
    let nextToken: Swift.String?
}

extension ListGraphsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphsContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.GraphSummary?].self, forKey: .graphs)
        var graphsDecoded0:[NeptuneGraphClientTypes.GraphSummary]? = nil
        if let graphsContainer = graphsContainer {
            graphsDecoded0 = [NeptuneGraphClientTypes.GraphSummary]()
            for structure0 in graphsContainer {
                if let structure0 = structure0 {
                    graphsDecoded0?.append(structure0)
                }
            }
        }
        graphs = graphsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGraphsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListImportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/importtasks"
    }
}

public struct ListImportTasksInput: Swift.Equatable {
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportTasksInputBody: Swift.Equatable {
}

extension ListImportTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListImportTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListImportTasksOutput: Swift.Equatable {
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?
    /// The requested list of import tasks.
    /// This member is required.
    public var tasks: [NeptuneGraphClientTypes.ImportTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [NeptuneGraphClientTypes.ImportTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListImportTasksOutputBody: Swift.Equatable {
    let tasks: [NeptuneGraphClientTypes.ImportTaskSummary]?
    let nextToken: Swift.String?
}

extension ListImportTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.ImportTaskSummary?].self, forKey: .tasks)
        var tasksDecoded0:[NeptuneGraphClientTypes.ImportTaskSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [NeptuneGraphClientTypes.ImportTaskSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrivateGraphEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPrivateGraphEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints"
    }
}

public struct ListPrivateGraphEndpointsInput: Swift.Equatable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPrivateGraphEndpointsInputBody: Swift.Equatable {
}

extension ListPrivateGraphEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPrivateGraphEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrivateGraphEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.privateGraphEndpoints = output.privateGraphEndpoints
        } else {
            self.nextToken = nil
            self.privateGraphEndpoints = nil
        }
    }
}

public struct ListPrivateGraphEndpointsOutput: Swift.Equatable {
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?
    /// A list of private endpoints for the specified Neptune Analytics graph.
    /// This member is required.
    public var privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privateGraphEndpoints = privateGraphEndpoints
    }
}

struct ListPrivateGraphEndpointsOutputBody: Swift.Equatable {
    let privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListPrivateGraphEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case privateGraphEndpoints
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateGraphEndpointsContainer = try containerValues.decodeIfPresent([NeptuneGraphClientTypes.PrivateGraphEndpointSummary?].self, forKey: .privateGraphEndpoints)
        var privateGraphEndpointsDecoded0:[NeptuneGraphClientTypes.PrivateGraphEndpointSummary]? = nil
        if let privateGraphEndpointsContainer = privateGraphEndpointsContainer {
            privateGraphEndpointsDecoded0 = [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]()
            for structure0 in privateGraphEndpointsContainer {
                if let structure0 = structure0 {
                    privateGraphEndpointsDecoded0?.append(structure0)
                }
            }
        }
        privateGraphEndpoints = privateGraphEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPrivateGraphEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of metadata tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NeptuneGraphClientTypes.NeptuneImportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preserveDefaultVertexLabels
        case preserveEdgeIds
        case s3ExportKmsKeyId
        case s3ExportPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preserveDefaultVertexLabels = self.preserveDefaultVertexLabels {
            try encodeContainer.encode(preserveDefaultVertexLabels, forKey: .preserveDefaultVertexLabels)
        }
        if let preserveEdgeIds = self.preserveEdgeIds {
            try encodeContainer.encode(preserveEdgeIds, forKey: .preserveEdgeIds)
        }
        if let s3ExportKmsKeyId = self.s3ExportKmsKeyId {
            try encodeContainer.encode(s3ExportKmsKeyId, forKey: .s3ExportKmsKeyId)
        }
        if let s3ExportPath = self.s3ExportPath {
            try encodeContainer.encode(s3ExportPath, forKey: .s3ExportPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ExportPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ExportPath)
        s3ExportPath = s3ExportPathDecoded
        let s3ExportKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ExportKmsKeyId)
        s3ExportKmsKeyId = s3ExportKmsKeyIdDecoded
        let preserveDefaultVertexLabelsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveDefaultVertexLabels)
        preserveDefaultVertexLabels = preserveDefaultVertexLabelsDecoded
        let preserveEdgeIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveEdgeIds)
        preserveEdgeIds = preserveEdgeIdsDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Options for how to import Neptune data.
    public struct NeptuneImportOptions: Swift.Equatable {
        /// Neptune Analytics supports label-less vertices and no labels are assigned unless one is explicitly provided. Neptune assigns default labels when none is explicitly provided. When importing the data into Neptune Analytics, the default vertex labels can be omitted by setting preserveDefaultVertexLabels to false. Note that if the vertex only has default labels, and has no other properties or edges, then the vertex will effectively not get imported into Neptune Analytics when preserveDefaultVertexLabels is set to false.
        public var preserveDefaultVertexLabels: Swift.Bool?
        /// Neptune Analytics currently does not support user defined edge ids. The edge ids are not imported by default. They are imported if preserveEdgeIds is set to true, and ids are stored as properties on the relationships with the property name neptuneEdgeId.
        public var preserveEdgeIds: Swift.Bool?
        /// The KMS key to use to encrypt data in the S3 bucket where the graph data is exported
        /// This member is required.
        public var s3ExportKmsKeyId: Swift.String?
        /// The path to an S3 bucket from which to import data.
        /// This member is required.
        public var s3ExportPath: Swift.String?

        public init(
            preserveDefaultVertexLabels: Swift.Bool? = nil,
            preserveEdgeIds: Swift.Bool? = nil,
            s3ExportKmsKeyId: Swift.String? = nil,
            s3ExportPath: Swift.String? = nil
        )
        {
            self.preserveDefaultVertexLabels = preserveDefaultVertexLabels
            self.preserveEdgeIds = preserveEdgeIds
            self.s3ExportKmsKeyId = s3ExportKmsKeyId
            self.s3ExportPath = s3ExportPath
        }
    }

}

extension NeptuneGraphClientTypes {
    public enum PrivateGraphEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateGraphEndpointStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivateGraphEndpointStatus(rawValue: rawValue) ?? PrivateGraphEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.PrivateGraphEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case subnetIds
        case vpcEndpointId
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.PrivateGraphEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Details about a private graph endpoint.
    public struct PrivateGraphEndpointSummary: Swift.Equatable {
        /// The status of the private graph endpoint.
        /// This member is required.
        public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
        /// The subnet IDs associated with the private graph endpoint.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC endpoint.
        public var vpcEndpointId: Swift.String?
        /// The ID of the VPC in which the private graph endpoint is located.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension ResetGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skipSnapshot
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skipSnapshot = self.skipSnapshot {
            try encodeContainer.encode(skipSnapshot, forKey: .skipSnapshot)
        }
    }
}

extension ResetGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct ResetGraphInput: Swift.Equatable {
    /// ID of the graph to reset.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Determines whether a final graph snapshot is created before the graph data is deleted. If set to true, no graph snapshot is created. If set to false, a graph snapshot is created before the data is deleted.
    /// This member is required.
    public var skipSnapshot: Swift.Bool?

    public init(
        graphIdentifier: Swift.String? = nil,
        skipSnapshot: Swift.Bool? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.skipSnapshot = skipSnapshot
    }
}

struct ResetGraphInputBody: Swift.Equatable {
    let skipSnapshot: Swift.Bool?
}

extension ResetGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skipSnapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skipSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipSnapshot)
        skipSnapshot = skipSnapshotDecoded
    }
}

extension ResetGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct ResetGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct ResetGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension ResetGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum ResetGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified resource could not be located.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreGraphFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let graphName = self.graphName {
            try encodeContainer.encode(graphName, forKey: .graphName)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
        if let replicaCount = self.replicaCount {
            try encodeContainer.encode(replicaCount, forKey: .replicaCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension RestoreGraphFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotIdentifier = snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())/restore"
    }
}

public struct RestoreGraphFromSnapshotInput: Swift.Equatable {
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// A name for the new Neptune Analytics graph to be created from the snapshot. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs IAM authenticated. (true to enable, or false to disable).
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Min =0, Max = 2, Default =1
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot in question.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?
    /// Adds metadata tags to the snapshot. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphName: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        snapshotIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphName = graphName
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
    }
}

struct RestoreGraphFromSnapshotInputBody: Swift.Equatable {
    let graphName: Swift.String?
    let provisionedMemory: Swift.Int?
    let deletionProtection: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let replicaCount: Swift.Int?
    let publicConnectivity: Swift.Bool?
}

extension RestoreGraphFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case graphName
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphName)
        graphName = graphNameDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
    }
}

extension RestoreGraphFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreGraphFromSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct RestoreGraphFromSnapshotOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct RestoreGraphFromSnapshotOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension RestoreGraphFromSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum RestoreGraphFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service quota was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quota code of the resource for which quota was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeded quota. Ex: Graph, Snapshot
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code that exceeded quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags need to be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Neptune Analytics resource. The tags are metadata that are specified as a list of key-value pairs: Key (string) – A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$"). Value (string) – A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The exception was interrupted by throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource whose tag needs to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys for the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case provisionedMemory
        case publicConnectivity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let provisionedMemory = self.provisionedMemory {
            try encodeContainer.encode(provisionedMemory, forKey: .provisionedMemory)
        }
        if let publicConnectivity = self.publicConnectivity {
            try encodeContainer.encode(publicConnectivity, forKey: .publicConnectivity)
        }
    }
}

extension UpdateGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let graphIdentifier = graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateGraphInput: Swift.Equatable {
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphIdentifier: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphIdentifier = graphIdentifier
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
    }
}

struct UpdateGraphInputBody: Swift.Equatable {
    let publicConnectivity: Swift.Bool?
    let provisionedMemory: Swift.Int?
    let deletionProtection: Swift.Bool?
}

extension UpdateGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection
        case provisionedMemory
        case publicConnectivity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension UpdateGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.buildNumber = output.buildNumber
            self.createTime = output.createTime
            self.deletionProtection = output.deletionProtection
            self.endpoint = output.endpoint
            self.id = output.id
            self.kmsKeyIdentifier = output.kmsKeyIdentifier
            self.name = output.name
            self.provisionedMemory = output.provisionedMemory
            self.publicConnectivity = output.publicConnectivity
            self.replicaCount = output.replicaCount
            self.sourceSnapshotId = output.sourceSnapshotId
            self.status = output.status
            self.statusReason = output.statusReason
            self.vectorSearchConfiguration = output.vectorSearchConfiguration
        } else {
            self.arn = nil
            self.buildNumber = nil
            self.createTime = nil
            self.deletionProtection = nil
            self.endpoint = nil
            self.id = nil
            self.kmsKeyIdentifier = nil
            self.name = nil
            self.provisionedMemory = nil
            self.publicConnectivity = nil
            self.replicaCount = nil
            self.sourceSnapshotId = nil
            self.status = nil
            self.statusReason = nil
            self.vectorSearchConfiguration = nil
        }
    }
}

public struct UpdateGraphOutput: Swift.Equatable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: ClientRuntime.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

struct UpdateGraphOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: NeptuneGraphClientTypes.GraphStatus?
    let statusReason: Swift.String?
    let createTime: ClientRuntime.Date?
    let provisionedMemory: Swift.Int?
    let endpoint: Swift.String?
    let publicConnectivity: Swift.Bool?
    let vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?
    let replicaCount: Swift.Int?
    let kmsKeyIdentifier: Swift.String?
    let sourceSnapshotId: Swift.String?
    let deletionProtection: Swift.Bool?
    let buildNumber: Swift.String?
}

extension UpdateGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildNumber
        case createTime
        case deletionProtection
        case endpoint
        case id
        case kmsKeyIdentifier
        case name
        case provisionedMemory
        case publicConnectivity
        case replicaCount
        case sourceSnapshotId
        case status
        case statusReason
        case vectorSearchConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.GraphStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let provisionedMemoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedMemory)
        provisionedMemory = provisionedMemoryDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let publicConnectivityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicConnectivity)
        publicConnectivity = publicConnectivityDecoded
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.VectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
        let replicaCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicaCount)
        replicaCount = replicaCountDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
    }
}

enum UpdateGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource could not be validated
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the resource could not be validated.
        public internal(set) var reason: NeptuneGraphClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: NeptuneGraphClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(NeptuneGraphClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension NeptuneGraphClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badRequest
        case constraintViolation
        case illegalArgument
        case malformedQuery
        case queryCancelled
        case queryTooLarge
        case unsupportedOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .badRequest,
                .constraintViolation,
                .illegalArgument,
                .malformedQuery,
                .queryCancelled,
                .queryTooLarge,
                .unsupportedOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .constraintViolation: return "CONSTRAINT_VIOLATION"
            case .illegalArgument: return "ILLEGAL_ARGUMENT"
            case .malformedQuery: return "MALFORMED_QUERY"
            case .queryCancelled: return "QUERY_CANCELLED"
            case .queryTooLarge: return "QUERY_TOO_LARGE"
            case .unsupportedOperation: return "UNSUPPORTED_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension NeptuneGraphClientTypes.VectorSearchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dimension)
        dimension = dimensionDecoded
    }
}

extension NeptuneGraphClientTypes {
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public struct VectorSearchConfiguration: Swift.Equatable {
        /// The number of dimensions.
        /// This member is required.
        public var dimension: Swift.Int?

        public init(
            dimension: Swift.Int? = nil
        )
        {
            self.dimension = dimension
        }
    }

}
