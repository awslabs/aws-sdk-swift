//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct CancelQueryOutput: Swift.Sendable {

    public init() { }
}

/// Raised in case of an authentication or authorization failure.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A failure occurred on the server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A specified resource could not be located.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The exception was interrupted by throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NeptuneGraphClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case constraintViolation
        case illegalArgument
        case malformedQuery
        case queryCancelled
        case queryTooLarge
        case unsupportedOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .badRequest,
                .constraintViolation,
                .illegalArgument,
                .malformedQuery,
                .queryCancelled,
                .queryTooLarge,
                .unsupportedOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .constraintViolation: return "CONSTRAINT_VIOLATION"
            case .illegalArgument: return "ILLEGAL_ARGUMENT"
            case .malformedQuery: return "MALFORMED_QUERY"
            case .queryCancelled: return "QUERY_CANCELLED"
            case .queryTooLarge: return "QUERY_TOO_LARGE"
            case .unsupportedOperation: return "UNSUPPORTED_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A resource could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the resource could not be validated.
        public internal(set) var reason: NeptuneGraphClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CancelQueryInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The unique identifier of the query to cancel.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.queryId = queryId
    }
}

extension NeptuneGraphClientTypes {

    public enum ConflictExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concurrentModification
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Raised when a conflict is encountered.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        public internal(set) var reason: NeptuneGraphClientTypes.ConflictExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.ConflictExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension NeptuneGraphClientTypes {

    public enum UnprocessableExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalLimitExceeded
        case memoryLimitExceeded
        case partitionFull
        case queryTimeout
        case storageLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UnprocessableExceptionReason] {
            return [
                .internalLimitExceeded,
                .memoryLimitExceeded,
                .partitionFull,
                .queryTimeout,
                .storageLimitExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalLimitExceeded: return "INTERNAL_LIMIT_EXCEEDED"
            case .memoryLimitExceeded: return "MEMORY_LIMIT_EXCEEDED"
            case .partitionFull: return "PARTITION_FULL"
            case .queryTimeout: return "QUERY_TIMEOUT"
            case .storageLimitExceeded: return "STORAGE_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Request cannot be processed due to known reasons. Eg. partition full.
public struct UnprocessableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the unprocessable exception.
        /// This member is required.
        public internal(set) var reason: NeptuneGraphClientTypes.UnprocessableExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: NeptuneGraphClientTypes.UnprocessableExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension NeptuneGraphClientTypes {

    public enum ExplainMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case details
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [ExplainMode] {
            return [
                .details,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .details: return "DETAILS"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptuneGraphClientTypes {

    public enum QueryLanguage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case openCypher
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryLanguage] {
            return [
                .openCypher
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .openCypher: return "OPEN_CYPHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptuneGraphClientTypes {

    public enum PlanCacheType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PlanCacheType] {
            return [
                .auto,
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ExecuteQueryInput: Swift.Sendable {
    /// The explain mode parameter returns a query explain instead of the actual query results. A query explain can be used to gather insights about the query execution such as planning decisions, time spent on each operator, solutions flowing etc.
    public var explainMode: NeptuneGraphClientTypes.ExplainMode?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The query language the query is written in. Currently only openCypher is supported.
    /// This member is required.
    public var language: NeptuneGraphClientTypes.QueryLanguage?
    /// The data parameters the query can use in JSON format. For example: {"name": "john", "age": 20}. (optional)
    public var parameters: [Swift.String: Smithy.Document]?
    /// Query plan cache is a feature that saves the query plan and reuses it on successive executions of the same query. This reduces query latency, and works for both READ and UPDATE queries. The plan cache is an LRU cache with a 5 minute TTL and a capacity of 1000.
    public var planCache: NeptuneGraphClientTypes.PlanCacheType?
    /// The query string to be executed.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies the query timeout duration, in milliseconds. (optional)
    public var queryTimeoutMilliseconds: Swift.Int?

    public init(
        explainMode: NeptuneGraphClientTypes.ExplainMode? = nil,
        graphIdentifier: Swift.String? = nil,
        language: NeptuneGraphClientTypes.QueryLanguage? = nil,
        parameters: [Swift.String: Smithy.Document]? = nil,
        planCache: NeptuneGraphClientTypes.PlanCacheType? = nil,
        queryString: Swift.String? = nil,
        queryTimeoutMilliseconds: Swift.Int? = nil
    )
    {
        self.explainMode = explainMode
        self.graphIdentifier = graphIdentifier
        self.language = language
        self.parameters = parameters
        self.planCache = planCache
        self.queryString = queryString
        self.queryTimeoutMilliseconds = queryTimeoutMilliseconds
    }
}

public struct ExecuteQueryOutput: Swift.Sendable {
    /// The query results.
    /// This member is required.
    public var payload: Smithy.ByteStream?

    public init(
        payload: Smithy.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

extension NeptuneGraphClientTypes {

    public enum GraphSummaryMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case detailed
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphSummaryMode] {
            return [
                .basic,
                .detailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .detailed: return "DETAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetGraphSummaryInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The summary mode can take one of two values: basic (the default), and detailed.
    public var mode: NeptuneGraphClientTypes.GraphSummaryMode?

    public init(
        graphIdentifier: Swift.String? = nil,
        mode: NeptuneGraphClientTypes.GraphSummaryMode? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.mode = mode
    }
}

extension NeptuneGraphClientTypes {

    /// Contains information about an edge in a Neptune Analytics graph.
    public struct EdgeStructure: Swift.Sendable {
        /// The number of instances of the edge in the graph.
        public var count: Swift.Int?
        /// A list of the properties associated with the edge.
        public var edgeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            edgeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.edgeProperties = edgeProperties
        }
    }
}

extension NeptuneGraphClientTypes {

    /// Information about a node.
    public struct NodeStructure: Swift.Sendable {
        /// The number of instances of this node.
        public var count: Swift.Int?
        /// The outgoing edge labels associated with this node.
        public var distinctOutgoingEdgeLabels: [Swift.String]?
        /// Properties associated with this node.
        public var nodeProperties: [Swift.String]?

        public init(
            count: Swift.Int? = nil,
            distinctOutgoingEdgeLabels: [Swift.String]? = nil,
            nodeProperties: [Swift.String]? = nil
        )
        {
            self.count = count
            self.distinctOutgoingEdgeLabels = distinctOutgoingEdgeLabels
            self.nodeProperties = nodeProperties
        }
    }
}

extension NeptuneGraphClientTypes {

    /// Summary information about the graph.
    public struct GraphDataSummary: Swift.Sendable {
        /// A list of the edge labels in the graph.
        public var edgeLabels: [Swift.String]?
        /// A list of the distinct edge properties in the graph, along with the count of edges where each property is used.
        public var edgeProperties: [[Swift.String: Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of edge structures.
        public var edgeStructures: [NeptuneGraphClientTypes.EdgeStructure]?
        /// A list of distinct node labels in the graph.
        public var nodeLabels: [Swift.String]?
        /// A list of the distinct node properties in the graph, along with the count of nodes where each property is used.
        public var nodeProperties: [[Swift.String: Swift.Int]]?
        /// This field is only present when the requested mode is DETAILED. It contains a list of node structures.
        public var nodeStructures: [NeptuneGraphClientTypes.NodeStructure]?
        /// The number of unique edge labels in the graph.
        public var numEdgeLabels: Swift.Int?
        /// The number of edge properties in the graph.
        public var numEdgeProperties: Swift.Int?
        /// The number of edges in the graph.
        public var numEdges: Swift.Int?
        /// The number of distinct node labels in the graph.
        public var numNodeLabels: Swift.Int?
        /// The number of distinct node properties in the graph.
        public var numNodeProperties: Swift.Int?
        /// The number of nodes in the graph.
        public var numNodes: Swift.Int?
        /// The total number of usages of all edge properties.
        public var totalEdgePropertyValues: Swift.Int?
        /// The total number of usages of all node properties.
        public var totalNodePropertyValues: Swift.Int?

        public init(
            edgeLabels: [Swift.String]? = nil,
            edgeProperties: [[Swift.String: Swift.Int]]? = nil,
            edgeStructures: [NeptuneGraphClientTypes.EdgeStructure]? = nil,
            nodeLabels: [Swift.String]? = nil,
            nodeProperties: [[Swift.String: Swift.Int]]? = nil,
            nodeStructures: [NeptuneGraphClientTypes.NodeStructure]? = nil,
            numEdgeLabels: Swift.Int? = nil,
            numEdgeProperties: Swift.Int? = nil,
            numEdges: Swift.Int? = nil,
            numNodeLabels: Swift.Int? = nil,
            numNodeProperties: Swift.Int? = nil,
            numNodes: Swift.Int? = nil,
            totalEdgePropertyValues: Swift.Int? = nil,
            totalNodePropertyValues: Swift.Int? = nil
        )
        {
            self.edgeLabels = edgeLabels
            self.edgeProperties = edgeProperties
            self.edgeStructures = edgeStructures
            self.nodeLabels = nodeLabels
            self.nodeProperties = nodeProperties
            self.nodeStructures = nodeStructures
            self.numEdgeLabels = numEdgeLabels
            self.numEdgeProperties = numEdgeProperties
            self.numEdges = numEdges
            self.numNodeLabels = numNodeLabels
            self.numNodeProperties = numNodeProperties
            self.numNodes = numNodes
            self.totalEdgePropertyValues = totalEdgePropertyValues
            self.totalNodePropertyValues = totalNodePropertyValues
        }
    }
}

public struct GetGraphSummaryOutput: Swift.Sendable {
    /// The graph summary.
    public var graphSummary: NeptuneGraphClientTypes.GraphDataSummary?
    /// The timestamp, in ISO 8601 format, of the time at which Neptune Analytics last computed statistics.
    public var lastStatisticsComputationTime: Foundation.Date?
    /// Display the version of this tool.
    public var version: Swift.String?

    public init(
        graphSummary: NeptuneGraphClientTypes.GraphDataSummary? = nil,
        lastStatisticsComputationTime: Foundation.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.graphSummary = graphSummary
        self.lastStatisticsComputationTime = lastStatisticsComputationTime
        self.version = version
    }
}

public struct GetQueryInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the query in question.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.queryId = queryId
    }
}

extension NeptuneGraphClientTypes {

    public enum QueryState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelling
        case running
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryState] {
            return [
                .cancelling,
                .running,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelling: return "CANCELLING"
            case .running: return "RUNNING"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQueryOutput: Swift.Sendable {
    /// The number of milliseconds the query has been running.
    public var elapsed: Swift.Int?
    /// The ID of the query in question.
    public var id: Swift.String?
    /// The query in question.
    public var queryString: Swift.String?
    /// State of the query.
    public var state: NeptuneGraphClientTypes.QueryState?
    /// Indicates how long the query waited, in milliseconds.
    public var waited: Swift.Int?

    public init(
        elapsed: Swift.Int? = nil,
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        state: NeptuneGraphClientTypes.QueryState? = nil,
        waited: Swift.Int? = nil
    )
    {
        self.elapsed = elapsed
        self.id = id
        self.queryString = queryString
        self.state = state
        self.waited = waited
    }
}

/// A service quota was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service quota code of the resource for which quota was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeded quota. Ex: Graph, Snapshot
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code that exceeded quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension NeptuneGraphClientTypes {

    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public struct VectorSearchConfiguration: Swift.Sendable {
        /// The number of dimensions.
        /// This member is required.
        public var dimension: Swift.Int?

        public init(
            dimension: Swift.Int? = nil
        )
        {
            self.dimension = dimension
        }
    }
}

public struct CreateGraphInput: Swift.Sendable {
    /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
    public var deletionProtection: Swift.Bool?
    /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// Specifies a KMS key to use to encrypt data in the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    /// This member is required.
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Min =0, Max = 2, Default = 1. Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    public var replicaCount: Swift.Int?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphName: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphName = graphName
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.tags = tags
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

extension NeptuneGraphClientTypes {

    public enum GraphStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case importing
        case resetting
        case snapshotting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .importing,
                .resetting,
                .snapshotting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .resetting: return "RESETTING"
            case .snapshotting: return "SNAPSHOTTING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGraphOutput: Swift.Sendable {
    /// The ARN of the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph software.
    public var buildNumber: Swift.String?
    /// The time when the graph was created.
    public var createTime: Foundation.Date?
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The ID of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// Specifies the KMS key used to encrypt data in the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. If enabling public connectivity for the first time, there will be a delay while it is enabled.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Default: If not specified, the default value is 1.
    public var replicaCount: Swift.Int?
    /// The ID of the source graph.
    public var sourceSnapshotId: Swift.String?
    /// The current status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason the status was given.
    public var statusReason: Swift.String?
    /// The vector-search configuration for the graph, which specifies the vector dimension to use in the vector index, if any.
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

public struct DeleteGraphInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Determines whether a final graph snapshot is created before the graph is deleted. If true is specified, no graph snapshot is created. If false is specified, a graph snapshot is created before the graph is deleted.
    /// This member is required.
    public var skipSnapshot: Swift.Bool?

    public init(
        graphIdentifier: Swift.String? = nil,
        skipSnapshot: Swift.Bool? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.skipSnapshot = skipSnapshot
    }
}

public struct DeleteGraphOutput: Swift.Sendable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number associated with the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: Foundation.Date?
    /// If true, deletion protection was enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if the graph was recovered from a snapshot.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason for the status of the graph.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

public struct GetGraphInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
    }
}

public struct GetGraphOutput: Swift.Sendable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: Foundation.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if it was created from a snapshot.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

public struct ListGraphsInput: Swift.Sendable {
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NeptuneGraphClientTypes {

    /// Summary details about a graph.
    public struct GraphSummary: Swift.Sendable {
        /// The ARN associated with the graph.
        /// This member is required.
        public var arn: Swift.String?
        /// If true, deletion protection is enabled for the graph.
        public var deletionProtection: Swift.Bool?
        /// The graph endpoint.
        public var endpoint: Swift.String?
        /// The unique identifier of the graph.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the KMS key used to encrypt and decrypt graph data.
        public var kmsKeyIdentifier: Swift.String?
        /// The name of the graph.
        /// This member is required.
        public var name: Swift.String?
        /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
        public var provisionedMemory: Swift.Int?
        /// If true, the graph has a public endpoint, otherwise not.
        public var publicConnectivity: Swift.Bool?
        /// The number of replicas for the graph.
        public var replicaCount: Swift.Int?
        /// The status of the graph.
        public var status: NeptuneGraphClientTypes.GraphStatus?

        public init(
            arn: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyIdentifier: Swift.String? = nil,
            name: Swift.String? = nil,
            provisionedMemory: Swift.Int? = nil,
            publicConnectivity: Swift.Bool? = nil,
            replicaCount: Swift.Int? = nil,
            status: NeptuneGraphClientTypes.GraphStatus? = nil
        )
        {
            self.arn = arn
            self.deletionProtection = deletionProtection
            self.endpoint = endpoint
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.provisionedMemory = provisionedMemory
            self.publicConnectivity = publicConnectivity
            self.replicaCount = replicaCount
            self.status = status
        }
    }
}

public struct ListGraphsOutput: Swift.Sendable {
    /// A list of the graphs.
    /// This member is required.
    public var graphs: [NeptuneGraphClientTypes.GraphSummary]?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphs: [NeptuneGraphClientTypes.GraphSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphs = graphs
        self.nextToken = nextToken
    }
}

public struct ResetGraphInput: Swift.Sendable {
    /// ID of the graph to reset.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Determines whether a final graph snapshot is created before the graph data is deleted. If set to true, no graph snapshot is created. If set to false, a graph snapshot is created before the data is deleted.
    /// This member is required.
    public var skipSnapshot: Swift.Bool?

    public init(
        graphIdentifier: Swift.String? = nil,
        skipSnapshot: Swift.Bool? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.skipSnapshot = skipSnapshot
    }
}

public struct ResetGraphOutput: Swift.Sendable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: Foundation.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

public struct RestoreGraphFromSnapshotInput: Swift.Sendable {
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// A name for the new Neptune Analytics graph to be created from the snapshot. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs. Min =0, Max = 2, Default =1 Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot in question.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?
    /// Adds metadata tags to the snapshot. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphName: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        snapshotIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphName = graphName
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
    }
}

public struct RestoreGraphFromSnapshotOutput: Swift.Sendable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: Foundation.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

public struct UpdateGraphInput: Swift.Sendable {
    /// A value that indicates whether the graph has deletion protection enabled. The graph can't be deleted when deletion protection is enabled.
    public var deletionProtection: Swift.Bool?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Min = 128
    public var provisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable.
    public var publicConnectivity: Swift.Bool?

    public init(
        deletionProtection: Swift.Bool? = nil,
        graphIdentifier: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.graphIdentifier = graphIdentifier
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
    }
}

public struct UpdateGraphOutput: Swift.Sendable {
    /// The ARN associated with the graph.
    /// This member is required.
    public var arn: Swift.String?
    /// The build number of the graph.
    public var buildNumber: Swift.String?
    /// The time at which the graph was created.
    public var createTime: Foundation.Date?
    /// If true, deletion protection is enabled for the graph.
    public var deletionProtection: Swift.Bool?
    /// The graph endpoint.
    public var endpoint: Swift.String?
    /// The unique identifier of the graph.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the graph.
    /// This member is required.
    public var name: Swift.String?
    /// The number of memory-optimized Neptune Capacity Units (m-NCUs) allocated to the graph.
    public var provisionedMemory: Swift.Int?
    /// If true, the graph has a public endpoint, otherwise not.
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas for the graph.
    public var replicaCount: Swift.Int?
    /// The ID of the snapshot from which the graph was created, if any.
    public var sourceSnapshotId: Swift.String?
    /// The status of the graph.
    public var status: NeptuneGraphClientTypes.GraphStatus?
    /// The reason that the graph has this status.
    public var statusReason: Swift.String?
    /// Specifies the number of dimensions for vector embeddings loaded into the graph. Max = 65535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        arn: Swift.String? = nil,
        buildNumber: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        provisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        sourceSnapshotId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.GraphStatus? = nil,
        statusReason: Swift.String? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.arn = arn
        self.buildNumber = buildNumber
        self.createTime = createTime
        self.deletionProtection = deletionProtection
        self.endpoint = endpoint
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.provisionedMemory = provisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.sourceSnapshotId = sourceSnapshotId
        self.status = status
        self.statusReason = statusReason
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

extension NeptuneGraphClientTypes {

    public enum QueryStateInput: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case cancelling
        case running
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStateInput] {
            return [
                .all,
                .cancelling,
                .running,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .cancelling: return "CANCELLING"
            case .running: return "RUNNING"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListQueriesInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The maximum number of results to be fetched by the API.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// Filtered list of queries based on state.
    public var state: NeptuneGraphClientTypes.QueryStateInput?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        state: NeptuneGraphClientTypes.QueryStateInput? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.state = state
    }
}

extension NeptuneGraphClientTypes {

    /// Details of the query listed.
    public struct QuerySummary: Swift.Sendable {
        /// The running time of the query, in milliseconds.
        public var elapsed: Swift.Int?
        /// A string representation of the id of the query.
        public var id: Swift.String?
        /// The actual query text. The queryString may be truncated if the actual query string is too long.
        public var queryString: Swift.String?
        /// State of the query.
        public var state: NeptuneGraphClientTypes.QueryState?
        /// The amount of time, in milliseconds, the query has waited in the queue before being picked up by a worker thread.
        public var waited: Swift.Int?

        public init(
            elapsed: Swift.Int? = nil,
            id: Swift.String? = nil,
            queryString: Swift.String? = nil,
            state: NeptuneGraphClientTypes.QueryState? = nil,
            waited: Swift.Int? = nil
        )
        {
            self.elapsed = elapsed
            self.id = id
            self.queryString = queryString
            self.state = state
            self.waited = waited
        }
    }
}

public struct ListQueriesOutput: Swift.Sendable {
    /// A list of current openCypher queries.
    /// This member is required.
    public var queries: [NeptuneGraphClientTypes.QuerySummary]?

    public init(
        queries: [NeptuneGraphClientTypes.QuerySummary]? = nil
    )
    {
        self.queries = queries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of metadata tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct CreatePrivateGraphEndpointInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Subnets in which private graph endpoint ENIs are created.
    public var subnetIds: [Swift.String]?
    /// The VPC in which the private graph endpoint needs to be created.
    public var vpcId: Swift.String?
    /// Security groups to be attached to the private graph endpoint..
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        graphIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.subnetIds = subnetIds
        self.vpcId = vpcId
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension NeptuneGraphClientTypes {

    public enum PrivateGraphEndpointStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateGraphEndpointStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePrivateGraphEndpointOutput: Swift.Sendable {
    /// Status of the private graph endpoint.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// Subnets in which the private graph endpoint ENIs are created.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Endpoint ID of the prviate grpah endpoint.
    public var vpcEndpointId: Swift.String?
    /// VPC in which the private graph endpoint is created.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

public struct DeletePrivateGraphEndpointInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.vpcId = vpcId
    }
}

public struct DeletePrivateGraphEndpointOutput: Swift.Sendable {
    /// The status of the delete operation.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// The subnet IDs involved.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC endpoint that was deleted.
    public var vpcEndpointId: Swift.String?
    /// The ID of the VPC where the private endpoint was deleted.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

public struct GetPrivateGraphEndpointInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.vpcId = vpcId
    }
}

public struct GetPrivateGraphEndpointOutput: Swift.Sendable {
    /// The current status of the private endpoint.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
    /// The subnet IDs involved.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the private endpoint.
    public var vpcEndpointId: Swift.String?
    /// The ID of the VPC where the private endpoint is located.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.status = status
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

public struct ListPrivateGraphEndpointsInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NeptuneGraphClientTypes {

    /// Details about a private graph endpoint.
    public struct PrivateGraphEndpointSummary: Swift.Sendable {
        /// The status of the private graph endpoint.
        /// This member is required.
        public var status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus?
        /// The subnet IDs associated with the private graph endpoint.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC endpoint.
        public var vpcEndpointId: Swift.String?
        /// The ID of the VPC in which the private graph endpoint is located.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            status: NeptuneGraphClientTypes.PrivateGraphEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.status = status
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }
}

public struct ListPrivateGraphEndpointsOutput: Swift.Sendable {
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?
    /// A list of private endpoints for the specified Neptune Analytics graph.
    /// This member is required.
    public var privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privateGraphEndpoints: [NeptuneGraphClientTypes.PrivateGraphEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privateGraphEndpoints = privateGraphEndpoints
    }
}

public struct CreateGraphSnapshotInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String: Swift.String]?

    public init(
        graphIdentifier: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

extension NeptuneGraphClientTypes {

    public enum SnapshotStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGraphSnapshotOutput: Swift.Sendable {
    /// The ARN of the snapshot created.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the snapshot created.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt graph data.
    public var kmsKeyIdentifier: Swift.String?
    /// The name of the snapshot created.
    /// This member is required.
    public var name: Swift.String?
    /// The snapshot creation time
    public var snapshotCreateTime: Foundation.Date?
    /// The Id of the Neptune Analytics graph from which the snapshot is created.
    public var sourceGraphId: Swift.String?
    /// The current state of the snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: Foundation.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

public struct DeleteGraphSnapshotInput: Swift.Sendable {
    /// ID of the graph snapshot to be deleted.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?

    public init(
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotIdentifier = snapshotIdentifier
    }
}

public struct DeleteGraphSnapshotOutput: Swift.Sendable {
    /// The ARN of the graph snapshot.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the graph snapshot.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt the snapshot.
    public var kmsKeyIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The time when the snapshot was created.
    public var snapshotCreateTime: Foundation.Date?
    /// The graph identifier for the graph from which the snapshot was created.
    public var sourceGraphId: Swift.String?
    /// The status of the graph snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: Foundation.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

public struct GetGraphSnapshotInput: Swift.Sendable {
    /// The ID of the snapshot to retrieve.
    /// This member is required.
    public var snapshotIdentifier: Swift.String?

    public init(
        snapshotIdentifier: Swift.String? = nil
    )
    {
        self.snapshotIdentifier = snapshotIdentifier
    }
}

public struct GetGraphSnapshotOutput: Swift.Sendable {
    /// The ARN of the graph snapshot.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the graph snapshot.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the KMS key used to encrypt and decrypt the snapshot.
    public var kmsKeyIdentifier: Swift.String?
    /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var name: Swift.String?
    /// The time when the snapshot was created.
    public var snapshotCreateTime: Foundation.Date?
    /// The graph identifier for the graph for which a snapshot is to be created.
    public var sourceGraphId: Swift.String?
    /// The status of the graph snapshot.
    public var status: NeptuneGraphClientTypes.SnapshotStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        snapshotCreateTime: Foundation.Date? = nil,
        sourceGraphId: Swift.String? = nil,
        status: NeptuneGraphClientTypes.SnapshotStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.name = name
        self.snapshotCreateTime = snapshotCreateTime
        self.sourceGraphId = sourceGraphId
        self.status = status
    }
}

public struct ListGraphSnapshotsInput: Swift.Sendable {
    /// The unique identifier of the Neptune Analytics graph.
    public var graphIdentifier: Swift.String?
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphIdentifier = graphIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NeptuneGraphClientTypes {

    /// Details about a graph snapshot.
    public struct GraphSnapshotSummary: Swift.Sendable {
        /// The ARN of the graph snapshot.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique identifier of the graph snapshot.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the KMS key used to encrypt and decrypt the snapshot.
        public var kmsKeyIdentifier: Swift.String?
        /// The snapshot name. For example: my-snapshot-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
        /// This member is required.
        public var name: Swift.String?
        /// The time when the snapshot was created.
        public var snapshotCreateTime: Foundation.Date?
        /// The graph identifier for the graph for which a snapshot is to be created.
        public var sourceGraphId: Swift.String?
        /// The status of the graph snapshot.
        public var status: NeptuneGraphClientTypes.SnapshotStatus?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyIdentifier: Swift.String? = nil,
            name: Swift.String? = nil,
            snapshotCreateTime: Foundation.Date? = nil,
            sourceGraphId: Swift.String? = nil,
            status: NeptuneGraphClientTypes.SnapshotStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.snapshotCreateTime = snapshotCreateTime
            self.sourceGraphId = sourceGraphId
            self.status = status
        }
    }
}

public struct ListGraphSnapshotsOutput: Swift.Sendable {
    /// The requested list of snapshots.
    /// This member is required.
    public var graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        graphSnapshots: [NeptuneGraphClientTypes.GraphSnapshotSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphSnapshots = graphSnapshots
        self.nextToken = nextToken
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// ARN of the resource for which tags need to be added.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Neptune Analytics resource. The tags are metadata that are specified as a list of key-value pairs: Key (string) – A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$"). Value (string) – A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length. It can't be prefixed with aws: and can only contain the set of Unicode characters specified by this Java regular expression: "^([\p{L}\p{Z}\p{N}_.:/=+\-]*)$").
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct CancelImportTaskInput: Swift.Sendable {
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskIdentifier: Swift.String?

    public init(
        taskIdentifier: Swift.String? = nil
    )
    {
        self.taskIdentifier = taskIdentifier
    }
}

extension NeptuneGraphClientTypes {

    public enum Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case ntriples
        case openCypher
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .ntriples,
                .openCypher
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .ntriples: return "NTRIPLES"
            case .openCypher: return "OPEN_CYPHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptuneGraphClientTypes {

    public enum ImportTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analyzingData
        case cancelled
        case cancelling
        case exporting
        case failed
        case importing
        case initializing
        case reprovisioning
        case rollingBack
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskStatus] {
            return [
                .analyzingData,
                .cancelled,
                .cancelling,
                .exporting,
                .failed,
                .importing,
                .initializing,
                .reprovisioning,
                .rollingBack,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analyzingData: return "ANALYZING_DATA"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .exporting: return "EXPORTING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .initializing: return "INITIALIZING"
            case .reprovisioning: return "REPROVISIONING"
            case .rollingBack: return "ROLLING_BACK"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelImportTaskOutput: Swift.Sendable {
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// Current status of the task. Status is CANCELLING when the import task is cancelled.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

extension NeptuneGraphClientTypes {

    public enum BlankNodeHandling: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case convertToIri
        case sdkUnknown(Swift.String)

        public static var allCases: [BlankNodeHandling] {
            return [
                .convertToIri
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .convertToIri: return "convertToIri"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NeptuneGraphClientTypes {

    /// Options for how to import Neptune data.
    public struct NeptuneImportOptions: Swift.Sendable {
        /// Neptune Analytics supports label-less vertices and no labels are assigned unless one is explicitly provided. Neptune assigns default labels when none is explicitly provided. When importing the data into Neptune Analytics, the default vertex labels can be omitted by setting preserveDefaultVertexLabels to false. Note that if the vertex only has default labels, and has no other properties or edges, then the vertex will effectively not get imported into Neptune Analytics when preserveDefaultVertexLabels is set to false.
        public var preserveDefaultVertexLabels: Swift.Bool?
        /// Neptune Analytics currently does not support user defined edge ids. The edge ids are not imported by default. They are imported if preserveEdgeIds is set to true, and ids are stored as properties on the relationships with the property name neptuneEdgeId.
        public var preserveEdgeIds: Swift.Bool?
        /// The KMS key to use to encrypt data in the S3 bucket where the graph data is exported
        /// This member is required.
        public var s3ExportKmsKeyId: Swift.String?
        /// The path to an S3 bucket from which to import data.
        /// This member is required.
        public var s3ExportPath: Swift.String?

        public init(
            preserveDefaultVertexLabels: Swift.Bool? = nil,
            preserveEdgeIds: Swift.Bool? = nil,
            s3ExportKmsKeyId: Swift.String? = nil,
            s3ExportPath: Swift.String? = nil
        )
        {
            self.preserveDefaultVertexLabels = preserveDefaultVertexLabels
            self.preserveEdgeIds = preserveEdgeIds
            self.s3ExportKmsKeyId = s3ExportKmsKeyId
            self.s3ExportPath = s3ExportPath
        }
    }
}

extension NeptuneGraphClientTypes {

    /// Options for how to perform an import.
    public enum ImportOptions: Swift.Sendable {
        /// Options for importing data from a Neptune database.
        case neptune(NeptuneGraphClientTypes.NeptuneImportOptions)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateGraphUsingImportTaskInput: Swift.Sendable {
    /// The method to handle blank nodes in the dataset. Currently, only convertToIri is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is ntriples. For more information, see [Handling RDF values](https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling).
    public var blankNodeHandling: NeptuneGraphClientTypes.BlankNodeHandling?
    /// Indicates whether or not to enable deletion protection on the graph. The graph can’t be deleted when deletion protection is enabled. (true or false).
    public var deletionProtection: Swift.Bool?
    /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
    public var failOnError: Swift.Bool?
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html), OPEN_CYPHER, which identifies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html), or ntriples, which identifies the [RDF n-triples](https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html) format.
    public var format: NeptuneGraphClientTypes.Format?
    /// A name for the new Neptune Analytics graph to be created. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var graphName: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// Specifies a KMS key to use to encrypt data imported into the new graph.
    public var kmsKeyIdentifier: Swift.String?
    /// The maximum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 1024, or the approved upper limit for your account. If both the minimum and maximum values are specified, the max of the min-provisioned-memory and max-provisioned memory is used to create the graph. If neither value is specified 128 m-NCUs are used.
    public var maxProvisionedMemory: Swift.Int?
    /// The minimum provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph. Default: 128
    public var minProvisionedMemory: Swift.Int?
    /// Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. (true to enable, or false to disable).
    public var publicConnectivity: Swift.Bool?
    /// The number of replicas in other AZs to provision on the new graph after import. Default = 0, Min = 0, Max = 2. Additional charges equivalent to the m-NCUs selected for the graph apply for each replica.
    public var replicaCount: Swift.Int?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// Adds metadata tags to the new graph. These tags can also be used with cost allocation reporting, or used in a Condition statement in an IAM policy.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies the number of dimensions for vector embeddings that will be loaded into the graph. The value is specified as dimension=value. Max = 65,535
    public var vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration?

    public init(
        blankNodeHandling: NeptuneGraphClientTypes.BlankNodeHandling? = nil,
        deletionProtection: Swift.Bool? = nil,
        failOnError: Swift.Bool? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphName: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        kmsKeyIdentifier: Swift.String? = nil,
        maxProvisionedMemory: Swift.Int? = nil,
        minProvisionedMemory: Swift.Int? = nil,
        publicConnectivity: Swift.Bool? = nil,
        replicaCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vectorSearchConfiguration: NeptuneGraphClientTypes.VectorSearchConfiguration? = nil
    )
    {
        self.blankNodeHandling = blankNodeHandling
        self.deletionProtection = deletionProtection
        self.failOnError = failOnError
        self.format = format
        self.graphName = graphName
        self.importOptions = importOptions
        self.kmsKeyIdentifier = kmsKeyIdentifier
        self.maxProvisionedMemory = maxProvisionedMemory
        self.minProvisionedMemory = minProvisionedMemory
        self.publicConnectivity = publicConnectivity
        self.replicaCount = replicaCount
        self.roleArn = roleArn
        self.source = source
        self.tags = tags
        self.vectorSearchConfiguration = vectorSearchConfiguration
    }
}

public struct CreateGraphUsingImportTaskOutput: Swift.Sendable {
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html), OPENCYPHER, which identifies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html), or ntriples, which identifies the [RDF n-triples](https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html) format.
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

public struct GetImportTaskInput: Swift.Sendable {
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskIdentifier: Swift.String?

    public init(
        taskIdentifier: Swift.String? = nil
    )
    {
        self.taskIdentifier = taskIdentifier
    }
}

extension NeptuneGraphClientTypes {

    /// Contains details about an import task.
    public struct ImportTaskDetails: Swift.Sendable {
        /// The number of dictionary entries in the import task.
        /// This member is required.
        public var dictionaryEntryCount: Swift.Int?
        /// The number of errors encountered so far.
        /// This member is required.
        public var errorCount: Swift.Int?
        /// Details about the errors that have been encountered.
        public var errorDetails: Swift.String?
        /// The percentage progress so far.
        /// This member is required.
        public var progressPercentage: Swift.Int?
        /// Time at which the import task started.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The number of statements in the import task.
        /// This member is required.
        public var statementCount: Swift.Int?
        /// Status of the import task.
        /// This member is required.
        public var status: Swift.String?
        /// Seconds elapsed since the import task started.
        /// This member is required.
        public var timeElapsedSeconds: Swift.Int?

        public init(
            dictionaryEntryCount: Swift.Int? = nil,
            errorCount: Swift.Int? = nil,
            errorDetails: Swift.String? = nil,
            progressPercentage: Swift.Int? = nil,
            startTime: Foundation.Date? = nil,
            statementCount: Swift.Int? = nil,
            status: Swift.String? = nil,
            timeElapsedSeconds: Swift.Int? = nil
        )
        {
            self.dictionaryEntryCount = dictionaryEntryCount
            self.errorCount = errorCount
            self.errorDetails = errorDetails
            self.progressPercentage = progressPercentage
            self.startTime = startTime
            self.statementCount = statementCount
            self.status = status
            self.timeElapsedSeconds = timeElapsedSeconds
        }
    }
}

public struct GetImportTaskOutput: Swift.Sendable {
    /// The number of the current attempt to execute the import task.
    public var attemptNumber: Swift.Int?
    /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Contains options for controlling the import process. For example, if the failOnError key is set to false, the import skips problem data and attempts to continue (whereas if set to true, the default, or if omitted, the import operation halts immediately when an error is encountered.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// Contains details about the specified import task.
    public var importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task:
    ///
    /// * INITIALIZING – The necessary resources needed to create the graph are being prepared.
    ///
    /// * ANALYZING_DATA – The data is being analyzed to determine the optimal infrastructure configuration for the new graph.
    ///
    /// * RE_PROVISIONING – The data did not fit into the provisioned graph, so it is being re-provisioned with more capacity.
    ///
    /// * IMPORTING – The data is being loaded.
    ///
    /// * ERROR_ENCOUNTERED – An error has been encountered while trying to create the graph and import the data.
    ///
    /// * ERROR_ENCOUNTERED_ROLLING_BACK – Because of the error that was encountered, the graph is being rolled back and all its resources released.
    ///
    /// * SUCCEEDED – Graph creation and data loading succeeded.
    ///
    /// * FAILED – Graph creation or data loading failed. When the status is FAILED, you can use get-graphs to get more information about the state of the graph.
    ///
    /// * CANCELLING – Because you cancelled the import task, cancellation is in progress.
    ///
    /// * CANCELLED – You have successfully cancelled the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The reason that the import task has this status value.
    public var statusReason: Swift.String?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        attemptNumber: Swift.Int? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        importTaskDetails: NeptuneGraphClientTypes.ImportTaskDetails? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        statusReason: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.attemptNumber = attemptNumber
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.importTaskDetails = importTaskDetails
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.statusReason = statusReason
        self.taskId = taskId
    }
}

public struct ListImportTasksInput: Swift.Sendable {
    /// The total number of records to return in the command's output. If the total number of records available is more than the value specified, nextToken is provided in the command's output. To resume pagination, provide the nextToken output value in the nextToken argument of a subsequent command. Do not use the nextToken response element directly outside of the Amazon CLI.
    public var maxResults: Swift.Int?
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NeptuneGraphClientTypes {

    /// Details about an import task.
    public struct ImportTaskSummary: Swift.Sendable {
        /// Specifies the format of S3 data to be imported. Valid values are CSV, which identifies the [Gremlin CSV format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-gremlin.html) or OPENCYPHER, which identies the [openCypher load format](https://docs.aws.amazon.com/neptune/latest/userguide/bulk-load-tutorial-format-opencypher.html).
        public var format: NeptuneGraphClientTypes.Format?
        /// The unique identifier of the Neptune Analytics graph.
        public var graphId: Swift.String?
        /// The ARN of the IAM role that will allow access to the data that is to be imported.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A URL identifying to the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot
        /// This member is required.
        public var source: Swift.String?
        /// Status of the import task.
        /// This member is required.
        public var status: NeptuneGraphClientTypes.ImportTaskStatus?
        /// The unique identifier of the import task.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            format: NeptuneGraphClientTypes.Format? = nil,
            graphId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            source: Swift.String? = nil,
            status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.format = format
            self.graphId = graphId
            self.roleArn = roleArn
            self.source = source
            self.status = status
            self.taskId = taskId
        }
    }
}

public struct ListImportTasksOutput: Swift.Sendable {
    /// Pagination token used to paginate output. When this value is provided as input, the service returns results from where the previous response left off. When this value is present in output, it indicates that there are more results to retrieve.
    public var nextToken: Swift.String?
    /// The requested list of import tasks.
    /// This member is required.
    public var tasks: [NeptuneGraphClientTypes.ImportTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [NeptuneGraphClientTypes.ImportTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct StartImportTaskInput: Swift.Sendable {
    /// The method to handle blank nodes in the dataset. Currently, only convertToIri is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is ntriples. For more information, see [Handling RDF values](https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling).
    public var blankNodeHandling: NeptuneGraphClientTypes.BlankNodeHandling?
    /// If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.
    public var failOnError: Swift.Bool?
    /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    /// This member is required.
    public var graphIdentifier: Swift.String?
    /// Options for how to perform an import.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?

    public init(
        blankNodeHandling: NeptuneGraphClientTypes.BlankNodeHandling? = nil,
        failOnError: Swift.Bool? = nil,
        format: NeptuneGraphClientTypes.Format? = nil,
        graphIdentifier: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.blankNodeHandling = blankNodeHandling
        self.failOnError = failOnError
        self.format = format
        self.graphIdentifier = graphIdentifier
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
    }
}

public struct StartImportTaskOutput: Swift.Sendable {
    /// Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.
    public var format: NeptuneGraphClientTypes.Format?
    /// The unique identifier of the Neptune Analytics graph.
    public var graphId: Swift.String?
    /// Options for how to perform an import.
    public var importOptions: NeptuneGraphClientTypes.ImportOptions?
    /// The ARN of the IAM role that will allow access to the data that is to be imported.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.
    /// This member is required.
    public var source: Swift.String?
    /// The status of the import task.
    /// This member is required.
    public var status: NeptuneGraphClientTypes.ImportTaskStatus?
    /// The unique identifier of the import task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        format: NeptuneGraphClientTypes.Format? = nil,
        graphId: Swift.String? = nil,
        importOptions: NeptuneGraphClientTypes.ImportOptions? = nil,
        roleArn: Swift.String? = nil,
        source: Swift.String? = nil,
        status: NeptuneGraphClientTypes.ImportTaskStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.format = format
        self.graphId = graphId
        self.importOptions = importOptions
        self.roleArn = roleArn
        self.source = source
        self.status = status
        self.taskId = taskId
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// ARN of the resource whose tag needs to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys for the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CancelImportTaskInput {

    static func urlPathProvider(_ value: CancelImportTaskInput) -> Swift.String? {
        guard let taskIdentifier = value.taskIdentifier else {
            return nil
        }
        return "/importtasks/\(taskIdentifier.urlPercentEncoding())"
    }
}

extension CancelQueryInput {

    static func urlPathProvider(_ value: CancelQueryInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/queries/\(queryId.urlPercentEncoding())"
    }
}

extension CancelQueryInput {

    static func headerProvider(_ value: CancelQueryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension CreateGraphInput {

    static func urlPathProvider(_ value: CreateGraphInput) -> Swift.String? {
        return "/graphs"
    }
}

extension CreateGraphSnapshotInput {

    static func urlPathProvider(_ value: CreateGraphSnapshotInput) -> Swift.String? {
        return "/snapshots"
    }
}

extension CreateGraphUsingImportTaskInput {

    static func urlPathProvider(_ value: CreateGraphUsingImportTaskInput) -> Swift.String? {
        return "/importtasks"
    }
}

extension CreatePrivateGraphEndpointInput {

    static func urlPathProvider(_ value: CreatePrivateGraphEndpointInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints"
    }
}

extension DeleteGraphInput {

    static func urlPathProvider(_ value: DeleteGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGraphInput {

    static func queryItemProvider(_ value: DeleteGraphInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let skipSnapshot = value.skipSnapshot else {
            let message = "Creating a URL Query Item failed. skipSnapshot is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let skipSnapshotQueryItem = Smithy.URIQueryItem(name: "skipSnapshot".urlPercentEncoding(), value: Swift.String(skipSnapshot).urlPercentEncoding())
        items.append(skipSnapshotQueryItem)
        return items
    }
}

extension DeleteGraphSnapshotInput {

    static func urlPathProvider(_ value: DeleteGraphSnapshotInput) -> Swift.String? {
        guard let snapshotIdentifier = value.snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())"
    }
}

extension DeletePrivateGraphEndpointInput {

    static func urlPathProvider(_ value: DeletePrivateGraphEndpointInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        guard let vpcId = value.vpcId else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints/\(vpcId.urlPercentEncoding())"
    }
}

extension ExecuteQueryInput {

    static func urlPathProvider(_ value: ExecuteQueryInput) -> Swift.String? {
        return "/queries"
    }
}

extension ExecuteQueryInput {

    static func headerProvider(_ value: ExecuteQueryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension GetGraphInput {

    static func urlPathProvider(_ value: GetGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

extension GetGraphSnapshotInput {

    static func urlPathProvider(_ value: GetGraphSnapshotInput) -> Swift.String? {
        guard let snapshotIdentifier = value.snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())"
    }
}

extension GetGraphSummaryInput {

    static func urlPathProvider(_ value: GetGraphSummaryInput) -> Swift.String? {
        return "/summary"
    }
}

extension GetGraphSummaryInput {

    static func headerProvider(_ value: GetGraphSummaryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension GetGraphSummaryInput {

    static func queryItemProvider(_ value: GetGraphSummaryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let mode = value.mode {
            let modeQueryItem = Smithy.URIQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        return items
    }
}

extension GetImportTaskInput {

    static func urlPathProvider(_ value: GetImportTaskInput) -> Swift.String? {
        guard let taskIdentifier = value.taskIdentifier else {
            return nil
        }
        return "/importtasks/\(taskIdentifier.urlPercentEncoding())"
    }
}

extension GetPrivateGraphEndpointInput {

    static func urlPathProvider(_ value: GetPrivateGraphEndpointInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        guard let vpcId = value.vpcId else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints/\(vpcId.urlPercentEncoding())"
    }
}

extension GetQueryInput {

    static func urlPathProvider(_ value: GetQueryInput) -> Swift.String? {
        guard let queryId = value.queryId else {
            return nil
        }
        return "/queries/\(queryId.urlPercentEncoding())"
    }
}

extension GetQueryInput {

    static func headerProvider(_ value: GetQueryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension ListGraphsInput {

    static func urlPathProvider(_ value: ListGraphsInput) -> Swift.String? {
        return "/graphs"
    }
}

extension ListGraphsInput {

    static func queryItemProvider(_ value: ListGraphsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGraphSnapshotsInput {

    static func urlPathProvider(_ value: ListGraphSnapshotsInput) -> Swift.String? {
        return "/snapshots"
    }
}

extension ListGraphSnapshotsInput {

    static func queryItemProvider(_ value: ListGraphSnapshotsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let graphIdentifier = value.graphIdentifier {
            let graphIdentifierQueryItem = Smithy.URIQueryItem(name: "graphIdentifier".urlPercentEncoding(), value: Swift.String(graphIdentifier).urlPercentEncoding())
            items.append(graphIdentifierQueryItem)
        }
        return items
    }
}

extension ListImportTasksInput {

    static func urlPathProvider(_ value: ListImportTasksInput) -> Swift.String? {
        return "/importtasks"
    }
}

extension ListImportTasksInput {

    static func queryItemProvider(_ value: ListImportTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPrivateGraphEndpointsInput {

    static func urlPathProvider(_ value: ListPrivateGraphEndpointsInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/endpoints"
    }
}

extension ListPrivateGraphEndpointsInput {

    static func queryItemProvider(_ value: ListPrivateGraphEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueriesInput {

    static func urlPathProvider(_ value: ListQueriesInput) -> Swift.String? {
        return "/queries"
    }
}

extension ListQueriesInput {

    static func headerProvider(_ value: ListQueriesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let graphIdentifier = value.graphIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "graphIdentifier", value: Swift.String(graphIdentifier)))
        }
        return items
    }
}

extension ListQueriesInput {

    static func queryItemProvider(_ value: ListQueriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let maxResults = value.maxResults else {
            let message = "Creating a URL Query Item failed. maxResults is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
        items.append(maxResultsQueryItem)
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ResetGraphInput {

    static func urlPathProvider(_ value: ResetGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

extension RestoreGraphFromSnapshotInput {

    static func urlPathProvider(_ value: RestoreGraphFromSnapshotInput) -> Swift.String? {
        guard let snapshotIdentifier = value.snapshotIdentifier else {
            return nil
        }
        return "/snapshots/\(snapshotIdentifier.urlPercentEncoding())/restore"
    }
}

extension StartImportTaskInput {

    static func urlPathProvider(_ value: StartImportTaskInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())/importtasks"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateGraphInput {

    static func urlPathProvider(_ value: UpdateGraphInput) -> Swift.String? {
        guard let graphIdentifier = value.graphIdentifier else {
            return nil
        }
        return "/graphs/\(graphIdentifier.urlPercentEncoding())"
    }
}

extension CreateGraphInput {

    static func write(value: CreateGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deletionProtection"].write(value.deletionProtection)
        try writer["graphName"].write(value.graphName)
        try writer["kmsKeyIdentifier"].write(value.kmsKeyIdentifier)
        try writer["provisionedMemory"].write(value.provisionedMemory)
        try writer["publicConnectivity"].write(value.publicConnectivity)
        try writer["replicaCount"].write(value.replicaCount)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vectorSearchConfiguration"].write(value.vectorSearchConfiguration, with: NeptuneGraphClientTypes.VectorSearchConfiguration.write(value:to:))
    }
}

extension CreateGraphSnapshotInput {

    static func write(value: CreateGraphSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["graphIdentifier"].write(value.graphIdentifier)
        try writer["snapshotName"].write(value.snapshotName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateGraphUsingImportTaskInput {

    static func write(value: CreateGraphUsingImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blankNodeHandling"].write(value.blankNodeHandling)
        try writer["deletionProtection"].write(value.deletionProtection)
        try writer["failOnError"].write(value.failOnError)
        try writer["format"].write(value.format)
        try writer["graphName"].write(value.graphName)
        try writer["importOptions"].write(value.importOptions, with: NeptuneGraphClientTypes.ImportOptions.write(value:to:))
        try writer["kmsKeyIdentifier"].write(value.kmsKeyIdentifier)
        try writer["maxProvisionedMemory"].write(value.maxProvisionedMemory)
        try writer["minProvisionedMemory"].write(value.minProvisionedMemory)
        try writer["publicConnectivity"].write(value.publicConnectivity)
        try writer["replicaCount"].write(value.replicaCount)
        try writer["roleArn"].write(value.roleArn)
        try writer["source"].write(value.source)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vectorSearchConfiguration"].write(value.vectorSearchConfiguration, with: NeptuneGraphClientTypes.VectorSearchConfiguration.write(value:to:))
    }
}

extension CreatePrivateGraphEndpointInput {

    static func write(value: CreatePrivateGraphEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
        try writer["vpcSecurityGroupIds"].writeList(value.vpcSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ExecuteQueryInput {

    static func write(value: ExecuteQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["explain"].write(value.explainMode)
        try writer["language"].write(value.language)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["planCache"].write(value.planCache)
        try writer["query"].write(value.queryString)
        try writer["queryTimeoutMilliseconds"].write(value.queryTimeoutMilliseconds)
    }
}

extension ResetGraphInput {

    static func write(value: ResetGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["skipSnapshot"].write(value.skipSnapshot)
    }
}

extension RestoreGraphFromSnapshotInput {

    static func write(value: RestoreGraphFromSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deletionProtection"].write(value.deletionProtection)
        try writer["graphName"].write(value.graphName)
        try writer["provisionedMemory"].write(value.provisionedMemory)
        try writer["publicConnectivity"].write(value.publicConnectivity)
        try writer["replicaCount"].write(value.replicaCount)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartImportTaskInput {

    static func write(value: StartImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blankNodeHandling"].write(value.blankNodeHandling)
        try writer["failOnError"].write(value.failOnError)
        try writer["format"].write(value.format)
        try writer["importOptions"].write(value.importOptions, with: NeptuneGraphClientTypes.ImportOptions.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["source"].write(value.source)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateGraphInput {

    static func write(value: UpdateGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deletionProtection"].write(value.deletionProtection)
        try writer["provisionedMemory"].write(value.provisionedMemory)
        try writer["publicConnectivity"].write(value.publicConnectivity)
    }
}

extension CancelImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelImportTaskOutput()
        value.format = try reader["format"].readIfPresent()
        value.graphId = try reader["graphId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        return value
    }
}

extension CancelQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelQueryOutput {
        return CancelQueryOutput()
    }
}

extension CreateGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGraphOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.buildNumber = try reader["buildNumber"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.sourceSnapshotId = try reader["sourceSnapshotId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: NeptuneGraphClientTypes.VectorSearchConfiguration.read(from:))
        return value
    }
}

extension CreateGraphSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGraphSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGraphSnapshotOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.snapshotCreateTime = try reader["snapshotCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceGraphId = try reader["sourceGraphId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateGraphUsingImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGraphUsingImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGraphUsingImportTaskOutput()
        value.format = try reader["format"].readIfPresent()
        value.graphId = try reader["graphId"].readIfPresent()
        value.importOptions = try reader["importOptions"].readIfPresent(with: NeptuneGraphClientTypes.ImportOptions.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePrivateGraphEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePrivateGraphEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePrivateGraphEndpointOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGraphOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.buildNumber = try reader["buildNumber"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.sourceSnapshotId = try reader["sourceSnapshotId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: NeptuneGraphClientTypes.VectorSearchConfiguration.read(from:))
        return value
    }
}

extension DeleteGraphSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGraphSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGraphSnapshotOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.snapshotCreateTime = try reader["snapshotCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceGraphId = try reader["sourceGraphId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeletePrivateGraphEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePrivateGraphEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePrivateGraphEndpointOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension ExecuteQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteQueryOutput {
        var value = ExecuteQueryOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = .data(data)
        case .stream(let stream):
            value.payload = .stream(stream)
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

extension GetGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGraphOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.buildNumber = try reader["buildNumber"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.sourceSnapshotId = try reader["sourceSnapshotId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: NeptuneGraphClientTypes.VectorSearchConfiguration.read(from:))
        return value
    }
}

extension GetGraphSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGraphSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGraphSnapshotOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.snapshotCreateTime = try reader["snapshotCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceGraphId = try reader["sourceGraphId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetGraphSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGraphSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGraphSummaryOutput()
        value.graphSummary = try reader["graphSummary"].readIfPresent(with: NeptuneGraphClientTypes.GraphDataSummary.read(from:))
        value.lastStatisticsComputationTime = try reader["lastStatisticsComputationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension GetImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportTaskOutput()
        value.attemptNumber = try reader["attemptNumber"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        value.graphId = try reader["graphId"].readIfPresent()
        value.importOptions = try reader["importOptions"].readIfPresent(with: NeptuneGraphClientTypes.ImportOptions.read(from:))
        value.importTaskDetails = try reader["importTaskDetails"].readIfPresent(with: NeptuneGraphClientTypes.ImportTaskDetails.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        return value
    }
}

extension GetPrivateGraphEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPrivateGraphEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPrivateGraphEndpointOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension GetQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryOutput()
        value.elapsed = try reader["elapsed"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.waited = try reader["waited"].readIfPresent()
        return value
    }
}

extension ListGraphsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGraphsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGraphsOutput()
        value.graphs = try reader["graphs"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.GraphSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGraphSnapshotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGraphSnapshotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGraphSnapshotsOutput()
        value.graphSnapshots = try reader["graphSnapshots"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.GraphSnapshotSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.ImportTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPrivateGraphEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrivateGraphEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrivateGraphEndpointsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.privateGraphEndpoints = try reader["privateGraphEndpoints"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.PrivateGraphEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListQueriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueriesOutput()
        value.queries = try reader["queries"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.QuerySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ResetGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetGraphOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.buildNumber = try reader["buildNumber"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.sourceSnapshotId = try reader["sourceSnapshotId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: NeptuneGraphClientTypes.VectorSearchConfiguration.read(from:))
        return value
    }
}

extension RestoreGraphFromSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreGraphFromSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreGraphFromSnapshotOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.buildNumber = try reader["buildNumber"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.sourceSnapshotId = try reader["sourceSnapshotId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: NeptuneGraphClientTypes.VectorSearchConfiguration.read(from:))
        return value
    }
}

extension StartImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportTaskOutput()
        value.format = try reader["format"].readIfPresent()
        value.graphId = try reader["graphId"].readIfPresent()
        value.importOptions = try reader["importOptions"].readIfPresent(with: NeptuneGraphClientTypes.ImportOptions.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGraphOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.buildNumber = try reader["buildNumber"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.sourceSnapshotId = try reader["sourceSnapshotId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: NeptuneGraphClientTypes.VectorSearchConfiguration.read(from:))
        return value
    }
}

enum CancelImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGraphSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGraphUsingImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePrivateGraphEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGraphSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePrivateGraphEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnprocessableException": return try UnprocessableException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGraphSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGraphSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPrivateGraphEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGraphsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGraphSnapshotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrivateGraphEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreGraphFromSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnprocessableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnprocessableException {
        let reader = baseError.errorBodyReader
        var value = UnprocessableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NeptuneGraphClientTypes.VectorSearchConfiguration {

    static func write(value: NeptuneGraphClientTypes.VectorSearchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dimension"].write(value.dimension)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.VectorSearchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.VectorSearchConfiguration()
        value.dimension = try reader["dimension"].readIfPresent() ?? 0
        return value
    }
}

extension NeptuneGraphClientTypes.ImportOptions {

    static func write(value: NeptuneGraphClientTypes.ImportOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .neptune(neptune):
                try writer["neptune"].write(neptune, with: NeptuneGraphClientTypes.NeptuneImportOptions.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.ImportOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "neptune":
                return .neptune(try reader["neptune"].read(with: NeptuneGraphClientTypes.NeptuneImportOptions.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension NeptuneGraphClientTypes.NeptuneImportOptions {

    static func write(value: NeptuneGraphClientTypes.NeptuneImportOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["preserveDefaultVertexLabels"].write(value.preserveDefaultVertexLabels)
        try writer["preserveEdgeIds"].write(value.preserveEdgeIds)
        try writer["s3ExportKmsKeyId"].write(value.s3ExportKmsKeyId)
        try writer["s3ExportPath"].write(value.s3ExportPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.NeptuneImportOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.NeptuneImportOptions()
        value.s3ExportPath = try reader["s3ExportPath"].readIfPresent() ?? ""
        value.s3ExportKmsKeyId = try reader["s3ExportKmsKeyId"].readIfPresent() ?? ""
        value.preserveDefaultVertexLabels = try reader["preserveDefaultVertexLabels"].readIfPresent()
        value.preserveEdgeIds = try reader["preserveEdgeIds"].readIfPresent()
        return value
    }
}

extension NeptuneGraphClientTypes.GraphDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.GraphDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.GraphDataSummary()
        value.numNodes = try reader["numNodes"].readIfPresent()
        value.numEdges = try reader["numEdges"].readIfPresent()
        value.numNodeLabels = try reader["numNodeLabels"].readIfPresent()
        value.numEdgeLabels = try reader["numEdgeLabels"].readIfPresent()
        value.nodeLabels = try reader["nodeLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.edgeLabels = try reader["edgeLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.numNodeProperties = try reader["numNodeProperties"].readIfPresent()
        value.numEdgeProperties = try reader["numEdgeProperties"].readIfPresent()
        value.nodeProperties = try reader["nodeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.edgeProperties = try reader["edgeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.totalNodePropertyValues = try reader["totalNodePropertyValues"].readIfPresent()
        value.totalEdgePropertyValues = try reader["totalEdgePropertyValues"].readIfPresent()
        value.nodeStructures = try reader["nodeStructures"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.NodeStructure.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.edgeStructures = try reader["edgeStructures"].readListIfPresent(memberReadingClosure: NeptuneGraphClientTypes.EdgeStructure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptuneGraphClientTypes.EdgeStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.EdgeStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.EdgeStructure()
        value.count = try reader["count"].readIfPresent()
        value.edgeProperties = try reader["edgeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptuneGraphClientTypes.NodeStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.NodeStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.NodeStructure()
        value.count = try reader["count"].readIfPresent()
        value.nodeProperties = try reader["nodeProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.distinctOutgoingEdgeLabels = try reader["distinctOutgoingEdgeLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NeptuneGraphClientTypes.ImportTaskDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.ImportTaskDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.ImportTaskDetails()
        value.status = try reader["status"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeElapsedSeconds = try reader["timeElapsedSeconds"].readIfPresent() ?? 0
        value.progressPercentage = try reader["progressPercentage"].readIfPresent() ?? 0
        value.errorCount = try reader["errorCount"].readIfPresent() ?? 0
        value.errorDetails = try reader["errorDetails"].readIfPresent()
        value.statementCount = try reader["statementCount"].readIfPresent() ?? 0
        value.dictionaryEntryCount = try reader["dictionaryEntryCount"].readIfPresent() ?? 0
        return value
    }
}

extension NeptuneGraphClientTypes.GraphSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.GraphSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.GraphSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.provisionedMemory = try reader["provisionedMemory"].readIfPresent()
        value.publicConnectivity = try reader["publicConnectivity"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.replicaCount = try reader["replicaCount"].readIfPresent()
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        value.deletionProtection = try reader["deletionProtection"].readIfPresent()
        return value
    }
}

extension NeptuneGraphClientTypes.GraphSnapshotSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.GraphSnapshotSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.GraphSnapshotSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.sourceGraphId = try reader["sourceGraphId"].readIfPresent()
        value.snapshotCreateTime = try reader["snapshotCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        return value
    }
}

extension NeptuneGraphClientTypes.ImportTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.ImportTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.ImportTaskSummary()
        value.graphId = try reader["graphId"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.format = try reader["format"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NeptuneGraphClientTypes.PrivateGraphEndpointSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.PrivateGraphEndpointSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.PrivateGraphEndpointSummary()
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        return value
    }
}

extension NeptuneGraphClientTypes.QuerySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NeptuneGraphClientTypes.QuerySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NeptuneGraphClientTypes.QuerySummary()
        value.id = try reader["id"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        value.waited = try reader["waited"].readIfPresent()
        value.elapsed = try reader["elapsed"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public enum NeptuneGraphClientTypes {}
