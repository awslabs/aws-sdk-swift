//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// We couldn't process your request because of an issue with the server. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// We couldn't find the requested resource. Check that your resources exists and were created in the same AWS Region as your request, and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You exceeded the maximum number of requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request isn't valid. Check the syntax and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteHumanLoopInput: Swift.Sendable {
    /// The name of the human loop that you want to delete.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

public struct DeleteHumanLoopOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeHumanLoopInput: Swift.Sendable {
    /// The name of the human loop that you want information about.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

extension SageMakerA2IRuntimeClientTypes {

    /// Information about where the human output will be stored.
    public struct HumanLoopOutput: Swift.Sendable {
        /// The location of the Amazon S3 object where Amazon Augmented AI stores your human loop output.
        /// This member is required.
        public var outputS3Uri: Swift.String?

        public init(
            outputS3Uri: Swift.String? = nil
        )
        {
            self.outputS3Uri = outputS3Uri
        }
    }
}

extension SageMakerA2IRuntimeClientTypes {

    public enum HumanLoopStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [HumanLoopStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeHumanLoopOutput: Swift.Sendable {
    /// The creation time when Amazon Augmented AI created the human loop.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// A failure code that identifies the type of failure. Possible values: ValidationError, Expired, InternalError
    public var failureCode: Swift.String?
    /// The reason why a human loop failed. The failure reason is returned when the status of the human loop is Failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow definition.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the human loop.
    /// This member is required.
    public var humanLoopArn: Swift.String?
    /// The name of the human loop. The name must be lowercase, unique within the Region in your account, and can have up to 63 characters. Valid characters: a-z, 0-9, and - (hyphen).
    /// This member is required.
    public var humanLoopName: Swift.String?
    /// An object that contains information about the output of the human loop.
    public var humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
    /// The status of the human loop.
    /// This member is required.
    public var humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

    public init(
        creationTime: Foundation.Date? = nil,
        failureCode: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopArn: Swift.String? = nil,
        humanLoopName: Swift.String? = nil,
        humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput? = nil,
        humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopArn = humanLoopArn
        self.humanLoopName = humanLoopName
        self.humanLoopOutput = humanLoopOutput
        self.humanLoopStatus = humanLoopStatus
    }
}

extension SageMakerA2IRuntimeClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListHumanLoopsInput: Swift.Sendable {
    /// (Optional) The timestamp of the date when you want the human loops to begin in ISO 8601 format. For example, 2020-02-24.
    public var creationTimeAfter: Foundation.Date?
    /// (Optional) The timestamp of the date before which you want the human loops to begin in ISO 8601 format. For example, 2020-02-24.
    public var creationTimeBefore: Foundation.Date?
    /// The Amazon Resource Name (ARN) of a flow definition.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// The total number of items to return. If the total number of available items is more than the value specified in MaxResults, then a NextToken is returned in the output. You can use this token to display the next page of results.
    public var maxResults: Swift.Int?
    /// A token to display the next page of results.
    public var nextToken: Swift.String?
    /// Optional. The order for displaying results. Valid values: Ascending and Descending.
    public var sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        flowDefinitionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.flowDefinitionArn = flowDefinitionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

extension SageMakerA2IRuntimeClientTypes {

    /// Summary information about the human loop.
    public struct HumanLoopSummary: Swift.Sendable {
        /// When Amazon Augmented AI created the human loop.
        public var creationTime: Foundation.Date?
        /// The reason why the human loop failed. A failure reason is returned when the status of the human loop is Failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the flow definition used to configure the human loop.
        public var flowDefinitionArn: Swift.String?
        /// The name of the human loop.
        public var humanLoopName: Swift.String?
        /// The status of the human loop.
        public var humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            flowDefinitionArn: Swift.String? = nil,
            humanLoopName: Swift.String? = nil,
            humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.flowDefinitionArn = flowDefinitionArn
            self.humanLoopName = humanLoopName
            self.humanLoopStatus = humanLoopStatus
        }
    }
}

public struct ListHumanLoopsOutput: Swift.Sendable {
    /// An array of objects that contain information about the human loops.
    /// This member is required.
    public var humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    /// A token to display the next page of results.
    public var nextToken: Swift.String?

    public init(
        humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.humanLoopSummaries = humanLoopSummaries
        self.nextToken = nextToken
    }
}

/// Your request has the same name as another active human loop but has different input data. You cannot start two human loops with the same name and different input data.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your AWS account. For a list of Amazon A2I service quotes, see [Amazon Augmented AI Service Quotes](https://docs.aws.amazon.com/general/latest/gr/a2i.html). Delete some resources or request an increase in your service quota. You can request a quota increase using Service Quotas or the AWS Support Center. To request an increase, see [AWS Service Quotas](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) in the AWS General Reference.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SageMakerA2IRuntimeClientTypes {

    public enum ContentClassifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case freeOfAdultContent
        case freeOfPersonallyIdentifiableInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentClassifier] {
            return [
                .freeOfAdultContent,
                .freeOfPersonallyIdentifiableInformation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .freeOfAdultContent: return "FreeOfAdultContent"
            case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SageMakerA2IRuntimeClientTypes {

    /// Attributes of the data specified by the customer. Use these to describe the data to be labeled.
    public struct HumanLoopDataAttributes: Swift.Sendable {
        /// Declares that your content is free of personally identifiable information or adult content. Amazon SageMaker can restrict the Amazon Mechanical Turk workers who can view your task based on this information.
        /// This member is required.
        public var contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]?

        public init(
            contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        )
        {
            self.contentClassifiers = contentClassifiers
        }
    }
}

extension SageMakerA2IRuntimeClientTypes {

    /// An object containing the human loop input in JSON format.
    public struct HumanLoopInput: Swift.Sendable {
        /// Serialized input from the human loop. The input must be a string representation of a file in JSON format.
        /// This member is required.
        public var inputContent: Swift.String?

        public init(
            inputContent: Swift.String? = nil
        )
        {
            self.inputContent = inputContent
        }
    }
}

public struct StartHumanLoopInput: Swift.Sendable {
    /// Attributes of the specified data. Use DataAttributes to specify if your data is free of personally identifiable information and/or free of adult content.
    public var dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
    /// The Amazon Resource Name (ARN) of the flow definition associated with this human loop.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// An object that contains information about the human loop.
    /// This member is required.
    public var humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    /// The name of the human loop.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput? = nil,
        humanLoopName: Swift.String? = nil
    )
    {
        self.dataAttributes = dataAttributes
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopInput = humanLoopInput
        self.humanLoopName = humanLoopName
    }
}

public struct StartHumanLoopOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the human loop.
    public var humanLoopArn: Swift.String?

    public init(
        humanLoopArn: Swift.String? = nil
    )
    {
        self.humanLoopArn = humanLoopArn
    }
}

public struct StopHumanLoopInput: Swift.Sendable {
    /// The name of the human loop that you want to stop.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

public struct StopHumanLoopOutput: Swift.Sendable {

    public init() { }
}

extension DeleteHumanLoopInput {

    static func urlPathProvider(_ value: DeleteHumanLoopInput) -> Swift.String? {
        guard let humanLoopName = value.humanLoopName else {
            return nil
        }
        return "/human-loops/\(humanLoopName.urlPercentEncoding())"
    }
}

extension DescribeHumanLoopInput {

    static func urlPathProvider(_ value: DescribeHumanLoopInput) -> Swift.String? {
        guard let humanLoopName = value.humanLoopName else {
            return nil
        }
        return "/human-loops/\(humanLoopName.urlPercentEncoding())"
    }
}

extension ListHumanLoopsInput {

    static func urlPathProvider(_ value: ListHumanLoopsInput) -> Swift.String? {
        return "/human-loops"
    }
}

extension ListHumanLoopsInput {

    static func queryItemProvider(_ value: ListHumanLoopsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let flowDefinitionArn = value.flowDefinitionArn else {
            let message = "Creating a URL Query Item failed. flowDefinitionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let flowDefinitionArnQueryItem = Smithy.URIQueryItem(name: "FlowDefinitionArn".urlPercentEncoding(), value: Swift.String(flowDefinitionArn).urlPercentEncoding())
        items.append(flowDefinitionArnQueryItem)
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "CreationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "CreationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        return items
    }
}

extension StartHumanLoopInput {

    static func urlPathProvider(_ value: StartHumanLoopInput) -> Swift.String? {
        return "/human-loops"
    }
}

extension StopHumanLoopInput {

    static func urlPathProvider(_ value: StopHumanLoopInput) -> Swift.String? {
        return "/human-loops/stop"
    }
}

extension StartHumanLoopInput {

    static func write(value: StartHumanLoopInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataAttributes"].write(value.dataAttributes, with: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes.write(value:to:))
        try writer["FlowDefinitionArn"].write(value.flowDefinitionArn)
        try writer["HumanLoopInput"].write(value.humanLoopInput, with: SageMakerA2IRuntimeClientTypes.HumanLoopInput.write(value:to:))
        try writer["HumanLoopName"].write(value.humanLoopName)
    }
}

extension StopHumanLoopInput {

    static func write(value: StopHumanLoopInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HumanLoopName"].write(value.humanLoopName)
    }
}

extension DeleteHumanLoopOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteHumanLoopOutput {
        return DeleteHumanLoopOutput()
    }
}

extension DescribeHumanLoopOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHumanLoopOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHumanLoopOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureCode = try reader["FailureCode"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.flowDefinitionArn = try reader["FlowDefinitionArn"].readIfPresent() ?? ""
        value.humanLoopArn = try reader["HumanLoopArn"].readIfPresent() ?? ""
        value.humanLoopName = try reader["HumanLoopName"].readIfPresent() ?? ""
        value.humanLoopOutput = try reader["HumanLoopOutput"].readIfPresent(with: SageMakerA2IRuntimeClientTypes.HumanLoopOutput.read(from:))
        value.humanLoopStatus = try reader["HumanLoopStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListHumanLoopsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHumanLoopsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHumanLoopsOutput()
        value.humanLoopSummaries = try reader["HumanLoopSummaries"].readListIfPresent(memberReadingClosure: SageMakerA2IRuntimeClientTypes.HumanLoopSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension StartHumanLoopOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartHumanLoopOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartHumanLoopOutput()
        value.humanLoopArn = try reader["HumanLoopArn"].readIfPresent()
        return value
    }
}

extension StopHumanLoopOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopHumanLoopOutput {
        return StopHumanLoopOutput()
    }
}

enum DeleteHumanLoopOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHumanLoopOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHumanLoopsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartHumanLoopOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopHumanLoopOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerA2IRuntimeClientTypes.HumanLoopOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerA2IRuntimeClientTypes.HumanLoopOutput()
        value.outputS3Uri = try reader["OutputS3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerA2IRuntimeClientTypes.HumanLoopSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerA2IRuntimeClientTypes.HumanLoopSummary()
        value.humanLoopName = try reader["HumanLoopName"].readIfPresent()
        value.humanLoopStatus = try reader["HumanLoopStatus"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.flowDefinitionArn = try reader["FlowDefinitionArn"].readIfPresent()
        return value
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopInput {

    static func write(value: SageMakerA2IRuntimeClientTypes.HumanLoopInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputContent"].write(value.inputContent)
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes {

    static func write(value: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentClassifiers"].writeList(value.contentClassifiers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<SageMakerA2IRuntimeClientTypes.ContentClassifier>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum SageMakerA2IRuntimeClientTypes {}
