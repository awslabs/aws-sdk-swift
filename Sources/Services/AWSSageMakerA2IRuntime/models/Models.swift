// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has the same name as another active human loop but has different input data. You cannot start two human loops with the same name and different input data.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    public enum ContentClassifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case freeOfAdultContent
        case freeOfPersonallyIdentifiableInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentClassifier] {
            return [
                .freeOfAdultContent,
                .freeOfPersonallyIdentifiableInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .freeOfAdultContent: return "FreeOfAdultContent"
            case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentClassifier(rawValue: rawValue) ?? ContentClassifier.sdkUnknown(rawValue)
        }
    }
}

extension DeleteHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let humanLoopName = humanLoopName else {
            return nil
        }
        return "/human-loops/\(humanLoopName.urlPercentEncoding())"
    }
}

public struct DeleteHumanLoopInput: Swift.Equatable {
    /// The name of the human loop that you want to delete.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DeleteHumanLoopInputBody: Swift.Equatable {
}

extension DeleteHumanLoopInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHumanLoopOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteHumanLoopOutput: Swift.Equatable {

    public init() { }
}

enum DeleteHumanLoopOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let humanLoopName = humanLoopName else {
            return nil
        }
        return "/human-loops/\(humanLoopName.urlPercentEncoding())"
    }
}

public struct DescribeHumanLoopInput: Swift.Equatable {
    /// The name of the human loop that you want information about.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DescribeHumanLoopInputBody: Swift.Equatable {
}

extension DescribeHumanLoopInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHumanLoopOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHumanLoopOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.flowDefinitionArn = output.flowDefinitionArn
            self.humanLoopArn = output.humanLoopArn
            self.humanLoopName = output.humanLoopName
            self.humanLoopOutput = output.humanLoopOutput
            self.humanLoopStatus = output.humanLoopStatus
        } else {
            self.creationTime = nil
            self.failureCode = nil
            self.failureReason = nil
            self.flowDefinitionArn = nil
            self.humanLoopArn = nil
            self.humanLoopName = nil
            self.humanLoopOutput = nil
            self.humanLoopStatus = nil
        }
    }
}

public struct DescribeHumanLoopOutput: Swift.Equatable {
    /// The creation time when Amazon Augmented AI created the human loop.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A failure code that identifies the type of failure. Possible values: ValidationError, Expired, InternalError
    public var failureCode: Swift.String?
    /// The reason why a human loop failed. The failure reason is returned when the status of the human loop is Failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow definition.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the human loop.
    /// This member is required.
    public var humanLoopArn: Swift.String?
    /// The name of the human loop. The name must be lowercase, unique within the Region in your account, and can have up to 63 characters. Valid characters: a-z, 0-9, and - (hyphen).
    /// This member is required.
    public var humanLoopName: Swift.String?
    /// An object that contains information about the output of the human loop.
    public var humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
    /// The status of the human loop.
    /// This member is required.
    public var humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        failureCode: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopArn: Swift.String? = nil,
        humanLoopName: Swift.String? = nil,
        humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput? = nil,
        humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopArn = humanLoopArn
        self.humanLoopName = humanLoopName
        self.humanLoopOutput = humanLoopOutput
        self.humanLoopStatus = humanLoopStatus
    }
}

struct DescribeHumanLoopOutputBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let failureReason: Swift.String?
    let failureCode: Swift.String?
    let humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?
    let humanLoopName: Swift.String?
    let humanLoopArn: Swift.String?
    let flowDefinitionArn: Swift.String?
    let humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
}

extension DescribeHumanLoopOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopArn = "HumanLoopArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopOutput = "HumanLoopOutput"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopOutputDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopOutput.self, forKey: .humanLoopOutput)
        humanLoopOutput = humanLoopOutputDecoded
    }
}

enum DescribeHumanLoopOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentClassifiers = "ContentClassifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentClassifiers = contentClassifiers {
            var contentClassifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentClassifiers)
            for contentclassifier0 in contentClassifiers {
                try contentClassifiersContainer.encode(contentclassifier0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentClassifiersContainer = try containerValues.decodeIfPresent([SageMakerA2IRuntimeClientTypes.ContentClassifier?].self, forKey: .contentClassifiers)
        var contentClassifiersDecoded0:[SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        if let contentClassifiersContainer = contentClassifiersContainer {
            contentClassifiersDecoded0 = [SageMakerA2IRuntimeClientTypes.ContentClassifier]()
            for enum0 in contentClassifiersContainer {
                if let enum0 = enum0 {
                    contentClassifiersDecoded0?.append(enum0)
                }
            }
        }
        contentClassifiers = contentClassifiersDecoded0
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// Attributes of the data specified by the customer. Use these to describe the data to be labeled.
    public struct HumanLoopDataAttributes: Swift.Equatable {
        /// Declares that your content is free of personally identifiable information or adult content. Amazon SageMaker can restrict the Amazon Mechanical Turk workers who can view your task based on this information.
        /// This member is required.
        public var contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]?

        public init(
            contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        )
        {
            self.contentClassifiers = contentClassifiers
        }
    }

}

extension SageMakerA2IRuntimeClientTypes.HumanLoopInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputContent = "InputContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputContent = self.inputContent {
            try encodeContainer.encode(inputContent, forKey: .inputContent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputContent)
        inputContent = inputContentDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// An object containing the human loop input in JSON format.
    public struct HumanLoopInput: Swift.Equatable {
        /// Serialized input from the human loop. The input must be a string representation of a file in JSON format.
        /// This member is required.
        public var inputContent: Swift.String?

        public init(
            inputContent: Swift.String? = nil
        )
        {
            self.inputContent = inputContent
        }
    }

}

extension SageMakerA2IRuntimeClientTypes.HumanLoopOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3Uri = "OutputS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Uri = self.outputS3Uri {
            try encodeContainer.encode(outputS3Uri, forKey: .outputS3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Uri)
        outputS3Uri = outputS3UriDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// Information about where the human output will be stored.
    public struct HumanLoopOutput: Swift.Equatable {
        /// The location of the Amazon S3 object where Amazon Augmented AI stores your human loop output.
        /// This member is required.
        public var outputS3Uri: Swift.String?

        public init(
            outputS3Uri: Swift.String? = nil
        )
        {
            self.outputS3Uri = outputS3Uri
        }
    }

}

extension SageMakerA2IRuntimeClientTypes {
    public enum HumanLoopStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [HumanLoopStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HumanLoopStatus(rawValue: rawValue) ?? HumanLoopStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let flowDefinitionArn = self.flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopName = self.humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
        if let humanLoopStatus = self.humanLoopStatus {
            try encodeContainer.encode(humanLoopStatus.rawValue, forKey: .humanLoopStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// Summary information about the human loop.
    public struct HumanLoopSummary: Swift.Equatable {
        /// When Amazon Augmented AI created the human loop.
        public var creationTime: ClientRuntime.Date?
        /// The reason why the human loop failed. A failure reason is returned when the status of the human loop is Failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the flow definition used to configure the human loop.
        public var flowDefinitionArn: Swift.String?
        /// The name of the human loop.
        public var humanLoopName: Swift.String?
        /// The status of the human loop.
        public var humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            flowDefinitionArn: Swift.String? = nil,
            humanLoopName: Swift.String? = nil,
            humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.flowDefinitionArn = flowDefinitionArn
            self.humanLoopName = humanLoopName
            self.humanLoopStatus = humanLoopStatus
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We couldn't process your request because of an issue with the server. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListHumanLoopsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let flowDefinitionArn = flowDefinitionArn else {
                let message = "Creating a URL Query Item failed. flowDefinitionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let flowDefinitionArnQueryItem = ClientRuntime.URLQueryItem(name: "FlowDefinitionArn".urlPercentEncoding(), value: Swift.String(flowDefinitionArn).urlPercentEncoding())
            items.append(flowDefinitionArnQueryItem)
            if let creationTimeBefore = creationTimeBefore {
                let creationTimeBeforeQueryItem = ClientRuntime.URLQueryItem(name: "CreationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
                items.append(creationTimeBeforeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let creationTimeAfter = creationTimeAfter {
                let creationTimeAfterQueryItem = ClientRuntime.URLQueryItem(name: "CreationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
                items.append(creationTimeAfterQueryItem)
            }
            return items
        }
    }
}

extension ListHumanLoopsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/human-loops"
    }
}

public struct ListHumanLoopsInput: Swift.Equatable {
    /// (Optional) The timestamp of the date when you want the human loops to begin in ISO 8601 format. For example, 2020-02-24.
    public var creationTimeAfter: ClientRuntime.Date?
    /// (Optional) The timestamp of the date before which you want the human loops to begin in ISO 8601 format. For example, 2020-02-24.
    public var creationTimeBefore: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of a flow definition.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// The total number of items to return. If the total number of available items is more than the value specified in MaxResults, then a NextToken is returned in the output. You can use this token to display the next page of results.
    public var maxResults: Swift.Int?
    /// A token to display the next page of results.
    public var nextToken: Swift.String?
    /// Optional. The order for displaying results. Valid values: Ascending and Descending.
    public var sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder?

    public init(
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        flowDefinitionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.flowDefinitionArn = flowDefinitionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListHumanLoopsInputBody: Swift.Equatable {
}

extension ListHumanLoopsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListHumanLoopsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHumanLoopsOutputBody = try responseDecoder.decode(responseBody: data)
            self.humanLoopSummaries = output.humanLoopSummaries
            self.nextToken = output.nextToken
        } else {
            self.humanLoopSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListHumanLoopsOutput: Swift.Equatable {
    /// An array of objects that contain information about the human loops.
    /// This member is required.
    public var humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    /// A token to display the next page of results.
    public var nextToken: Swift.String?

    public init(
        humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.humanLoopSummaries = humanLoopSummaries
        self.nextToken = nextToken
    }
}

struct ListHumanLoopsOutputBody: Swift.Equatable {
    let humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    let nextToken: Swift.String?
}

extension ListHumanLoopsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopSummaries = "HumanLoopSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopSummariesContainer = try containerValues.decodeIfPresent([SageMakerA2IRuntimeClientTypes.HumanLoopSummary?].self, forKey: .humanLoopSummaries)
        var humanLoopSummariesDecoded0:[SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil
        if let humanLoopSummariesContainer = humanLoopSummariesContainer {
            humanLoopSummariesDecoded0 = [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]()
            for structure0 in humanLoopSummariesContainer {
                if let structure0 = structure0 {
                    humanLoopSummariesDecoded0?.append(structure0)
                }
            }
        }
        humanLoopSummaries = humanLoopSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHumanLoopsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We couldn't find the requested resource. Check that your resources exists and were created in the same AWS Region as your request, and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your AWS account. For a list of Amazon A2I service quotes, see [Amazon Augmented AI Service Quotes](https://docs.aws.amazon.com/general/latest/gr/a2i.html). Delete some resources or request an increase in your service quota. You can request a quota increase using Service Quotas or the AWS Support Center. To request an increase, see [AWS Service Quotas](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) in the AWS General Reference.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartHumanLoopInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAttributes = self.dataAttributes {
            try encodeContainer.encode(dataAttributes, forKey: .dataAttributes)
        }
        if let flowDefinitionArn = self.flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopInput = self.humanLoopInput {
            try encodeContainer.encode(humanLoopInput, forKey: .humanLoopInput)
        }
        if let humanLoopName = self.humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

extension StartHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/human-loops"
    }
}

public struct StartHumanLoopInput: Swift.Equatable {
    /// Attributes of the specified data. Use DataAttributes to specify if your data is free of personally identifiable information and/or free of adult content.
    public var dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
    /// The Amazon Resource Name (ARN) of the flow definition associated with this human loop.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// An object that contains information about the human loop.
    /// This member is required.
    public var humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    /// The name of the human loop.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput? = nil,
        humanLoopName: Swift.String? = nil
    )
    {
        self.dataAttributes = dataAttributes
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopInput = humanLoopInput
        self.humanLoopName = humanLoopName
    }
}

struct StartHumanLoopInputBody: Swift.Equatable {
    let humanLoopName: Swift.String?
    let flowDefinitionArn: Swift.String?
    let humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    let dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
}

extension StartHumanLoopInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopInputDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopInput.self, forKey: .humanLoopInput)
        humanLoopInput = humanLoopInputDecoded
        let dataAttributesDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes.self, forKey: .dataAttributes)
        dataAttributes = dataAttributesDecoded
    }
}

extension StartHumanLoopOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartHumanLoopOutputBody = try responseDecoder.decode(responseBody: data)
            self.humanLoopArn = output.humanLoopArn
        } else {
            self.humanLoopArn = nil
        }
    }
}

public struct StartHumanLoopOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the human loop.
    public var humanLoopArn: Swift.String?

    public init(
        humanLoopArn: Swift.String? = nil
    )
    {
        self.humanLoopArn = humanLoopArn
    }
}

struct StartHumanLoopOutputBody: Swift.Equatable {
    let humanLoopArn: Swift.String?
}

extension StartHumanLoopOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopArn = "HumanLoopArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
    }
}

enum StartHumanLoopOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopHumanLoopInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let humanLoopName = self.humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

extension StopHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/human-loops/stop"
    }
}

public struct StopHumanLoopInput: Swift.Equatable {
    /// The name of the human loop that you want to stop.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init(
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct StopHumanLoopInputBody: Swift.Equatable {
    let humanLoopName: Swift.String?
}

extension StopHumanLoopInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
    }
}

extension StopHumanLoopOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopHumanLoopOutput: Swift.Equatable {

    public init() { }
}

enum StopHumanLoopOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You exceeded the maximum number of requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request isn't valid. Check the syntax and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
