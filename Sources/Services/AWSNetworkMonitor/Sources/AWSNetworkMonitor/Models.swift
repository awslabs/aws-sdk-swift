//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NetworkMonitorClientTypes {

    public enum AddressFamily: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressFamily] {
            return [
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// This operation attempted to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One of the parameters for the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NetworkMonitorClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icmp
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .icmp,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icmp: return "ICMP"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkMonitorClientTypes {

    /// Creates a monitor probe.
    public struct CreateMonitorProbeInput: Swift.Sendable {
        /// The destination IP address. This must be either IPV4 or IPV6.
        /// This member is required.
        public var destination: Swift.String?
        /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
        public var destinationPort: Swift.Int?
        /// The size of the packets sent between the source and destination. This must be a number between 56 and 8500.
        public var packetSize: Swift.Int?
        /// The list of key-value pairs created and assigned to the monitor.
        public var probeTags: [Swift.String: Swift.String]?
        /// The protocol used for the network traffic between the source and destination. This must be either TCP or ICMP.
        /// This member is required.
        public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
        /// The ARN of the subnet.
        /// This member is required.
        public var sourceArn: Swift.String?

        public init(
            destination: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            packetSize: Swift.Int? = nil,
            probeTags: [Swift.String: Swift.String]? = nil,
            `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
            sourceArn: Swift.String? = nil
        )
        {
            self.destination = destination
            self.destinationPort = destinationPort
            self.packetSize = packetSize
            self.probeTags = probeTags
            self.`protocol` = `protocol`
            self.sourceArn = sourceArn
        }
    }
}

public struct CreateMonitorInput: Swift.Sendable {
    /// The time, in seconds, that metrics are aggregated and sent to Amazon CloudWatch. Valid values are either 30 or 60. 60 is the default if no period is chosen.
    public var aggregationPeriod: Swift.Int?
    /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
    public var clientToken: Swift.String?
    /// The name identifying the monitor. It can contain only letters, underscores (_), or dashes (-), and can be up to 200 characters.
    /// This member is required.
    public var monitorName: Swift.String?
    /// Displays a list of all of the probes created for a monitor.
    public var probes: [NetworkMonitorClientTypes.CreateMonitorProbeInput]?
    /// The list of key-value pairs created and assigned to the monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        probes: [NetworkMonitorClientTypes.CreateMonitorProbeInput]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.clientToken = clientToken
        self.monitorName = monitorName
        self.probes = probes
        self.tags = tags
    }
}

extension NetworkMonitorClientTypes {

    public enum MonitorState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorState] {
            return [
                .active,
                .deleting,
                .error,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMonitorOutput: Swift.Sendable {
    /// The number of seconds that metrics are aggregated by and sent to Amazon CloudWatch. This will be either 30 or 60.
    public var aggregationPeriod: Swift.Int?
    /// The ARN of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The state of the monitor.
    /// This member is required.
    public var state: NetworkMonitorClientTypes.MonitorState?
    /// The list of key-value pairs assigned to the monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        state: NetworkMonitorClientTypes.MonitorState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.state = state
        self.tags = tags
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NetworkMonitorClientTypes {

    /// Defines a probe when creating a probe or monitor.
    public struct ProbeInput: Swift.Sendable {
        /// The destination IP address. This must be either IPV4 or IPV6.
        /// This member is required.
        public var destination: Swift.String?
        /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
        public var destinationPort: Swift.Int?
        /// The size of the packets sent between the source and destination. This must be a number between 56 and 8500.
        public var packetSize: Swift.Int?
        /// The protocol used for the network traffic between the source and destination. This must be either TCP or ICMP.
        /// This member is required.
        public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
        /// The ARN of the subnet.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// The list of key-value pairs created and assigned to the monitor.
        public var tags: [Swift.String: Swift.String]?

        public init(
            destination: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            packetSize: Swift.Int? = nil,
            `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
            sourceArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.destination = destination
            self.destinationPort = destinationPort
            self.packetSize = packetSize
            self.`protocol` = `protocol`
            self.sourceArn = sourceArn
            self.tags = tags
        }
    }
}

public struct CreateProbeInput: Swift.Sendable {
    /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
    public var clientToken: Swift.String?
    /// The name of the monitor to associated with the probe.
    /// This member is required.
    public var monitorName: Swift.String?
    /// Describes the details of an individual probe for a monitor.
    /// This member is required.
    public var probe: NetworkMonitorClientTypes.ProbeInput?
    /// The list of key-value pairs created and assigned to the probe.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        probe: NetworkMonitorClientTypes.ProbeInput? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.monitorName = monitorName
        self.probe = probe
        self.tags = tags
    }
}

extension NetworkMonitorClientTypes {

    public enum ProbeState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ProbeState] {
            return [
                .active,
                .deleted,
                .deleting,
                .error,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProbeOutput: Swift.Sendable {
    /// Indicates whether the IP address is IPV4 or IPV6.
    public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
    /// The time and date that the probe was created.
    public var createdAt: Foundation.Date?
    /// The destination IP address for the monitor. This must be either an IPv4 or IPv6 address.
    /// This member is required.
    public var destination: Swift.String?
    /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The time and date when the probe was last modified.
    public var modifiedAt: Foundation.Date?
    /// The size of the packets sent between the source and destination. This must be a number between 56 and 8500.
    public var packetSize: Swift.Int?
    /// The ARN of the probe.
    public var probeArn: Swift.String?
    /// The ID of the probe for which details are returned.
    public var probeId: Swift.String?
    /// The protocol used for the network traffic between the source and destination. This must be either TCP or ICMP.
    /// This member is required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The ARN of the probe.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The state of the probe.
    public var state: NetworkMonitorClientTypes.ProbeState?
    /// The list of key-value pairs assigned to the probe.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the source VPC or subnet.
    public var vpcId: Swift.String?

    public init(
        addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
        createdAt: Foundation.Date? = nil,
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        modifiedAt: Foundation.Date? = nil,
        packetSize: Swift.Int? = nil,
        probeArn: Swift.String? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.createdAt = createdAt
        self.destination = destination
        self.destinationPort = destinationPort
        self.modifiedAt = modifiedAt
        self.packetSize = packetSize
        self.probeArn = probeArn
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

public struct DeleteMonitorInput: Swift.Sendable {
    /// The name of the monitor to delete.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

public struct DeleteMonitorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProbeInput: Swift.Sendable {
    /// The name of the monitor to delete.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The ID of the probe to delete.
    /// This member is required.
    public var probeId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        probeId: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
        self.probeId = probeId
    }
}

public struct DeleteProbeOutput: Swift.Sendable {

    public init() { }
}

public struct GetMonitorInput: Swift.Sendable {
    /// The name of the monitor that details are returned for.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

extension NetworkMonitorClientTypes {

    /// Describes information about a network monitor probe.
    public struct Probe: Swift.Sendable {
        /// The IPv4 or IPv6 address for the probe.
        public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
        /// The time and date the probe was created.
        public var createdAt: Foundation.Date?
        /// The destination for the probe. This should be either an IPV4 or IPV6.
        /// This member is required.
        public var destination: Swift.String?
        /// The destination port for the probe. This is required only if the protocol is TCP and must be a number between 1 and 65536.
        public var destinationPort: Swift.Int?
        /// The time and date that the probe was last modified.
        public var modifiedAt: Foundation.Date?
        /// The size of the packets traveling between the source and destination. This must be a number between 56 and
        public var packetSize: Swift.Int?
        /// The ARN of the probe.
        public var probeArn: Swift.String?
        /// The ID of the probe.
        public var probeId: Swift.String?
        /// The network protocol for the destination. This can be either TCP or ICMP. If the protocol is TCP, then port is also required.
        /// This member is required.
        public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
        /// The ARN of the probe source subnet.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// The state of the probe.
        public var state: NetworkMonitorClientTypes.ProbeState?
        /// The list of key-value pairs created and assigned to the probe.
        public var tags: [Swift.String: Swift.String]?
        /// The ID of the source VPC subnet.
        public var vpcId: Swift.String?

        public init(
            addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
            createdAt: Foundation.Date? = nil,
            destination: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            modifiedAt: Foundation.Date? = nil,
            packetSize: Swift.Int? = nil,
            probeArn: Swift.String? = nil,
            probeId: Swift.String? = nil,
            `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
            sourceArn: Swift.String? = nil,
            state: NetworkMonitorClientTypes.ProbeState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressFamily = addressFamily
            self.createdAt = createdAt
            self.destination = destination
            self.destinationPort = destinationPort
            self.modifiedAt = modifiedAt
            self.packetSize = packetSize
            self.probeArn = probeArn
            self.probeId = probeId
            self.`protocol` = `protocol`
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
            self.vpcId = vpcId
        }
    }
}

public struct GetMonitorOutput: Swift.Sendable {
    /// The aggregation period for the specified monitor.
    /// This member is required.
    public var aggregationPeriod: Swift.Int?
    /// The time and date when the monitor was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The time and date when the monitor was last modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The ARN of the selected monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The details about each probe associated with that monitor.
    public var probes: [NetworkMonitorClientTypes.Probe]?
    /// Lists the status of the state of each monitor.
    /// This member is required.
    public var state: NetworkMonitorClientTypes.MonitorState?
    /// The list of key-value pairs assigned to the monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        modifiedAt: Foundation.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        probes: [NetworkMonitorClientTypes.Probe]? = nil,
        state: NetworkMonitorClientTypes.MonitorState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.probes = probes
        self.state = state
        self.tags = tags
    }
}

public struct GetProbeInput: Swift.Sendable {
    /// The name of the monitor associated with the probe. Run ListMonitors to get a list of monitor names.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The ID of the probe to get information about. Run GetMonitor action to get a list of probes and probe IDs for the monitor.
    /// This member is required.
    public var probeId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        probeId: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
        self.probeId = probeId
    }
}

public struct GetProbeOutput: Swift.Sendable {
    /// Indicates whether the IP address is IPV4 or IPV6.
    public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
    /// The time and date that the probe was created.
    public var createdAt: Foundation.Date?
    /// The destination IP address for the monitor. This must be either an IPv4 or IPv6 address.
    /// This member is required.
    public var destination: Swift.String?
    /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The time and date that the probe was last modified.
    public var modifiedAt: Foundation.Date?
    /// The size of the packets sent between the source and destination. This must be a number between 56 and 8500.
    public var packetSize: Swift.Int?
    /// The ARN of the probe.
    public var probeArn: Swift.String?
    /// The ID of the probe for which details are returned.
    public var probeId: Swift.String?
    /// The protocol used for the network traffic between the source and destination. This must be either TCP or ICMP.
    /// This member is required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The ARN of the probe.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The state of the probe.
    public var state: NetworkMonitorClientTypes.ProbeState?
    /// The list of key-value pairs assigned to the probe.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the source VPC or subnet.
    public var vpcId: Swift.String?

    public init(
        addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
        createdAt: Foundation.Date? = nil,
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        modifiedAt: Foundation.Date? = nil,
        packetSize: Swift.Int? = nil,
        probeArn: Swift.String? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.createdAt = createdAt
        self.destination = destination
        self.destinationPort = destinationPort
        self.modifiedAt = modifiedAt
        self.packetSize = packetSize
        self.probeArn = probeArn
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

public struct ListMonitorsInput: Swift.Sendable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of all monitors and their states.
    public var state: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

extension NetworkMonitorClientTypes {

    /// Displays summary information about a monitor.
    public struct MonitorSummary: Swift.Sendable {
        /// The time, in seconds, that metrics are collected and sent to Amazon CloudWatch. Valid values are either 30 or 60.
        public var aggregationPeriod: Swift.Int?
        /// The ARN of the monitor.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// The state of the monitor.
        /// This member is required.
        public var state: NetworkMonitorClientTypes.MonitorState?
        /// The list of key-value pairs assigned to the monitor.
        public var tags: [Swift.String: Swift.String]?

        public init(
            aggregationPeriod: Swift.Int? = nil,
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            state: NetworkMonitorClientTypes.MonitorState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.aggregationPeriod = aggregationPeriod
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.state = state
            self.tags = tags
        }
    }
}

public struct ListMonitorsOutput: Swift.Sendable {
    /// Lists individual details about each of your monitors.
    /// This member is required.
    public var monitors: [NetworkMonitorClientTypes.MonitorSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        monitors: [NetworkMonitorClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Lists the tags assigned to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct UpdateMonitorInput: Swift.Sendable {
    /// The aggregation time, in seconds, to change to. This must be either 30 or 60.
    /// This member is required.
    public var aggregationPeriod: Swift.Int?
    /// The name of the monitor to update.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.monitorName = monitorName
    }
}

public struct UpdateMonitorOutput: Swift.Sendable {
    /// The changed aggregation period.
    public var aggregationPeriod: Swift.Int?
    /// The ARN of the monitor that was updated.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor that was updated.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The state of the updated monitor.
    /// This member is required.
    public var state: NetworkMonitorClientTypes.MonitorState?
    /// The list of key-value pairs associated with the monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        state: NetworkMonitorClientTypes.MonitorState? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.state = state
        self.tags = tags
    }
}

public struct UpdateProbeInput: Swift.Sendable {
    /// The updated IP address for the probe destination. This must be either an IPv4 or IPv6 address.
    public var destination: Swift.String?
    /// The updated port for the probe destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The name of the monitor that the probe was updated for.
    /// This member is required.
    public var monitorName: Swift.String?
    /// he updated packets size for network traffic between the source and destination. This must be a number between 56 and 8500.
    public var packetSize: Swift.Int?
    /// The ID of the probe to update.
    /// This member is required.
    public var probeId: Swift.String?
    /// The updated network protocol for the destination. This can be either TCP or ICMP. If the protocol is TCP, then port is also required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The state of the probe update.
    public var state: NetworkMonitorClientTypes.ProbeState?

    public init(
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        packetSize: Swift.Int? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil
    )
    {
        self.destination = destination
        self.destinationPort = destinationPort
        self.monitorName = monitorName
        self.packetSize = packetSize
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.state = state
    }
}

public struct UpdateProbeOutput: Swift.Sendable {
    /// The updated IP address family. This must be either IPV4 or IPV6.
    public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
    /// The time and date that the probe was created.
    public var createdAt: Foundation.Date?
    /// The updated destination IP address for the probe.
    /// This member is required.
    public var destination: Swift.String?
    /// The updated destination port. This must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The time and date that the probe was last updated.
    public var modifiedAt: Foundation.Date?
    /// The updated packet size for the probe.
    public var packetSize: Swift.Int?
    /// The updated ARN of the probe.
    public var probeArn: Swift.String?
    /// The updated ID of the probe.
    public var probeId: Swift.String?
    /// The updated protocol for the probe.
    /// This member is required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The updated ARN of the source subnet.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The state of the updated probe.
    public var state: NetworkMonitorClientTypes.ProbeState?
    /// Update tags for a probe.
    public var tags: [Swift.String: Swift.String]?
    /// The updated ID of the source VPC subnet ID.
    public var vpcId: Swift.String?

    public init(
        addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
        createdAt: Foundation.Date? = nil,
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        modifiedAt: Foundation.Date? = nil,
        packetSize: Swift.Int? = nil,
        probeArn: Swift.String? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.createdAt = createdAt
        self.destination = destination
        self.destinationPort = destinationPort
        self.modifiedAt = modifiedAt
        self.packetSize = packetSize
        self.probeArn = probeArn
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the monitor or probe to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs assigned to the monitor or probe.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the monitor or probe that the tag should be removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pa
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateMonitorInput {

    static func urlPathProvider(_ value: CreateMonitorInput) -> Swift.String? {
        return "/monitors"
    }
}

extension CreateProbeInput {

    static func urlPathProvider(_ value: CreateProbeInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes"
    }
}

extension DeleteMonitorInput {

    static func urlPathProvider(_ value: DeleteMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension DeleteProbeInput {

    static func urlPathProvider(_ value: DeleteProbeInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let probeId = value.probeId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes/\(probeId.urlPercentEncoding())"
    }
}

extension GetMonitorInput {

    static func urlPathProvider(_ value: GetMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension GetProbeInput {

    static func urlPathProvider(_ value: GetProbeInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let probeId = value.probeId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes/\(probeId.urlPercentEncoding())"
    }
}

extension ListMonitorsInput {

    static func urlPathProvider(_ value: ListMonitorsInput) -> Swift.String? {
        return "/monitors"
    }
}

extension ListMonitorsInput {

    static func queryItemProvider(_ value: ListMonitorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateMonitorInput {

    static func urlPathProvider(_ value: UpdateMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension UpdateProbeInput {

    static func urlPathProvider(_ value: UpdateProbeInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let probeId = value.probeId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes/\(probeId.urlPercentEncoding())"
    }
}

extension CreateMonitorInput {

    static func write(value: CreateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationPeriod"].write(value.aggregationPeriod)
        try writer["clientToken"].write(value.clientToken)
        try writer["monitorName"].write(value.monitorName)
        try writer["probes"].writeList(value.probes, memberWritingClosure: NetworkMonitorClientTypes.CreateMonitorProbeInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateProbeInput {

    static func write(value: CreateProbeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["probe"].write(value.probe, with: NetworkMonitorClientTypes.ProbeInput.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateMonitorInput {

    static func write(value: UpdateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationPeriod"].write(value.aggregationPeriod)
    }
}

extension UpdateProbeInput {

    static func write(value: UpdateProbeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["packetSize"].write(value.packetSize)
        try writer["protocol"].write(value.`protocol`)
        try writer["state"].write(value.state)
    }
}

extension CreateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMonitorOutput()
        value.aggregationPeriod = try reader["aggregationPeriod"].readIfPresent()
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateProbeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProbeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProbeOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["destination"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.packetSize = try reader["packetSize"].readIfPresent()
        value.probeArn = try reader["probeArn"].readIfPresent()
        value.probeId = try reader["probeId"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.sourceArn = try reader["sourceArn"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension DeleteMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMonitorOutput {
        return DeleteMonitorOutput()
    }
}

extension DeleteProbeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProbeOutput {
        return DeleteProbeOutput()
    }
}

extension GetMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMonitorOutput()
        value.aggregationPeriod = try reader["aggregationPeriod"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.probes = try reader["probes"].readListIfPresent(memberReadingClosure: NetworkMonitorClientTypes.Probe.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetProbeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProbeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProbeOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["destination"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.packetSize = try reader["packetSize"].readIfPresent()
        value.probeArn = try reader["probeArn"].readIfPresent()
        value.probeId = try reader["probeId"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.sourceArn = try reader["sourceArn"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension ListMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitorsOutput()
        value.monitors = try reader["monitors"].readListIfPresent(memberReadingClosure: NetworkMonitorClientTypes.MonitorSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMonitorOutput()
        value.aggregationPeriod = try reader["aggregationPeriod"].readIfPresent()
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateProbeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProbeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProbeOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destination = try reader["destination"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.packetSize = try reader["packetSize"].readIfPresent()
        value.probeArn = try reader["probeArn"].readIfPresent()
        value.probeId = try reader["probeId"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.sourceArn = try reader["sourceArn"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

enum CreateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProbeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProbeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProbeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProbeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NetworkMonitorClientTypes.Probe {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkMonitorClientTypes.Probe {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkMonitorClientTypes.Probe()
        value.probeId = try reader["probeId"].readIfPresent()
        value.probeArn = try reader["probeArn"].readIfPresent()
        value.sourceArn = try reader["sourceArn"].readIfPresent() ?? ""
        value.destination = try reader["destination"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.packetSize = try reader["packetSize"].readIfPresent()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NetworkMonitorClientTypes.MonitorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkMonitorClientTypes.MonitorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkMonitorClientTypes.MonitorSummary()
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.aggregationPeriod = try reader["aggregationPeriod"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NetworkMonitorClientTypes.CreateMonitorProbeInput {

    static func write(value: NetworkMonitorClientTypes.CreateMonitorProbeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["packetSize"].write(value.packetSize)
        try writer["probeTags"].writeMap(value.probeTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["protocol"].write(value.`protocol`)
        try writer["sourceArn"].write(value.sourceArn)
    }
}

extension NetworkMonitorClientTypes.ProbeInput {

    static func write(value: NetworkMonitorClientTypes.ProbeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination)
        try writer["destinationPort"].write(value.destinationPort)
        try writer["packetSize"].write(value.packetSize)
        try writer["protocol"].write(value.`protocol`)
        try writer["sourceArn"].write(value.sourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public enum NetworkMonitorClientTypes {}
