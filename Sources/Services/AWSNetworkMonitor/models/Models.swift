// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkMonitorClientTypes {
    public enum AddressFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressFamily] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AddressFamily(rawValue: rawValue) ?? AddressFamily.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation attempted to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
        case clientToken
        case monitorName
        case probes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationPeriod = self.aggregationPeriod {
            try encodeContainer.encode(aggregationPeriod, forKey: .aggregationPeriod)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let probes = probes {
            var probesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .probes)
            for createmonitorprobeinput0 in probes {
                try probesContainer.encode(createmonitorprobeinput0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/monitors"
    }
}

public struct CreateMonitorInput: Swift.Equatable {
    /// The time, in seconds, that metrics are aggregated and sent to Amazon CloudWatch. Valid values are either 30 or 60.
    public var aggregationPeriod: Swift.Int?
    /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
    public var clientToken: Swift.String?
    /// The name identifying the monitor. It can contain only letters, underscores (_), or dashes (-), and can be up to 255 characters.
    /// This member is required.
    public var monitorName: Swift.String?
    /// Displays a list of all of the probes created for a monitor.
    public var probes: [NetworkMonitorClientTypes.CreateMonitorProbeInput]?
    /// The list of key-value pairs created and assigned to the monitor.
    public var tags: [Swift.String:Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        probes: [NetworkMonitorClientTypes.CreateMonitorProbeInput]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.clientToken = clientToken
        self.monitorName = monitorName
        self.probes = probes
        self.tags = tags
    }
}

struct CreateMonitorInputBody: Swift.Equatable {
    let monitorName: Swift.String?
    let probes: [NetworkMonitorClientTypes.CreateMonitorProbeInput]?
    let aggregationPeriod: Swift.Int?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
        case clientToken
        case monitorName
        case probes
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let probesContainer = try containerValues.decodeIfPresent([NetworkMonitorClientTypes.CreateMonitorProbeInput?].self, forKey: .probes)
        var probesDecoded0:[NetworkMonitorClientTypes.CreateMonitorProbeInput]? = nil
        if let probesContainer = probesContainer {
            probesDecoded0 = [NetworkMonitorClientTypes.CreateMonitorProbeInput]()
            for structure0 in probesContainer {
                if let structure0 = structure0 {
                    probesDecoded0?.append(structure0)
                }
            }
        }
        probes = probesDecoded0
        let aggregationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .aggregationPeriod)
        aggregationPeriod = aggregationPeriodDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationPeriod = output.aggregationPeriod
            self.monitorArn = output.monitorArn
            self.monitorName = output.monitorName
            self.state = output.state
            self.tags = output.tags
        } else {
            self.aggregationPeriod = nil
            self.monitorArn = nil
            self.monitorName = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateMonitorOutput: Swift.Equatable {
    /// The number of seconds that metrics are aggregated by and sent to Amazon CloudWatch. This will be either 30 or 60.
    public var aggregationPeriod: Swift.Int?
    /// The ARN of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The state of the monitor.
    /// This member is required.
    public var state: NetworkMonitorClientTypes.MonitorState?
    /// The list of key-value pairs assigned to the monitor.
    public var tags: [Swift.String:Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        state: NetworkMonitorClientTypes.MonitorState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.state = state
        self.tags = tags
    }
}

struct CreateMonitorOutputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let monitorName: Swift.String?
    let state: NetworkMonitorClientTypes.MonitorState?
    let aggregationPeriod: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
        case monitorArn
        case monitorName
        case state
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.MonitorState.self, forKey: .state)
        state = stateDecoded
        let aggregationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .aggregationPeriod)
        aggregationPeriod = aggregationPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NetworkMonitorClientTypes.CreateMonitorProbeInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationPort
        case packetSize
        case probeTags
        case `protocol` = "protocol"
        case sourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let packetSize = self.packetSize {
            try encodeContainer.encode(packetSize, forKey: .packetSize)
        }
        if let probeTags = probeTags {
            var probeTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .probeTags)
            for (dictKey0, tagMap0) in probeTags {
                try probeTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
        let probeTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .probeTags)
        var probeTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let probeTagsContainer = probeTagsContainer {
            probeTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in probeTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    probeTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        probeTags = probeTagsDecoded0
    }
}

extension NetworkMonitorClientTypes {
    /// Creates a monitor probe.
    public struct CreateMonitorProbeInput: Swift.Equatable {
        /// The destination IP address. This will be either IPV4 or IPV6.
        /// This member is required.
        public var destination: Swift.String?
        /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
        public var destinationPort: Swift.Int?
        /// The size of the packets sent between the source and destination. This will be a number between 56 and 8500.
        public var packetSize: Swift.Int?
        /// The list of key-value pairs created and assigned to the monitor.
        public var probeTags: [Swift.String:Swift.String]?
        /// The protocol used for the network traffic between the source and destination. This will be either TCP or ICMP.
        /// This member is required.
        public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
        /// The ARN of the subnet.
        /// This member is required.
        public var sourceArn: Swift.String?

        public init(
            destination: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            packetSize: Swift.Int? = nil,
            probeTags: [Swift.String:Swift.String]? = nil,
            `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
            sourceArn: Swift.String? = nil
        )
        {
            self.destination = destination
            self.destinationPort = destinationPort
            self.packetSize = packetSize
            self.probeTags = probeTags
            self.`protocol` = `protocol`
            self.sourceArn = sourceArn
        }
    }

}

extension CreateProbeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case probe
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let probe = self.probe {
            try encodeContainer.encode(probe, forKey: .probe)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProbeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes"
    }
}

public struct CreateProbeInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
    public var clientToken: Swift.String?
    /// The name of the monitor to associated with the probe. To get a list of available monitors, use ListMonitors.
    /// This member is required.
    public var monitorName: Swift.String?
    /// Describes the details of an individual probe for a monitor.
    /// This member is required.
    public var probe: NetworkMonitorClientTypes.ProbeInput?
    /// The list of key-value pairs created and assigned to the probe.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        probe: NetworkMonitorClientTypes.ProbeInput? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.monitorName = monitorName
        self.probe = probe
        self.tags = tags
    }
}

struct CreateProbeInputBody: Swift.Equatable {
    let probe: NetworkMonitorClientTypes.ProbeInput?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProbeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case probe
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let probeDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ProbeInput.self, forKey: .probe)
        probe = probeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProbeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProbeOutputBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.addressFamily = output.addressFamily
            self.createdAt = output.createdAt
            self.destination = output.destination
            self.destinationPort = output.destinationPort
            self.modifiedAt = output.modifiedAt
            self.packetSize = output.packetSize
            self.probeArn = output.probeArn
            self.probeId = output.probeId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.addressFamily = nil
            self.createdAt = nil
            self.destination = nil
            self.destinationPort = nil
            self.modifiedAt = nil
            self.packetSize = nil
            self.probeArn = nil
            self.probeId = nil
            self.`protocol` = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct CreateProbeOutput: Swift.Equatable {
    /// Indicates whether the IP address is IPV4 or IPV6.
    public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
    /// The time and date that the probe was created.
    public var createdAt: ClientRuntime.Date?
    /// The destination IP address for the monitor. This will be either an IPv4 or IPv6 address.
    /// This member is required.
    public var destination: Swift.String?
    /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The time and date when the probe was last modified.
    public var modifiedAt: ClientRuntime.Date?
    /// The size of the packets sent between the source and destination. This will be a number between 56 and 8500.
    public var packetSize: Swift.Int?
    /// The ARN of the probe.
    public var probeArn: Swift.String?
    /// The ID of the probe for which details are returned.
    public var probeId: Swift.String?
    /// The protocol used for the network traffic between the source and destination. This will be either TCP or ICMP.
    /// This member is required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The ARN of the probe.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The state of the probe.
    public var state: NetworkMonitorClientTypes.ProbeState?
    /// The list of key-value pairs assigned to the probe.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the source VPC or subnet.
    public var vpcId: Swift.String?

    public init(
        addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
        createdAt: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        packetSize: Swift.Int? = nil,
        probeArn: Swift.String? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.createdAt = createdAt
        self.destination = destination
        self.destinationPort = destinationPort
        self.modifiedAt = modifiedAt
        self.packetSize = packetSize
        self.probeArn = probeArn
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateProbeOutputBody: Swift.Equatable {
    let probeId: Swift.String?
    let probeArn: Swift.String?
    let sourceArn: Swift.String?
    let destination: Swift.String?
    let destinationPort: Swift.Int?
    let `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    let packetSize: Swift.Int?
    let addressFamily: NetworkMonitorClientTypes.AddressFamily?
    let vpcId: Swift.String?
    let state: NetworkMonitorClientTypes.ProbeState?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProbeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case createdAt
        case destination
        case destinationPort
        case modifiedAt
        case packetSize
        case probeArn
        case probeId
        case `protocol` = "protocol"
        case sourceArn
        case state
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let probeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeId)
        probeId = probeIdDecoded
        let probeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeArn)
        probeArn = probeArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ProbeState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateProbeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

public struct DeleteMonitorInput: Swift.Equatable {
    /// The name of the monitor to delete. Use the ListMonitors action to get a list of your current monitors.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

struct DeleteMonitorInputBody: Swift.Equatable {
}

extension DeleteMonitorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMonitorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProbeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        guard let probeId = probeId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes/\(probeId.urlPercentEncoding())"
    }
}

public struct DeleteProbeInput: Swift.Equatable {
    /// The name of the monitor to delete. For a list of the available monitors, use the ListMonitors action.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The ID of the probe to delete. Run GetMonitor to get a lst of all probes and probe IDs associated with the monitor.
    /// This member is required.
    public var probeId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        probeId: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
        self.probeId = probeId
    }
}

struct DeleteProbeInputBody: Swift.Equatable {
}

extension DeleteProbeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProbeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProbeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProbeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

public struct GetMonitorInput: Swift.Equatable {
    /// The name of the monitor that details are returned for.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

struct GetMonitorInputBody: Swift.Equatable {
}

extension GetMonitorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationPeriod = output.aggregationPeriod
            self.createdAt = output.createdAt
            self.modifiedAt = output.modifiedAt
            self.monitorArn = output.monitorArn
            self.monitorName = output.monitorName
            self.probes = output.probes
            self.state = output.state
            self.tags = output.tags
        } else {
            self.aggregationPeriod = nil
            self.createdAt = nil
            self.modifiedAt = nil
            self.monitorArn = nil
            self.monitorName = nil
            self.probes = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct GetMonitorOutput: Swift.Equatable {
    /// The aggregation period for the specified monitor.
    /// This member is required.
    public var aggregationPeriod: Swift.Int?
    /// The time and date when the monitor was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The time and date when the monitor was last modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// The ARN of the selected monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor. To get a list of the current monitors and their names, use the ListMonitors action.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The details about each probe associated with that monitor.
    public var probes: [NetworkMonitorClientTypes.Probe]?
    /// Returns a list of the state of each monitor.
    /// This member is required.
    public var state: NetworkMonitorClientTypes.MonitorState?
    /// The list of key-value pairs assigned to the monitor.
    public var tags: [Swift.String:Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        createdAt: ClientRuntime.Date? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        probes: [NetworkMonitorClientTypes.Probe]? = nil,
        state: NetworkMonitorClientTypes.MonitorState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.probes = probes
        self.state = state
        self.tags = tags
    }
}

struct GetMonitorOutputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let monitorName: Swift.String?
    let state: NetworkMonitorClientTypes.MonitorState?
    let aggregationPeriod: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let probes: [NetworkMonitorClientTypes.Probe]?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension GetMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
        case createdAt
        case modifiedAt
        case monitorArn
        case monitorName
        case probes
        case state
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.MonitorState.self, forKey: .state)
        state = stateDecoded
        let aggregationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .aggregationPeriod)
        aggregationPeriod = aggregationPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let probesContainer = try containerValues.decodeIfPresent([NetworkMonitorClientTypes.Probe?].self, forKey: .probes)
        var probesDecoded0:[NetworkMonitorClientTypes.Probe]? = nil
        if let probesContainer = probesContainer {
            probesDecoded0 = [NetworkMonitorClientTypes.Probe]()
            for structure0 in probesContainer {
                if let structure0 = structure0 {
                    probesDecoded0?.append(structure0)
                }
            }
        }
        probes = probesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum GetMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProbeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        guard let probeId = probeId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes/\(probeId.urlPercentEncoding())"
    }
}

public struct GetProbeInput: Swift.Equatable {
    /// The name of the monitor associated with the probe. Run ListMonitors to get a list of monitor names.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The ID of the probe to get information about. Run GetMonitor action to get a list of probes and probe IDs for the monitor.
    /// This member is required.
    public var probeId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        probeId: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
        self.probeId = probeId
    }
}

struct GetProbeInputBody: Swift.Equatable {
}

extension GetProbeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProbeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProbeOutputBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.addressFamily = output.addressFamily
            self.createdAt = output.createdAt
            self.destination = output.destination
            self.destinationPort = output.destinationPort
            self.modifiedAt = output.modifiedAt
            self.packetSize = output.packetSize
            self.probeArn = output.probeArn
            self.probeId = output.probeId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.addressFamily = nil
            self.createdAt = nil
            self.destination = nil
            self.destinationPort = nil
            self.modifiedAt = nil
            self.packetSize = nil
            self.probeArn = nil
            self.probeId = nil
            self.`protocol` = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct GetProbeOutput: Swift.Equatable {
    /// Indicates whether the IP address is IPV4 or IPV6.
    public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
    /// The time and date that the probe was created.
    public var createdAt: ClientRuntime.Date?
    /// The destination IP address for the monitor. This will be either an IPv4 or IPv6 address.
    /// This member is required.
    public var destination: Swift.String?
    /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The time and date that the probe was last modified.
    public var modifiedAt: ClientRuntime.Date?
    /// The size of the packets sent between the source and destination. This will be a number between 56 and 8500.
    public var packetSize: Swift.Int?
    /// The ARN of the probe.
    public var probeArn: Swift.String?
    /// The ID of the probe for which details are returned.
    public var probeId: Swift.String?
    /// The protocol used for the network traffic between the source and destination. This will be either TCP or ICMP.
    /// This member is required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The ARN of the probe.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The state of the probe.
    public var state: NetworkMonitorClientTypes.ProbeState?
    /// The list of key-value pairs assigned to the probe.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the source VPC or subnet.
    public var vpcId: Swift.String?

    public init(
        addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
        createdAt: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        packetSize: Swift.Int? = nil,
        probeArn: Swift.String? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.createdAt = createdAt
        self.destination = destination
        self.destinationPort = destinationPort
        self.modifiedAt = modifiedAt
        self.packetSize = packetSize
        self.probeArn = probeArn
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct GetProbeOutputBody: Swift.Equatable {
    let probeId: Swift.String?
    let probeArn: Swift.String?
    let sourceArn: Swift.String?
    let destination: Swift.String?
    let destinationPort: Swift.Int?
    let `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    let packetSize: Swift.Int?
    let addressFamily: NetworkMonitorClientTypes.AddressFamily?
    let vpcId: Swift.String?
    let state: NetworkMonitorClientTypes.ProbeState?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetProbeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case createdAt
        case destination
        case destinationPort
        case modifiedAt
        case packetSize
        case probeArn
        case probeId
        case `protocol` = "protocol"
        case sourceArn
        case state
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let probeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeId)
        probeId = probeIdDecoded
        let probeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeArn)
        probeArn = probeArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ProbeState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetProbeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListMonitorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            return items
        }
    }
}

extension ListMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/monitors"
    }
}

public struct ListMonitorsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of all monitors and their states.
    public var state: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListMonitorsInputBody: Swift.Equatable {
}

extension ListMonitorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMonitorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMonitorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitors = output.monitors
            self.nextToken = output.nextToken
        } else {
            self.monitors = nil
            self.nextToken = nil
        }
    }
}

public struct ListMonitorsOutput: Swift.Equatable {
    /// Lists individual details about each of your monitors.
    /// This member is required.
    public var monitors: [NetworkMonitorClientTypes.MonitorSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        monitors: [NetworkMonitorClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

struct ListMonitorsOutputBody: Swift.Equatable {
    let monitors: [NetworkMonitorClientTypes.MonitorSummary]?
    let nextToken: Swift.String?
}

extension ListMonitorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitors
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorsContainer = try containerValues.decodeIfPresent([NetworkMonitorClientTypes.MonitorSummary?].self, forKey: .monitors)
        var monitorsDecoded0:[NetworkMonitorClientTypes.MonitorSummary]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [NetworkMonitorClientTypes.MonitorSummary]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMonitorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Lists the tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NetworkMonitorClientTypes {
    public enum MonitorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorState] {
            return [
                .active,
                .deleting,
                .error,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorState(rawValue: rawValue) ?? MonitorState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkMonitorClientTypes.MonitorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
        case monitorArn
        case monitorName
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationPeriod = self.aggregationPeriod {
            try encodeContainer.encode(aggregationPeriod, forKey: .aggregationPeriod)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.MonitorState.self, forKey: .state)
        state = stateDecoded
        let aggregationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .aggregationPeriod)
        aggregationPeriod = aggregationPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkMonitorClientTypes {
    /// Displays summary information about a monitor.
    public struct MonitorSummary: Swift.Equatable {
        /// The time, in seconds, that metrics are collected and sent to Amazon CloudWatch. Valid values are either 30 or 60.
        public var aggregationPeriod: Swift.Int?
        /// The ARN of the monitor.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// The state of the monitor.
        /// This member is required.
        public var state: NetworkMonitorClientTypes.MonitorState?
        /// The list of key-value pairs assigned to the monitor.
        public var tags: [Swift.String:Swift.String]?

        public init(
            aggregationPeriod: Swift.Int? = nil,
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            state: NetworkMonitorClientTypes.MonitorState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.aggregationPeriod = aggregationPeriod
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkMonitorClientTypes.Probe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case createdAt
        case destination
        case destinationPort
        case modifiedAt
        case packetSize
        case probeArn
        case probeId
        case `protocol` = "protocol"
        case sourceArn
        case state
        case tags
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily.rawValue, forKey: .addressFamily)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let packetSize = self.packetSize {
            try encodeContainer.encode(packetSize, forKey: .packetSize)
        }
        if let probeArn = self.probeArn {
            try encodeContainer.encode(probeArn, forKey: .probeArn)
        }
        if let probeId = self.probeId {
            try encodeContainer.encode(probeId, forKey: .probeId)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let probeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeId)
        probeId = probeIdDecoded
        let probeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeArn)
        probeArn = probeArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ProbeState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkMonitorClientTypes {
    /// Describes information about a monitor probe.
    public struct Probe: Swift.Equatable {
        /// The IPv4 or IPv6 address for the probe.
        public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
        /// The time and date the probe was created.
        public var createdAt: ClientRuntime.Date?
        /// The destination for the probe. This should be either an IPV4 or IPV6.
        /// This member is required.
        public var destination: Swift.String?
        /// The destination port for the probe. This is required only if the protocol is TCP and must be a number between 1 and 65536.
        public var destinationPort: Swift.Int?
        /// The time and date that the probe was last modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The size of the packets traveling between the source and destination. This must be a number between 56 and
        public var packetSize: Swift.Int?
        /// The ARN of the probe.
        public var probeArn: Swift.String?
        /// The ID of the probe.
        public var probeId: Swift.String?
        /// The network protocol for the destination. This can be either TCP or ICMP. If the protocol is TCP, then port is also required.
        /// This member is required.
        public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
        /// The ARN of the probe source subnet.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// The state of the probe.
        public var state: NetworkMonitorClientTypes.ProbeState?
        /// The list of key-value pairs created and assigned to the probe.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the source VPC subnet.
        public var vpcId: Swift.String?

        public init(
            addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destination: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            packetSize: Swift.Int? = nil,
            probeArn: Swift.String? = nil,
            probeId: Swift.String? = nil,
            `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
            sourceArn: Swift.String? = nil,
            state: NetworkMonitorClientTypes.ProbeState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressFamily = addressFamily
            self.createdAt = createdAt
            self.destination = destination
            self.destinationPort = destinationPort
            self.modifiedAt = modifiedAt
            self.packetSize = packetSize
            self.probeArn = probeArn
            self.probeId = probeId
            self.`protocol` = `protocol`
            self.sourceArn = sourceArn
            self.state = state
            self.tags = tags
            self.vpcId = vpcId
        }
    }

}

extension NetworkMonitorClientTypes.ProbeInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationPort
        case packetSize
        case `protocol` = "protocol"
        case sourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let packetSize = self.packetSize {
            try encodeContainer.encode(packetSize, forKey: .packetSize)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NetworkMonitorClientTypes {
    /// Defines a probe when creating a probe or monitor.
    public struct ProbeInput: Swift.Equatable {
        /// The destination IP address. This will be either IPV4 or IPV6.
        /// This member is required.
        public var destination: Swift.String?
        /// The port associated with the destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
        public var destinationPort: Swift.Int?
        /// The size of the packets sent between the source and destination. This will be a number between 56 and 8500.
        public var packetSize: Swift.Int?
        /// The protocol used for the network traffic between the source and destination. This will be either TCP or ICMP.
        /// This member is required.
        public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
        /// The ARN of the subnet.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// The list of key-value pairs created and assigned to the monitor.
        public var tags: [Swift.String:Swift.String]?

        public init(
            destination: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            packetSize: Swift.Int? = nil,
            `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
            sourceArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.destination = destination
            self.destinationPort = destinationPort
            self.packetSize = packetSize
            self.`protocol` = `protocol`
            self.sourceArn = sourceArn
            self.tags = tags
        }
    }

}

extension NetworkMonitorClientTypes {
    public enum ProbeState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ProbeState] {
            return [
                .active,
                .deleted,
                .deleting,
                .error,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProbeState(rawValue: rawValue) ?? ProbeState.sdkUnknown(rawValue)
        }
    }
}

extension NetworkMonitorClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case icmp
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .icmp,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .icmp: return "ICMP"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the monitor or probe to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs assigned to the monitor or probe.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the monitor or probe that the tag should be removed from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pa
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationPeriod = self.aggregationPeriod {
            try encodeContainer.encode(aggregationPeriod, forKey: .aggregationPeriod)
        }
    }
}

extension UpdateMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

public struct UpdateMonitorInput: Swift.Equatable {
    /// The aggregation time, in seconds, to change to. This must be either 30 or 60.
    /// This member is required.
    public var aggregationPeriod: Swift.Int?
    /// The name of the monitor to update. Run ListMonitors to get a list of monitor names.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.monitorName = monitorName
    }
}

struct UpdateMonitorInputBody: Swift.Equatable {
    let aggregationPeriod: Swift.Int?
}

extension UpdateMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .aggregationPeriod)
        aggregationPeriod = aggregationPeriodDecoded
    }
}

extension UpdateMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationPeriod = output.aggregationPeriod
            self.monitorArn = output.monitorArn
            self.monitorName = output.monitorName
            self.state = output.state
            self.tags = output.tags
        } else {
            self.aggregationPeriod = nil
            self.monitorArn = nil
            self.monitorName = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct UpdateMonitorOutput: Swift.Equatable {
    /// The changed aggregation period.
    public var aggregationPeriod: Swift.Int?
    /// The ARN of the monitor that was updated.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor that was updated.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The state of the updated monitor.
    /// This member is required.
    public var state: NetworkMonitorClientTypes.MonitorState?
    /// The list of key-value pairs associated with the monitor.
    public var tags: [Swift.String:Swift.String]?

    public init(
        aggregationPeriod: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        state: NetworkMonitorClientTypes.MonitorState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.aggregationPeriod = aggregationPeriod
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.state = state
        self.tags = tags
    }
}

struct UpdateMonitorOutputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let monitorName: Swift.String?
    let state: NetworkMonitorClientTypes.MonitorState?
    let aggregationPeriod: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationPeriod
        case monitorArn
        case monitorName
        case state
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.MonitorState.self, forKey: .state)
        state = stateDecoded
        let aggregationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .aggregationPeriod)
        aggregationPeriod = aggregationPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProbeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationPort
        case packetSize
        case `protocol` = "protocol"
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let packetSize = self.packetSize {
            try encodeContainer.encode(packetSize, forKey: .packetSize)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateProbeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let monitorName = monitorName else {
            return nil
        }
        guard let probeId = probeId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/probes/\(probeId.urlPercentEncoding())"
    }
}

public struct UpdateProbeInput: Swift.Equatable {
    /// The updated IP address for the probe destination. This must be either an IPv4 or IPv6 address.
    public var destination: Swift.String?
    /// The updated port for the probe destination. This is required only if the protocol is TCP and must be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The name of the monitor that the probe was updated for.
    /// This member is required.
    public var monitorName: Swift.String?
    /// he updated packets size for network traffic between the source and destination. This must be a number between 56 and 8500.
    public var packetSize: Swift.Int?
    /// Run GetMonitor to get a list of probes and probe IDs.
    /// This member is required.
    public var probeId: Swift.String?
    /// The updated network protocol for the destination. This can be either TCP or ICMP. If the protocol is TCP, then port is also required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The state of the probe update.
    public var state: NetworkMonitorClientTypes.ProbeState?

    public init(
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        packetSize: Swift.Int? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil
    )
    {
        self.destination = destination
        self.destinationPort = destinationPort
        self.monitorName = monitorName
        self.packetSize = packetSize
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.state = state
    }
}

struct UpdateProbeInputBody: Swift.Equatable {
    let state: NetworkMonitorClientTypes.ProbeState?
    let destination: Swift.String?
    let destinationPort: Swift.Int?
    let `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    let packetSize: Swift.Int?
}

extension UpdateProbeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationPort
        case packetSize
        case `protocol` = "protocol"
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ProbeState.self, forKey: .state)
        state = stateDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
    }
}

extension UpdateProbeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProbeOutputBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.addressFamily = output.addressFamily
            self.createdAt = output.createdAt
            self.destination = output.destination
            self.destinationPort = output.destinationPort
            self.modifiedAt = output.modifiedAt
            self.packetSize = output.packetSize
            self.probeArn = output.probeArn
            self.probeId = output.probeId
            self.sourceArn = output.sourceArn
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.addressFamily = nil
            self.createdAt = nil
            self.destination = nil
            self.destinationPort = nil
            self.modifiedAt = nil
            self.packetSize = nil
            self.probeArn = nil
            self.probeId = nil
            self.`protocol` = nil
            self.sourceArn = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct UpdateProbeOutput: Swift.Equatable {
    /// The updated IP address family. This will be either IPV4 or IPV6.
    public var addressFamily: NetworkMonitorClientTypes.AddressFamily?
    /// The time and date that the probe was created.
    public var createdAt: ClientRuntime.Date?
    /// The updated destination IP address for the probe.
    /// This member is required.
    public var destination: Swift.String?
    /// The updated destination port. This will be a number between 1 and 65536.
    public var destinationPort: Swift.Int?
    /// The time and date that the probe was last updated.
    public var modifiedAt: ClientRuntime.Date?
    /// The updated packet size for the probe.
    public var packetSize: Swift.Int?
    /// The updated ARN of the probe.
    public var probeArn: Swift.String?
    /// The updated ID of the probe.
    public var probeId: Swift.String?
    /// The updated protocol for the probe.
    /// This member is required.
    public var `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    /// The updated ARN of the source subnet.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The state of the updated probe.
    public var state: NetworkMonitorClientTypes.ProbeState?
    /// Update tags for a probe.
    public var tags: [Swift.String:Swift.String]?
    /// The updated ID of the source VPC subnet ID.
    public var vpcId: Swift.String?

    public init(
        addressFamily: NetworkMonitorClientTypes.AddressFamily? = nil,
        createdAt: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        destinationPort: Swift.Int? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        packetSize: Swift.Int? = nil,
        probeArn: Swift.String? = nil,
        probeId: Swift.String? = nil,
        `protocol`: NetworkMonitorClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        state: NetworkMonitorClientTypes.ProbeState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.addressFamily = addressFamily
        self.createdAt = createdAt
        self.destination = destination
        self.destinationPort = destinationPort
        self.modifiedAt = modifiedAt
        self.packetSize = packetSize
        self.probeArn = probeArn
        self.probeId = probeId
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct UpdateProbeOutputBody: Swift.Equatable {
    let probeId: Swift.String?
    let probeArn: Swift.String?
    let sourceArn: Swift.String?
    let destination: Swift.String?
    let destinationPort: Swift.Int?
    let `protocol`: NetworkMonitorClientTypes.ModelProtocol?
    let packetSize: Swift.Int?
    let addressFamily: NetworkMonitorClientTypes.AddressFamily?
    let vpcId: Swift.String?
    let state: NetworkMonitorClientTypes.ProbeState?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateProbeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily
        case createdAt
        case destination
        case destinationPort
        case modifiedAt
        case packetSize
        case probeArn
        case probeId
        case `protocol` = "protocol"
        case sourceArn
        case state
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let probeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeId)
        probeId = probeIdDecoded
        let probeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .probeArn)
        probeArn = probeArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let packetSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetSize)
        packetSize = packetSizeDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.AddressFamily.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NetworkMonitorClientTypes.ProbeState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateProbeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the parameters for the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
