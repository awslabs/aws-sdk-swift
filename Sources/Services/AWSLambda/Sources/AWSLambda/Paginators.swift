//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension LambdaClient {
    /// Paginate over `[GetDurableExecutionHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDurableExecutionHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDurableExecutionHistoryOutput`
    public func getDurableExecutionHistoryPaginated(input: GetDurableExecutionHistoryInput) -> ClientRuntime.PaginatorSequence<GetDurableExecutionHistoryInput, GetDurableExecutionHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetDurableExecutionHistoryInput, GetDurableExecutionHistoryOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.getDurableExecutionHistory(input:))
    }
}

extension GetDurableExecutionHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDurableExecutionHistoryInput {
        return GetDurableExecutionHistoryInput(
            durableExecutionArn: self.durableExecutionArn,
            includeExecutionData: self.includeExecutionData,
            marker: token,
            maxItems: self.maxItems,
            reverseOrder: self.reverseOrder
        )}
}

extension PaginatorSequence where OperationStackInput == GetDurableExecutionHistoryInput, OperationStackOutput == GetDurableExecutionHistoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getDurableExecutionHistoryPaginated`
    /// to access the nested member `[LambdaClientTypes.Event]`
    /// - Returns: `[LambdaClientTypes.Event]`
    public func events() async throws -> [LambdaClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension LambdaClient {
    /// Paginate over `[GetDurableExecutionStateOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDurableExecutionStateInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDurableExecutionStateOutput`
    public func getDurableExecutionStatePaginated(input: GetDurableExecutionStateInput) -> ClientRuntime.PaginatorSequence<GetDurableExecutionStateInput, GetDurableExecutionStateOutput> {
        return ClientRuntime.PaginatorSequence<GetDurableExecutionStateInput, GetDurableExecutionStateOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.getDurableExecutionState(input:))
    }
}

extension GetDurableExecutionStateInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDurableExecutionStateInput {
        return GetDurableExecutionStateInput(
            checkpointToken: self.checkpointToken,
            durableExecutionArn: self.durableExecutionArn,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == GetDurableExecutionStateInput, OperationStackOutput == GetDurableExecutionStateOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getDurableExecutionStatePaginated`
    /// to access the nested member `[LambdaClientTypes.Operation]`
    /// - Returns: `[LambdaClientTypes.Operation]`
    public func operations() async throws -> [LambdaClientTypes.Operation] {
        return try await self.asyncCompactMap { item in item.operations }
    }
}
extension LambdaClient {
    /// Paginate over `[ListDurableExecutionsByFunctionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDurableExecutionsByFunctionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDurableExecutionsByFunctionOutput`
    public func listDurableExecutionsByFunctionPaginated(input: ListDurableExecutionsByFunctionInput) -> ClientRuntime.PaginatorSequence<ListDurableExecutionsByFunctionInput, ListDurableExecutionsByFunctionOutput> {
        return ClientRuntime.PaginatorSequence<ListDurableExecutionsByFunctionInput, ListDurableExecutionsByFunctionOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listDurableExecutionsByFunction(input:))
    }
}

extension ListDurableExecutionsByFunctionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDurableExecutionsByFunctionInput {
        return ListDurableExecutionsByFunctionInput(
            durableExecutionName: self.durableExecutionName,
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems,
            qualifier: self.qualifier,
            reverseOrder: self.reverseOrder,
            startedAfter: self.startedAfter,
            startedBefore: self.startedBefore,
            statuses: self.statuses
        )}
}

extension PaginatorSequence where OperationStackInput == ListDurableExecutionsByFunctionInput, OperationStackOutput == ListDurableExecutionsByFunctionOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDurableExecutionsByFunctionPaginated`
    /// to access the nested member `[LambdaClientTypes.Execution]`
    /// - Returns: `[LambdaClientTypes.Execution]`
    public func durableExecutions() async throws -> [LambdaClientTypes.Execution] {
        return try await self.asyncCompactMap { item in item.durableExecutions }
    }
}
extension LambdaClient {
    /// Paginate over `[ListFunctionEventInvokeConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFunctionEventInvokeConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFunctionEventInvokeConfigsOutput`
    public func listFunctionEventInvokeConfigsPaginated(input: ListFunctionEventInvokeConfigsInput) -> ClientRuntime.PaginatorSequence<ListFunctionEventInvokeConfigsInput, ListFunctionEventInvokeConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListFunctionEventInvokeConfigsInput, ListFunctionEventInvokeConfigsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listFunctionEventInvokeConfigs(input:))
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionEventInvokeConfigsInput {
        return ListFunctionEventInvokeConfigsInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListFunctionEventInvokeConfigsInput, OperationStackOutput == ListFunctionEventInvokeConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFunctionEventInvokeConfigsPaginated`
    /// to access the nested member `[LambdaClientTypes.FunctionEventInvokeConfig]`
    /// - Returns: `[LambdaClientTypes.FunctionEventInvokeConfig]`
    public func functionEventInvokeConfigs() async throws -> [LambdaClientTypes.FunctionEventInvokeConfig] {
        return try await self.asyncCompactMap { item in item.functionEventInvokeConfigs }
    }
}
