//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
import typealias SmithyEventStreamsAPI.UnmarshalClosure


public struct DeleteAliasOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionCodeSigningConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionConcurrencyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionEventInvokeConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionUrlConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLayerVersionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProvisionedConcurrencyConfigOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveLayerVersionPermissionOutput: Swift.Sendable {

    public init() { }
}

public struct RemovePermissionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension LambdaClientTypes {

    /// Limits that are related to concurrency and storage. All file and storage sizes are in bytes.
    public struct AccountLimit: Swift.Sendable {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public var codeSizeUnzipped: Swift.Int
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.
        public var codeSizeZipped: Swift.Int
        /// The maximum number of simultaneous function executions.
        public var concurrentExecutions: Swift.Int
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public var totalCodeSize: Swift.Int
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with [PutFunctionConcurrency].
        public var unreservedConcurrentExecutions: Swift.Int?

        public init(
            codeSizeUnzipped: Swift.Int = 0,
            codeSizeZipped: Swift.Int = 0,
            concurrentExecutions: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0,
            unreservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }
    }
}

extension LambdaClientTypes {

    /// The number of functions and amount of storage in use.
    public struct AccountUsage: Swift.Sendable {
        /// The number of Lambda functions.
        public var functionCount: Swift.Int
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public var totalCodeSize: Swift.Int

        public init(
            functionCount: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0
        )
        {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }
    }
}

/// One of the parameters in the request is not valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The permissions policy for the resource is too large. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct PolicyLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyLengthExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias.
///
/// * For AddPermission and RemovePermission API operations: Call GetPolicy to retrieve the latest RevisionId for your resource.
///
/// * For all other API operations: Call GetFunction or GetAlias to retrieve the latest RevisionId for your resource.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The resource already exists, or another operation is in progress.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda service encountered an internal error.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    public enum ThrottleReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case callerratelimitexceeded
        case concurrentinvocationlimitexceeded
        case concurrentsnapshotcreatelimitexceeded
        case functioninvocationratelimitexceeded
        case reservedfunctionconcurrentinvocationlimitexceeded
        case reservedfunctioninvocationratelimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .callerratelimitexceeded,
                .concurrentinvocationlimitexceeded,
                .concurrentsnapshotcreatelimitexceeded,
                .functioninvocationratelimitexceeded,
                .reservedfunctionconcurrentinvocationlimitexceeded,
                .reservedfunctioninvocationratelimitexceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .callerratelimitexceeded: return "CallerRateLimitExceeded"
            case .concurrentinvocationlimitexceeded: return "ConcurrentInvocationLimitExceeded"
            case .concurrentsnapshotcreatelimitexceeded: return "ConcurrentSnapshotCreateLimitExceeded"
            case .functioninvocationratelimitexceeded: return "FunctionInvocationRateLimitExceeded"
            case .reservedfunctionconcurrentinvocationlimitexceeded: return "ReservedFunctionConcurrentInvocationLimitExceeded"
            case .reservedfunctioninvocationratelimitexceeded: return "ReservedFunctionInvocationRateLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request throughput limit was exceeded. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html#api-requests).
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: LambdaClientTypes.ThrottleReason? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: LambdaClientTypes.ThrottleReason? = nil,
        retryAfterSeconds: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.type = type
    }
}

public struct AddLayerVersionPermissionInput: Swift.Sendable {
    /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
    /// This member is required.
    public var action: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// With the principal set to *, grant permission to all accounts in the specified organization.
    public var organizationId: Swift.String?
    /// An account ID, or * to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
    /// This member is required.
    public var principal: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An identifier that distinguishes the policy from others on the same layer version.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        action: Swift.String? = nil,
        layerName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        principal: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    )
    {
        self.action = action
        self.layerName = layerName
        self.organizationId = organizationId
        self.principal = principal
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

public struct AddLayerVersionPermissionOutput: Swift.Sendable {
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?
    /// The permission statement.
    public var statement: Swift.String?

    public init(
        revisionId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
        self.statement = statement
    }
}

extension LambdaClientTypes {

    public enum FunctionUrlAuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionUrlAuthType] {
            return [
                .awsIam,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AddPermissionInput: Swift.Sendable {
    /// The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
    /// This member is required.
    public var action: Swift.String?
    /// For Alexa Smart Home functions, a token that the invoker must supply.
    public var eventSourceToken: Swift.String?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    public var functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType?
    /// The Amazon Web Services service, Amazon Web Services account, IAM user, or IAM role that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
    /// This member is required.
    public var principal: Swift.String?
    /// The identifier for your organization in Organizations. Use this to grant permissions to all the Amazon Web Services accounts under this organization.
    public var principalOrgID: Swift.String?
    /// Specify a version or alias to add permissions to a published version of the function.
    public var qualifier: Swift.String?
    /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// For Amazon Web Services service, the ID of the Amazon Web Services account that owns the resource. Use this together with SourceArn to ensure that the specified account owns the resource. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
    public var sourceAccount: Swift.String?
    /// For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic. Note that Lambda configures the comparison using the StringLike operator.
    public var sourceArn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: Swift.String? = nil,
        eventSourceToken: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        principal: Swift.String? = nil,
        principalOrgID: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceAccount: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.eventSourceToken = eventSourceToken
        self.functionName = functionName
        self.functionUrlAuthType = functionUrlAuthType
        self.principal = principal
        self.principalOrgID = principalOrgID
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.sourceAccount = sourceAccount
        self.sourceArn = sourceArn
        self.statementId = statementId
    }
}

public struct AddPermissionOutput: Swift.Sendable {
    /// The permission statement that's added to the function policy.
    public var statement: Swift.String?

    public init(
        statement: Swift.String? = nil
    )
    {
        self.statement = statement
    }
}

extension LambdaClientTypes {

    /// The [traffic-shifting](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) configuration of a Lambda function alias.
    public struct AliasRoutingConfiguration: Swift.Sendable {
        /// The second version, and the percentage of traffic that's routed to it.
        public var additionalVersionWeights: [Swift.String: Swift.Double]?

        public init(
            additionalVersionWeights: [Swift.String: Swift.Double]? = nil
        )
        {
            self.additionalVersionWeights = additionalVersionWeights
        }
    }
}

extension LambdaClientTypes {

    /// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
    public struct AliasConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the alias.
        public var aliasArn: Swift.String?
        /// A description of the alias.
        public var description: Swift.String?
        /// The function version that the alias invokes.
        public var functionVersion: Swift.String?
        /// The name of the alias.
        public var name: Swift.String?
        /// A unique identifier that changes when you update the alias.
        public var revisionId: Swift.String?
        /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
        public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

        public init(
            aliasArn: Swift.String? = nil,
            description: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
        )
        {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }
    }
}

extension LambdaClientTypes {

    /// List of signing profiles that can sign a code package.
    public struct AllowedPublishers: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        /// This member is required.
        public var signingProfileVersionArns: [Swift.String]?

        public init(
            signingProfileVersionArns: [Swift.String]? = nil
        )
        {
            self.signingProfileVersionArns = signingProfileVersionArns
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public struct AmazonManagedKafkaEventSourceConfig: Swift.Sendable {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        public var consumerGroupId: Swift.String?

        public init(
            consumerGroupId: Swift.String? = nil
        )
        {
            self.consumerGroupId = consumerGroupId
        }
    }
}

extension LambdaClientTypes {

    public enum ApplicationLogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case trace
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLogLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .trace,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .trace: return "TRACE"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum Architecture: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAliasInput: Swift.Sendable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.routingConfig = routingConfig
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct CreateAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

extension LambdaClientTypes {

    public enum CodeSigningPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enforce
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSigningPolicy] {
            return [
                .enforce,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "Enforce"
            case .warn: return "Warn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Code signing configuration [policies](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies) specify the validation failure action for signature mismatch or expiry.
    public struct CodeSigningPolicies: Swift.Sendable {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Default value: Warn
        public var untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy?

        public init(
            untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy? = nil
        )
        {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }
    }
}

public struct CreateCodeSigningConfigInput: Swift.Sendable {
    /// Signing profiles for this code signing configuration.
    /// This member is required.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The code signing policies define the actions to take if the validation checks fail.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?
    /// A list of tags to add to the code signing configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
        self.tags = tags
    }
}

extension LambdaClientTypes {

    /// Details about a [Code signing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
    public struct CodeSigningConfig: Swift.Sendable {
        /// List of allowed publishers.
        /// This member is required.
        public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigArn: Swift.String?
        /// Unique identifer for the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigId: Swift.String?
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        /// This member is required.
        public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
        /// Code signing configuration description.
        public var description: Swift.String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModified: Swift.String?

        public init(
            allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
            codeSigningConfigArn: Swift.String? = nil,
            codeSigningConfigId: Swift.String? = nil,
            codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
            description: Swift.String? = nil,
            lastModified: Swift.String? = nil
        )
        {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }
    }
}

public struct CreateCodeSigningConfigOutput: Swift.Sendable {
    /// The code signing configuration.
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

extension LambdaClientTypes {

    /// A destination for events that failed processing.
    public struct OnFailure: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination resource. To retain records of [asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations), you can configure an Amazon SNS topic, Amazon SQS queue, Lambda function, or Amazon EventBridge event bus as the destination. To retain records of failed invocations from [Kinesis and DynamoDB event sources](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#event-source-mapping-destinations), you can configure an Amazon SNS topic or Amazon SQS queue as the destination. To retain records of failed invocations from [self-managed Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-smaa-onfailure-destination) or [Amazon MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-onfailure-destination), you can configure an Amazon SNS topic, Amazon SQS queue, or Amazon S3 bucket as the destination.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }
}

extension LambdaClientTypes {

    /// A destination for events that were processed successfully.
    public struct OnSuccess: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }
}

extension LambdaClientTypes {

    /// A configuration object that specifies the destination of an event after Lambda processes it.
    public struct DestinationConfig: Swift.Sendable {
        /// The destination configuration for failed invocations.
        public var onFailure: LambdaClientTypes.OnFailure?
        /// The destination configuration for successful invocations.
        public var onSuccess: LambdaClientTypes.OnSuccess?

        public init(
            onFailure: LambdaClientTypes.OnFailure? = nil,
            onSuccess: LambdaClientTypes.OnSuccess? = nil
        )
        {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }
    }
}

extension LambdaClientTypes {

    public enum FullDocument: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case updatelookup
        case sdkUnknown(Swift.String)

        public static var allCases: [FullDocument] {
            return [
                .default,
                .updatelookup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .updatelookup: return "UpdateLookup"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for a DocumentDB event source.
    public struct DocumentDBEventSourceConfig: Swift.Sendable {
        /// The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        public var collectionName: Swift.String?
        /// The name of the database to consume within the DocumentDB cluster.
        public var databaseName: Swift.String?
        /// Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        public var fullDocument: LambdaClientTypes.FullDocument?

        public init(
            collectionName: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fullDocument: LambdaClientTypes.FullDocument? = nil
        )
        {
            self.collectionName = collectionName
            self.databaseName = databaseName
            self.fullDocument = fullDocument
        }
    }
}

extension LambdaClientTypes {

    /// A structure within a FilterCriteria object that defines an event filtering pattern.
    public struct Filter: Swift.Sendable {
        /// A filter pattern. For more information on the syntax of a filter pattern, see [ Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        public var pattern: Swift.String?

        public init(
            pattern: Swift.String? = nil
        )
        {
            self.pattern = pattern
        }
    }
}

extension LambdaClientTypes {

    /// An object that contains the filters for an event source.
    public struct FilterCriteria: Swift.Sendable {
        /// A list of filters.
        public var filters: [LambdaClientTypes.Filter]?

        public init(
            filters: [LambdaClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension LambdaClientTypes {

    public enum FunctionResponseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case reportbatchitemfailures
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionResponseType] {
            return [
                .reportbatchitemfailures
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .reportbatchitemfailures: return "ReportBatchItemFailures"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// (Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.
    public struct ScalingConfig: Swift.Sendable {
        /// Limits the number of concurrent instances that the Amazon SQS event source can invoke.
        public var maximumConcurrency: Swift.Int?

        public init(
            maximumConcurrency: Swift.Int? = nil
        )
        {
            self.maximumConcurrency = maximumConcurrency
        }
    }
}

extension LambdaClientTypes {

    public enum EndPointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kafkaBootstrapServers
        case sdkUnknown(Swift.String)

        public static var allCases: [EndPointType] {
            return [
                .kafkaBootstrapServers
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The self-managed Apache Kafka cluster for your event source.
    public struct SelfManagedEventSource: Swift.Sendable {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public var endpoints: [Swift.String: [Swift.String]]?

        public init(
            endpoints: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.endpoints = endpoints
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public struct SelfManagedKafkaEventSourceConfig: Swift.Sendable {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        public var consumerGroupId: Swift.String?

        public init(
            consumerGroupId: Swift.String? = nil
        )
        {
            self.consumerGroupId = consumerGroupId
        }
    }
}

extension LambdaClientTypes {

    public enum SourceAccessType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basicAuth
        case clientCertificateTlsAuth
        case saslScram256Auth
        case saslScram512Auth
        case serverRootCaCertificate
        case virtualHost
        case vpcSecurityGroup
        case vpcSubnet
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceAccessType] {
            return [
                .basicAuth,
                .clientCertificateTlsAuth,
                .saslScram256Auth,
                .saslScram512Auth,
                .serverRootCaCertificate,
                .virtualHost,
                .vpcSecurityGroup,
                .vpcSubnet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .clientCertificateTlsAuth: return "CLIENT_CERTIFICATE_TLS_AUTH"
            case .saslScram256Auth: return "SASL_SCRAM_256_AUTH"
            case .saslScram512Auth: return "SASL_SCRAM_512_AUTH"
            case .serverRootCaCertificate: return "SERVER_ROOT_CA_CERTIFICATE"
            case .virtualHost: return "VIRTUAL_HOST"
            case .vpcSecurityGroup: return "VPC_SECURITY_GROUP"
            case .vpcSubnet: return "VPC_SUBNET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.
    public struct SourceAccessConfiguration: Swift.Sendable {
        /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".
        ///
        /// * BASIC_AUTH – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.
        ///
        /// * BASIC_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
        ///
        /// * VPC_SUBNET – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
        ///
        /// * VPC_SECURITY_GROUP – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_256_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_512_AUTH – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * VIRTUAL_HOST –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
        ///
        /// * CLIENT_CERTIFICATE_TLS_AUTH – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
        ///
        /// * SERVER_ROOT_CA_CERTIFICATE – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        public var type: LambdaClientTypes.SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public var uri: Swift.String?

        public init(
            type: LambdaClientTypes.SourceAccessType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.type = type
            self.uri = uri
        }
    }
}

extension LambdaClientTypes {

    public enum EventSourcePosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case atTimestamp
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourcePosition] {
            return [
                .atTimestamp,
                .latest,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .atTimestamp: return "AT_TIMESTAMP"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEventSourceMappingInput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis – Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams – Default 100. Max 10,000.
    ///
    /// * Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Self-managed Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
    ///
    /// * DocumentDB – Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Kafka only) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis – The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams – The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service – The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – The ARN of the cluster or the ARN of the VPC connection (for [cross-account event source mappings](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#msk-multi-vpc)).
    ///
    /// * Amazon MQ – The ARN of the broker.
    ///
    /// * Amazon DocumentDB – The ARN of the DocumentDB change stream.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics). By default, Lambda does not encrypt your filter criteria object. Specify this property to encrypt data using your own customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For Kinesis, DynamoDB, and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster to receive records from.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// A list of tags to apply to the event source mapping.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        enabled: Swift.Bool? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.enabled = enabled
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.tags = tags
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
    }
}

extension LambdaClientTypes {

    /// An object that contains details about an error related to filter criteria encryption.
    public struct FilterCriteriaError: Swift.Sendable {
        /// The KMS exception that resulted from filter criteria encryption or decryption.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct CreateEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka event sources only) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

/// The specified code signing configuration does not exist.
public struct CodeSigningConfigNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeSigningConfigNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Your Amazon Web Services account has exceeded its maximum total code size. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct CodeStorageExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeStorageExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.
public struct CodeVerificationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeVerificationFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The code signature failed the integrity check. If the integrity check fails, then Lambda blocks deployment, even if the code signing policy is set to WARN.
public struct InvalidCodeSignatureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCodeSignatureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    /// The code for the Lambda function. You can either specify an object in Amazon S3, upload a .zip file archive deployment package directly, or specify the URI of a container image.
    public struct FunctionCode: Swift.Sendable {
        /// URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.
        public var zipFile: Foundation.Data?

        public init(
            imageUri: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: Foundation.Data? = nil
        )
        {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }
}

extension LambdaClientTypes.FunctionCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionCode(imageUri: \(Swift.String(describing: imageUri)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq) for failed asynchronous invocations.
    public struct DeadLetterConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public var targetArn: Swift.String?

        public init(
            targetArn: Swift.String? = nil
        )
        {
            self.targetArn = targetArn
        }
    }
}

extension LambdaClientTypes {

    /// A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
    public struct Environment: Swift.Sendable {
        /// Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        public var variables: [Swift.String: Swift.String]?

        public init(
            variables: [Swift.String: Swift.String]? = nil
        )
        {
            self.variables = variables
        }
    }
}

extension LambdaClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(variables: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public struct EphemeralStorage: Swift.Sendable {
        /// The size of the function's /tmp directory.
        /// This member is required.
        public var size: Swift.Int?

        public init(
            size: Swift.Int? = nil
        )
        {
            self.size = size
        }
    }
}

extension LambdaClientTypes {

    /// Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public struct FileSystemConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        /// This member is required.
        public var arn: Swift.String?
        /// The path where the function can access the file system, starting with /mnt/.
        /// This member is required.
        public var localMountPath: Swift.String?

        public init(
            arn: Swift.String? = nil,
            localMountPath: Swift.String? = nil
        )
        {
            self.arn = arn
            self.localMountPath = localMountPath
        }
    }
}

extension LambdaClientTypes {

    /// Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
    public struct ImageConfig: Swift.Sendable {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public var command: [Swift.String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime executable.
        public var entryPoint: [Swift.String]?
        /// Specifies the working directory.
        public var workingDirectory: Swift.String?

        public init(
            command: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }
    }
}

extension LambdaClientTypes {

    public enum LogFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [LogFormat] {
            return [
                .json,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum SystemLogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemLogLevel] {
            return [
                .debug,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's Amazon CloudWatch Logs configuration settings.
    public struct LoggingConfig: Swift.Sendable {
        /// Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
        public var applicationLogLevel: LambdaClientTypes.ApplicationLogLevel?
        /// The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        public var logFormat: LambdaClientTypes.LogFormat?
        /// The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/. To use a different log group, enter an existing log group or enter a new log group name.
        public var logGroup: Swift.String?
        /// Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
        public var systemLogLevel: LambdaClientTypes.SystemLogLevel?

        public init(
            applicationLogLevel: LambdaClientTypes.ApplicationLogLevel? = nil,
            logFormat: LambdaClientTypes.LogFormat? = nil,
            logGroup: Swift.String? = nil,
            systemLogLevel: LambdaClientTypes.SystemLogLevel? = nil
        )
        {
            self.applicationLogLevel = applicationLogLevel
            self.logFormat = logFormat
            self.logGroup = logGroup
            self.systemLogLevel = systemLogLevel
        }
    }
}

extension LambdaClientTypes {

    public enum PackageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "Image"
            case .zip: return "Zip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum Runtime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dotnet6
        case dotnet8
        case dotnetcore10
        case dotnetcore20
        case dotnetcore21
        case dotnetcore31
        case go1x
        case java11
        case java17
        case java21
        case java8
        case java8al2
        case nodejs
        case nodejs10x
        case nodejs12x
        case nodejs14x
        case nodejs16x
        case nodejs18x
        case nodejs20x
        case nodejs43
        case nodejs43edge
        case nodejs610
        case nodejs810
        case provided
        case providedal2
        case providedal2023
        case python27
        case python310
        case python311
        case python312
        case python36
        case python37
        case python38
        case python39
        case ruby25
        case ruby27
        case ruby32
        case ruby33
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .dotnet6,
                .dotnet8,
                .dotnetcore10,
                .dotnetcore20,
                .dotnetcore21,
                .dotnetcore31,
                .go1x,
                .java11,
                .java17,
                .java21,
                .java8,
                .java8al2,
                .nodejs,
                .nodejs10x,
                .nodejs12x,
                .nodejs14x,
                .nodejs16x,
                .nodejs18x,
                .nodejs20x,
                .nodejs43,
                .nodejs43edge,
                .nodejs610,
                .nodejs810,
                .provided,
                .providedal2,
                .providedal2023,
                .python27,
                .python310,
                .python311,
                .python312,
                .python36,
                .python37,
                .python38,
                .python39,
                .ruby25,
                .ruby27,
                .ruby32,
                .ruby33
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dotnet6: return "dotnet6"
            case .dotnet8: return "dotnet8"
            case .dotnetcore10: return "dotnetcore1.0"
            case .dotnetcore20: return "dotnetcore2.0"
            case .dotnetcore21: return "dotnetcore2.1"
            case .dotnetcore31: return "dotnetcore3.1"
            case .go1x: return "go1.x"
            case .java11: return "java11"
            case .java17: return "java17"
            case .java21: return "java21"
            case .java8: return "java8"
            case .java8al2: return "java8.al2"
            case .nodejs: return "nodejs"
            case .nodejs10x: return "nodejs10.x"
            case .nodejs12x: return "nodejs12.x"
            case .nodejs14x: return "nodejs14.x"
            case .nodejs16x: return "nodejs16.x"
            case .nodejs18x: return "nodejs18.x"
            case .nodejs20x: return "nodejs20.x"
            case .nodejs43: return "nodejs4.3"
            case .nodejs43edge: return "nodejs4.3-edge"
            case .nodejs610: return "nodejs6.10"
            case .nodejs810: return "nodejs8.10"
            case .provided: return "provided"
            case .providedal2: return "provided.al2"
            case .providedal2023: return "provided.al2023"
            case .python27: return "python2.7"
            case .python310: return "python3.10"
            case .python311: return "python3.11"
            case .python312: return "python3.12"
            case .python36: return "python3.6"
            case .python37: return "python3.7"
            case .python38: return "python3.8"
            case .python39: return "python3.9"
            case .ruby25: return "ruby2.5"
            case .ruby27: return "ruby2.7"
            case .ruby32: return "ruby3.2"
            case .ruby33: return "ruby3.3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum SnapStartApplyOn: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case publishedversions
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapStartApplyOn] {
            return [
                .none,
                .publishedversions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .publishedversions: return "PublishedVersions"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting. Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
    public struct SnapStart: Swift.Sendable {
        /// Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
        public var applyOn: LambdaClientTypes.SnapStartApplyOn?

        public init(
            applyOn: LambdaClientTypes.SnapStartApplyOn? = nil
        )
        {
            self.applyOn = applyOn
        }
    }
}

extension LambdaClientTypes {

    public enum TracingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingMode] {
            return [
                .active,
                .passthrough
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .passthrough: return "PassThrough"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set Mode to Active.
    public struct TracingConfig: Swift.Sendable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init(
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }
}

extension LambdaClientTypes {

    /// The VPC security groups and subnets that are attached to a Lambda function. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public struct VpcConfig: Swift.Sendable {
        /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        public var ipv6AllowedForDualStack: Swift.Bool?
        /// A list of VPC security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?

        public init(
            ipv6AllowedForDualStack: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.ipv6AllowedForDualStack = ipv6AllowedForDualStack
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

public struct CreateFunctionInput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The code for the function.
    /// This member is required.
    public var code: LambdaClientTypes.FunctionCode?
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    public var codeSigningConfigArn: Swift.String?
    /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
    public var handler: Swift.String?
    /// Container image [configuration values](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms) that override the values in the container image Dockerfile.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
    public var kmsKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// Set to true to publish the first version of the function during creation.
    public var publish: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    /// This member is required.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public var snapStart: LambdaClientTypes.SnapStart?
    /// A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
    public var tags: [Swift.String: Swift.String]?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        code: LambdaClientTypes.FunctionCode? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        publish: Swift.Bool? = false,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        snapStart: LambdaClientTypes.SnapStart? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.architectures = architectures
        self.code = code
        self.codeSigningConfigArn = codeSigningConfigArn
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kmsKeyArn = kmsKeyArn
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.memorySize = memorySize
        self.packageType = packageType
        self.publish = publish
        self.role = role
        self.runtime = runtime
        self.snapStart = snapStart
        self.tags = tags
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

extension LambdaClientTypes {

    /// Error messages for environment variables that couldn't be applied.
    public struct EnvironmentError: Swift.Sendable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

extension LambdaClientTypes.EnvironmentError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The results of an operation to update or read environment variables. If the operation succeeds, the response contains the environment variables. If it fails, the response contains details about the error.
    public struct EnvironmentResponse: Swift.Sendable {
        /// Error messages for environment variables that couldn't be applied.
        public var error: LambdaClientTypes.EnvironmentError?
        /// Environment variable key-value pairs. Omitted from CloudTrail logs.
        public var variables: [Swift.String: Swift.String]?

        public init(
            error: LambdaClientTypes.EnvironmentError? = nil,
            variables: [Swift.String: Swift.String]? = nil
        )
        {
            self.error = error
            self.variables = variables
        }
    }
}

extension LambdaClientTypes.EnvironmentResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentResponse(error: \(Swift.String(describing: error)), variables: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Error response to GetFunctionConfiguration.
    public struct ImageConfigError: Swift.Sendable {
        /// Error code.
        public var errorCode: Swift.String?
        /// Error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

extension LambdaClientTypes.ImageConfigError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfigError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Response to a GetFunctionConfiguration request.
    public struct ImageConfigResponse: Swift.Sendable {
        /// Error response to GetFunctionConfiguration.
        public var error: LambdaClientTypes.ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public var imageConfig: LambdaClientTypes.ImageConfig?

        public init(
            error: LambdaClientTypes.ImageConfigError? = nil,
            imageConfig: LambdaClientTypes.ImageConfig? = nil
        )
        {
            self.error = error
            self.imageConfig = imageConfig
        }
    }
}

extension LambdaClientTypes {

    public enum LastUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatus] {
            return [
                .failed,
                .inprogress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum LastUpdateStatusReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabledkmskey
        case efsioerror
        case efsmountconnectivityerror
        case efsmountfailure
        case efsmounttimeout
        case enilimitexceeded
        case functionerror
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidruntime
        case invalidsecuritygroup
        case invalidstatekmskey
        case invalidsubnet
        case invalidzipfileexception
        case kmskeyaccessdenied
        case kmskeynotfound
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatusReasonCode] {
            return [
                .disabledkmskey,
                .efsioerror,
                .efsmountconnectivityerror,
                .efsmountfailure,
                .efsmounttimeout,
                .enilimitexceeded,
                .functionerror,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidruntime,
                .invalidsecuritygroup,
                .invalidstatekmskey,
                .invalidsubnet,
                .invalidzipfileexception,
                .kmskeyaccessdenied,
                .kmskeynotfound,
                .subnetoutofipaddresses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabledkmskey: return "DisabledKMSKey"
            case .efsioerror: return "EFSIOError"
            case .efsmountconnectivityerror: return "EFSMountConnectivityError"
            case .efsmountfailure: return "EFSMountFailure"
            case .efsmounttimeout: return "EFSMountTimeout"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .functionerror: return "FunctionError"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidruntime: return "InvalidRuntime"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidstatekmskey: return "InvalidStateKMSKey"
            case .invalidsubnet: return "InvalidSubnet"
            case .invalidzipfileexception: return "InvalidZipFileException"
            case .kmskeyaccessdenied: return "KMSKeyAccessDenied"
            case .kmskeynotfound: return "KMSKeyNotFound"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// An [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct Layer: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }
}

extension LambdaClientTypes {

    /// Any error returned when the runtime version information for the function could not be retrieved.
    public struct RuntimeVersionError: Swift.Sendable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

extension LambdaClientTypes.RuntimeVersionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuntimeVersionError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The ARN of the runtime and any errors that occured.
    public struct RuntimeVersionConfig: Swift.Sendable {
        /// Error response when Lambda is unable to retrieve the runtime version for a function.
        public var error: LambdaClientTypes.RuntimeVersionError?
        /// The ARN of the runtime version you want the function to use.
        public var runtimeVersionArn: Swift.String?

        public init(
            error: LambdaClientTypes.RuntimeVersionError? = nil,
            runtimeVersionArn: Swift.String? = nil
        )
        {
            self.error = error
            self.runtimeVersionArn = runtimeVersionArn
        }
    }
}

extension LambdaClientTypes {

    public enum SnapStartOptimizationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapStartOptimizationStatus] {
            return [
                .off,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public struct SnapStartResponse: Swift.Sendable {
        /// When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        public var applyOn: LambdaClientTypes.SnapStartApplyOn?
        /// When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
        public var optimizationStatus: LambdaClientTypes.SnapStartOptimizationStatus?

        public init(
            applyOn: LambdaClientTypes.SnapStartApplyOn? = nil,
            optimizationStatus: LambdaClientTypes.SnapStartOptimizationStatus? = nil
        )
        {
            self.applyOn = applyOn
            self.optimizationStatus = optimizationStatus
        }
    }
}

extension LambdaClientTypes {

    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .failed,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case .inactive: return "Inactive"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum StateReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case disabledkmskey
        case efsioerror
        case efsmountconnectivityerror
        case efsmountfailure
        case efsmounttimeout
        case enilimitexceeded
        case functionerror
        case idle
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidruntime
        case invalidsecuritygroup
        case invalidstatekmskey
        case invalidsubnet
        case invalidzipfileexception
        case kmskeyaccessdenied
        case kmskeynotfound
        case restoring
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [StateReasonCode] {
            return [
                .creating,
                .disabledkmskey,
                .efsioerror,
                .efsmountconnectivityerror,
                .efsmountfailure,
                .efsmounttimeout,
                .enilimitexceeded,
                .functionerror,
                .idle,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidruntime,
                .invalidsecuritygroup,
                .invalidstatekmskey,
                .invalidsubnet,
                .invalidzipfileexception,
                .kmskeyaccessdenied,
                .kmskeynotfound,
                .restoring,
                .subnetoutofipaddresses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .disabledkmskey: return "DisabledKMSKey"
            case .efsioerror: return "EFSIOError"
            case .efsmountconnectivityerror: return "EFSMountConnectivityError"
            case .efsmountfailure: return "EFSMountFailure"
            case .efsmounttimeout: return "EFSMountTimeout"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .functionerror: return "FunctionError"
            case .idle: return "Idle"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidruntime: return "InvalidRuntime"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidstatekmskey: return "InvalidStateKMSKey"
            case .invalidsubnet: return "InvalidSubnet"
            case .invalidzipfileexception: return "InvalidZipFileException"
            case .kmskeyaccessdenied: return "KMSKeyAccessDenied"
            case .kmskeynotfound: return "KMSKeyNotFound"
            case .restoring: return "Restoring"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's X-Ray tracing configuration.
    public struct TracingConfigResponse: Swift.Sendable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init(
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }
}

extension LambdaClientTypes {

    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct VpcConfigResponse: Swift.Sendable {
        /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        public var ipv6AllowedForDualStack: Swift.Bool?
        /// A list of VPC security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            ipv6AllowedForDualStack: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6AllowedForDualStack = ipv6AllowedForDualStack
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

/// Details about a function's configuration.
public struct CreateFunctionOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

extension LambdaClientTypes {

    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your Lambda function URL. Use CORS to grant access to your function URL from any origin. You can also use CORS to control access for specific HTTP headers and methods in requests to your function URL.
    public struct Cors: Swift.Sendable {
        /// Whether to allow cookies or other credentials in requests to your function URL. The default is false.
        public var allowCredentials: Swift.Bool?
        /// The HTTP headers that origins can include in requests to your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public var allowHeaders: [Swift.String]?
        /// The HTTP methods that are allowed when calling your function URL. For example: GET, POST, DELETE, or the wildcard character (*).
        public var allowMethods: [Swift.String]?
        /// The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: https://www.example.com, http://localhost:60905. Alternatively, you can grant access to all origins using the wildcard character (*).
        public var allowOrigins: [Swift.String]?
        /// The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public var exposeHeaders: [Swift.String]?
        /// The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to 0, which means that the browser doesn't cache results.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }
}

extension LambdaClientTypes {

    public enum InvokeMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case buffered
        case responseStream
        case sdkUnknown(Swift.String)

        public static var allCases: [InvokeMode] {
            return [
                .buffered,
                .responseStream
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .buffered: return "BUFFERED"
            case .responseStream: return "RESPONSE_STREAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFunctionUrlConfigInput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        functionName: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.functionName = functionName
        self.invokeMode = invokeMode
        self.qualifier = qualifier
    }
}

public struct CreateFunctionUrlConfigOutput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
    }
}

public struct DeleteAliasInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

public struct DeleteCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

public struct DeleteCodeSigningConfigOutput: Swift.Sendable {

    public init() { }
}

/// The operation conflicts with the resource's availability. For example, you tried to update an event source mapping in the CREATING state, or you tried to delete an event source mapping currently UPDATING.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

public struct DeleteEventSourceMappingInput: Swift.Sendable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        uuid: Swift.String? = nil
    )
    {
        self.uuid = uuid
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct DeleteEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka event sources only) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

public struct DeleteFunctionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function or version. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:1 (with version).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version to delete. You can't delete a version that an alias references.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct DeleteFunctionCodeSigningConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

public struct DeleteFunctionConcurrencyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

public struct DeleteFunctionEventInvokeConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct DeleteFunctionUrlConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct DeleteLayerVersionInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

public struct DeleteProvisionedConcurrencyConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetAccountSettingsInput: Swift.Sendable {

    public init() { }
}

public struct GetAccountSettingsOutput: Swift.Sendable {
    /// Limits that are related to concurrency and code storage.
    public var accountLimit: LambdaClientTypes.AccountLimit?
    /// The number of functions and amount of storage in use.
    public var accountUsage: LambdaClientTypes.AccountUsage?

    public init(
        accountLimit: LambdaClientTypes.AccountLimit? = nil,
        accountUsage: LambdaClientTypes.AccountUsage? = nil
    )
    {
        self.accountLimit = accountLimit
        self.accountUsage = accountUsage
    }
}

public struct GetAliasInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct GetAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

public struct GetCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

public struct GetCodeSigningConfigOutput: Swift.Sendable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

public struct GetEventSourceMappingInput: Swift.Sendable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        uuid: Swift.String? = nil
    )
    {
        self.uuid = uuid
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct GetEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka event sources only) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

public struct GetFunctionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    /// Details about a function's deployment package.
    public struct FunctionCodeLocation: Swift.Sendable {
        /// URI of a container image in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// A presigned URL that you can use to download the deployment package.
        public var location: Swift.String?
        /// The service that's hosting the file.
        public var repositoryType: Swift.String?
        /// The resolved URI for the image.
        public var resolvedImageUri: Swift.String?

        public init(
            imageUri: Swift.String? = nil,
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil,
            resolvedImageUri: Swift.String? = nil
        )
        {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
        }
    }
}

extension LambdaClientTypes {

    public struct Concurrency: Swift.Sendable {
        /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Lambda reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
        public var reservedConcurrentExecutions: Swift.Int?

        public init(
            reservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }
    }
}

extension LambdaClientTypes {

    /// Details about a function's configuration.
    public struct FunctionConfiguration: Swift.Sendable {
        /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
        public var architectures: [LambdaClientTypes.Architecture]?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The size of the function's deployment package, in bytes.
        public var codeSize: Swift.Int
        /// The function's dead letter queue.
        public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
        /// The function's description.
        public var description: Swift.String?
        /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
        public var environment: LambdaClientTypes.EnvironmentResponse?
        /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
        public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
        /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
        public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public var functionArn: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin running your function.
        public var handler: Swift.String?
        /// The function's image configuration values.
        public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
        /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
        public var kmsKeyArn: Swift.String?
        /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var lastModified: Swift.String?
        /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
        public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public var lastUpdateStatusReason: Swift.String?
        /// The reason code for the last update that was performed on the function.
        public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
        /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
        public var layers: [LambdaClientTypes.Layer]?
        /// The function's Amazon CloudWatch Logs configuration settings.
        public var loggingConfig: LambdaClientTypes.LoggingConfig?
        /// For Lambda@Edge functions, the ARN of the main function.
        public var masterArn: Swift.String?
        /// The amount of memory available to the function at runtime.
        public var memorySize: Swift.Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: LambdaClientTypes.PackageType?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
        public var runtime: LambdaClientTypes.Runtime?
        /// The ARN of the runtime and any errors that occured.
        public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
        /// The ARN of the signing job.
        public var signingJobArn: Swift.String?
        /// The ARN of the signing profile version.
        public var signingProfileVersionArn: Swift.String?
        /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
        public var snapStart: LambdaClientTypes.SnapStartResponse?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
        public var state: LambdaClientTypes.State?
        /// The reason for the function's current state.
        public var stateReason: Swift.String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
        public var stateReasonCode: LambdaClientTypes.StateReasonCode?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int?
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

        public init(
            architectures: [LambdaClientTypes.Architecture]? = nil,
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
            description: Swift.String? = nil,
            environment: LambdaClientTypes.EnvironmentResponse? = nil,
            ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
            fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
            functionArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
            lastUpdateStatusReason: Swift.String? = nil,
            lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
            layers: [LambdaClientTypes.Layer]? = nil,
            loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            packageType: LambdaClientTypes.PackageType? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: LambdaClientTypes.Runtime? = nil,
            runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil,
            snapStart: LambdaClientTypes.SnapStartResponse? = nil,
            state: LambdaClientTypes.State? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
            timeout: Swift.Int? = nil,
            tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
            version: Swift.String? = nil,
            vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
        )
        {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.ephemeralStorage = ephemeralStorage
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.loggingConfig = loggingConfig
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.runtimeVersionConfig = runtimeVersionConfig
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.snapStart = snapStart
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }
}

extension LambdaClientTypes {

    /// An object that contains details about an error related to retrieving tags.
    public struct TagsError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

public struct GetFunctionOutput: Swift.Sendable {
    /// The deployment package of the function or version.
    public var code: LambdaClientTypes.FunctionCodeLocation?
    /// The function's [reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html).
    public var concurrency: LambdaClientTypes.Concurrency?
    /// The configuration of the function or version.
    public var configuration: LambdaClientTypes.FunctionConfiguration?
    /// The function's [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html). Lambda returns tag data only if you have explicit allow permissions for [lambda:ListTags](https://docs.aws.amazon.com/https:/docs.aws.amazon.com/lambda/latest/api/API_ListTags.html).
    public var tags: [Swift.String: Swift.String]?
    /// An object that contains details about an error related to retrieving tags.
    public var tagsError: LambdaClientTypes.TagsError?

    public init(
        code: LambdaClientTypes.FunctionCodeLocation? = nil,
        concurrency: LambdaClientTypes.Concurrency? = nil,
        configuration: LambdaClientTypes.FunctionConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tagsError: LambdaClientTypes.TagsError? = nil
    )
    {
        self.code = code
        self.concurrency = concurrency
        self.configuration = configuration
        self.tags = tags
        self.tagsError = tagsError
    }
}

public struct GetFunctionCodeSigningConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

public struct GetFunctionCodeSigningConfigOutput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

public struct GetFunctionConcurrencyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

public struct GetFunctionConcurrencyOutput: Swift.Sendable {
    /// The number of simultaneous executions that are reserved for the function.
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct GetFunctionConfigurationInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

/// Details about a function's configuration.
public struct GetFunctionConfigurationOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct GetFunctionEventInvokeConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetFunctionEventInvokeConfigOutput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: Foundation.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

public struct GetFunctionRecursionConfigInput: Swift.Sendable {
    ///
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

extension LambdaClientTypes {

    public enum RecursiveLoop: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [RecursiveLoop] {
            return [
                .allow,
                .terminate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "Allow"
            case .terminate: return "Terminate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFunctionRecursionConfigOutput: Swift.Sendable {
    /// If your function's recursive loop detection configuration is Allow, Lambda doesn't take any action when it detects your function being invoked as part of a recursive loop. If your function's recursive loop detection configuration is Terminate, Lambda stops your function being invoked and notifies you when it detects your function being invoked as part of a recursive loop. By default, Lambda sets your function's configuration to Terminate. You can update this configuration using the [PutFunctionRecursionConfig] action.
    public var recursiveLoop: LambdaClientTypes.RecursiveLoop?

    public init(
        recursiveLoop: LambdaClientTypes.RecursiveLoop? = nil
    )
    {
        self.recursiveLoop = recursiveLoop
    }
}

public struct GetFunctionUrlConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetFunctionUrlConfigOutput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var lastModifiedTime: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        lastModifiedTime: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
        self.lastModifiedTime = lastModifiedTime
    }
}

public struct GetLayerVersionInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

extension LambdaClientTypes {

    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionContentOutput: Swift.Sendable {
        /// The SHA-256 hash of the layer archive.
        public var codeSha256: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public var location: Swift.String?
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init(
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            location: Swift.String? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }
}

public struct GetLayerVersionOutput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

public struct GetLayerVersionByArnInput: Swift.Sendable {
    /// The ARN of the layer version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetLayerVersionByArnOutput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

public struct GetLayerVersionPolicyInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

public struct GetLayerVersionPolicyOutput: Swift.Sendable {
    /// The policy document.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

public struct GetPolicyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get the policy for that resource.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetPolicyOutput: Swift.Sendable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

/// The specified configuration does not exist.
public struct ProvisionedConcurrencyConfigNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProvisionedConcurrencyConfigNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

public struct GetProvisionedConcurrencyConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    public enum ProvisionedConcurrencyStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedConcurrencyStatusEnum] {
            return [
                .failed,
                .inProgress,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetProvisionedConcurrencyConfigOutput: Swift.Sendable {
    /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init(
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

public struct GetRuntimeManagementConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the $LATEST version is returned.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    public enum UpdateRuntimeOn: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case functionupdate
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRuntimeOn] {
            return [
                .auto,
                .functionupdate,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .functionupdate: return "FunctionUpdate"
            case .manual: return "Manual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetRuntimeManagementConfigOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of your function.
    public var functionArn: Swift.String?
    /// The ARN of the runtime the function is configured to use. If the runtime update mode is Manual, the ARN is returned, otherwise null is returned.
    public var runtimeVersionArn: Swift.String?
    /// The current runtime update mode of the function.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionArn: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    )
    {
        self.functionArn = functionArn
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

/// Need additional permissions to configure VPC settings.
public struct EC2AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Amazon EC2 throttled Lambda during Lambda function initialization using the execution role provided for the function.
public struct EC2ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda function.
public struct EC2UnexpectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var ec2ErrorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2UnexpectedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        ec2ErrorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.ec2ErrorCode = ec2ErrorCode
        self.properties.message = message
        self.properties.type = type
    }
}

/// An error occurred when reading from or writing to a connected file system.
public struct EFSIOException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSIOException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda function couldn't make a network connection to the configured file system.
public struct EFSMountConnectivityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountConnectivityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda function couldn't mount the configured file system due to a permission or configuration issue.
public struct EFSMountFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda function made a network connection to the configured file system, but the mount operation timed out.
public struct EFSMountTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct ENILimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ENILimitReachedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The request body could not be parsed as JSON.
public struct InvalidRequestContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestContentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The runtime or runtime version specified is not supported.
public struct InvalidRuntimeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuntimeException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The security group ID provided in the Lambda function VPC configuration is not valid.
public struct InvalidSecurityGroupIDException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurityGroupIDException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The subnet ID provided in the Lambda function VPC configuration is not valid.
public struct InvalidSubnetIDException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnetIDException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda could not unzip the deployment package.
public struct InvalidZipFileException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidZipFileException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.
public struct KMSAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.
public struct KMSDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabledException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because the state of the KMS key used is not valid for Decrypt. Check the function's KMS key settings.
public struct KMSInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.
public struct KMSNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda has detected your function being invoked in a recursive loop with other Amazon Web Services resources and stopped your function's invocation.
public struct RecursiveInvocationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RecursiveInvocationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The request payload exceeded the Invoke request body JSON input quota. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct RequestTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The afterRestore()[runtime hook](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-runtime-hooks.html) encountered an error. For more information, check the Amazon CloudWatch logs.
public struct SnapStartException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda is initializing your function. You can invoke the function when the [function state](https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html) becomes Active.
public struct SnapStartNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't restore the snapshot within the timeout limit.
public struct SnapStartTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.
public struct SubnetIPAddressLimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetIPAddressLimitReachedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The content type of the Invoke request body is not JSON.
public struct UnsupportedMediaTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedMediaTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    public enum InvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dryrun
        case event
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .dryrun,
                .event,
                .requestresponse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .event: return "Event"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum LogType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case tail
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .none,
                .tail
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .tail: return "Tail"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeInput: Swift.Sendable {
    /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object. Lambda passes the ClientContext object to your function for synchronous invocations only.
    public var clientContext: Swift.String?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Choose from the following options.
    ///
    /// * RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API response includes the function response and additional data.
    ///
    /// * Event – Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if one is configured). The API response only includes a status code.
    ///
    /// * DryRun – Validate parameter values and verify that the user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.InvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: Foundation.Data?
    /// Specify a version or alias to invoke a published version of the function.
    public var qualifier: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.InvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: Foundation.Data? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

extension InvokeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeInput(clientContext: \(Swift.String(describing: clientContext)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), qualifier: \(Swift.String(describing: qualifier)), payload: \"CONTENT_REDACTED\")"}
}

public struct InvokeOutput: Swift.Sendable {
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// If present, indicates that an error occurred during function execution. Details about the error are included in the response payload.
    public var functionError: Swift.String?
    /// The last 4 KB of the execution log, which is base64-encoded.
    public var logResult: Swift.String?
    /// The response from the function, or an error object.
    public var payload: Foundation.Data?
    /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse invocation type, this status code is 200. For the Event invocation type, this status code is 202. For the DryRun invocation type, the status code is 204.
    public var statusCode: Swift.Int

    public init(
        executedVersion: Swift.String? = nil,
        functionError: Swift.String? = nil,
        logResult: Swift.String? = nil,
        payload: Foundation.Data? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.executedVersion = executedVersion
        self.functionError = functionError
        self.logResult = logResult
        self.payload = payload
        self.statusCode = statusCode
    }
}

extension InvokeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeOutput(executedVersion: \(Swift.String(describing: executedVersion)), functionError: \(Swift.String(describing: functionError)), logResult: \(Swift.String(describing: logResult)), statusCode: \(Swift.String(describing: statusCode)), payload: \"CONTENT_REDACTED\")"}
}

@available(*, deprecated)
public struct InvokeAsyncInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The JSON that you want to provide to your Lambda function as input.
    /// This member is required.
    public var invokeArgs: Smithy.ByteStream?

    public init(
        functionName: Swift.String? = nil,
        invokeArgs: Smithy.ByteStream? = nil
    )
    {
        self.functionName = functionName
        self.invokeArgs = invokeArgs
    }
}

/// A success response (202 Accepted) indicates that the request is queued for invocation.
@available(*, deprecated)
public struct InvokeAsyncOutput: Swift.Sendable {
    /// The status code.
    public var status: Swift.Int

    public init(
        status: Swift.Int = 0
    )
    {
        self.status = status
    }
}

extension LambdaClientTypes {

    public enum ResponseStreamingInvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dryrun
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseStreamingInvocationType] {
            return [
                .dryrun,
                .requestresponse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeWithResponseStreamInput: Swift.Sendable {
    /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
    public var clientContext: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API operation response includes the function response and additional data.
    ///
    /// * DryRun – Validate parameter values and verify that the IAM user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.ResponseStreamingInvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: Foundation.Data?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.ResponseStreamingInvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: Foundation.Data? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

extension InvokeWithResponseStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeWithResponseStreamInput(clientContext: \(Swift.String(describing: clientContext)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), qualifier: \(Swift.String(describing: qualifier)), payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// A response confirming that the event stream is complete.
    public struct InvokeWithResponseStreamCompleteEvent: Swift.Sendable {
        /// An error code.
        public var errorCode: Swift.String?
        /// The details of any returned error.
        public var errorDetails: Swift.String?
        /// The last 4 KB of the execution log, which is base64-encoded.
        public var logResult: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorDetails: Swift.String? = nil,
            logResult: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
            self.logResult = logResult
        }
    }
}

extension LambdaClientTypes {

    /// A chunk of the streamed response payload.
    public struct InvokeResponseStreamUpdate: Swift.Sendable {
        /// Data returned by your Lambda function.
        public var payload: Foundation.Data?

        public init(
            payload: Foundation.Data? = nil
        )
        {
            self.payload = payload
        }
    }
}

extension LambdaClientTypes.InvokeResponseStreamUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeResponseStreamUpdate(payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// An object that includes a chunk of the response payload. When the stream has ended, Lambda includes a InvokeComplete object.
    public enum InvokeWithResponseStreamResponseEvent: Swift.Sendable {
        /// A chunk of the streamed response payload.
        case payloadchunk(LambdaClientTypes.InvokeResponseStreamUpdate)
        /// An object that's returned when the stream has ended and all the payload chunks have been returned.
        case invokecomplete(LambdaClientTypes.InvokeWithResponseStreamCompleteEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeWithResponseStreamOutput: Swift.Sendable {
    /// The stream of response payloads.
    public var eventStream: AsyncThrowingStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent, Swift.Error>?
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// The type of data the stream is returning.
    public var responseStreamContentType: Swift.String?
    /// For a successful request, the HTTP status code is in the 200 range. For the RequestResponse invocation type, this status code is 200. For the DryRun invocation type, this status code is 204.
    public var statusCode: Swift.Int

    public init(
        eventStream: AsyncThrowingStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent, Swift.Error>? = nil,
        executedVersion: Swift.String? = nil,
        responseStreamContentType: Swift.String? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.eventStream = eventStream
        self.executedVersion = executedVersion
        self.responseStreamContentType = responseStreamContentType
        self.statusCode = statusCode
    }
}

public struct ListAliasesInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a function version to only list aliases that invoke that version.
    public var functionVersion: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Limit the number of aliases returned.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListAliasesOutput: Swift.Sendable {
    /// A list of aliases.
    public var aliases: [LambdaClientTypes.AliasConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        aliases: [LambdaClientTypes.AliasConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextMarker = nextMarker
    }
}

public struct ListCodeSigningConfigsInput: Swift.Sendable {
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListCodeSigningConfigsOutput: Swift.Sendable {
    /// The code signing configurations
    public var codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.codeSigningConfigs = codeSigningConfigs
        self.nextMarker = nextMarker
    }
}

public struct ListEventSourceMappingsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis – The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams – The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service – The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – The ARN of the cluster or the ARN of the VPC connection (for [cross-account event source mappings](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#msk-multi-vpc)).
    ///
    /// * Amazon MQ – The ARN of the broker.
    ///
    /// * Amazon DocumentDB – The ARN of the DocumentDB change stream.
    public var eventSourceArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of event source mappings to return. Note that ListEventSourceMappings returns a maximum of 100 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        eventSourceArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
    public struct EventSourceMappingConfiguration: Swift.Sendable {
        /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var batchSize: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
        public var bisectBatchOnFunctionError: Swift.Bool?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka event sources only) A configuration object that specifies the destination of an event after Lambda processes it.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// Specific configuration settings for a DocumentDB event source.
        public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public var eventSourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the event source mapping.
        public var eventSourceMappingArn: Swift.String?
        /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
        public var filterCriteria: LambdaClientTypes.FilterCriteria?
        /// An object that contains details about an error related to filter criteria encryption.
        public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
        public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
        /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
        public var kmsKeyArn: Swift.String?
        /// The date that the event source mapping was last updated or that its state changed.
        public var lastModified: Foundation.Date?
        /// The result of the last Lambda invocation of your function.
        public var lastProcessingResult: Swift.String?
        /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var maximumBatchingWindowInSeconds: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
        public var maximumRecordAgeInSeconds: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public var maximumRetryAttempts: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
        public var parallelizationFactor: Swift.Int?
        /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
        public var queues: [Swift.String]?
        /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
        public var scalingConfig: LambdaClientTypes.ScalingConfig?
        /// The self-managed Apache Kafka cluster for your event source.
        public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
        /// Specific configuration settings for a self-managed Apache Kafka event source.
        public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
        /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
        public var startingPosition: LambdaClientTypes.EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
        public var startingPositionTimestamp: Foundation.Date?
        /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
        public var state: Swift.String?
        /// Indicates whether a user or Lambda made the last change to the event source mapping.
        public var stateTransitionReason: Swift.String?
        /// The name of the Kafka topic.
        public var topics: [Swift.String]?
        /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
        public var tumblingWindowInSeconds: Swift.Int?
        /// The identifier of the event source mapping.
        public var uuid: Swift.String?

        public init(
            amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
            batchSize: Swift.Int? = nil,
            bisectBatchOnFunctionError: Swift.Bool? = nil,
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
            eventSourceArn: Swift.String? = nil,
            eventSourceMappingArn: Swift.String? = nil,
            filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
            filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
            functionArn: Swift.String? = nil,
            functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            lastProcessingResult: Swift.String? = nil,
            maximumBatchingWindowInSeconds: Swift.Int? = nil,
            maximumRecordAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil,
            parallelizationFactor: Swift.Int? = nil,
            queues: [Swift.String]? = nil,
            scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
            selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
            selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
            sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
            startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
            startingPositionTimestamp: Foundation.Date? = nil,
            state: Swift.String? = nil,
            stateTransitionReason: Swift.String? = nil,
            topics: [Swift.String]? = nil,
            tumblingWindowInSeconds: Swift.Int? = nil,
            uuid: Swift.String? = nil
        )
        {
            self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.documentDBEventSourceConfig = documentDBEventSourceConfig
            self.eventSourceArn = eventSourceArn
            self.eventSourceMappingArn = eventSourceMappingArn
            self.filterCriteria = filterCriteria
            self.filterCriteriaError = filterCriteriaError
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.queues = queues
            self.scalingConfig = scalingConfig
            self.selfManagedEventSource = selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }
    }
}

public struct ListEventSourceMappingsOutput: Swift.Sendable {
    /// A list of event source mappings.
    public var eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
    /// A pagination token that's returned when the response doesn't contain all event source mappings.
    public var nextMarker: Swift.String?

    public init(
        eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.eventSourceMappings = eventSourceMappings
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionEventInvokeConfigsInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of configurations to return.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    public struct FunctionEventInvokeConfig: Swift.Sendable {
        /// A destination for events after they have been sent to a function for processing. Destinations
        ///
        /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
        ///
        /// * Queue - The ARN of a standard SQS queue.
        ///
        /// * Topic - The ARN of a standard SNS topic.
        ///
        /// * Event Bus - The ARN of an Amazon EventBridge event bus.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public var functionArn: Swift.String?
        /// The date and time that the configuration was last updated.
        public var lastModified: Foundation.Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of times to retry when the function returns an error.
        public var maximumRetryAttempts: Swift.Int?

        public init(
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }
}

public struct ListFunctionEventInvokeConfigsOutput: Swift.Sendable {
    /// A list of configurations.
    public var functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionEventInvokeConfigs = functionEventInvokeConfigs
        self.nextMarker = nextMarker
    }
}

extension LambdaClientTypes {

    public enum FunctionVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionVersion] {
            return [
                .all
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListFunctionsInput: Swift.Sendable {
    /// Set to ALL to include entries for all published versions of each function.
    public var functionVersion: LambdaClientTypes.FunctionVersion?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// For Lambda@Edge functions, the Amazon Web Services Region of the master function. For example, us-east-1 filters the list of functions to include only Lambda@Edge functions replicated from a master function in US East (N. Virginia). If specified, you must set FunctionVersion to ALL.
    public var masterRegion: Swift.String?
    /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionVersion: LambdaClientTypes.FunctionVersion? = nil,
        marker: Swift.String? = nil,
        masterRegion: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionVersion = functionVersion
        self.marker = marker
        self.masterRegion = masterRegion
        self.maxItems = maxItems
    }
}

/// A list of Lambda functions.
public struct ListFunctionsOutput: Swift.Sendable {
    /// A list of Lambda functions.
    public var functions: [LambdaClientTypes.FunctionConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functions: [LambdaClientTypes.FunctionConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionsByCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListFunctionsByCodeSigningConfigOutput: Swift.Sendable {
    /// The function ARNs.
    public var functionArns: [Swift.String]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionArns: [Swift.String]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionArns = functionArns
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionUrlConfigsInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of function URLs to return in the response. Note that ListFunctionUrlConfigs returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// Details about a Lambda function URL.
    public struct FunctionUrlConfig: Swift.Sendable {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
        /// This member is required.
        public var authType: LambdaClientTypes.FunctionUrlAuthType?
        /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
        public var cors: LambdaClientTypes.Cors?
        /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var creationTime: Swift.String?
        /// The Amazon Resource Name (ARN) of your function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// The HTTP URL endpoint for your function.
        /// This member is required.
        public var functionUrl: Swift.String?
        /// Use one of the following options:
        ///
        /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
        ///
        /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
        public var invokeMode: LambdaClientTypes.InvokeMode?
        /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModifiedTime: Swift.String?

        public init(
            authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
            cors: LambdaClientTypes.Cors? = nil,
            creationTime: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionUrl: Swift.String? = nil,
            invokeMode: LambdaClientTypes.InvokeMode? = nil,
            lastModifiedTime: Swift.String? = nil
        )
        {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct ListFunctionUrlConfigsOutput: Swift.Sendable {
    /// A list of function URL configurations.
    /// This member is required.
    public var functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionUrlConfigs = functionUrlConfigs
        self.nextMarker = nextMarker
    }
}

public struct ListLayersInput: Swift.Sendable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of layers to return.
    public var maxItems: Swift.Int?

    public init(
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionsListItem: Swift.Sendable {
        /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
        public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
        /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
        public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public var createdDate: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// The ARN of the layer version.
        public var layerVersionArn: Swift.String?
        /// The layer's open-source license.
        public var licenseInfo: Swift.String?
        /// The version number.
        public var version: Swift.Int

        public init(
            compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
            compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            layerVersionArn: Swift.String? = nil,
            licenseInfo: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }
    }
}

extension LambdaClientTypes {

    /// Details about an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayersListItem: Swift.Sendable {
        /// The newest version of the layer.
        public var latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public var layerArn: Swift.String?
        /// The name of the layer.
        public var layerName: Swift.String?

        public init(
            latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem? = nil,
            layerArn: Swift.String? = nil,
            layerName: Swift.String? = nil
        )
        {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }
    }
}

public struct ListLayersOutput: Swift.Sendable {
    /// A list of function layers.
    public var layers: [LambdaClientTypes.LayersListItem]?
    /// A pagination token returned when the response doesn't contain all layers.
    public var nextMarker: Swift.String?

    public init(
        layers: [LambdaClientTypes.LayersListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layers = layers
        self.nextMarker = nextMarker
    }
}

public struct ListLayerVersionsInput: Swift.Sendable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of versions to return.
    public var maxItems: Swift.Int?

    public init(
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        layerName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.layerName = layerName
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListLayerVersionsOutput: Swift.Sendable {
    /// A list of versions.
    public var layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
    /// A pagination token returned when the response doesn't contain all versions.
    public var nextMarker: Swift.String?

    public init(
        layerVersions: [LambdaClientTypes.LayerVersionsListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layerVersions = layerVersions
        self.nextMarker = nextMarker
    }
}

public struct ListProvisionedConcurrencyConfigsInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Specify a number to limit the number of configurations returned.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// Details about the provisioned concurrency configuration for a function alias or version.
    public struct ProvisionedConcurrencyConfigListItem: Swift.Sendable {
        /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
        public var allocatedProvisionedConcurrentExecutions: Swift.Int?
        /// The amount of provisioned concurrency available.
        public var availableProvisionedConcurrentExecutions: Swift.Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public var functionArn: Swift.String?
        /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
        public var lastModified: Swift.String?
        /// The amount of provisioned concurrency requested.
        public var requestedProvisionedConcurrentExecutions: Swift.Int?
        /// The status of the allocation process.
        public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public var statusReason: Swift.String?

        public init(
            allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
            availableProvisionedConcurrentExecutions: Swift.Int? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
            status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListProvisionedConcurrencyConfigsOutput: Swift.Sendable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of provisioned concurrency configurations.
    public var provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?

    public init(
        nextMarker: Swift.String? = nil,
        provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
    }
}

public struct ListTagsInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN). Note: Lambda does not support adding tags to function aliases or versions.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

public struct ListTagsOutput: Swift.Sendable {
    /// The function's tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListVersionsByFunctionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListVersionsByFunctionOutput: Swift.Sendable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of Lambda function versions.
    public var versions: [LambdaClientTypes.FunctionConfiguration]?

    public init(
        nextMarker: Swift.String? = nil,
        versions: [LambdaClientTypes.FunctionConfiguration]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.versions = versions
    }
}

extension LambdaClientTypes {

    /// A ZIP archive that contains the contents of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). You can specify either an Amazon S3 location, or upload a layer archive directly.
    public struct LayerVersionContentInput: Swift.Sendable {
        /// The Amazon S3 bucket of the layer archive.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the layer archive.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the layer archive object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: Foundation.Data?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: Foundation.Data? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }
}

extension LambdaClientTypes.LayerVersionContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerVersionContentInput(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

public struct PublishLayerVersionInput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// A list of compatible [function runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Used for filtering with [ListLayers] and [ListLayerVersions]. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// The function layer archive.
    /// This member is required.
    public var content: LambdaClientTypes.LayerVersionContentInput?
    /// The description of the version.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The layer's software license. It can be any of the following:
    ///
    /// * An [SPDX license identifier](https://spdx.org/licenses/). For example, MIT.
    ///
    /// * The URL of a license hosted on the internet. For example, https://opensource.org/licenses/MIT.
    ///
    /// * The full text of the license.
    public var licenseInfo: Swift.String?

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentInput? = nil,
        description: Swift.String? = nil,
        layerName: Swift.String? = nil,
        licenseInfo: Swift.String? = nil
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.description = description
        self.layerName = layerName
        self.licenseInfo = licenseInfo
    }
}

public struct PublishLayerVersionOutput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

public struct PublishVersionInput: Swift.Sendable {
    /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of [UpdateFunctionCode].
    public var codeSha256: Swift.String?
    /// A description for the version to override the description in the function configuration.
    public var description: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.
    public var revisionId: Swift.String?

    public init(
        codeSha256: Swift.String? = nil,
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.description = description
        self.functionName = functionName
        self.revisionId = revisionId
    }
}

/// Details about a function's configuration.
public struct PublishVersionOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct PutFunctionCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

public struct PutFunctionCodeSigningConfigOutput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

public struct PutFunctionConcurrencyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The number of simultaneous executions to reserve for the function.
    /// This member is required.
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct PutFunctionConcurrencyOutput: Swift.Sendable {
    /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Lambda reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct PutFunctionEventInvokeConfigInput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

public struct PutFunctionEventInvokeConfigOutput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: Foundation.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

public struct PutFunctionRecursionConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// If you set your function's recursive loop detection configuration to Allow, Lambda doesn't take any action when it detects your function being invoked as part of a recursive loop. We recommend that you only use this setting if your design intentionally uses a Lambda function to write data back to the same Amazon Web Services resource that invokes it. If you set your function's recursive loop detection configuration to Terminate, Lambda stops your function being invoked and notifies you when it detects your function being invoked as part of a recursive loop. By default, Lambda sets your function's configuration to Terminate. If your design intentionally uses a Lambda function to write data back to the same Amazon Web Services resource that invokes the function, then use caution and implement suitable guard rails to prevent unexpected charges being billed to your Amazon Web Services account. To learn more about best practices for using recursive invocation patterns, see [Recursive patterns that cause run-away Lambda functions](https://serverlessland.com/content/service/lambda/guides/aws-lambda-operator-guide/recursive-runaway) in Serverless Land.
    /// This member is required.
    public var recursiveLoop: LambdaClientTypes.RecursiveLoop?

    public init(
        functionName: Swift.String? = nil,
        recursiveLoop: LambdaClientTypes.RecursiveLoop? = nil
    )
    {
        self.functionName = functionName
        self.recursiveLoop = recursiveLoop
    }
}

public struct PutFunctionRecursionConfigOutput: Swift.Sendable {
    /// The status of your function's recursive loop detection configuration. When this value is set to Allowand Lambda detects your function being invoked as part of a recursive loop, it doesn't take any action. When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive loop, it stops your function being invoked and notifies you.
    public var recursiveLoop: LambdaClientTypes.RecursiveLoop?

    public init(
        recursiveLoop: LambdaClientTypes.RecursiveLoop? = nil
    )
    {
        self.recursiveLoop = recursiveLoop
    }
}

public struct PutProvisionedConcurrencyConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The amount of provisioned concurrency to allocate for the version or alias.
    /// This member is required.
    public var provisionedConcurrentExecutions: Swift.Int?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        provisionedConcurrentExecutions: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
        self.qualifier = qualifier
    }
}

public struct PutProvisionedConcurrencyConfigOutput: Swift.Sendable {
    /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init(
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

public struct PutRuntimeManagementConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the $LATEST version is returned.
    public var qualifier: Swift.String?
    /// The ARN of the runtime version you want the function to use. This is only required if you're using the Manual runtime update mode.
    public var runtimeVersionArn: Swift.String?
    /// Specify the runtime update mode.
    ///
    /// * Auto (default) - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
    ///
    /// * Function update - Lambda updates the runtime of your function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
    ///
    /// * Manual - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
    /// This member is required.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

public struct PutRuntimeManagementConfigOutput: Swift.Sendable {
    /// The ARN of the function
    /// This member is required.
    public var functionArn: Swift.String?
    /// The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
    public var runtimeVersionArn: Swift.String?
    /// The runtime update mode.
    /// This member is required.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionArn: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    )
    {
        self.functionArn = functionArn
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

public struct RemoveLayerVersionPermissionInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The identifier that was specified when the statement was added.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    )
    {
        self.layerName = layerName
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

public struct RemovePermissionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to remove permissions from a published version of the function.
    public var qualifier: Swift.String?
    /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// Statement ID of the permission to remove.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

public struct UpdateAliasInput: Swift.Sendable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct UpdateAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

public struct UpdateCodeSigningConfigInput: Swift.Sendable {
    /// Signing profiles for this code signing configuration.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The code signing policy.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init(
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

public struct UpdateCodeSigningConfigOutput: Swift.Sendable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

public struct UpdateEventSourceMappingInput: Swift.Sendable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis – Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams – Default 100. Max 10,000.
    ///
    /// * Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Self-managed Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
    ///
    /// * DocumentDB – Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Kafka only) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics). By default, Lambda does not encrypt your filter criteria object. Specify this property to encrypt data using your own customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For Kinesis, DynamoDB, and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        enabled: Swift.Bool? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.enabled = enabled
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.scalingConfig = scalingConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct UpdateEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka event sources only) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

public struct UpdateFunctionCodeInput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Set to true to validate the request parameters and access permissions without modifying the function code.
    public var dryRun: Swift.Bool?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// URI of a container image in the Amazon ECR registry. Do not use for a function defined with a .zip file archive.
    public var imageUri: Swift.String?
    /// Set to true to publish a new version of the function after updating the code. This has the same effect as calling [PublishVersion] separately.
    public var publish: Swift.Bool?
    /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account. Use only with a function defined with a .zip file archive deployment package.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 key of the deployment package. Use only with a function defined with a .zip file archive deployment package.
    public var s3Key: Swift.String?
    /// For versioned objects, the version of the deployment package object to use.
    public var s3ObjectVersion: Swift.String?
    /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you. Use only with a function defined with a .zip file archive deployment package.
    public var zipFile: Foundation.Data?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        dryRun: Swift.Bool? = false,
        functionName: Swift.String? = nil,
        imageUri: Swift.String? = nil,
        publish: Swift.Bool? = false,
        revisionId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3Key: Swift.String? = nil,
        s3ObjectVersion: Swift.String? = nil,
        zipFile: Foundation.Data? = nil
    )
    {
        self.architectures = architectures
        self.dryRun = dryRun
        self.functionName = functionName
        self.imageUri = imageUri
        self.publish = publish
        self.revisionId = revisionId
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

extension UpdateFunctionCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionCodeInput(architectures: \(Swift.String(describing: architectures)), dryRun: \(Swift.String(describing: dryRun)), functionName: \(Swift.String(describing: functionName)), imageUri: \(Swift.String(describing: imageUri)), publish: \(Swift.String(describing: publish)), revisionId: \(Swift.String(describing: revisionId)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

/// Details about a function's configuration.
public struct UpdateFunctionCodeOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateFunctionConfigurationInput: Swift.Sendable {
    /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
    public var handler: Swift.String?
    /// [Container image configuration values](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms) that override the values in the container image Docker file.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
    public var kmsKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public var snapStart: LambdaClientTypes.SnapStart?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init(
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        memorySize: Swift.Int? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        snapStart: LambdaClientTypes.SnapStart? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kmsKeyArn = kmsKeyArn
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.snapStart = snapStart
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionConfigurationOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateFunctionEventInvokeConfigInput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

public struct UpdateFunctionEventInvokeConfigOutput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: Foundation.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

public struct UpdateFunctionUrlConfigInput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        functionName: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.functionName = functionName
        self.invokeMode = invokeMode
        self.qualifier = qualifier
    }
}

public struct UpdateFunctionUrlConfigOutput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var lastModifiedTime: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        lastModifiedTime: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
        self.lastModifiedTime = lastModifiedTime
    }
}

extension AddLayerVersionPermissionInput {

    static func urlPathProvider(_ value: AddLayerVersionPermissionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

extension AddLayerVersionPermissionInput {

    static func queryItemProvider(_ value: AddLayerVersionPermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = Smithy.URIQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension AddPermissionInput {

    static func urlPathProvider(_ value: AddPermissionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

extension AddPermissionInput {

    static func queryItemProvider(_ value: AddPermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension CreateAliasInput {

    static func urlPathProvider(_ value: CreateAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

extension CreateCodeSigningConfigInput {

    static func urlPathProvider(_ value: CreateCodeSigningConfigInput) -> Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

extension CreateEventSourceMappingInput {

    static func urlPathProvider(_ value: CreateEventSourceMappingInput) -> Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

extension CreateFunctionInput {

    static func urlPathProvider(_ value: CreateFunctionInput) -> Swift.String? {
        return "/2015-03-31/functions"
    }
}

extension CreateFunctionUrlConfigInput {

    static func urlPathProvider(_ value: CreateFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension CreateFunctionUrlConfigInput {

    static func queryItemProvider(_ value: CreateFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteAliasInput {

    static func urlPathProvider(_ value: DeleteAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

extension DeleteCodeSigningConfigInput {

    static func urlPathProvider(_ value: DeleteCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

extension DeleteEventSourceMappingInput {

    static func urlPathProvider(_ value: DeleteEventSourceMappingInput) -> Swift.String? {
        guard let uuid = value.uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

extension DeleteFunctionInput {

    static func urlPathProvider(_ value: DeleteFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

extension DeleteFunctionInput {

    static func queryItemProvider(_ value: DeleteFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteFunctionCodeSigningConfigInput {

    static func urlPathProvider(_ value: DeleteFunctionCodeSigningConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

extension DeleteFunctionConcurrencyInput {

    static func urlPathProvider(_ value: DeleteFunctionConcurrencyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

extension DeleteFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: DeleteFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension DeleteFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: DeleteFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteFunctionUrlConfigInput {

    static func urlPathProvider(_ value: DeleteFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension DeleteFunctionUrlConfigInput {

    static func queryItemProvider(_ value: DeleteFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteLayerVersionInput {

    static func urlPathProvider(_ value: DeleteLayerVersionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension DeleteProvisionedConcurrencyConfigInput {

    static func urlPathProvider(_ value: DeleteProvisionedConcurrencyConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension DeleteProvisionedConcurrencyConfigInput {

    static func queryItemProvider(_ value: DeleteProvisionedConcurrencyConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension GetAccountSettingsInput {

    static func urlPathProvider(_ value: GetAccountSettingsInput) -> Swift.String? {
        return "/2016-08-19/account-settings"
    }
}

extension GetAliasInput {

    static func urlPathProvider(_ value: GetAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

extension GetCodeSigningConfigInput {

    static func urlPathProvider(_ value: GetCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

extension GetEventSourceMappingInput {

    static func urlPathProvider(_ value: GetEventSourceMappingInput) -> Swift.String? {
        guard let uuid = value.uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

extension GetFunctionInput {

    static func urlPathProvider(_ value: GetFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

extension GetFunctionInput {

    static func queryItemProvider(_ value: GetFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionCodeSigningConfigInput {

    static func urlPathProvider(_ value: GetFunctionCodeSigningConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

extension GetFunctionConcurrencyInput {

    static func urlPathProvider(_ value: GetFunctionConcurrencyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

extension GetFunctionConfigurationInput {

    static func urlPathProvider(_ value: GetFunctionConfigurationInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

extension GetFunctionConfigurationInput {

    static func queryItemProvider(_ value: GetFunctionConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: GetFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension GetFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: GetFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionRecursionConfigInput {

    static func urlPathProvider(_ value: GetFunctionRecursionConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2024-08-31/functions/\(functionName.urlPercentEncoding())/recursion-config"
    }
}

extension GetFunctionUrlConfigInput {

    static func urlPathProvider(_ value: GetFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension GetFunctionUrlConfigInput {

    static func queryItemProvider(_ value: GetFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetLayerVersionInput {

    static func urlPathProvider(_ value: GetLayerVersionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension GetLayerVersionByArnInput {

    static func urlPathProvider(_ value: GetLayerVersionByArnInput) -> Swift.String? {
        return "/2018-10-31/layers"
    }
}

extension GetLayerVersionByArnInput {

    static func queryItemProvider(_ value: GetLayerVersionByArnInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "find", value: "LayerVersion"))
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension GetLayerVersionPolicyInput {

    static func urlPathProvider(_ value: GetLayerVersionPolicyInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

extension GetPolicyInput {

    static func queryItemProvider(_ value: GetPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetProvisionedConcurrencyConfigInput {

    static func urlPathProvider(_ value: GetProvisionedConcurrencyConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension GetProvisionedConcurrencyConfigInput {

    static func queryItemProvider(_ value: GetProvisionedConcurrencyConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension GetRuntimeManagementConfigInput {

    static func urlPathProvider(_ value: GetRuntimeManagementConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-07-20/functions/\(functionName.urlPercentEncoding())/runtime-management-config"
    }
}

extension GetRuntimeManagementConfigInput {

    static func queryItemProvider(_ value: GetRuntimeManagementConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeInput {

    static func urlPathProvider(_ value: InvokeInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/invocations"
    }
}

extension InvokeInput {

    static func headerProvider(_ value: InvokeInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientContext = value.clientContext {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let invocationType = value.invocationType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = value.logType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        return items
    }
}

extension InvokeInput {

    static func queryItemProvider(_ value: InvokeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeAsyncInput {

    static func urlPathProvider(_ value: InvokeAsyncInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2014-11-13/functions/\(functionName.urlPercentEncoding())/invoke-async"
    }
}

extension InvokeWithResponseStreamInput {

    static func urlPathProvider(_ value: InvokeWithResponseStreamInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-11-15/functions/\(functionName.urlPercentEncoding())/response-streaming-invocations"
    }
}

extension InvokeWithResponseStreamInput {

    static func headerProvider(_ value: InvokeWithResponseStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientContext = value.clientContext {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let invocationType = value.invocationType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = value.logType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        return items
    }
}

extension InvokeWithResponseStreamInput {

    static func queryItemProvider(_ value: InvokeWithResponseStreamInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension ListAliasesInput {

    static func urlPathProvider(_ value: ListAliasesInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

extension ListAliasesInput {

    static func queryItemProvider(_ value: ListAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let functionVersion = value.functionVersion {
            let functionVersionQueryItem = Smithy.URIQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion).urlPercentEncoding())
            items.append(functionVersionQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCodeSigningConfigsInput {

    static func urlPathProvider(_ value: ListCodeSigningConfigsInput) -> Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

extension ListCodeSigningConfigsInput {

    static func queryItemProvider(_ value: ListCodeSigningConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListEventSourceMappingsInput {

    static func urlPathProvider(_ value: ListEventSourceMappingsInput) -> Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

extension ListEventSourceMappingsInput {

    static func queryItemProvider(_ value: ListEventSourceMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let functionName = value.functionName {
            let functionNameQueryItem = Smithy.URIQueryItem(name: "FunctionName".urlPercentEncoding(), value: Swift.String(functionName).urlPercentEncoding())
            items.append(functionNameQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let eventSourceArn = value.eventSourceArn {
            let eventSourceArnQueryItem = Smithy.URIQueryItem(name: "EventSourceArn".urlPercentEncoding(), value: Swift.String(eventSourceArn).urlPercentEncoding())
            items.append(eventSourceArnQueryItem)
        }
        return items
    }
}

extension ListFunctionEventInvokeConfigsInput {

    static func urlPathProvider(_ value: ListFunctionEventInvokeConfigsInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config/list"
    }
}

extension ListFunctionEventInvokeConfigsInput {

    static func queryItemProvider(_ value: ListFunctionEventInvokeConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput {

    static func urlPathProvider(_ value: ListFunctionsInput) -> Swift.String? {
        return "/2015-03-31/functions"
    }
}

extension ListFunctionsInput {

    static func queryItemProvider(_ value: ListFunctionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let masterRegion = value.masterRegion {
            let masterRegionQueryItem = Smithy.URIQueryItem(name: "MasterRegion".urlPercentEncoding(), value: Swift.String(masterRegion).urlPercentEncoding())
            items.append(masterRegionQueryItem)
        }
        if let functionVersion = value.functionVersion {
            let functionVersionQueryItem = Smithy.URIQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion.rawValue).urlPercentEncoding())
            items.append(functionVersionQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsByCodeSigningConfigInput {

    static func urlPathProvider(_ value: ListFunctionsByCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())/functions"
    }
}

extension ListFunctionsByCodeSigningConfigInput {

    static func queryItemProvider(_ value: ListFunctionsByCodeSigningConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionUrlConfigsInput {

    static func urlPathProvider(_ value: ListFunctionUrlConfigsInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/urls"
    }
}

extension ListFunctionUrlConfigsInput {

    static func queryItemProvider(_ value: ListFunctionUrlConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListLayersInput {

    static func urlPathProvider(_ value: ListLayersInput) -> Swift.String? {
        return "/2018-10-31/layers"
    }
}

extension ListLayersInput {

    static func queryItemProvider(_ value: ListLayersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let compatibleRuntime = value.compatibleRuntime {
            let compatibleRuntimeQueryItem = Smithy.URIQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            items.append(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = value.compatibleArchitecture {
            let compatibleArchitectureQueryItem = Smithy.URIQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            items.append(compatibleArchitectureQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListLayerVersionsInput {

    static func urlPathProvider(_ value: ListLayerVersionsInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

extension ListLayerVersionsInput {

    static func queryItemProvider(_ value: ListLayerVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let compatibleRuntime = value.compatibleRuntime {
            let compatibleRuntimeQueryItem = Smithy.URIQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            items.append(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = value.compatibleArchitecture {
            let compatibleArchitectureQueryItem = Smithy.URIQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            items.append(compatibleArchitectureQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListProvisionedConcurrencyConfigsInput {

    static func urlPathProvider(_ value: ListProvisionedConcurrencyConfigsInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension ListProvisionedConcurrencyConfigsInput {

    static func queryItemProvider(_ value: ListProvisionedConcurrencyConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: "ALL"))
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        guard let resource = value.resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

extension ListVersionsByFunctionInput {

    static func urlPathProvider(_ value: ListVersionsByFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

extension ListVersionsByFunctionInput {

    static func queryItemProvider(_ value: ListVersionsByFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension PublishLayerVersionInput {

    static func urlPathProvider(_ value: PublishLayerVersionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

extension PublishVersionInput {

    static func urlPathProvider(_ value: PublishVersionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

extension PutFunctionCodeSigningConfigInput {

    static func urlPathProvider(_ value: PutFunctionCodeSigningConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

extension PutFunctionConcurrencyInput {

    static func urlPathProvider(_ value: PutFunctionConcurrencyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

extension PutFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: PutFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension PutFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: PutFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension PutFunctionRecursionConfigInput {

    static func urlPathProvider(_ value: PutFunctionRecursionConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2024-08-31/functions/\(functionName.urlPercentEncoding())/recursion-config"
    }
}

extension PutProvisionedConcurrencyConfigInput {

    static func urlPathProvider(_ value: PutProvisionedConcurrencyConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension PutProvisionedConcurrencyConfigInput {

    static func queryItemProvider(_ value: PutProvisionedConcurrencyConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension PutRuntimeManagementConfigInput {

    static func urlPathProvider(_ value: PutRuntimeManagementConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-07-20/functions/\(functionName.urlPercentEncoding())/runtime-management-config"
    }
}

extension PutRuntimeManagementConfigInput {

    static func queryItemProvider(_ value: PutRuntimeManagementConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension RemoveLayerVersionPermissionInput {

    static func urlPathProvider(_ value: RemoveLayerVersionPermissionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy/\(statementId.urlPercentEncoding())"
    }
}

extension RemoveLayerVersionPermissionInput {

    static func queryItemProvider(_ value: RemoveLayerVersionPermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = Smithy.URIQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension RemovePermissionInput {

    static func urlPathProvider(_ value: RemovePermissionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy/\(statementId.urlPercentEncoding())"
    }
}

extension RemovePermissionInput {

    static func queryItemProvider(_ value: RemovePermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = Smithy.URIQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resource = value.resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resource = value.resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAliasInput {

    static func urlPathProvider(_ value: UpdateAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

extension UpdateCodeSigningConfigInput {

    static func urlPathProvider(_ value: UpdateCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

extension UpdateEventSourceMappingInput {

    static func urlPathProvider(_ value: UpdateEventSourceMappingInput) -> Swift.String? {
        guard let uuid = value.uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

extension UpdateFunctionCodeInput {

    static func urlPathProvider(_ value: UpdateFunctionCodeInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/code"
    }
}

extension UpdateFunctionConfigurationInput {

    static func urlPathProvider(_ value: UpdateFunctionConfigurationInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

extension UpdateFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: UpdateFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension UpdateFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: UpdateFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension UpdateFunctionUrlConfigInput {

    static func urlPathProvider(_ value: UpdateFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension UpdateFunctionUrlConfigInput {

    static func queryItemProvider(_ value: UpdateFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension AddLayerVersionPermissionInput {

    static func write(value: AddLayerVersionPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Principal"].write(value.principal)
        try writer["StatementId"].write(value.statementId)
    }
}

extension AddPermissionInput {

    static func write(value: AddPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["EventSourceToken"].write(value.eventSourceToken)
        try writer["FunctionUrlAuthType"].write(value.functionUrlAuthType)
        try writer["Principal"].write(value.principal)
        try writer["PrincipalOrgID"].write(value.principalOrgID)
        try writer["RevisionId"].write(value.revisionId)
        try writer["SourceAccount"].write(value.sourceAccount)
        try writer["SourceArn"].write(value.sourceArn)
        try writer["StatementId"].write(value.statementId)
    }
}

extension CreateAliasInput {

    static func write(value: CreateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FunctionVersion"].write(value.functionVersion)
        try writer["Name"].write(value.name)
        try writer["RoutingConfig"].write(value.routingConfig, with: LambdaClientTypes.AliasRoutingConfiguration.write(value:to:))
    }
}

extension CreateCodeSigningConfigInput {

    static func write(value: CreateCodeSigningConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedPublishers"].write(value.allowedPublishers, with: LambdaClientTypes.AllowedPublishers.write(value:to:))
        try writer["CodeSigningPolicies"].write(value.codeSigningPolicies, with: LambdaClientTypes.CodeSigningPolicies.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEventSourceMappingInput {

    static func write(value: CreateEventSourceMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonManagedKafkaEventSourceConfig"].write(value.amazonManagedKafkaEventSourceConfig, with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.write(value:to:))
        try writer["BatchSize"].write(value.batchSize)
        try writer["BisectBatchOnFunctionError"].write(value.bisectBatchOnFunctionError)
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["DocumentDBEventSourceConfig"].write(value.documentDBEventSourceConfig, with: LambdaClientTypes.DocumentDBEventSourceConfig.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["EventSourceArn"].write(value.eventSourceArn)
        try writer["FilterCriteria"].write(value.filterCriteria, with: LambdaClientTypes.FilterCriteria.write(value:to:))
        try writer["FunctionName"].write(value.functionName)
        try writer["FunctionResponseTypes"].writeList(value.functionResponseTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.FunctionResponseType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["MaximumBatchingWindowInSeconds"].write(value.maximumBatchingWindowInSeconds)
        try writer["MaximumRecordAgeInSeconds"].write(value.maximumRecordAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
        try writer["ParallelizationFactor"].write(value.parallelizationFactor)
        try writer["Queues"].writeList(value.queues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScalingConfig"].write(value.scalingConfig, with: LambdaClientTypes.ScalingConfig.write(value:to:))
        try writer["SelfManagedEventSource"].write(value.selfManagedEventSource, with: LambdaClientTypes.SelfManagedEventSource.write(value:to:))
        try writer["SelfManagedKafkaEventSourceConfig"].write(value.selfManagedKafkaEventSourceConfig, with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.write(value:to:))
        try writer["SourceAccessConfigurations"].writeList(value.sourceAccessConfigurations, memberWritingClosure: LambdaClientTypes.SourceAccessConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartingPosition"].write(value.startingPosition)
        try writer["StartingPositionTimestamp"].writeTimestamp(value.startingPositionTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Topics"].writeList(value.topics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TumblingWindowInSeconds"].write(value.tumblingWindowInSeconds)
    }
}

extension CreateFunctionInput {

    static func write(value: CreateFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architectures"].writeList(value.architectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Code"].write(value.code, with: LambdaClientTypes.FunctionCode.write(value:to:))
        try writer["CodeSigningConfigArn"].write(value.codeSigningConfigArn)
        try writer["DeadLetterConfig"].write(value.deadLetterConfig, with: LambdaClientTypes.DeadLetterConfig.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Environment"].write(value.environment, with: LambdaClientTypes.Environment.write(value:to:))
        try writer["EphemeralStorage"].write(value.ephemeralStorage, with: LambdaClientTypes.EphemeralStorage.write(value:to:))
        try writer["FileSystemConfigs"].writeList(value.fileSystemConfigs, memberWritingClosure: LambdaClientTypes.FileSystemConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FunctionName"].write(value.functionName)
        try writer["Handler"].write(value.handler)
        try writer["ImageConfig"].write(value.imageConfig, with: LambdaClientTypes.ImageConfig.write(value:to:))
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["Layers"].writeList(value.layers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoggingConfig"].write(value.loggingConfig, with: LambdaClientTypes.LoggingConfig.write(value:to:))
        try writer["MemorySize"].write(value.memorySize)
        try writer["PackageType"].write(value.packageType)
        try writer["Publish"].write(value.publish)
        try writer["Role"].write(value.role)
        try writer["Runtime"].write(value.runtime)
        try writer["SnapStart"].write(value.snapStart, with: LambdaClientTypes.SnapStart.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Timeout"].write(value.timeout)
        try writer["TracingConfig"].write(value.tracingConfig, with: LambdaClientTypes.TracingConfig.write(value:to:))
        try writer["VpcConfig"].write(value.vpcConfig, with: LambdaClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateFunctionUrlConfigInput {

    static func write(value: CreateFunctionUrlConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthType"].write(value.authType)
        try writer["Cors"].write(value.cors, with: LambdaClientTypes.Cors.write(value:to:))
        try writer["InvokeMode"].write(value.invokeMode)
    }
}

extension InvokeInput {

    static func write(value: InvokeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Payload"].write(value.payload)
    }
}

extension InvokeAsyncInput {

    static func write(value: InvokeAsyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvokeArgs"].write(value.invokeArgs)
    }
}

extension InvokeWithResponseStreamInput {

    static func write(value: InvokeWithResponseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Payload"].write(value.payload)
    }
}

extension PublishLayerVersionInput {

    static func write(value: PublishLayerVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompatibleArchitectures"].writeList(value.compatibleArchitectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CompatibleRuntimes"].writeList(value.compatibleRuntimes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Runtime>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Content"].write(value.content, with: LambdaClientTypes.LayerVersionContentInput.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["LicenseInfo"].write(value.licenseInfo)
    }
}

extension PublishVersionInput {

    static func write(value: PublishVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeSha256"].write(value.codeSha256)
        try writer["Description"].write(value.description)
        try writer["RevisionId"].write(value.revisionId)
    }
}

extension PutFunctionCodeSigningConfigInput {

    static func write(value: PutFunctionCodeSigningConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeSigningConfigArn"].write(value.codeSigningConfigArn)
    }
}

extension PutFunctionConcurrencyInput {

    static func write(value: PutFunctionConcurrencyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReservedConcurrentExecutions"].write(value.reservedConcurrentExecutions)
    }
}

extension PutFunctionEventInvokeConfigInput {

    static func write(value: PutFunctionEventInvokeConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["MaximumEventAgeInSeconds"].write(value.maximumEventAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
    }
}

extension PutFunctionRecursionConfigInput {

    static func write(value: PutFunctionRecursionConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecursiveLoop"].write(value.recursiveLoop)
    }
}

extension PutProvisionedConcurrencyConfigInput {

    static func write(value: PutProvisionedConcurrencyConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProvisionedConcurrentExecutions"].write(value.provisionedConcurrentExecutions)
    }
}

extension PutRuntimeManagementConfigInput {

    static func write(value: PutRuntimeManagementConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuntimeVersionArn"].write(value.runtimeVersionArn)
        try writer["UpdateRuntimeOn"].write(value.updateRuntimeOn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAliasInput {

    static func write(value: UpdateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FunctionVersion"].write(value.functionVersion)
        try writer["RevisionId"].write(value.revisionId)
        try writer["RoutingConfig"].write(value.routingConfig, with: LambdaClientTypes.AliasRoutingConfiguration.write(value:to:))
    }
}

extension UpdateCodeSigningConfigInput {

    static func write(value: UpdateCodeSigningConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedPublishers"].write(value.allowedPublishers, with: LambdaClientTypes.AllowedPublishers.write(value:to:))
        try writer["CodeSigningPolicies"].write(value.codeSigningPolicies, with: LambdaClientTypes.CodeSigningPolicies.write(value:to:))
        try writer["Description"].write(value.description)
    }
}

extension UpdateEventSourceMappingInput {

    static func write(value: UpdateEventSourceMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchSize"].write(value.batchSize)
        try writer["BisectBatchOnFunctionError"].write(value.bisectBatchOnFunctionError)
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["DocumentDBEventSourceConfig"].write(value.documentDBEventSourceConfig, with: LambdaClientTypes.DocumentDBEventSourceConfig.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["FilterCriteria"].write(value.filterCriteria, with: LambdaClientTypes.FilterCriteria.write(value:to:))
        try writer["FunctionName"].write(value.functionName)
        try writer["FunctionResponseTypes"].writeList(value.functionResponseTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.FunctionResponseType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["MaximumBatchingWindowInSeconds"].write(value.maximumBatchingWindowInSeconds)
        try writer["MaximumRecordAgeInSeconds"].write(value.maximumRecordAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
        try writer["ParallelizationFactor"].write(value.parallelizationFactor)
        try writer["ScalingConfig"].write(value.scalingConfig, with: LambdaClientTypes.ScalingConfig.write(value:to:))
        try writer["SourceAccessConfigurations"].writeList(value.sourceAccessConfigurations, memberWritingClosure: LambdaClientTypes.SourceAccessConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TumblingWindowInSeconds"].write(value.tumblingWindowInSeconds)
    }
}

extension UpdateFunctionCodeInput {

    static func write(value: UpdateFunctionCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architectures"].writeList(value.architectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DryRun"].write(value.dryRun)
        try writer["ImageUri"].write(value.imageUri)
        try writer["Publish"].write(value.publish)
        try writer["RevisionId"].write(value.revisionId)
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["ZipFile"].write(value.zipFile)
    }
}

extension UpdateFunctionConfigurationInput {

    static func write(value: UpdateFunctionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeadLetterConfig"].write(value.deadLetterConfig, with: LambdaClientTypes.DeadLetterConfig.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Environment"].write(value.environment, with: LambdaClientTypes.Environment.write(value:to:))
        try writer["EphemeralStorage"].write(value.ephemeralStorage, with: LambdaClientTypes.EphemeralStorage.write(value:to:))
        try writer["FileSystemConfigs"].writeList(value.fileSystemConfigs, memberWritingClosure: LambdaClientTypes.FileSystemConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Handler"].write(value.handler)
        try writer["ImageConfig"].write(value.imageConfig, with: LambdaClientTypes.ImageConfig.write(value:to:))
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["Layers"].writeList(value.layers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoggingConfig"].write(value.loggingConfig, with: LambdaClientTypes.LoggingConfig.write(value:to:))
        try writer["MemorySize"].write(value.memorySize)
        try writer["RevisionId"].write(value.revisionId)
        try writer["Role"].write(value.role)
        try writer["Runtime"].write(value.runtime)
        try writer["SnapStart"].write(value.snapStart, with: LambdaClientTypes.SnapStart.write(value:to:))
        try writer["Timeout"].write(value.timeout)
        try writer["TracingConfig"].write(value.tracingConfig, with: LambdaClientTypes.TracingConfig.write(value:to:))
        try writer["VpcConfig"].write(value.vpcConfig, with: LambdaClientTypes.VpcConfig.write(value:to:))
    }
}

extension UpdateFunctionEventInvokeConfigInput {

    static func write(value: UpdateFunctionEventInvokeConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["MaximumEventAgeInSeconds"].write(value.maximumEventAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
    }
}

extension UpdateFunctionUrlConfigInput {

    static func write(value: UpdateFunctionUrlConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthType"].write(value.authType)
        try writer["Cors"].write(value.cors, with: LambdaClientTypes.Cors.write(value:to:))
        try writer["InvokeMode"].write(value.invokeMode)
    }
}

extension AddLayerVersionPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddLayerVersionPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddLayerVersionPermissionOutput()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.statement = try reader["Statement"].readIfPresent()
        return value
    }
}

extension AddPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddPermissionOutput()
        value.statement = try reader["Statement"].readIfPresent()
        return value
    }
}

extension CreateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAliasOutput()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        return value
    }
}

extension CreateCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCodeSigningConfigOutput()
        value.codeSigningConfig = try reader["CodeSigningConfig"].readIfPresent(with: LambdaClientTypes.CodeSigningConfig.read(from:))
        return value
    }
}

extension CreateEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension CreateFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension CreateFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionUrlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionUrlConfigOutput()
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        return value
    }
}

extension DeleteAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAliasOutput {
        return DeleteAliasOutput()
    }
}

extension DeleteCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCodeSigningConfigOutput {
        return DeleteCodeSigningConfigOutput()
    }
}

extension DeleteEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension DeleteFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionOutput {
        return DeleteFunctionOutput()
    }
}

extension DeleteFunctionCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionCodeSigningConfigOutput {
        return DeleteFunctionCodeSigningConfigOutput()
    }
}

extension DeleteFunctionConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionConcurrencyOutput {
        return DeleteFunctionConcurrencyOutput()
    }
}

extension DeleteFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionEventInvokeConfigOutput {
        return DeleteFunctionEventInvokeConfigOutput()
    }
}

extension DeleteFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionUrlConfigOutput {
        return DeleteFunctionUrlConfigOutput()
    }
}

extension DeleteLayerVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLayerVersionOutput {
        return DeleteLayerVersionOutput()
    }
}

extension DeleteProvisionedConcurrencyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisionedConcurrencyConfigOutput {
        return DeleteProvisionedConcurrencyConfigOutput()
    }
}

extension GetAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountSettingsOutput()
        value.accountLimit = try reader["AccountLimit"].readIfPresent(with: LambdaClientTypes.AccountLimit.read(from:))
        value.accountUsage = try reader["AccountUsage"].readIfPresent(with: LambdaClientTypes.AccountUsage.read(from:))
        return value
    }
}

extension GetAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAliasOutput()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        return value
    }
}

extension GetCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCodeSigningConfigOutput()
        value.codeSigningConfig = try reader["CodeSigningConfig"].readIfPresent(with: LambdaClientTypes.CodeSigningConfig.read(from:))
        return value
    }
}

extension GetEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension GetFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionOutput()
        value.code = try reader["Code"].readIfPresent(with: LambdaClientTypes.FunctionCodeLocation.read(from:))
        value.concurrency = try reader["Concurrency"].readIfPresent(with: LambdaClientTypes.Concurrency.read(from:))
        value.configuration = try reader["Configuration"].readIfPresent(with: LambdaClientTypes.FunctionConfiguration.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tagsError = try reader["TagsError"].readIfPresent(with: LambdaClientTypes.TagsError.read(from:))
        return value
    }
}

extension GetFunctionCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionCodeSigningConfigOutput()
        value.codeSigningConfigArn = try reader["CodeSigningConfigArn"].readIfPresent() ?? ""
        value.functionName = try reader["FunctionName"].readIfPresent() ?? ""
        return value
    }
}

extension GetFunctionConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionConcurrencyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionConcurrencyOutput()
        value.reservedConcurrentExecutions = try reader["ReservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension GetFunctionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionConfigurationOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension GetFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionEventInvokeConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionEventInvokeConfigOutput()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        return value
    }
}

extension GetFunctionRecursionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionRecursionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionRecursionConfigOutput()
        value.recursiveLoop = try reader["RecursiveLoop"].readIfPresent()
        return value
    }
}

extension GetFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionUrlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionUrlConfigOutput()
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? ""
        return value
    }
}

extension GetLayerVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayerVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayerVersionOutput()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent(with: LambdaClientTypes.LayerVersionContentOutput.read(from:))
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension GetLayerVersionByArnOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayerVersionByArnOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayerVersionByArnOutput()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent(with: LambdaClientTypes.LayerVersionContentOutput.read(from:))
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension GetLayerVersionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayerVersionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayerVersionPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension GetProvisionedConcurrencyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisionedConcurrencyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedConcurrencyConfigOutput()
        value.allocatedProvisionedConcurrentExecutions = try reader["AllocatedProvisionedConcurrentExecutions"].readIfPresent()
        value.availableProvisionedConcurrentExecutions = try reader["AvailableProvisionedConcurrentExecutions"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.requestedProvisionedConcurrentExecutions = try reader["RequestedProvisionedConcurrentExecutions"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension GetRuntimeManagementConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuntimeManagementConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuntimeManagementConfigOutput()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.runtimeVersionArn = try reader["RuntimeVersionArn"].readIfPresent()
        value.updateRuntimeOn = try reader["UpdateRuntimeOn"].readIfPresent()
        return value
    }
}

extension InvokeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeOutput {
        var value = InvokeOutput()
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            value.executedVersion = executedVersionHeaderValue
        }
        if let functionErrorHeaderValue = httpResponse.headers.value(for: "X-Amz-Function-Error") {
            value.functionError = functionErrorHeaderValue
        }
        if let logResultHeaderValue = httpResponse.headers.value(for: "X-Amz-Log-Result") {
            value.logResult = logResultHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension InvokeAsyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeAsyncOutput {
        var value = InvokeAsyncOutput()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension InvokeWithResponseStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeWithResponseStreamOutput {
        var value = InvokeWithResponseStreamOutput()
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            value.executedVersion = executedVersionHeaderValue
        }
        if let responseStreamContentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.responseStreamContentType = responseStreamContentTypeHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: LambdaClientTypes.InvokeWithResponseStreamResponseEvent.unmarshal)
            value.eventStream = decoderStream.toAsyncStream()
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAliasesOutput()
        value.aliases = try reader["Aliases"].readListIfPresent(memberReadingClosure: LambdaClientTypes.AliasConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListCodeSigningConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCodeSigningConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCodeSigningConfigsOutput()
        value.codeSigningConfigs = try reader["CodeSigningConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.CodeSigningConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListEventSourceMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventSourceMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventSourceMappingsOutput()
        value.eventSourceMappings = try reader["EventSourceMappings"].readListIfPresent(memberReadingClosure: LambdaClientTypes.EventSourceMappingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionEventInvokeConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionEventInvokeConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionEventInvokeConfigsOutput()
        value.functionEventInvokeConfigs = try reader["FunctionEventInvokeConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionEventInvokeConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionsOutput()
        value.functions = try reader["Functions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionsByCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionsByCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionsByCodeSigningConfigOutput()
        value.functionArns = try reader["FunctionArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionUrlConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionUrlConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionUrlConfigsOutput()
        value.functionUrlConfigs = try reader["FunctionUrlConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionUrlConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListLayersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLayersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLayersOutput()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.LayersListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListLayerVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLayerVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLayerVersionsOutput()
        value.layerVersions = try reader["LayerVersions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.LayerVersionsListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListProvisionedConcurrencyConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisionedConcurrencyConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedConcurrencyConfigsOutput()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.provisionedConcurrencyConfigs = try reader["ProvisionedConcurrencyConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.ProvisionedConcurrencyConfigListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListVersionsByFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVersionsByFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVersionsByFunctionOutput()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PublishLayerVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishLayerVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PublishLayerVersionOutput()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent(with: LambdaClientTypes.LayerVersionContentOutput.read(from:))
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension PublishVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PublishVersionOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension PutFunctionCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionCodeSigningConfigOutput()
        value.codeSigningConfigArn = try reader["CodeSigningConfigArn"].readIfPresent() ?? ""
        value.functionName = try reader["FunctionName"].readIfPresent() ?? ""
        return value
    }
}

extension PutFunctionConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionConcurrencyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionConcurrencyOutput()
        value.reservedConcurrentExecutions = try reader["ReservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension PutFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionEventInvokeConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionEventInvokeConfigOutput()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        return value
    }
}

extension PutFunctionRecursionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionRecursionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionRecursionConfigOutput()
        value.recursiveLoop = try reader["RecursiveLoop"].readIfPresent()
        return value
    }
}

extension PutProvisionedConcurrencyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProvisionedConcurrencyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProvisionedConcurrencyConfigOutput()
        value.allocatedProvisionedConcurrentExecutions = try reader["AllocatedProvisionedConcurrentExecutions"].readIfPresent()
        value.availableProvisionedConcurrentExecutions = try reader["AvailableProvisionedConcurrentExecutions"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.requestedProvisionedConcurrentExecutions = try reader["RequestedProvisionedConcurrentExecutions"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension PutRuntimeManagementConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRuntimeManagementConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRuntimeManagementConfigOutput()
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.runtimeVersionArn = try reader["RuntimeVersionArn"].readIfPresent()
        value.updateRuntimeOn = try reader["UpdateRuntimeOn"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RemoveLayerVersionPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveLayerVersionPermissionOutput {
        return RemoveLayerVersionPermissionOutput()
    }
}

extension RemovePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemovePermissionOutput {
        return RemovePermissionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAliasOutput()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        return value
    }
}

extension UpdateCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCodeSigningConfigOutput()
        value.codeSigningConfig = try reader["CodeSigningConfig"].readIfPresent(with: LambdaClientTypes.CodeSigningConfig.read(from:))
        return value
    }
}

extension UpdateEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension UpdateFunctionCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionCodeOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension UpdateFunctionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionConfigurationOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension UpdateFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionEventInvokeConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionEventInvokeConfigOutput()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        return value
    }
}

extension UpdateFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionUrlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionUrlConfigOutput()
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? ""
        return value
    }
}

enum AddLayerVersionPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PolicyLengthExceededException": return try PolicyLengthExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PolicyLengthExceededException": return try PolicyLengthExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "CodeVerificationFailedException": return try CodeVerificationFailedException.makeError(baseError: baseError)
            case "InvalidCodeSignatureException": return try InvalidCodeSignatureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLayerVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisionedConcurrencyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionRecursionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayerVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayerVersionByArnOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayerVersionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisionedConcurrencyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ProvisionedConcurrencyConfigNotFoundException": return try ProvisionedConcurrencyConfigNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuntimeManagementConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EC2AccessDeniedException": return try EC2AccessDeniedException.makeError(baseError: baseError)
            case "EC2ThrottledException": return try EC2ThrottledException.makeError(baseError: baseError)
            case "EC2UnexpectedException": return try EC2UnexpectedException.makeError(baseError: baseError)
            case "EFSIOException": return try EFSIOException.makeError(baseError: baseError)
            case "EFSMountConnectivityException": return try EFSMountConnectivityException.makeError(baseError: baseError)
            case "EFSMountFailureException": return try EFSMountFailureException.makeError(baseError: baseError)
            case "EFSMountTimeoutException": return try EFSMountTimeoutException.makeError(baseError: baseError)
            case "ENILimitReachedException": return try ENILimitReachedException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestContentException": return try InvalidRequestContentException.makeError(baseError: baseError)
            case "InvalidRuntimeException": return try InvalidRuntimeException.makeError(baseError: baseError)
            case "InvalidSecurityGroupIDException": return try InvalidSecurityGroupIDException.makeError(baseError: baseError)
            case "InvalidSubnetIDException": return try InvalidSubnetIDException.makeError(baseError: baseError)
            case "InvalidZipFileException": return try InvalidZipFileException.makeError(baseError: baseError)
            case "KMSAccessDeniedException": return try KMSAccessDeniedException.makeError(baseError: baseError)
            case "KMSDisabledException": return try KMSDisabledException.makeError(baseError: baseError)
            case "KMSInvalidStateException": return try KMSInvalidStateException.makeError(baseError: baseError)
            case "KMSNotFoundException": return try KMSNotFoundException.makeError(baseError: baseError)
            case "RecursiveInvocationException": return try RecursiveInvocationException.makeError(baseError: baseError)
            case "RequestTooLargeException": return try RequestTooLargeException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "SnapStartException": return try SnapStartException.makeError(baseError: baseError)
            case "SnapStartNotReadyException": return try SnapStartNotReadyException.makeError(baseError: baseError)
            case "SnapStartTimeoutException": return try SnapStartTimeoutException.makeError(baseError: baseError)
            case "SubnetIPAddressLimitReachedException": return try SubnetIPAddressLimitReachedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedMediaTypeException": return try UnsupportedMediaTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeAsyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestContentException": return try InvalidRequestContentException.makeError(baseError: baseError)
            case "InvalidRuntimeException": return try InvalidRuntimeException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeWithResponseStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EC2AccessDeniedException": return try EC2AccessDeniedException.makeError(baseError: baseError)
            case "EC2ThrottledException": return try EC2ThrottledException.makeError(baseError: baseError)
            case "EC2UnexpectedException": return try EC2UnexpectedException.makeError(baseError: baseError)
            case "EFSIOException": return try EFSIOException.makeError(baseError: baseError)
            case "EFSMountConnectivityException": return try EFSMountConnectivityException.makeError(baseError: baseError)
            case "EFSMountFailureException": return try EFSMountFailureException.makeError(baseError: baseError)
            case "EFSMountTimeoutException": return try EFSMountTimeoutException.makeError(baseError: baseError)
            case "ENILimitReachedException": return try ENILimitReachedException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestContentException": return try InvalidRequestContentException.makeError(baseError: baseError)
            case "InvalidRuntimeException": return try InvalidRuntimeException.makeError(baseError: baseError)
            case "InvalidSecurityGroupIDException": return try InvalidSecurityGroupIDException.makeError(baseError: baseError)
            case "InvalidSubnetIDException": return try InvalidSubnetIDException.makeError(baseError: baseError)
            case "InvalidZipFileException": return try InvalidZipFileException.makeError(baseError: baseError)
            case "KMSAccessDeniedException": return try KMSAccessDeniedException.makeError(baseError: baseError)
            case "KMSDisabledException": return try KMSDisabledException.makeError(baseError: baseError)
            case "KMSInvalidStateException": return try KMSInvalidStateException.makeError(baseError: baseError)
            case "KMSNotFoundException": return try KMSNotFoundException.makeError(baseError: baseError)
            case "RecursiveInvocationException": return try RecursiveInvocationException.makeError(baseError: baseError)
            case "RequestTooLargeException": return try RequestTooLargeException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "SnapStartException": return try SnapStartException.makeError(baseError: baseError)
            case "SnapStartNotReadyException": return try SnapStartNotReadyException.makeError(baseError: baseError)
            case "SnapStartTimeoutException": return try SnapStartTimeoutException.makeError(baseError: baseError)
            case "SubnetIPAddressLimitReachedException": return try SubnetIPAddressLimitReachedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedMediaTypeException": return try UnsupportedMediaTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCodeSigningConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventSourceMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionEventInvokeConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionsByCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionUrlConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLayersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLayerVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisionedConcurrencyConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVersionsByFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishLayerVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionRecursionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProvisionedConcurrencyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRuntimeManagementConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveLayerVersionPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemovePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "CodeVerificationFailedException": return try CodeVerificationFailedException.makeError(baseError: baseError)
            case "InvalidCodeSignatureException": return try InvalidCodeSignatureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "CodeVerificationFailedException": return try CodeVerificationFailedException.makeError(baseError: baseError)
            case "InvalidCodeSignatureException": return try InvalidCodeSignatureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = TooManyRequestsException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyLengthExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PolicyLengthExceededException {
        let reader = baseError.errorBodyReader
        var value = PolicyLengthExceededException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceConflictException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeVerificationFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CodeVerificationFailedException {
        let reader = baseError.errorBodyReader
        var value = CodeVerificationFailedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCodeSignatureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidCodeSignatureException {
        let reader = baseError.errorBodyReader
        var value = InvalidCodeSignatureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeSigningConfigNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CodeSigningConfigNotFoundException {
        let reader = baseError.errorBodyReader
        var value = CodeSigningConfigNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeStorageExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CodeStorageExceededException {
        let reader = baseError.errorBodyReader
        var value = CodeStorageExceededException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ProvisionedConcurrencyConfigNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ProvisionedConcurrencyConfigNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ProvisionedConcurrencyConfigNotFoundException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSNotFoundException {
        let reader = baseError.errorBodyReader
        var value = KMSNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RecursiveInvocationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RecursiveInvocationException {
        let reader = baseError.errorBodyReader
        var value = RecursiveInvocationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapStartException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SnapStartException {
        let reader = baseError.errorBodyReader
        var value = SnapStartException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSubnetIDException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSubnetIDException {
        let reader = baseError.errorBodyReader
        var value = InvalidSubnetIDException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSDisabledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSDisabledException {
        let reader = baseError.errorBodyReader
        var value = KMSDisabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSIOException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSIOException {
        let reader = baseError.errorBodyReader
        var value = EFSIOException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSMountConnectivityException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSMountConnectivityException {
        let reader = baseError.errorBodyReader
        var value = EFSMountConnectivityException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSMountFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSMountFailureException {
        let reader = baseError.errorBodyReader
        var value = EFSMountFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotReadyException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidZipFileException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidZipFileException {
        let reader = baseError.errorBodyReader
        var value = InvalidZipFileException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestContentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestContentException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestContentException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapStartTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SnapStartTimeoutException {
        let reader = baseError.errorBodyReader
        var value = SnapStartTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EC2ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EC2ThrottledException {
        let reader = baseError.errorBodyReader
        var value = EC2ThrottledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetIPAddressLimitReachedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SubnetIPAddressLimitReachedException {
        let reader = baseError.errorBodyReader
        var value = SubnetIPAddressLimitReachedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSecurityGroupIDException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSecurityGroupIDException {
        let reader = baseError.errorBodyReader
        var value = InvalidSecurityGroupIDException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestTooLargeException {
        let reader = baseError.errorBodyReader
        var value = RequestTooLargeException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedMediaTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedMediaTypeException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedMediaTypeException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSMountTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSMountTimeoutException {
        let reader = baseError.errorBodyReader
        var value = EFSMountTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ENILimitReachedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ENILimitReachedException {
        let reader = baseError.errorBodyReader
        var value = ENILimitReachedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapStartNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SnapStartNotReadyException {
        let reader = baseError.errorBodyReader
        var value = SnapStartNotReadyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EC2UnexpectedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EC2UnexpectedException {
        let reader = baseError.errorBodyReader
        var value = EC2UnexpectedException()
        value.properties.ec2ErrorCode = try reader["EC2ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EC2AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EC2AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = EC2AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRuntimeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRuntimeException {
        let reader = baseError.errorBodyReader
        var value = InvalidRuntimeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = KMSAccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSInvalidStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSInvalidStateException {
        let reader = baseError.errorBodyReader
        var value = KMSInvalidStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LambdaClientTypes.InvokeWithResponseStreamResponseEvent {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<LambdaClientTypes.InvokeWithResponseStreamResponseEvent> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "PayloadChunk":
                    var event = LambdaClientTypes.InvokeResponseStreamUpdate()
                    event.payload = message.payload
                    return .payloadchunk(event)
                case "InvokeComplete":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: LambdaClientTypes.InvokeWithResponseStreamCompleteEvent.read(from:))
                    return .invokecomplete(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension LambdaClientTypes.AliasRoutingConfiguration {

    static func write(value: LambdaClientTypes.AliasRoutingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalVersionWeights"].writeMap(value.additionalVersionWeights, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AliasRoutingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AliasRoutingConfiguration()
        value.additionalVersionWeights = try reader["AdditionalVersionWeights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.CodeSigningConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CodeSigningConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CodeSigningConfig()
        value.codeSigningConfigId = try reader["CodeSigningConfigId"].readIfPresent() ?? ""
        value.codeSigningConfigArn = try reader["CodeSigningConfigArn"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.allowedPublishers = try reader["AllowedPublishers"].readIfPresent(with: LambdaClientTypes.AllowedPublishers.read(from:))
        value.codeSigningPolicies = try reader["CodeSigningPolicies"].readIfPresent(with: LambdaClientTypes.CodeSigningPolicies.read(from:))
        value.lastModified = try reader["LastModified"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.CodeSigningPolicies {

    static func write(value: LambdaClientTypes.CodeSigningPolicies?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UntrustedArtifactOnDeployment"].write(value.untrustedArtifactOnDeployment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CodeSigningPolicies {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CodeSigningPolicies()
        value.untrustedArtifactOnDeployment = try reader["UntrustedArtifactOnDeployment"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AllowedPublishers {

    static func write(value: LambdaClientTypes.AllowedPublishers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SigningProfileVersionArns"].writeList(value.signingProfileVersionArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AllowedPublishers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AllowedPublishers()
        value.signingProfileVersionArns = try reader["SigningProfileVersionArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LambdaClientTypes.FilterCriteria {

    static func write(value: LambdaClientTypes.FilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LambdaClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FilterCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FilterCriteria()
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Filter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.Filter {

    static func write(value: LambdaClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Pattern"].write(value.pattern)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Filter()
        value.pattern = try reader["Pattern"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DestinationConfig {

    static func write(value: LambdaClientTypes.DestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OnFailure"].write(value.onFailure, with: LambdaClientTypes.OnFailure.write(value:to:))
        try writer["OnSuccess"].write(value.onSuccess, with: LambdaClientTypes.OnSuccess.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DestinationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DestinationConfig()
        value.onSuccess = try reader["OnSuccess"].readIfPresent(with: LambdaClientTypes.OnSuccess.read(from:))
        value.onFailure = try reader["OnFailure"].readIfPresent(with: LambdaClientTypes.OnFailure.read(from:))
        return value
    }
}

extension LambdaClientTypes.OnFailure {

    static func write(value: LambdaClientTypes.OnFailure?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.OnFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.OnFailure()
        value.destination = try reader["Destination"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.OnSuccess {

    static func write(value: LambdaClientTypes.OnSuccess?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.OnSuccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.OnSuccess()
        value.destination = try reader["Destination"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.SourceAccessConfiguration {

    static func write(value: LambdaClientTypes.SourceAccessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["URI"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SourceAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SourceAccessConfiguration()
        value.type = try reader["Type"].readIfPresent()
        value.uri = try reader["URI"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.SelfManagedEventSource {

    static func write(value: LambdaClientTypes.SelfManagedEventSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Endpoints"].writeMap(value.endpoints, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SelfManagedEventSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SelfManagedEventSource()
        value.endpoints = try reader["Endpoints"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.AmazonManagedKafkaEventSourceConfig {

    static func write(value: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumerGroupId"].write(value.consumerGroupId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AmazonManagedKafkaEventSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AmazonManagedKafkaEventSourceConfig()
        value.consumerGroupId = try reader["ConsumerGroupId"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.SelfManagedKafkaEventSourceConfig {

    static func write(value: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumerGroupId"].write(value.consumerGroupId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SelfManagedKafkaEventSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SelfManagedKafkaEventSourceConfig()
        value.consumerGroupId = try reader["ConsumerGroupId"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.ScalingConfig {

    static func write(value: LambdaClientTypes.ScalingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumConcurrency"].write(value.maximumConcurrency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ScalingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ScalingConfig()
        value.maximumConcurrency = try reader["MaximumConcurrency"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DocumentDBEventSourceConfig {

    static func write(value: LambdaClientTypes.DocumentDBEventSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectionName"].write(value.collectionName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["FullDocument"].write(value.fullDocument)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DocumentDBEventSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DocumentDBEventSourceConfig()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.collectionName = try reader["CollectionName"].readIfPresent()
        value.fullDocument = try reader["FullDocument"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FilterCriteriaError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FilterCriteriaError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FilterCriteriaError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.VpcConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.VpcConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.VpcConfigResponse()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.ipv6AllowedForDualStack = try reader["Ipv6AllowedForDualStack"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DeadLetterConfig {

    static func write(value: LambdaClientTypes.DeadLetterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DeadLetterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DeadLetterConfig()
        value.targetArn = try reader["TargetArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EnvironmentResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EnvironmentResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EnvironmentResponse()
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EnvironmentError.read(from:))
        return value
    }
}

extension LambdaClientTypes.EnvironmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EnvironmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EnvironmentError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.TracingConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TracingConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TracingConfigResponse()
        value.mode = try reader["Mode"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.Layer {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Layer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Layer()
        value.arn = try reader["Arn"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FileSystemConfig {

    static func write(value: LambdaClientTypes.FileSystemConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["LocalMountPath"].write(value.localMountPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FileSystemConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FileSystemConfig()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.localMountPath = try reader["LocalMountPath"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.ImageConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ImageConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ImageConfigResponse()
        value.imageConfig = try reader["ImageConfig"].readIfPresent(with: LambdaClientTypes.ImageConfig.read(from:))
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ImageConfigError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ImageConfigError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ImageConfigError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ImageConfigError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.ImageConfig {

    static func write(value: LambdaClientTypes.ImageConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Command"].writeList(value.command, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EntryPoint"].writeList(value.entryPoint, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkingDirectory"].write(value.workingDirectory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ImageConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ImageConfig()
        value.entryPoint = try reader["EntryPoint"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.command = try reader["Command"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.workingDirectory = try reader["WorkingDirectory"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EphemeralStorage {

    static func write(value: LambdaClientTypes.EphemeralStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Size"].write(value.size)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EphemeralStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EphemeralStorage()
        value.size = try reader["Size"].readIfPresent() ?? 0
        return value
    }
}

extension LambdaClientTypes.SnapStartResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SnapStartResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SnapStartResponse()
        value.applyOn = try reader["ApplyOn"].readIfPresent()
        value.optimizationStatus = try reader["OptimizationStatus"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.RuntimeVersionConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.RuntimeVersionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.RuntimeVersionConfig()
        value.runtimeVersionArn = try reader["RuntimeVersionArn"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.RuntimeVersionError.read(from:))
        return value
    }
}

extension LambdaClientTypes.RuntimeVersionError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.RuntimeVersionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.RuntimeVersionError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.LoggingConfig {

    static func write(value: LambdaClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationLogLevel"].write(value.applicationLogLevel)
        try writer["LogFormat"].write(value.logFormat)
        try writer["LogGroup"].write(value.logGroup)
        try writer["SystemLogLevel"].write(value.systemLogLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LoggingConfig()
        value.logFormat = try reader["LogFormat"].readIfPresent()
        value.applicationLogLevel = try reader["ApplicationLogLevel"].readIfPresent()
        value.systemLogLevel = try reader["SystemLogLevel"].readIfPresent()
        value.logGroup = try reader["LogGroup"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.Cors {

    static func write(value: LambdaClientTypes.Cors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCredentials"].write(value.allowCredentials)
        try writer["AllowHeaders"].writeList(value.allowHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowMethods"].writeList(value.allowMethods, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowOrigins"].writeList(value.allowOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExposeHeaders"].writeList(value.exposeHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxAge"].write(value.maxAge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Cors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Cors()
        value.allowCredentials = try reader["AllowCredentials"].readIfPresent()
        value.allowHeaders = try reader["AllowHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowMethods = try reader["AllowMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowOrigins = try reader["AllowOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exposeHeaders = try reader["ExposeHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxAge = try reader["MaxAge"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AccountLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AccountLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AccountLimit()
        value.totalCodeSize = try reader["TotalCodeSize"].readIfPresent() ?? 0
        value.codeSizeUnzipped = try reader["CodeSizeUnzipped"].readIfPresent() ?? 0
        value.codeSizeZipped = try reader["CodeSizeZipped"].readIfPresent() ?? 0
        value.concurrentExecutions = try reader["ConcurrentExecutions"].readIfPresent() ?? 0
        value.unreservedConcurrentExecutions = try reader["UnreservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AccountUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AccountUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AccountUsage()
        value.totalCodeSize = try reader["TotalCodeSize"].readIfPresent() ?? 0
        value.functionCount = try reader["FunctionCount"].readIfPresent() ?? 0
        return value
    }
}

extension LambdaClientTypes.FunctionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionConfiguration()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.packageType = try reader["PackageType"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.FunctionCodeLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionCodeLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionCodeLocation()
        value.repositoryType = try reader["RepositoryType"].readIfPresent()
        value.location = try reader["Location"].readIfPresent()
        value.imageUri = try reader["ImageUri"].readIfPresent()
        value.resolvedImageUri = try reader["ResolvedImageUri"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.TagsError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TagsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TagsError()
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.Concurrency {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Concurrency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Concurrency()
        value.reservedConcurrentExecutions = try reader["ReservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.LayerVersionContentOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LayerVersionContentOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LayerVersionContentOutput()
        value.location = try reader["Location"].readIfPresent()
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.InvokeWithResponseStreamCompleteEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.InvokeWithResponseStreamCompleteEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.InvokeWithResponseStreamCompleteEvent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readIfPresent()
        value.logResult = try reader["LogResult"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.InvokeResponseStreamUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.InvokeResponseStreamUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.InvokeResponseStreamUpdate()
        value.payload = try reader["Payload"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AliasConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AliasConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AliasConfiguration()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EventSourceMappingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EventSourceMappingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EventSourceMappingConfiguration()
        value.uuid = try reader["UUID"].readIfPresent()
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FunctionEventInvokeConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionEventInvokeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionEventInvokeConfig()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.FunctionUrlConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionUrlConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionUrlConfig()
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? ""
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.LayersListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LayersListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LayersListItem()
        value.layerName = try reader["LayerName"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.latestMatchingVersion = try reader["LatestMatchingVersion"].readIfPresent(with: LambdaClientTypes.LayerVersionsListItem.read(from:))
        return value
    }
}

extension LambdaClientTypes.LayerVersionsListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LayerVersionsListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LayerVersionsListItem()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.ProvisionedConcurrencyConfigListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ProvisionedConcurrencyConfigListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ProvisionedConcurrencyConfigListItem()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.requestedProvisionedConcurrentExecutions = try reader["RequestedProvisionedConcurrentExecutions"].readIfPresent()
        value.availableProvisionedConcurrentExecutions = try reader["AvailableProvisionedConcurrentExecutions"].readIfPresent()
        value.allocatedProvisionedConcurrentExecutions = try reader["AllocatedProvisionedConcurrentExecutions"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FunctionCode {

    static func write(value: LambdaClientTypes.FunctionCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageUri"].write(value.imageUri)
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["ZipFile"].write(value.zipFile)
    }
}

extension LambdaClientTypes.VpcConfig {

    static func write(value: LambdaClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6AllowedForDualStack"].write(value.ipv6AllowedForDualStack)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LambdaClientTypes.Environment {

    static func write(value: LambdaClientTypes.Environment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension LambdaClientTypes.TracingConfig {

    static func write(value: LambdaClientTypes.TracingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mode"].write(value.mode)
    }
}

extension LambdaClientTypes.SnapStart {

    static func write(value: LambdaClientTypes.SnapStart?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplyOn"].write(value.applyOn)
    }
}

extension LambdaClientTypes.LayerVersionContentInput {

    static func write(value: LambdaClientTypes.LayerVersionContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["ZipFile"].write(value.zipFile)
    }
}

public enum LambdaClientTypes {}
