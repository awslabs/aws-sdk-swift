//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter
import typealias SmithyEventStreamsAPI.UnmarshalClosure


public struct DeleteAliasOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionCodeSigningConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionConcurrencyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionEventInvokeConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionUrlConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLayerVersionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProvisionedConcurrencyConfigOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveLayerVersionPermissionOutput: Swift.Sendable {

    public init() { }
}

public struct RemovePermissionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension LambdaClientTypes {

    /// Limits that are related to concurrency and storage. All file and storage sizes are in bytes.
    public struct AccountLimit: Swift.Sendable {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public var codeSizeUnzipped: Swift.Int
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.
        public var codeSizeZipped: Swift.Int
        /// The maximum number of simultaneous function executions.
        public var concurrentExecutions: Swift.Int
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public var totalCodeSize: Swift.Int
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with [PutFunctionConcurrency].
        public var unreservedConcurrentExecutions: Swift.Int?

        public init(
            codeSizeUnzipped: Swift.Int = 0,
            codeSizeZipped: Swift.Int = 0,
            concurrentExecutions: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0,
            unreservedConcurrentExecutions: Swift.Int? = nil
        ) {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }
    }
}

extension LambdaClientTypes {

    /// The number of functions and amount of storage in use.
    public struct AccountUsage: Swift.Sendable {
        /// The number of Lambda functions.
        public var functionCount: Swift.Int
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public var totalCodeSize: Swift.Int

        public init(
            functionCount: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0
        ) {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }
    }
}

/// One of the parameters in the request is not valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The permissions policy for the resource is too large. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct PolicyLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyLengthExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias.
///
/// * For AddPermission and RemovePermission API operations: Call GetPolicy to retrieve the latest RevisionId for your resource.
///
/// * For all other API operations: Call GetFunction or GetAlias to retrieve the latest RevisionId for your resource.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The resource already exists, or another operation is in progress.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda service encountered an internal error.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    public enum ThrottleReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case callerratelimitexceeded
        case concurrentinvocationlimitexceeded
        case concurrentsnapshotcreatelimitexceeded
        case functioninvocationratelimitexceeded
        case reservedfunctionconcurrentinvocationlimitexceeded
        case reservedfunctioninvocationratelimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .callerratelimitexceeded,
                .concurrentinvocationlimitexceeded,
                .concurrentsnapshotcreatelimitexceeded,
                .functioninvocationratelimitexceeded,
                .reservedfunctionconcurrentinvocationlimitexceeded,
                .reservedfunctioninvocationratelimitexceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .callerratelimitexceeded: return "CallerRateLimitExceeded"
            case .concurrentinvocationlimitexceeded: return "ConcurrentInvocationLimitExceeded"
            case .concurrentsnapshotcreatelimitexceeded: return "ConcurrentSnapshotCreateLimitExceeded"
            case .functioninvocationratelimitexceeded: return "FunctionInvocationRateLimitExceeded"
            case .reservedfunctionconcurrentinvocationlimitexceeded: return "ReservedFunctionConcurrentInvocationLimitExceeded"
            case .reservedfunctioninvocationratelimitexceeded: return "ReservedFunctionInvocationRateLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request throughput limit was exceeded. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html#api-requests).
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: LambdaClientTypes.ThrottleReason? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: LambdaClientTypes.ThrottleReason? = nil,
        retryAfterSeconds: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.type = type
    }
}

public struct AddLayerVersionPermissionInput: Swift.Sendable {
    /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
    /// This member is required.
    public var action: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// With the principal set to *, grant permission to all accounts in the specified organization.
    public var organizationId: Swift.String?
    /// An account ID, or * to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
    /// This member is required.
    public var principal: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An identifier that distinguishes the policy from others on the same layer version.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        action: Swift.String? = nil,
        layerName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        principal: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    ) {
        self.action = action
        self.layerName = layerName
        self.organizationId = organizationId
        self.principal = principal
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

public struct AddLayerVersionPermissionOutput: Swift.Sendable {
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?
    /// The permission statement.
    public var statement: Swift.String?

    public init(
        revisionId: Swift.String? = nil,
        statement: Swift.String? = nil
    ) {
        self.revisionId = revisionId
        self.statement = statement
    }
}

extension LambdaClientTypes {

    public enum FunctionUrlAuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionUrlAuthType] {
            return [
                .awsIam,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AddPermissionInput: Swift.Sendable {
    /// The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
    /// This member is required.
    public var action: Swift.String?
    /// For Alexa Smart Home functions, a token that the invoker must supply.
    public var eventSourceToken: Swift.String?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Control access to Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    public var functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType?
    /// Indicates whether the permission applies when the function is invoked through a function URL.
    public var invokedViaFunctionUrl: Swift.Bool?
    /// The Amazon Web Services service, Amazon Web Services account, IAM user, or IAM role that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
    /// This member is required.
    public var principal: Swift.String?
    /// The identifier for your organization in Organizations. Use this to grant permissions to all the Amazon Web Services accounts under this organization.
    public var principalOrgID: Swift.String?
    /// Specify a version or alias to add permissions to a published version of the function.
    public var qualifier: Swift.String?
    /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// For Amazon Web Services service, the ID of the Amazon Web Services account that owns the resource. Use this together with SourceArn to ensure that the specified account owns the resource. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
    public var sourceAccount: Swift.String?
    /// For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic. Note that Lambda configures the comparison using the StringLike operator.
    public var sourceArn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: Swift.String? = nil,
        eventSourceToken: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        invokedViaFunctionUrl: Swift.Bool? = nil,
        principal: Swift.String? = nil,
        principalOrgID: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceAccount: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    ) {
        self.action = action
        self.eventSourceToken = eventSourceToken
        self.functionName = functionName
        self.functionUrlAuthType = functionUrlAuthType
        self.invokedViaFunctionUrl = invokedViaFunctionUrl
        self.principal = principal
        self.principalOrgID = principalOrgID
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.sourceAccount = sourceAccount
        self.sourceArn = sourceArn
        self.statementId = statementId
    }
}

public struct AddPermissionOutput: Swift.Sendable {
    /// The permission statement that's added to the function policy.
    public var statement: Swift.String?

    public init(
        statement: Swift.String? = nil
    ) {
        self.statement = statement
    }
}

extension LambdaClientTypes {

    /// The [traffic-shifting](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) configuration of a Lambda function alias.
    public struct AliasRoutingConfiguration: Swift.Sendable {
        /// The second version, and the percentage of traffic that's routed to it.
        public var additionalVersionWeights: [Swift.String: Swift.Double]?

        public init(
            additionalVersionWeights: [Swift.String: Swift.Double]? = nil
        ) {
            self.additionalVersionWeights = additionalVersionWeights
        }
    }
}

extension LambdaClientTypes {

    /// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
    public struct AliasConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the alias.
        public var aliasArn: Swift.String?
        /// A description of the alias.
        public var description: Swift.String?
        /// The function version that the alias invokes.
        public var functionVersion: Swift.String?
        /// The name of the alias.
        public var name: Swift.String?
        /// A unique identifier that changes when you update the alias.
        public var revisionId: Swift.String?
        /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
        public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

        public init(
            aliasArn: Swift.String? = nil,
            description: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
        ) {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }
    }
}

extension LambdaClientTypes {

    /// List of signing profiles that can sign a code package.
    public struct AllowedPublishers: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        /// This member is required.
        public var signingProfileVersionArns: [Swift.String]?

        public init(
            signingProfileVersionArns: [Swift.String]? = nil
        ) {
            self.signingProfileVersionArns = signingProfileVersionArns
        }
    }
}

extension LambdaClientTypes {

    public enum KafkaSchemaRegistryAuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basicAuth
        case clientCertificateTlsAuth
        case serverRootCaCertificate
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSchemaRegistryAuthType] {
            return [
                .basicAuth,
                .clientCertificateTlsAuth,
                .serverRootCaCertificate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .clientCertificateTlsAuth: return "CLIENT_CERTIFICATE_TLS_AUTH"
            case .serverRootCaCertificate: return "SERVER_ROOT_CA_CERTIFICATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Specific access configuration settings that tell Lambda how to authenticate with your schema registry. If you're working with an Glue schema registry, don't provide authentication details in this object. Instead, ensure that your execution role has the required permissions for Lambda to access your cluster. If you're working with a Confluent schema registry, choose the authentication method in the Type field, and provide the Secrets Manager secret ARN in the URI field.
    public struct KafkaSchemaRegistryAccessConfig: Swift.Sendable {
        /// The type of authentication Lambda uses to access your schema registry.
        public var type: LambdaClientTypes.KafkaSchemaRegistryAuthType?
        /// The URI of the secret (Secrets Manager secret ARN) to authenticate with your schema registry.
        public var uri: Swift.String?

        public init(
            type: LambdaClientTypes.KafkaSchemaRegistryAuthType? = nil,
            uri: Swift.String? = nil
        ) {
            self.type = type
            self.uri = uri
        }
    }
}

extension LambdaClientTypes {

    public enum SchemaRegistryEventRecordFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaRegistryEventRecordFormat] {
            return [
                .json,
                .source
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum KafkaSchemaValidationAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case key
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSchemaValidationAttribute] {
            return [
                .key,
                .value
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .key: return "KEY"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Specific schema validation configuration settings that tell Lambda the message attributes you want to validate and filter using your schema registry.
    public struct KafkaSchemaValidationConfig: Swift.Sendable {
        /// The attributes you want your schema registry to validate and filter for. If you selected JSON as the EventRecordFormat, Lambda also deserializes the selected message attributes.
        public var attribute: LambdaClientTypes.KafkaSchemaValidationAttribute?

        public init(
            attribute: LambdaClientTypes.KafkaSchemaValidationAttribute? = nil
        ) {
            self.attribute = attribute
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for a Kafka schema registry.
    public struct KafkaSchemaRegistryConfig: Swift.Sendable {
        /// An array of access configuration objects that tell Lambda how to authenticate with your schema registry.
        public var accessConfigs: [LambdaClientTypes.KafkaSchemaRegistryAccessConfig]?
        /// The record format that Lambda delivers to your function after schema validation.
        ///
        /// * Choose JSON to have Lambda deliver the record to your function as a standard JSON object.
        ///
        /// * Choose SOURCE to have Lambda deliver the record to your function in its original source format. Lambda removes all schema metadata, such as the schema ID, before sending the record to your function.
        public var eventRecordFormat: LambdaClientTypes.SchemaRegistryEventRecordFormat?
        /// The URI for your schema registry. The correct URI format depends on the type of schema registry you're using.
        ///
        /// * For Glue schema registries, use the ARN of the registry.
        ///
        /// * For Confluent schema registries, use the URL of the registry.
        public var schemaRegistryURI: Swift.String?
        /// An array of schema validation configuration objects, which tell Lambda the message attributes you want to validate and filter using your schema registry.
        public var schemaValidationConfigs: [LambdaClientTypes.KafkaSchemaValidationConfig]?

        public init(
            accessConfigs: [LambdaClientTypes.KafkaSchemaRegistryAccessConfig]? = nil,
            eventRecordFormat: LambdaClientTypes.SchemaRegistryEventRecordFormat? = nil,
            schemaRegistryURI: Swift.String? = nil,
            schemaValidationConfigs: [LambdaClientTypes.KafkaSchemaValidationConfig]? = nil
        ) {
            self.accessConfigs = accessConfigs
            self.eventRecordFormat = eventRecordFormat
            self.schemaRegistryURI = schemaRegistryURI
            self.schemaValidationConfigs = schemaValidationConfigs
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public struct AmazonManagedKafkaEventSourceConfig: Swift.Sendable {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        public var consumerGroupId: Swift.String?
        /// Specific configuration settings for a Kafka schema registry.
        public var schemaRegistryConfig: LambdaClientTypes.KafkaSchemaRegistryConfig?

        public init(
            consumerGroupId: Swift.String? = nil,
            schemaRegistryConfig: LambdaClientTypes.KafkaSchemaRegistryConfig? = nil
        ) {
            self.consumerGroupId = consumerGroupId
            self.schemaRegistryConfig = schemaRegistryConfig
        }
    }
}

extension LambdaClientTypes {

    public enum ApplicationLogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case trace
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLogLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .trace,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .trace: return "TRACE"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum Architecture: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The maximum number of capacity providers for your account has been exceeded. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html)
public struct CapacityProviderLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CapacityProviderLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    public enum CapacityProviderScalingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityProviderScalingMode] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .manual: return "Manual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum CapacityProviderPredefinedMetricType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lambdacapacityprovideraveragecpuutilization
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityProviderPredefinedMetricType] {
            return [
                .lambdacapacityprovideraveragecpuutilization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lambdacapacityprovideraveragecpuutilization: return "LambdaCapacityProviderAverageCPUUtilization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// A scaling policy for the capacity provider that automatically adjusts capacity to maintain a target value for a specific metric.
    public struct TargetTrackingScalingPolicy: Swift.Sendable {
        /// The predefined metric type to track for scaling decisions.
        /// This member is required.
        public var predefinedMetricType: LambdaClientTypes.CapacityProviderPredefinedMetricType?
        /// The target value for the metric that the scaling policy attempts to maintain through scaling actions.
        /// This member is required.
        public var targetValue: Swift.Double?

        public init(
            predefinedMetricType: LambdaClientTypes.CapacityProviderPredefinedMetricType? = nil,
            targetValue: Swift.Double? = nil
        ) {
            self.predefinedMetricType = predefinedMetricType
            self.targetValue = targetValue
        }
    }
}

extension LambdaClientTypes {

    /// Configuration that defines how the capacity provider scales compute instances based on demand and policies.
    public struct CapacityProviderScalingConfig: Swift.Sendable {
        /// The maximum number of vCPUs that the capacity provider can provision across all compute instances.
        public var maxVCpuCount: Swift.Int?
        /// The scaling mode that determines how the capacity provider responds to changes in demand.
        public var scalingMode: LambdaClientTypes.CapacityProviderScalingMode?
        /// A list of scaling policies that define how the capacity provider scales compute instances based on metrics and thresholds.
        public var scalingPolicies: [LambdaClientTypes.TargetTrackingScalingPolicy]?

        public init(
            maxVCpuCount: Swift.Int? = nil,
            scalingMode: LambdaClientTypes.CapacityProviderScalingMode? = nil,
            scalingPolicies: [LambdaClientTypes.TargetTrackingScalingPolicy]? = nil
        ) {
            self.maxVCpuCount = maxVCpuCount
            self.scalingMode = scalingMode
            self.scalingPolicies = scalingPolicies
        }
    }
}

extension LambdaClientTypes {

    /// Specifications that define the characteristics and constraints for compute instances used by the capacity provider.
    public struct InstanceRequirements: Swift.Sendable {
        /// A list of EC2 instance types that the capacity provider is allowed to use. If not specified, all compatible instance types are allowed.
        public var allowedInstanceTypes: [Swift.String]?
        /// A list of supported CPU architectures for compute instances. Valid values include x86_64 and arm64.
        public var architectures: [LambdaClientTypes.Architecture]?
        /// A list of EC2 instance types that the capacity provider should not use, even if they meet other requirements.
        public var excludedInstanceTypes: [Swift.String]?

        public init(
            allowedInstanceTypes: [Swift.String]? = nil,
            architectures: [LambdaClientTypes.Architecture]? = nil,
            excludedInstanceTypes: [Swift.String]? = nil
        ) {
            self.allowedInstanceTypes = allowedInstanceTypes
            self.architectures = architectures
            self.excludedInstanceTypes = excludedInstanceTypes
        }
    }
}

extension LambdaClientTypes {

    /// Configuration that specifies the permissions required for the capacity provider to manage compute resources.
    public struct CapacityProviderPermissionsConfig: Swift.Sendable {
        /// The ARN of the IAM role that the capacity provider uses to manage compute instances and other Amazon Web Services resources.
        /// This member is required.
        public var capacityProviderOperatorRoleArn: Swift.String?

        public init(
            capacityProviderOperatorRoleArn: Swift.String? = nil
        ) {
            self.capacityProviderOperatorRoleArn = capacityProviderOperatorRoleArn
        }
    }
}

extension LambdaClientTypes {

    /// VPC configuration that specifies the network settings for compute instances managed by the capacity provider.
    public struct CapacityProviderVpcConfig: Swift.Sendable {
        /// A list of security group IDs that control network access for compute instances managed by the capacity provider.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs where the capacity provider launches compute instances.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        ) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

public struct CreateCapacityProviderInput: Swift.Sendable {
    /// The name of the capacity provider.
    /// This member is required.
    public var capacityProviderName: Swift.String?
    /// The scaling configuration that defines how the capacity provider scales compute instances, including maximum vCPU count and scaling policies.
    public var capacityProviderScalingConfig: LambdaClientTypes.CapacityProviderScalingConfig?
    /// The instance requirements that specify the compute instance characteristics, including architectures and allowed or excluded instance types.
    public var instanceRequirements: LambdaClientTypes.InstanceRequirements?
    /// The ARN of the KMS key used to encrypt data associated with the capacity provider.
    public var kmsKeyArn: Swift.String?
    /// The permissions configuration that specifies the IAM role ARN used by the capacity provider to manage compute resources.
    /// This member is required.
    public var permissionsConfig: LambdaClientTypes.CapacityProviderPermissionsConfig?
    /// A list of tags to associate with the capacity provider.
    public var tags: [Swift.String: Swift.String]?
    /// The VPC configuration for the capacity provider, including subnet IDs and security group IDs where compute instances will be launched.
    /// This member is required.
    public var vpcConfig: LambdaClientTypes.CapacityProviderVpcConfig?

    public init(
        capacityProviderName: Swift.String? = nil,
        capacityProviderScalingConfig: LambdaClientTypes.CapacityProviderScalingConfig? = nil,
        instanceRequirements: LambdaClientTypes.InstanceRequirements? = nil,
        kmsKeyArn: Swift.String? = nil,
        permissionsConfig: LambdaClientTypes.CapacityProviderPermissionsConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcConfig: LambdaClientTypes.CapacityProviderVpcConfig? = nil
    ) {
        self.capacityProviderName = capacityProviderName
        self.capacityProviderScalingConfig = capacityProviderScalingConfig
        self.instanceRequirements = instanceRequirements
        self.kmsKeyArn = kmsKeyArn
        self.permissionsConfig = permissionsConfig
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

extension LambdaClientTypes {

    public enum CapacityProviderState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityProviderState] {
            return [
                .active,
                .deleting,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// A capacity provider manages compute resources for Lambda functions.
    public struct CapacityProvider: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the capacity provider.
        /// This member is required.
        public var capacityProviderArn: Swift.String?
        /// The scaling configuration for the capacity provider.
        public var capacityProviderScalingConfig: LambdaClientTypes.CapacityProviderScalingConfig?
        /// The instance requirements for compute resources managed by the capacity provider.
        public var instanceRequirements: LambdaClientTypes.InstanceRequirements?
        /// The ARN of the KMS key used to encrypt the capacity provider's resources.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the capacity provider was last modified.
        public var lastModified: Swift.String?
        /// The permissions configuration for the capacity provider.
        /// This member is required.
        public var permissionsConfig: LambdaClientTypes.CapacityProviderPermissionsConfig?
        /// The current state of the capacity provider.
        /// This member is required.
        public var state: LambdaClientTypes.CapacityProviderState?
        /// The VPC configuration for the capacity provider.
        /// This member is required.
        public var vpcConfig: LambdaClientTypes.CapacityProviderVpcConfig?

        public init(
            capacityProviderArn: Swift.String? = nil,
            capacityProviderScalingConfig: LambdaClientTypes.CapacityProviderScalingConfig? = nil,
            instanceRequirements: LambdaClientTypes.InstanceRequirements? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            permissionsConfig: LambdaClientTypes.CapacityProviderPermissionsConfig? = nil,
            state: LambdaClientTypes.CapacityProviderState? = nil,
            vpcConfig: LambdaClientTypes.CapacityProviderVpcConfig? = nil
        ) {
            self.capacityProviderArn = capacityProviderArn
            self.capacityProviderScalingConfig = capacityProviderScalingConfig
            self.instanceRequirements = instanceRequirements
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.permissionsConfig = permissionsConfig
            self.state = state
            self.vpcConfig = vpcConfig
        }
    }
}

public struct CreateCapacityProviderOutput: Swift.Sendable {
    /// Information about the capacity provider that was created.
    /// This member is required.
    public var capacityProvider: LambdaClientTypes.CapacityProvider?

    public init(
        capacityProvider: LambdaClientTypes.CapacityProvider? = nil
    ) {
        self.capacityProvider = capacityProvider
    }
}

public struct DeleteCapacityProviderInput: Swift.Sendable {
    /// The name of the capacity provider to delete.
    /// This member is required.
    public var capacityProviderName: Swift.String?

    public init(
        capacityProviderName: Swift.String? = nil
    ) {
        self.capacityProviderName = capacityProviderName
    }
}

public struct DeleteCapacityProviderOutput: Swift.Sendable {
    /// Information about the deleted capacity provider.
    /// This member is required.
    public var capacityProvider: LambdaClientTypes.CapacityProvider?

    public init(
        capacityProvider: LambdaClientTypes.CapacityProvider? = nil
    ) {
        self.capacityProvider = capacityProvider
    }
}

public struct GetCapacityProviderInput: Swift.Sendable {
    /// The name of the capacity provider to retrieve.
    /// This member is required.
    public var capacityProviderName: Swift.String?

    public init(
        capacityProviderName: Swift.String? = nil
    ) {
        self.capacityProviderName = capacityProviderName
    }
}

public struct GetCapacityProviderOutput: Swift.Sendable {
    /// Information about the capacity provider, including its configuration and current state.
    /// This member is required.
    public var capacityProvider: LambdaClientTypes.CapacityProvider?

    public init(
        capacityProvider: LambdaClientTypes.CapacityProvider? = nil
    ) {
        self.capacityProvider = capacityProvider
    }
}

public struct ListCapacityProvidersInput: Swift.Sendable {
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of capacity providers to return.
    public var maxItems: Swift.Int?
    /// Filter capacity providers by their current state.
    public var state: LambdaClientTypes.CapacityProviderState?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        state: LambdaClientTypes.CapacityProviderState? = nil
    ) {
        self.marker = marker
        self.maxItems = maxItems
        self.state = state
    }
}

public struct ListCapacityProvidersOutput: Swift.Sendable {
    /// A list of capacity providers in your account.
    /// This member is required.
    public var capacityProviders: [LambdaClientTypes.CapacityProvider]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        capacityProviders: [LambdaClientTypes.CapacityProvider]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.capacityProviders = capacityProviders
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionVersionsByCapacityProviderInput: Swift.Sendable {
    /// The name of the capacity provider to list function versions for.
    /// This member is required.
    public var capacityProviderName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of function versions to return in the response.
    public var maxItems: Swift.Int?

    public init(
        capacityProviderName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.capacityProviderName = capacityProviderName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case activenoninvocable
        case deactivated
        case deactivating
        case deleting
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .activenoninvocable,
                .deactivated,
                .deactivating,
                .deleting,
                .failed,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .activenoninvocable: return "ActiveNonInvocable"
            case .deactivated: return "Deactivated"
            case .deactivating: return "Deactivating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .inactive: return "Inactive"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Information about a function version that uses a specific capacity provider, including its ARN and current state.
    public struct FunctionVersionsByCapacityProviderListItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the function version.
        /// This member is required.
        public var functionArn: Swift.String?
        /// The current state of the function version.
        /// This member is required.
        public var state: LambdaClientTypes.State?

        public init(
            functionArn: Swift.String? = nil,
            state: LambdaClientTypes.State? = nil
        ) {
            self.functionArn = functionArn
            self.state = state
        }
    }
}

public struct ListFunctionVersionsByCapacityProviderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the capacity provider.
    /// This member is required.
    public var capacityProviderArn: Swift.String?
    /// A list of function versions that use the specified capacity provider.
    /// This member is required.
    public var functionVersions: [LambdaClientTypes.FunctionVersionsByCapacityProviderListItem]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        capacityProviderArn: Swift.String? = nil,
        functionVersions: [LambdaClientTypes.FunctionVersionsByCapacityProviderListItem]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.capacityProviderArn = capacityProviderArn
        self.functionVersions = functionVersions
        self.nextMarker = nextMarker
    }
}

public struct UpdateCapacityProviderInput: Swift.Sendable {
    /// The name of the capacity provider to update.
    /// This member is required.
    public var capacityProviderName: Swift.String?
    /// The updated scaling configuration for the capacity provider.
    public var capacityProviderScalingConfig: LambdaClientTypes.CapacityProviderScalingConfig?

    public init(
        capacityProviderName: Swift.String? = nil,
        capacityProviderScalingConfig: LambdaClientTypes.CapacityProviderScalingConfig? = nil
    ) {
        self.capacityProviderName = capacityProviderName
        self.capacityProviderScalingConfig = capacityProviderScalingConfig
    }
}

public struct UpdateCapacityProviderOutput: Swift.Sendable {
    /// Information about the updated capacity provider.
    /// This member is required.
    public var capacityProvider: LambdaClientTypes.CapacityProvider?

    public init(
        capacityProvider: LambdaClientTypes.CapacityProvider? = nil
    ) {
        self.capacityProvider = capacityProvider
    }
}

extension LambdaClientTypes {

    public enum OperationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case fail
        case retry
        case start
        case succeed
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationAction] {
            return [
                .cancel,
                .fail,
                .retry,
                .start,
                .succeed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case .fail: return "FAIL"
            case .retry: return "RETRY"
            case .start: return "START"
            case .succeed: return "SUCCEED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Configuration options for callback operations in durable executions, including timeout settings and retry behavior.
    public struct CallbackOptions: Swift.Sendable {
        /// The heartbeat timeout for the callback operation, in seconds. If not specified or set to 0, heartbeat timeout is disabled.
        public var heartbeatTimeoutSeconds: Swift.Int
        /// The timeout for the callback operation in seconds. If not specified or set to 0, the callback has no timeout.
        public var timeoutSeconds: Swift.Int

        public init(
            heartbeatTimeoutSeconds: Swift.Int = 0,
            timeoutSeconds: Swift.Int = 0
        ) {
            self.heartbeatTimeoutSeconds = heartbeatTimeoutSeconds
            self.timeoutSeconds = timeoutSeconds
        }
    }
}

extension LambdaClientTypes {

    /// Configuration options for chained function invocations in durable executions, including retry settings and timeout configuration.
    public struct ChainedInvokeOptions: Swift.Sendable {
        /// The name or ARN of the Lambda function to invoke.
        /// This member is required.
        public var functionName: Swift.String?
        /// The tenant identifier for the chained invocation.
        public var tenantId: Swift.String?

        public init(
            functionName: Swift.String? = nil,
            tenantId: Swift.String? = nil
        ) {
            self.functionName = functionName
            self.tenantId = tenantId
        }
    }
}

extension LambdaClientTypes {

    /// Configuration options for a durable execution context.
    public struct ContextOptions: Swift.Sendable {
        /// Whether the state data of children of the completed context should be included in the invoke payload and GetDurableExecutionState response.
        public var replayChildren: Swift.Bool?

        public init(
            replayChildren: Swift.Bool? = nil
        ) {
            self.replayChildren = replayChildren
        }
    }
}

extension LambdaClientTypes {

    /// An object that contains error information.
    public struct ErrorObject: Swift.Sendable {
        /// Machine-readable error data.
        public var errorData: Swift.String?
        /// A human-readable error message.
        public var errorMessage: Swift.String?
        /// The error type.
        public var errorType: Swift.String?
        /// Stack trace information for the error.
        public var stackTrace: [Swift.String]?

        public init(
            errorData: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil,
            stackTrace: [Swift.String]? = nil
        ) {
            self.errorData = errorData
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.stackTrace = stackTrace
        }
    }
}

extension LambdaClientTypes.ErrorObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorObject(errorData: \"CONTENT_REDACTED\", errorMessage: \"CONTENT_REDACTED\", errorType: \"CONTENT_REDACTED\", stackTrace: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Configuration options for a step operation.
    public struct StepOptions: Swift.Sendable {
        /// The delay in seconds before the next retry attempt.
        public var nextAttemptDelaySeconds: Swift.Int?

        public init(
            nextAttemptDelaySeconds: Swift.Int? = nil
        ) {
            self.nextAttemptDelaySeconds = nextAttemptDelaySeconds
        }
    }
}

extension LambdaClientTypes {

    public enum OperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case callback
        case chainedInvoke
        case context
        case execution
        case step
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .callback,
                .chainedInvoke,
                .context,
                .execution,
                .step,
                .wait
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .callback: return "CALLBACK"
            case .chainedInvoke: return "CHAINED_INVOKE"
            case .context: return "CONTEXT"
            case .execution: return "EXECUTION"
            case .step: return "STEP"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Specifies how long to pause the durable execution.
    public struct WaitOptions: Swift.Sendable {
        /// The duration to wait, in seconds.
        public var waitSeconds: Swift.Int?

        public init(
            waitSeconds: Swift.Int? = nil
        ) {
            self.waitSeconds = waitSeconds
        }
    }
}

extension LambdaClientTypes {

    /// An update to be applied to an operation during checkpointing.
    public struct OperationUpdate: Swift.Sendable {
        /// The action to take on the operation.
        /// This member is required.
        public var action: LambdaClientTypes.OperationAction?
        /// Configuration options for callback operations in durable executions, including timeout settings and retry behavior.
        public var callbackOptions: LambdaClientTypes.CallbackOptions?
        /// Configuration options for chained function invocations in durable executions, including retry settings and timeout configuration.
        public var chainedInvokeOptions: LambdaClientTypes.ChainedInvokeOptions?
        /// Options for context operations.
        public var contextOptions: LambdaClientTypes.ContextOptions?
        /// The error information for failed operations.
        public var error: LambdaClientTypes.ErrorObject?
        /// The unique identifier for this operation.
        /// This member is required.
        public var id: Swift.String?
        /// The customer-provided name for this operation.
        public var name: Swift.String?
        /// The unique identifier of the parent operation, if this operation is running within a child context.
        public var parentId: Swift.String?
        /// The payload for successful operations.
        public var payload: Swift.String?
        /// Options for step operations.
        public var stepOptions: LambdaClientTypes.StepOptions?
        /// The subtype of the operation, providing additional categorization.
        public var subType: Swift.String?
        /// The type of operation to update.
        /// This member is required.
        public var type: LambdaClientTypes.OperationType?
        /// Options for wait operations.
        public var waitOptions: LambdaClientTypes.WaitOptions?

        public init(
            action: LambdaClientTypes.OperationAction? = nil,
            callbackOptions: LambdaClientTypes.CallbackOptions? = nil,
            chainedInvokeOptions: LambdaClientTypes.ChainedInvokeOptions? = nil,
            contextOptions: LambdaClientTypes.ContextOptions? = nil,
            error: LambdaClientTypes.ErrorObject? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            parentId: Swift.String? = nil,
            payload: Swift.String? = nil,
            stepOptions: LambdaClientTypes.StepOptions? = nil,
            subType: Swift.String? = nil,
            type: LambdaClientTypes.OperationType? = nil,
            waitOptions: LambdaClientTypes.WaitOptions? = nil
        ) {
            self.action = action
            self.callbackOptions = callbackOptions
            self.chainedInvokeOptions = chainedInvokeOptions
            self.contextOptions = contextOptions
            self.error = error
            self.id = id
            self.name = name
            self.parentId = parentId
            self.payload = payload
            self.stepOptions = stepOptions
            self.subType = subType
            self.type = type
            self.waitOptions = waitOptions
        }
    }
}

extension LambdaClientTypes.OperationUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationUpdate(action: \(Swift.String(describing: action)), callbackOptions: \(Swift.String(describing: callbackOptions)), chainedInvokeOptions: \(Swift.String(describing: chainedInvokeOptions)), contextOptions: \(Swift.String(describing: contextOptions)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), parentId: \(Swift.String(describing: parentId)), stepOptions: \(Swift.String(describing: stepOptions)), subType: \(Swift.String(describing: subType)), type: \(Swift.String(describing: type)), waitOptions: \(Swift.String(describing: waitOptions)), payload: \"CONTENT_REDACTED\")"}
}

public struct CheckpointDurableExecutionInput: Swift.Sendable {
    /// A unique token that identifies the current checkpoint state. This token is provided by the Lambda runtime and must be used to ensure checkpoints are applied in the correct order. Each checkpoint operation consumes this token and returns a new one.
    /// This member is required.
    public var checkpointToken: Swift.String?
    /// An optional idempotency token to ensure that duplicate checkpoint requests are handled correctly. If provided, Lambda uses this token to detect and handle duplicate requests within a 15-minute window.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the durable execution.
    /// This member is required.
    public var durableExecutionArn: Swift.String?
    /// An array of state updates to apply during this checkpoint. Each update represents a change to the execution state, such as completing a step, starting a callback, or scheduling a timer. Updates are applied atomically as part of the checkpoint operation.
    public var updates: [LambdaClientTypes.OperationUpdate]?

    public init(
        checkpointToken: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        durableExecutionArn: Swift.String? = nil,
        updates: [LambdaClientTypes.OperationUpdate]? = nil
    ) {
        self.checkpointToken = checkpointToken
        self.clientToken = clientToken
        self.durableExecutionArn = durableExecutionArn
        self.updates = updates
    }
}

extension LambdaClientTypes {

    /// Contains details about a callback operation in a durable execution, including the callback token and timeout configuration.
    public struct CallbackDetails: Swift.Sendable {
        /// The callback ID. Callback IDs are generated by the DurableContext when a durable function calls ctx.waitForCallback.
        public var callbackId: Swift.String?
        /// An error object that contains details about the failure.
        public var error: LambdaClientTypes.ErrorObject?
        /// The response payload from the callback operation as a string.
        public var result: Swift.String?

        public init(
            callbackId: Swift.String? = nil,
            error: LambdaClientTypes.ErrorObject? = nil,
            result: Swift.String? = nil
        ) {
            self.callbackId = callbackId
            self.error = error
            self.result = result
        }
    }
}

extension LambdaClientTypes.CallbackDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CallbackDetails(callbackId: \(Swift.String(describing: callbackId)), error: \(Swift.String(describing: error)), result: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Contains details about a chained function invocation in a durable execution, including the target function and invocation parameters.
    public struct ChainedInvokeDetails: Swift.Sendable {
        /// Details about the chained invocation failure.
        public var error: LambdaClientTypes.ErrorObject?
        /// The response payload from the chained invocation.
        public var result: Swift.String?

        public init(
            error: LambdaClientTypes.ErrorObject? = nil,
            result: Swift.String? = nil
        ) {
            self.error = error
            self.result = result
        }
    }
}

extension LambdaClientTypes.ChainedInvokeDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChainedInvokeDetails(error: \(Swift.String(describing: error)), result: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Details about a durable execution context.
    public struct ContextDetails: Swift.Sendable {
        /// Details about the context failure.
        public var error: LambdaClientTypes.ErrorObject?
        /// Whether the state data of child operations of this completed context should be included in the invoke payload and GetDurableExecutionState response.
        public var replayChildren: Swift.Bool?
        /// The response payload from the context.
        public var result: Swift.String?

        public init(
            error: LambdaClientTypes.ErrorObject? = nil,
            replayChildren: Swift.Bool? = nil,
            result: Swift.String? = nil
        ) {
            self.error = error
            self.replayChildren = replayChildren
            self.result = result
        }
    }
}

extension LambdaClientTypes.ContextDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContextDetails(error: \(Swift.String(describing: error)), replayChildren: \(Swift.String(describing: replayChildren)), result: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Details about a [durable execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html).
    public struct ExecutionDetails: Swift.Sendable {
        /// The original input payload provided for the durable execution.
        public var inputPayload: Swift.String?

        public init(
            inputPayload: Swift.String? = nil
        ) {
            self.inputPayload = inputPayload
        }
    }
}

extension LambdaClientTypes.ExecutionDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionDetails(inputPayload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    public enum OperationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case pending
        case ready
        case started
        case stopped
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .cancelled,
                .failed,
                .pending,
                .ready,
                .started,
                .stopped,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Details about a step operation.
    public struct StepDetails: Swift.Sendable {
        /// The current attempt number for this step.
        public var attempt: Swift.Int
        /// Details about the step failure.
        public var error: LambdaClientTypes.ErrorObject?
        /// The date and time when the next attempt is scheduled, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD). Only populated when the step is in a pending state.
        public var nextAttemptTimestamp: Foundation.Date?
        /// The JSON response payload from the step operation.
        public var result: Swift.String?

        public init(
            attempt: Swift.Int = 0,
            error: LambdaClientTypes.ErrorObject? = nil,
            nextAttemptTimestamp: Foundation.Date? = nil,
            result: Swift.String? = nil
        ) {
            self.attempt = attempt
            self.error = error
            self.nextAttemptTimestamp = nextAttemptTimestamp
            self.result = result
        }
    }
}

extension LambdaClientTypes.StepDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StepDetails(attempt: \(Swift.String(describing: attempt)), error: \(Swift.String(describing: error)), nextAttemptTimestamp: \(Swift.String(describing: nextAttemptTimestamp)), result: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Details about a wait operation.
    public struct WaitDetails: Swift.Sendable {
        /// The date and time when the wait operation is scheduled to complete, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var scheduledEndTimestamp: Foundation.Date?

        public init(
            scheduledEndTimestamp: Foundation.Date? = nil
        ) {
            self.scheduledEndTimestamp = scheduledEndTimestamp
        }
    }
}

extension LambdaClientTypes {

    /// Information about an operation within a durable execution.
    public struct Operation: Swift.Sendable {
        /// Contains details about a callback operation in a durable execution, including the callback token and timeout configuration.
        public var callbackDetails: LambdaClientTypes.CallbackDetails?
        /// Contains details about a chained function invocation in a durable execution, including the target function and invocation parameters.
        public var chainedInvokeDetails: LambdaClientTypes.ChainedInvokeDetails?
        /// Details about the context, if this operation represents a context.
        public var contextDetails: LambdaClientTypes.ContextDetails?
        /// The date and time when the operation ended, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var endTimestamp: Foundation.Date?
        /// Details about the execution, if this operation represents an execution.
        public var executionDetails: LambdaClientTypes.ExecutionDetails?
        /// The unique identifier for this operation.
        /// This member is required.
        public var id: Swift.String?
        /// The customer-provided name for this operation.
        public var name: Swift.String?
        /// The unique identifier of the parent operation, if this operation is running within a child context.
        public var parentId: Swift.String?
        /// The date and time when the operation started, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var startTimestamp: Foundation.Date?
        /// The current status of the operation.
        /// This member is required.
        public var status: LambdaClientTypes.OperationStatus?
        /// Details about the step, if this operation represents a step.
        public var stepDetails: LambdaClientTypes.StepDetails?
        /// The subtype of the operation, providing additional categorization.
        public var subType: Swift.String?
        /// The type of operation.
        /// This member is required.
        public var type: LambdaClientTypes.OperationType?
        /// Details about the wait operation, if this operation represents a wait.
        public var waitDetails: LambdaClientTypes.WaitDetails?

        public init(
            callbackDetails: LambdaClientTypes.CallbackDetails? = nil,
            chainedInvokeDetails: LambdaClientTypes.ChainedInvokeDetails? = nil,
            contextDetails: LambdaClientTypes.ContextDetails? = nil,
            endTimestamp: Foundation.Date? = nil,
            executionDetails: LambdaClientTypes.ExecutionDetails? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            parentId: Swift.String? = nil,
            startTimestamp: Foundation.Date? = nil,
            status: LambdaClientTypes.OperationStatus? = nil,
            stepDetails: LambdaClientTypes.StepDetails? = nil,
            subType: Swift.String? = nil,
            type: LambdaClientTypes.OperationType? = nil,
            waitDetails: LambdaClientTypes.WaitDetails? = nil
        ) {
            self.callbackDetails = callbackDetails
            self.chainedInvokeDetails = chainedInvokeDetails
            self.contextDetails = contextDetails
            self.endTimestamp = endTimestamp
            self.executionDetails = executionDetails
            self.id = id
            self.name = name
            self.parentId = parentId
            self.startTimestamp = startTimestamp
            self.status = status
            self.stepDetails = stepDetails
            self.subType = subType
            self.type = type
            self.waitDetails = waitDetails
        }
    }
}

extension LambdaClientTypes {

    /// Contains operations that have been updated since the last checkpoint, such as completed asynchronous work like timers or callbacks.
    public struct CheckpointUpdatedExecutionState: Swift.Sendable {
        /// Indicates that more results are available. Use this value in a subsequent call to retrieve the next page of results.
        public var nextMarker: Swift.String?
        /// A list of operations that have been updated since the last checkpoint.
        public var operations: [LambdaClientTypes.Operation]?

        public init(
            nextMarker: Swift.String? = nil,
            operations: [LambdaClientTypes.Operation]? = nil
        ) {
            self.nextMarker = nextMarker
            self.operations = operations
        }
    }
}

/// The response from the CheckpointDurableExecution operation.
public struct CheckpointDurableExecutionOutput: Swift.Sendable {
    /// A new checkpoint token to use for the next checkpoint operation. This token replaces the one provided in the request and must be used for subsequent checkpoints to maintain proper ordering.
    public var checkpointToken: Swift.String?
    /// Updated execution state information that includes any changes that occurred since the last checkpoint, such as completed callbacks or expired timers. This allows the SDK to update its internal state during replay.
    /// This member is required.
    public var newExecutionState: LambdaClientTypes.CheckpointUpdatedExecutionState?

    public init(
        checkpointToken: Swift.String? = nil,
        newExecutionState: LambdaClientTypes.CheckpointUpdatedExecutionState? = nil
    ) {
        self.checkpointToken = checkpointToken
        self.newExecutionState = newExecutionState
    }
}

extension LambdaClientTypes {

    public enum CodeSigningPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enforce
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSigningPolicy] {
            return [
                .enforce,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "Enforce"
            case .warn: return "Warn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Code signing configuration [policies](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies) specify the validation failure action for signature mismatch or expiry.
    public struct CodeSigningPolicies: Swift.Sendable {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to Warn, Lambda allows the deployment and issues a new Amazon CloudWatch metric (SignatureValidationErrors) and also stores the warning in the CloudTrail log. Default value: Warn
        public var untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy?

        public init(
            untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy? = nil
        ) {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }
    }
}

public struct CreateCodeSigningConfigInput: Swift.Sendable {
    /// Signing profiles for this code signing configuration.
    /// This member is required.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The code signing policies define the actions to take if the validation checks fail.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?
    /// A list of tags to add to the code signing configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.allowedPublishers = allowedPublishers
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
        self.tags = tags
    }
}

extension LambdaClientTypes {

    /// Details about a [Code signing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
    public struct CodeSigningConfig: Swift.Sendable {
        /// List of allowed publishers.
        /// This member is required.
        public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigArn: Swift.String?
        /// Unique identifer for the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigId: Swift.String?
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        /// This member is required.
        public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
        /// Code signing configuration description.
        public var description: Swift.String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModified: Swift.String?

        public init(
            allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
            codeSigningConfigArn: Swift.String? = nil,
            codeSigningConfigId: Swift.String? = nil,
            codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
            description: Swift.String? = nil,
            lastModified: Swift.String? = nil
        ) {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }
    }
}

public struct CreateCodeSigningConfigOutput: Swift.Sendable {
    /// The code signing configuration.
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    ) {
        self.codeSigningConfig = codeSigningConfig
    }
}

public struct DeleteCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil
    ) {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

public struct DeleteCodeSigningConfigOutput: Swift.Sendable {

    public init() { }
}

public struct GetCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil
    ) {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

public struct GetCodeSigningConfigOutput: Swift.Sendable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    ) {
        self.codeSigningConfig = codeSigningConfig
    }
}

public struct ListCodeSigningConfigsInput: Swift.Sendable {
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListCodeSigningConfigsOutput: Swift.Sendable {
    /// The code signing configurations
    public var codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.codeSigningConfigs = codeSigningConfigs
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionsByCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListFunctionsByCodeSigningConfigOutput: Swift.Sendable {
    /// The function ARNs.
    public var functionArns: [Swift.String]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionArns: [Swift.String]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.functionArns = functionArns
        self.nextMarker = nextMarker
    }
}

public struct UpdateCodeSigningConfigInput: Swift.Sendable {
    /// Signing profiles for this code signing configuration.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The code signing policy.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init(
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    ) {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

public struct UpdateCodeSigningConfigOutput: Swift.Sendable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    ) {
        self.codeSigningConfig = codeSigningConfig
    }
}

public struct DeleteFunctionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function or version. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:1 (with version).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version to delete. You can't delete a version that an alias references.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct DeleteFunctionOutput: Swift.Sendable {
    /// The HTTP status code returned by the operation.
    public var statusCode: Swift.Int

    public init(
        statusCode: Swift.Int = 0
    ) {
        self.statusCode = statusCode
    }
}

public struct DeleteFunctionEventInvokeConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    /// A destination for events that failed processing. For more information, see [Adding a destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
    public struct OnFailure: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination resource. To retain records of failed invocations from [Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html), [DynamoDB](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html), [self-managed Apache Kafka](https://docs.aws.amazon.com/lambda/latest/dg/kafka-on-failure.html), or [Amazon MSK](https://docs.aws.amazon.com/lambda/latest/dg/kafka-on-failure.html), you can configure an Amazon SNS topic, Amazon SQS queue, Amazon S3 bucket, or Kafka topic as the destination. Amazon SNS destinations have a message size limit of 256 KB. If the combined size of the function request and response payload exceeds the limit, Lambda will drop the payload when sending OnFailure event to the destination. For details on this behavior, refer to [Retaining records of asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html). To retain records of failed invocations from [Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html), [DynamoDB](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html), [self-managed Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-smaa-onfailure-destination) or [Amazon MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-onfailure-destination), you can configure an Amazon SNS topic, Amazon SQS queue, or Amazon S3 bucket as the destination.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        ) {
            self.destination = destination
        }
    }
}

extension LambdaClientTypes {

    /// A destination for events that were processed successfully. To retain records of successful [asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations), you can configure an Amazon SNS topic, Amazon SQS queue, Lambda function, or Amazon EventBridge event bus as the destination. OnSuccess is not supported in CreateEventSourceMapping or UpdateEventSourceMapping requests.
    public struct OnSuccess: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the destination resource. Amazon SNS destinations have a message size limit of 256 KB. If the combined size of the function request and response payload exceeds the limit, Lambda will drop the payload when sending OnFailure event to the destination. For details on this behavior, refer to [Retaining records of asynchronous invocations](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html).
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        ) {
            self.destination = destination
        }
    }
}

extension LambdaClientTypes {

    /// A configuration object that specifies the destination of an event after Lambda processes it. For more information, see [Adding a destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
    public struct DestinationConfig: Swift.Sendable {
        /// The destination configuration for failed invocations.
        public var onFailure: LambdaClientTypes.OnFailure?
        /// The destination configuration for successful invocations. Not supported in CreateEventSourceMapping or UpdateEventSourceMapping.
        public var onSuccess: LambdaClientTypes.OnSuccess?

        public init(
            onFailure: LambdaClientTypes.OnFailure? = nil,
            onSuccess: LambdaClientTypes.OnSuccess? = nil
        ) {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }
    }
}

extension LambdaClientTypes {

    public enum FullDocument: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case updatelookup
        case sdkUnknown(Swift.String)

        public static var allCases: [FullDocument] {
            return [
                .default,
                .updatelookup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .updatelookup: return "UpdateLookup"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for a DocumentDB event source.
    public struct DocumentDBEventSourceConfig: Swift.Sendable {
        /// The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        public var collectionName: Swift.String?
        /// The name of the database to consume within the DocumentDB cluster.
        public var databaseName: Swift.String?
        /// Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        public var fullDocument: LambdaClientTypes.FullDocument?

        public init(
            collectionName: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fullDocument: LambdaClientTypes.FullDocument? = nil
        ) {
            self.collectionName = collectionName
            self.databaseName = databaseName
            self.fullDocument = fullDocument
        }
    }
}

extension LambdaClientTypes {

    /// A structure within a FilterCriteria object that defines an event filtering pattern.
    public struct Filter: Swift.Sendable {
        /// A filter pattern. For more information on the syntax of a filter pattern, see [ Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        public var pattern: Swift.String?

        public init(
            pattern: Swift.String? = nil
        ) {
            self.pattern = pattern
        }
    }
}

extension LambdaClientTypes {

    /// An object that contains the filters for an event source.
    public struct FilterCriteria: Swift.Sendable {
        /// A list of filters.
        public var filters: [LambdaClientTypes.Filter]?

        public init(
            filters: [LambdaClientTypes.Filter]? = nil
        ) {
            self.filters = filters
        }
    }
}

extension LambdaClientTypes {

    public enum FunctionResponseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case reportbatchitemfailures
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionResponseType] {
            return [
                .reportbatchitemfailures
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .reportbatchitemfailures: return "ReportBatchItemFailures"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum EventSourceMappingMetric: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventcount
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceMappingMetric] {
            return [
                .eventcount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventcount: return "EventCount"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The metrics configuration for your event source. Use this configuration object to define which metrics you want your event source mapping to produce.
    public struct EventSourceMappingMetricsConfig: Swift.Sendable {
        /// The metrics you want your event source mapping to produce. Include EventCount to receive event source mapping metrics related to the number of events processed by your event source mapping. For more information about these metrics, see [ Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
        public var metrics: [LambdaClientTypes.EventSourceMappingMetric]?

        public init(
            metrics: [LambdaClientTypes.EventSourceMappingMetric]? = nil
        ) {
            self.metrics = metrics
        }
    }
}

extension LambdaClientTypes {

    /// The [ provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode) configuration for the event source. Use Provisioned Mode to customize the minimum and maximum number of event pollers for your event source.
    public struct ProvisionedPollerConfig: Swift.Sendable {
        /// The maximum number of event pollers this event source can scale up to. For Amazon SQS events source mappings, default is 200, and minimum value allowed is 2. For Amazon MSK and self-managed Apache Kafka event source mappings, default is 200, and minimum value allowed is 1.
        public var maximumPollers: Swift.Int?
        /// The minimum number of event pollers this event source can scale down to. For Amazon SQS events source mappings, default is 2, and minimum 2 required. For Amazon MSK and self-managed Apache Kafka event source mappings, default is 1.
        public var minimumPollers: Swift.Int?
        /// (Amazon MSK and self-managed Apache Kafka) The name of the provisioned poller group. Use this option to group multiple ESMs within the event source's VPC to share Event Poller Unit (EPU) capacity. You can use this option to optimize Provisioned mode costs for your ESMs. You can group up to 100 ESMs per poller group and aggregate maximum pollers across all ESMs in a group cannot exceed 2000.
        public var pollerGroupName: Swift.String?

        public init(
            maximumPollers: Swift.Int? = nil,
            minimumPollers: Swift.Int? = nil,
            pollerGroupName: Swift.String? = nil
        ) {
            self.maximumPollers = maximumPollers
            self.minimumPollers = minimumPollers
            self.pollerGroupName = pollerGroupName
        }
    }
}

extension LambdaClientTypes {

    /// (Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.
    public struct ScalingConfig: Swift.Sendable {
        /// Limits the number of concurrent instances that the Amazon SQS event source can invoke.
        public var maximumConcurrency: Swift.Int?

        public init(
            maximumConcurrency: Swift.Int? = nil
        ) {
            self.maximumConcurrency = maximumConcurrency
        }
    }
}

extension LambdaClientTypes {

    public enum EndPointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kafkaBootstrapServers
        case sdkUnknown(Swift.String)

        public static var allCases: [EndPointType] {
            return [
                .kafkaBootstrapServers
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The self-managed Apache Kafka cluster for your event source.
    public struct SelfManagedEventSource: Swift.Sendable {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public var endpoints: [Swift.String: [Swift.String]]?

        public init(
            endpoints: [Swift.String: [Swift.String]]? = nil
        ) {
            self.endpoints = endpoints
        }
    }
}

extension LambdaClientTypes {

    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public struct SelfManagedKafkaEventSourceConfig: Swift.Sendable {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka-process.html#services-smaa-topic-add).
        public var consumerGroupId: Swift.String?
        /// Specific configuration settings for a Kafka schema registry.
        public var schemaRegistryConfig: LambdaClientTypes.KafkaSchemaRegistryConfig?

        public init(
            consumerGroupId: Swift.String? = nil,
            schemaRegistryConfig: LambdaClientTypes.KafkaSchemaRegistryConfig? = nil
        ) {
            self.consumerGroupId = consumerGroupId
            self.schemaRegistryConfig = schemaRegistryConfig
        }
    }
}

extension LambdaClientTypes {

    public enum SourceAccessType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basicAuth
        case clientCertificateTlsAuth
        case saslScram256Auth
        case saslScram512Auth
        case serverRootCaCertificate
        case virtualHost
        case vpcSecurityGroup
        case vpcSubnet
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceAccessType] {
            return [
                .basicAuth,
                .clientCertificateTlsAuth,
                .saslScram256Auth,
                .saslScram512Auth,
                .serverRootCaCertificate,
                .virtualHost,
                .vpcSecurityGroup,
                .vpcSubnet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .clientCertificateTlsAuth: return "CLIENT_CERTIFICATE_TLS_AUTH"
            case .saslScram256Auth: return "SASL_SCRAM_256_AUTH"
            case .saslScram512Auth: return "SASL_SCRAM_512_AUTH"
            case .serverRootCaCertificate: return "SERVER_ROOT_CA_CERTIFICATE"
            case .virtualHost: return "VIRTUAL_HOST"
            case .vpcSecurityGroup: return "VPC_SECURITY_GROUP"
            case .vpcSubnet: return "VPC_SUBNET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.
    public struct SourceAccessConfiguration: Swift.Sendable {
        /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".
        ///
        /// * BASIC_AUTH – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.
        ///
        /// * BASIC_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
        ///
        /// * VPC_SUBNET – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
        ///
        /// * VPC_SECURITY_GROUP – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_256_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_512_AUTH – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * VIRTUAL_HOST –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
        ///
        /// * CLIENT_CERTIFICATE_TLS_AUTH – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
        ///
        /// * SERVER_ROOT_CA_CERTIFICATE – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        public var type: LambdaClientTypes.SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public var uri: Swift.String?

        public init(
            type: LambdaClientTypes.SourceAccessType? = nil,
            uri: Swift.String? = nil
        ) {
            self.type = type
            self.uri = uri
        }
    }
}

extension LambdaClientTypes {

    public enum EventSourcePosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case atTimestamp
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourcePosition] {
            return [
                .atTimestamp,
                .latest,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .atTimestamp: return "AT_TIMESTAMP"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEventSourceMappingInput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis – Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams – Default 100. Max 10,000.
    ///
    /// * Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Self-managed Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
    ///
    /// * DocumentDB – Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis – The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams – The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service – The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – The ARN of the cluster or the ARN of the VPC connection (for [cross-account event source mappings](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#msk-multi-vpc)).
    ///
    /// * Amazon MQ – The ARN of the broker.
    ///
    /// * Amazon DocumentDB – The ARN of the DocumentDB change stream.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics). By default, Lambda does not encrypt your filter criteria object. Specify this property to encrypt data using your own customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For Kinesis, DynamoDB, and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
    public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
    public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster to receive records from.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// A list of tags to apply to the event source mapping.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        enabled: Swift.Bool? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
        parallelizationFactor: Swift.Int? = nil,
        provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil
    ) {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.enabled = enabled
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.metricsConfig = metricsConfig
        self.parallelizationFactor = parallelizationFactor
        self.provisionedPollerConfig = provisionedPollerConfig
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.tags = tags
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
    }
}

extension LambdaClientTypes {

    /// An object that contains details about an error related to filter criteria encryption.
    public struct FilterCriteriaError: Swift.Sendable {
        /// The KMS exception that resulted from filter criteria encryption or decryption.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct CreateEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the event source mapping's last processing attempt.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
    public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
    public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
        parallelizationFactor: Swift.Int? = nil,
        provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    ) {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.metricsConfig = metricsConfig
        self.parallelizationFactor = parallelizationFactor
        self.provisionedPollerConfig = provisionedPollerConfig
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

/// The operation conflicts with the resource's availability. For example, you tried to update an event source mapping in the CREATING state, or you tried to delete an event source mapping currently UPDATING.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

public struct DeleteEventSourceMappingInput: Swift.Sendable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        uuid: Swift.String? = nil
    ) {
        self.uuid = uuid
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct DeleteEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the event source mapping's last processing attempt.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
    public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
    public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
        parallelizationFactor: Swift.Int? = nil,
        provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    ) {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.metricsConfig = metricsConfig
        self.parallelizationFactor = parallelizationFactor
        self.provisionedPollerConfig = provisionedPollerConfig
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

public struct GetEventSourceMappingInput: Swift.Sendable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        uuid: Swift.String? = nil
    ) {
        self.uuid = uuid
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct GetEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the event source mapping's last processing attempt.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
    public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
    public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
        parallelizationFactor: Swift.Int? = nil,
        provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    ) {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.metricsConfig = metricsConfig
        self.parallelizationFactor = parallelizationFactor
        self.provisionedPollerConfig = provisionedPollerConfig
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

public struct ListEventSourceMappingsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis – The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams – The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service – The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – The ARN of the cluster or the ARN of the VPC connection (for [cross-account event source mappings](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#msk-multi-vpc)).
    ///
    /// * Amazon MQ – The ARN of the broker.
    ///
    /// * Amazon DocumentDB – The ARN of the DocumentDB change stream.
    public var eventSourceArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of event source mappings to return. Note that ListEventSourceMappings returns a maximum of 100 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        eventSourceArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
    public struct EventSourceMappingConfiguration: Swift.Sendable {
        /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var batchSize: Swift.Int?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry. The default value is false.
        public var bisectBatchOnFunctionError: Swift.Bool?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// Specific configuration settings for a DocumentDB event source.
        public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public var eventSourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the event source mapping.
        public var eventSourceMappingArn: Swift.String?
        /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
        public var filterCriteria: LambdaClientTypes.FilterCriteria?
        /// An object that contains details about an error related to filter criteria encryption.
        public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
        public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
        /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
        public var kmsKeyArn: Swift.String?
        /// The date that the event source mapping was last updated or that its state changed.
        public var lastModified: Foundation.Date?
        /// The result of the event source mapping's last processing attempt.
        public var lastProcessingResult: Swift.String?
        /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var maximumBatchingWindowInSeconds: Swift.Int?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
        public var maximumRecordAgeInSeconds: Swift.Int?
        /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public var maximumRetryAttempts: Swift.Int?
        /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
        public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
        /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
        public var parallelizationFactor: Swift.Int?
        /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
        public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
        /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
        public var queues: [Swift.String]?
        /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
        public var scalingConfig: LambdaClientTypes.ScalingConfig?
        /// The self-managed Apache Kafka cluster for your event source.
        public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
        /// Specific configuration settings for a self-managed Apache Kafka event source.
        public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
        /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
        public var startingPosition: LambdaClientTypes.EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
        public var startingPositionTimestamp: Foundation.Date?
        /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
        public var state: Swift.String?
        /// Indicates whether a user or Lambda made the last change to the event source mapping.
        public var stateTransitionReason: Swift.String?
        /// The name of the Kafka topic.
        public var topics: [Swift.String]?
        /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
        public var tumblingWindowInSeconds: Swift.Int?
        /// The identifier of the event source mapping.
        public var uuid: Swift.String?

        public init(
            amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
            batchSize: Swift.Int? = nil,
            bisectBatchOnFunctionError: Swift.Bool? = nil,
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
            eventSourceArn: Swift.String? = nil,
            eventSourceMappingArn: Swift.String? = nil,
            filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
            filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
            functionArn: Swift.String? = nil,
            functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            lastProcessingResult: Swift.String? = nil,
            maximumBatchingWindowInSeconds: Swift.Int? = nil,
            maximumRecordAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil,
            metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
            parallelizationFactor: Swift.Int? = nil,
            provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
            queues: [Swift.String]? = nil,
            scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
            selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
            selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
            sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
            startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
            startingPositionTimestamp: Foundation.Date? = nil,
            state: Swift.String? = nil,
            stateTransitionReason: Swift.String? = nil,
            topics: [Swift.String]? = nil,
            tumblingWindowInSeconds: Swift.Int? = nil,
            uuid: Swift.String? = nil
        ) {
            self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.documentDBEventSourceConfig = documentDBEventSourceConfig
            self.eventSourceArn = eventSourceArn
            self.eventSourceMappingArn = eventSourceMappingArn
            self.filterCriteria = filterCriteria
            self.filterCriteriaError = filterCriteriaError
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.metricsConfig = metricsConfig
            self.parallelizationFactor = parallelizationFactor
            self.provisionedPollerConfig = provisionedPollerConfig
            self.queues = queues
            self.scalingConfig = scalingConfig
            self.selfManagedEventSource = selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }
    }
}

public struct ListEventSourceMappingsOutput: Swift.Sendable {
    /// A list of event source mappings.
    public var eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
    /// A pagination token that's returned when the response doesn't contain all event source mappings.
    public var nextMarker: Swift.String?

    public init(
        eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.eventSourceMappings = eventSourceMappings
        self.nextMarker = nextMarker
    }
}

public struct UpdateEventSourceMappingInput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis – Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams – Default 100. Max 10,000.
    ///
    /// * Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Self-managed Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
    ///
    /// * DocumentDB – Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics). By default, Lambda does not encrypt your filter criteria object. Specify this property to encrypt data using your own customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For Kinesis, DynamoDB, and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
    public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
    public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        enabled: Swift.Bool? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
        parallelizationFactor: Swift.Int? = nil,
        provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    ) {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.enabled = enabled
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.metricsConfig = metricsConfig
        self.parallelizationFactor = parallelizationFactor
        self.provisionedPollerConfig = provisionedPollerConfig
        self.scalingConfig = scalingConfig
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct UpdateEventSourceMappingOutput: Swift.Sendable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A configuration object that specifies the destination of an event after Lambda processes it.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the event source mapping.
    public var eventSourceMappingArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html). If filter criteria is encrypted, this field shows up as null in the response of ListEventSourceMapping API calls. You can view this field in plaintext in the response of GetEventSourceMapping and DeleteEventSourceMapping calls if you have kms:Decrypt permissions for the correct KMS key.
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// An object that contains details about an error related to filter criteria encryption.
    public var filterCriteriaError: LambdaClientTypes.FilterCriteriaError?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The ARN of the Key Management Service (KMS) customer managed key that Lambda uses to encrypt your function's [filter criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
    public var kmsKeyArn: Swift.String?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: Foundation.Date?
    /// The result of the event source mapping's last processing attempt.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// The metrics configuration for your event source. For more information, see [Event source mapping metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
    public var metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The provisioned mode configuration for the event source. For more information, see [provisioned mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
    public var provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: Foundation.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        eventSourceMappingArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        filterCriteriaError: LambdaClientTypes.FilterCriteriaError? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        metricsConfig: LambdaClientTypes.EventSourceMappingMetricsConfig? = nil,
        parallelizationFactor: Swift.Int? = nil,
        provisionedPollerConfig: LambdaClientTypes.ProvisionedPollerConfig? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: Foundation.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    ) {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.eventSourceMappingArn = eventSourceMappingArn
        self.filterCriteria = filterCriteria
        self.filterCriteriaError = filterCriteriaError
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.metricsConfig = metricsConfig
        self.parallelizationFactor = parallelizationFactor
        self.provisionedPollerConfig = provisionedPollerConfig
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

/// The specified code signing configuration does not exist.
public struct CodeSigningConfigNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeSigningConfigNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Your Amazon Web Services account has exceeded its maximum total code size. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct CodeStorageExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeStorageExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.
public struct CodeVerificationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeVerificationFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The maximum number of function versions that can be associated with a single capacity provider has been exceeded. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct FunctionVersionsPerCapacityProviderLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionVersionsPerCapacityProviderLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The code signature failed the integrity check. If the integrity check fails, then Lambda blocks deployment, even if the code signing policy is set to WARN.
public struct InvalidCodeSignatureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCodeSignatureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    /// Configuration for Lambda-managed instances used by the capacity provider.
    public struct LambdaManagedInstancesCapacityProviderConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the capacity provider.
        /// This member is required.
        public var capacityProviderArn: Swift.String?
        /// The amount of memory in GiB allocated per vCPU for execution environments.
        public var executionEnvironmentMemoryGiBPerVCpu: Swift.Double?
        /// The maximum number of concurrent execution environments that can run on each compute instance.
        public var perExecutionEnvironmentMaxConcurrency: Swift.Int?

        public init(
            capacityProviderArn: Swift.String? = nil,
            executionEnvironmentMemoryGiBPerVCpu: Swift.Double? = nil,
            perExecutionEnvironmentMaxConcurrency: Swift.Int? = nil
        ) {
            self.capacityProviderArn = capacityProviderArn
            self.executionEnvironmentMemoryGiBPerVCpu = executionEnvironmentMemoryGiBPerVCpu
            self.perExecutionEnvironmentMaxConcurrency = perExecutionEnvironmentMaxConcurrency
        }
    }
}

extension LambdaClientTypes {

    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public struct CapacityProviderConfig: Swift.Sendable {
        /// Configuration for Lambda-managed instances used by the capacity provider.
        /// This member is required.
        public var lambdaManagedInstancesCapacityProviderConfig: LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig?

        public init(
            lambdaManagedInstancesCapacityProviderConfig: LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig? = nil
        ) {
            self.lambdaManagedInstancesCapacityProviderConfig = lambdaManagedInstancesCapacityProviderConfig
        }
    }
}

extension LambdaClientTypes {

    /// The code for the Lambda function. You can either specify an object in Amazon S3, upload a .zip file archive deployment package directly, or specify the URI of a container image.
    public struct FunctionCode: Swift.Sendable {
        /// URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's .zip deployment package. If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk).
        public var sourceKMSKeyArn: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.
        public var zipFile: Foundation.Data?

        public init(
            imageUri: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            sourceKMSKeyArn: Swift.String? = nil,
            zipFile: Foundation.Data? = nil
        ) {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.sourceKMSKeyArn = sourceKMSKeyArn
            self.zipFile = zipFile
        }
    }
}

extension LambdaClientTypes.FunctionCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionCode(imageUri: \(Swift.String(describing: imageUri)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), sourceKMSKeyArn: \(Swift.String(describing: sourceKMSKeyArn)), zipFile: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-dlq) for failed asynchronous invocations.
    public struct DeadLetterConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public var targetArn: Swift.String?

        public init(
            targetArn: Swift.String? = nil
        ) {
            self.targetArn = targetArn
        }
    }
}

extension LambdaClientTypes {

    /// Configuration settings for [durable functions](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html), including execution timeout and retention period for execution history.
    public struct DurableConfig: Swift.Sendable {
        /// The maximum time (in seconds) that a durable execution can run before timing out. This timeout applies to the entire durable execution, not individual function invocations.
        public var executionTimeout: Swift.Int?
        /// The number of days to retain execution history after a durable execution completes. After this period, execution history is no longer available through the GetDurableExecutionHistory API.
        public var retentionPeriodInDays: Swift.Int?

        public init(
            executionTimeout: Swift.Int? = nil,
            retentionPeriodInDays: Swift.Int? = nil
        ) {
            self.executionTimeout = executionTimeout
            self.retentionPeriodInDays = retentionPeriodInDays
        }
    }
}

extension LambdaClientTypes {

    /// A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
    public struct Environment: Swift.Sendable {
        /// Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        public var variables: [Swift.String: Swift.String]?

        public init(
            variables: [Swift.String: Swift.String]? = nil
        ) {
            self.variables = variables
        }
    }
}

extension LambdaClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(variables: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public struct EphemeralStorage: Swift.Sendable {
        /// The size of the function's /tmp directory.
        /// This member is required.
        public var size: Swift.Int?

        public init(
            size: Swift.Int? = nil
        ) {
            self.size = size
        }
    }
}

extension LambdaClientTypes {

    /// Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public struct FileSystemConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        /// This member is required.
        public var arn: Swift.String?
        /// The path where the function can access the file system, starting with /mnt/.
        /// This member is required.
        public var localMountPath: Swift.String?

        public init(
            arn: Swift.String? = nil,
            localMountPath: Swift.String? = nil
        ) {
            self.arn = arn
            self.localMountPath = localMountPath
        }
    }
}

extension LambdaClientTypes {

    /// Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
    public struct ImageConfig: Swift.Sendable {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public var command: [Swift.String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime executable.
        public var entryPoint: [Swift.String]?
        /// Specifies the working directory.
        public var workingDirectory: Swift.String?

        public init(
            command: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            workingDirectory: Swift.String? = nil
        ) {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }
    }
}

extension LambdaClientTypes {

    public enum LogFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [LogFormat] {
            return [
                .json,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum SystemLogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemLogLevel] {
            return [
                .debug,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's Amazon CloudWatch Logs configuration settings.
    public struct LoggingConfig: Swift.Sendable {
        /// Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
        public var applicationLogLevel: LambdaClientTypes.ApplicationLogLevel?
        /// The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        public var logFormat: LambdaClientTypes.LogFormat?
        /// The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name>. To use a different log group, enter an existing log group or enter a new log group name.
        public var logGroup: Swift.String?
        /// Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
        public var systemLogLevel: LambdaClientTypes.SystemLogLevel?

        public init(
            applicationLogLevel: LambdaClientTypes.ApplicationLogLevel? = nil,
            logFormat: LambdaClientTypes.LogFormat? = nil,
            logGroup: Swift.String? = nil,
            systemLogLevel: LambdaClientTypes.SystemLogLevel? = nil
        ) {
            self.applicationLogLevel = applicationLogLevel
            self.logFormat = logFormat
            self.logGroup = logGroup
            self.systemLogLevel = systemLogLevel
        }
    }
}

extension LambdaClientTypes {

    public enum PackageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "Image"
            case .zip: return "Zip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum FunctionVersionLatestPublished: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case latestPublished
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionVersionLatestPublished] {
            return [
                .latestPublished
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .latestPublished: return "LATEST_PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum Runtime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dotnet6
        case dotnet8
        case dotnetcore10
        case dotnetcore20
        case dotnetcore21
        case dotnetcore31
        case go1x
        case java11
        case java17
        case java21
        case java25
        case java8
        case java8al2
        case nodejs
        case nodejs10x
        case nodejs12x
        case nodejs14x
        case nodejs16x
        case nodejs18x
        case nodejs20x
        case nodejs22x
        case nodejs24x
        case nodejs43
        case nodejs43edge
        case nodejs610
        case nodejs810
        case provided
        case providedal2
        case providedal2023
        case python27
        case python310
        case python311
        case python312
        case python313
        case python314
        case python36
        case python37
        case python38
        case python39
        case ruby25
        case ruby27
        case ruby32
        case ruby33
        case ruby34
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .dotnet6,
                .dotnet8,
                .dotnetcore10,
                .dotnetcore20,
                .dotnetcore21,
                .dotnetcore31,
                .go1x,
                .java11,
                .java17,
                .java21,
                .java25,
                .java8,
                .java8al2,
                .nodejs,
                .nodejs10x,
                .nodejs12x,
                .nodejs14x,
                .nodejs16x,
                .nodejs18x,
                .nodejs20x,
                .nodejs22x,
                .nodejs24x,
                .nodejs43,
                .nodejs43edge,
                .nodejs610,
                .nodejs810,
                .provided,
                .providedal2,
                .providedal2023,
                .python27,
                .python310,
                .python311,
                .python312,
                .python313,
                .python314,
                .python36,
                .python37,
                .python38,
                .python39,
                .ruby25,
                .ruby27,
                .ruby32,
                .ruby33,
                .ruby34
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dotnet6: return "dotnet6"
            case .dotnet8: return "dotnet8"
            case .dotnetcore10: return "dotnetcore1.0"
            case .dotnetcore20: return "dotnetcore2.0"
            case .dotnetcore21: return "dotnetcore2.1"
            case .dotnetcore31: return "dotnetcore3.1"
            case .go1x: return "go1.x"
            case .java11: return "java11"
            case .java17: return "java17"
            case .java21: return "java21"
            case .java25: return "java25"
            case .java8: return "java8"
            case .java8al2: return "java8.al2"
            case .nodejs: return "nodejs"
            case .nodejs10x: return "nodejs10.x"
            case .nodejs12x: return "nodejs12.x"
            case .nodejs14x: return "nodejs14.x"
            case .nodejs16x: return "nodejs16.x"
            case .nodejs18x: return "nodejs18.x"
            case .nodejs20x: return "nodejs20.x"
            case .nodejs22x: return "nodejs22.x"
            case .nodejs24x: return "nodejs24.x"
            case .nodejs43: return "nodejs4.3"
            case .nodejs43edge: return "nodejs4.3-edge"
            case .nodejs610: return "nodejs6.10"
            case .nodejs810: return "nodejs8.10"
            case .provided: return "provided"
            case .providedal2: return "provided.al2"
            case .providedal2023: return "provided.al2023"
            case .python27: return "python2.7"
            case .python310: return "python3.10"
            case .python311: return "python3.11"
            case .python312: return "python3.12"
            case .python313: return "python3.13"
            case .python314: return "python3.14"
            case .python36: return "python3.6"
            case .python37: return "python3.7"
            case .python38: return "python3.8"
            case .python39: return "python3.9"
            case .ruby25: return "ruby2.5"
            case .ruby27: return "ruby2.7"
            case .ruby32: return "ruby3.2"
            case .ruby33: return "ruby3.3"
            case .ruby34: return "ruby3.4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum SnapStartApplyOn: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case publishedversions
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapStartApplyOn] {
            return [
                .none,
                .publishedversions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .publishedversions: return "PublishedVersions"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting. Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
    public struct SnapStart: Swift.Sendable {
        /// Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
        public var applyOn: LambdaClientTypes.SnapStartApplyOn?

        public init(
            applyOn: LambdaClientTypes.SnapStartApplyOn? = nil
        ) {
            self.applyOn = applyOn
        }
    }
}

extension LambdaClientTypes {

    public enum TenantIsolationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case perTenant
        case sdkUnknown(Swift.String)

        public static var allCases: [TenantIsolationMode] {
            return [
                .perTenant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .perTenant: return "PER_TENANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Specifies the tenant isolation mode configuration for a Lambda function. This allows you to configure specific tenant isolation strategies for your function invocations. Tenant isolation configuration cannot be modified after function creation.
    public struct TenancyConfig: Swift.Sendable {
        /// Tenant isolation mode allows for invocation to be sent to a corresponding execution environment dedicated to a specific tenant ID.
        /// This member is required.
        public var tenantIsolationMode: LambdaClientTypes.TenantIsolationMode?

        public init(
            tenantIsolationMode: LambdaClientTypes.TenantIsolationMode? = nil
        ) {
            self.tenantIsolationMode = tenantIsolationMode
        }
    }
}

extension LambdaClientTypes {

    public enum TracingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingMode] {
            return [
                .active,
                .passthrough
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .passthrough: return "PassThrough"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set Mode to Active.
    public struct TracingConfig: Swift.Sendable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init(
            mode: LambdaClientTypes.TracingMode? = nil
        ) {
            self.mode = mode
        }
    }
}

extension LambdaClientTypes {

    /// The VPC security groups and subnets that are attached to a Lambda function. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public struct VpcConfig: Swift.Sendable {
        /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        public var ipv6AllowedForDualStack: Swift.Bool?
        /// A list of VPC security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?

        public init(
            ipv6AllowedForDualStack: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        ) {
            self.ipv6AllowedForDualStack = ipv6AllowedForDualStack
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

public struct CreateFunctionInput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// The code for the function.
    /// This member is required.
    public var code: LambdaClientTypes.FunctionCode?
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    public var codeSigningConfigArn: Swift.String?
    /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Configuration settings for durable functions. Enables creating functions with durability that can remember their state and continue execution even after interruptions.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
    public var handler: Swift.String?
    /// Container image [configuration values](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms) that override the values in the container image Dockerfile.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// Set to true to publish the first version of the function during creation.
    public var publish: Swift.Bool?
    /// Specifies where to publish the function version or configuration.
    public var publishTo: LambdaClientTypes.FunctionVersionLatestPublished?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    /// This member is required.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public var snapStart: LambdaClientTypes.SnapStart?
    /// A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
    public var tags: [Swift.String: Swift.String]?
    /// Configuration for multi-tenant applications that use Lambda functions. Defines tenant isolation settings and resource allocations. Required for functions supporting multiple tenants.
    public var tenancyConfig: LambdaClientTypes.TenancyConfig?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        code: LambdaClientTypes.FunctionCode? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        publish: Swift.Bool? = false,
        publishTo: LambdaClientTypes.FunctionVersionLatestPublished? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        snapStart: LambdaClientTypes.SnapStart? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    ) {
        self.architectures = architectures
        self.capacityProviderConfig = capacityProviderConfig
        self.code = code
        self.codeSigningConfigArn = codeSigningConfigArn
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kmsKeyArn = kmsKeyArn
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.memorySize = memorySize
        self.packageType = packageType
        self.publish = publish
        self.publishTo = publishTo
        self.role = role
        self.runtime = runtime
        self.snapStart = snapStart
        self.tags = tags
        self.tenancyConfig = tenancyConfig
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

extension LambdaClientTypes {

    /// Error messages for environment variables that couldn't be applied.
    public struct EnvironmentError: Swift.Sendable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

extension LambdaClientTypes.EnvironmentError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The results of an operation to update or read environment variables. If the operation succeeds, the response contains the environment variables. If it fails, the response contains details about the error.
    public struct EnvironmentResponse: Swift.Sendable {
        /// Error messages for environment variables that couldn't be applied.
        public var error: LambdaClientTypes.EnvironmentError?
        /// Environment variable key-value pairs. Omitted from CloudTrail logs.
        public var variables: [Swift.String: Swift.String]?

        public init(
            error: LambdaClientTypes.EnvironmentError? = nil,
            variables: [Swift.String: Swift.String]? = nil
        ) {
            self.error = error
            self.variables = variables
        }
    }
}

extension LambdaClientTypes.EnvironmentResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentResponse(error: \(Swift.String(describing: error)), variables: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Error response to GetFunctionConfiguration.
    public struct ImageConfigError: Swift.Sendable {
        /// Error code.
        public var errorCode: Swift.String?
        /// Error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

extension LambdaClientTypes.ImageConfigError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfigError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Response to a GetFunctionConfiguration request.
    public struct ImageConfigResponse: Swift.Sendable {
        /// Error response to GetFunctionConfiguration.
        public var error: LambdaClientTypes.ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public var imageConfig: LambdaClientTypes.ImageConfig?

        public init(
            error: LambdaClientTypes.ImageConfigError? = nil,
            imageConfig: LambdaClientTypes.ImageConfig? = nil
        ) {
            self.error = error
            self.imageConfig = imageConfig
        }
    }
}

extension LambdaClientTypes {

    public enum LastUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatus] {
            return [
                .failed,
                .inprogress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum LastUpdateStatusReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capacityproviderscalinglimitexceeded
        case disabledkmskey
        case ec2requestlimitexceeded
        case efsioerror
        case efsmountconnectivityerror
        case efsmountfailure
        case efsmounttimeout
        case enilimitexceeded
        case functionerror
        case functionerrorextensioniniterror
        case functionerrorinitresourceexhausted
        case functionerrorinittimeout
        case functionerrorinvalidentrypoint
        case functionerrorinvalidworkingdirectory
        case functionerrorpermissiondenied
        case functionerrorruntimeiniterror
        case functionerrortoomanyextensions
        case imageaccessdenied
        case imagedeleted
        case insufficientcapacity
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidruntime
        case invalidsecuritygroup
        case invalidstatekmskey
        case invalidsubnet
        case invalidzipfileexception
        case kmskeyaccessdenied
        case kmskeynotfound
        case subnetoutofipaddresses
        case vcpulimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatusReasonCode] {
            return [
                .capacityproviderscalinglimitexceeded,
                .disabledkmskey,
                .ec2requestlimitexceeded,
                .efsioerror,
                .efsmountconnectivityerror,
                .efsmountfailure,
                .efsmounttimeout,
                .enilimitexceeded,
                .functionerror,
                .functionerrorextensioniniterror,
                .functionerrorinitresourceexhausted,
                .functionerrorinittimeout,
                .functionerrorinvalidentrypoint,
                .functionerrorinvalidworkingdirectory,
                .functionerrorpermissiondenied,
                .functionerrorruntimeiniterror,
                .functionerrortoomanyextensions,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientcapacity,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidruntime,
                .invalidsecuritygroup,
                .invalidstatekmskey,
                .invalidsubnet,
                .invalidzipfileexception,
                .kmskeyaccessdenied,
                .kmskeynotfound,
                .subnetoutofipaddresses,
                .vcpulimitexceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capacityproviderscalinglimitexceeded: return "CapacityProviderScalingLimitExceeded"
            case .disabledkmskey: return "DisabledKMSKey"
            case .ec2requestlimitexceeded: return "EC2RequestLimitExceeded"
            case .efsioerror: return "EFSIOError"
            case .efsmountconnectivityerror: return "EFSMountConnectivityError"
            case .efsmountfailure: return "EFSMountFailure"
            case .efsmounttimeout: return "EFSMountTimeout"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .functionerror: return "FunctionError"
            case .functionerrorextensioniniterror: return "FunctionError.ExtensionInitError"
            case .functionerrorinitresourceexhausted: return "FunctionError.InitResourceExhausted"
            case .functionerrorinittimeout: return "FunctionError.InitTimeout"
            case .functionerrorinvalidentrypoint: return "FunctionError.InvalidEntryPoint"
            case .functionerrorinvalidworkingdirectory: return "FunctionError.InvalidWorkingDirectory"
            case .functionerrorpermissiondenied: return "FunctionError.PermissionDenied"
            case .functionerrorruntimeiniterror: return "FunctionError.RuntimeInitError"
            case .functionerrortoomanyextensions: return "FunctionError.TooManyExtensions"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientcapacity: return "InsufficientCapacity"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidruntime: return "InvalidRuntime"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidstatekmskey: return "InvalidStateKMSKey"
            case .invalidsubnet: return "InvalidSubnet"
            case .invalidzipfileexception: return "InvalidZipFileException"
            case .kmskeyaccessdenied: return "KMSKeyAccessDenied"
            case .kmskeynotfound: return "KMSKeyNotFound"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case .vcpulimitexceeded: return "VcpuLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// An [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct Layer: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        ) {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }
}

extension LambdaClientTypes {

    /// Any error returned when the runtime version information for the function could not be retrieved.
    public struct RuntimeVersionError: Swift.Sendable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

extension LambdaClientTypes.RuntimeVersionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuntimeVersionError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// The ARN of the runtime and any errors that occured.
    public struct RuntimeVersionConfig: Swift.Sendable {
        /// Error response when Lambda is unable to retrieve the runtime version for a function.
        public var error: LambdaClientTypes.RuntimeVersionError?
        /// The ARN of the runtime version you want the function to use.
        public var runtimeVersionArn: Swift.String?

        public init(
            error: LambdaClientTypes.RuntimeVersionError? = nil,
            runtimeVersionArn: Swift.String? = nil
        ) {
            self.error = error
            self.runtimeVersionArn = runtimeVersionArn
        }
    }
}

extension LambdaClientTypes {

    public enum SnapStartOptimizationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapStartOptimizationStatus] {
            return [
                .off,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public struct SnapStartResponse: Swift.Sendable {
        /// When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        public var applyOn: LambdaClientTypes.SnapStartApplyOn?
        /// When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
        public var optimizationStatus: LambdaClientTypes.SnapStartOptimizationStatus?

        public init(
            applyOn: LambdaClientTypes.SnapStartApplyOn? = nil,
            optimizationStatus: LambdaClientTypes.SnapStartOptimizationStatus? = nil
        ) {
            self.applyOn = applyOn
            self.optimizationStatus = optimizationStatus
        }
    }
}

extension LambdaClientTypes {

    public enum StateReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capacityproviderscalinglimitexceeded
        case creating
        case disabledkmskey
        case drainingdurableexecutions
        case ec2requestlimitexceeded
        case efsioerror
        case efsmountconnectivityerror
        case efsmountfailure
        case efsmounttimeout
        case enilimitexceeded
        case functionerror
        case functionerrorextensioniniterror
        case functionerrorinitresourceexhausted
        case functionerrorinittimeout
        case functionerrorinvalidentrypoint
        case functionerrorinvalidworkingdirectory
        case functionerrorpermissiondenied
        case functionerrorruntimeiniterror
        case functionerrortoomanyextensions
        case idle
        case imageaccessdenied
        case imagedeleted
        case insufficientcapacity
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidruntime
        case invalidsecuritygroup
        case invalidstatekmskey
        case invalidsubnet
        case invalidzipfileexception
        case kmskeyaccessdenied
        case kmskeynotfound
        case restoring
        case subnetoutofipaddresses
        case vcpulimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StateReasonCode] {
            return [
                .capacityproviderscalinglimitexceeded,
                .creating,
                .disabledkmskey,
                .drainingdurableexecutions,
                .ec2requestlimitexceeded,
                .efsioerror,
                .efsmountconnectivityerror,
                .efsmountfailure,
                .efsmounttimeout,
                .enilimitexceeded,
                .functionerror,
                .functionerrorextensioniniterror,
                .functionerrorinitresourceexhausted,
                .functionerrorinittimeout,
                .functionerrorinvalidentrypoint,
                .functionerrorinvalidworkingdirectory,
                .functionerrorpermissiondenied,
                .functionerrorruntimeiniterror,
                .functionerrortoomanyextensions,
                .idle,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientcapacity,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidruntime,
                .invalidsecuritygroup,
                .invalidstatekmskey,
                .invalidsubnet,
                .invalidzipfileexception,
                .kmskeyaccessdenied,
                .kmskeynotfound,
                .restoring,
                .subnetoutofipaddresses,
                .vcpulimitexceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capacityproviderscalinglimitexceeded: return "CapacityProviderScalingLimitExceeded"
            case .creating: return "Creating"
            case .disabledkmskey: return "DisabledKMSKey"
            case .drainingdurableexecutions: return "DrainingDurableExecutions"
            case .ec2requestlimitexceeded: return "EC2RequestLimitExceeded"
            case .efsioerror: return "EFSIOError"
            case .efsmountconnectivityerror: return "EFSMountConnectivityError"
            case .efsmountfailure: return "EFSMountFailure"
            case .efsmounttimeout: return "EFSMountTimeout"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .functionerror: return "FunctionError"
            case .functionerrorextensioniniterror: return "FunctionError.ExtensionInitError"
            case .functionerrorinitresourceexhausted: return "FunctionError.InitResourceExhausted"
            case .functionerrorinittimeout: return "FunctionError.InitTimeout"
            case .functionerrorinvalidentrypoint: return "FunctionError.InvalidEntryPoint"
            case .functionerrorinvalidworkingdirectory: return "FunctionError.InvalidWorkingDirectory"
            case .functionerrorpermissiondenied: return "FunctionError.PermissionDenied"
            case .functionerrorruntimeiniterror: return "FunctionError.RuntimeInitError"
            case .functionerrortoomanyextensions: return "FunctionError.TooManyExtensions"
            case .idle: return "Idle"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientcapacity: return "InsufficientCapacity"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidruntime: return "InvalidRuntime"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidstatekmskey: return "InvalidStateKMSKey"
            case .invalidsubnet: return "InvalidSubnet"
            case .invalidzipfileexception: return "InvalidZipFileException"
            case .kmskeyaccessdenied: return "KMSKeyAccessDenied"
            case .kmskeynotfound: return "KMSKeyNotFound"
            case .restoring: return "Restoring"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case .vcpulimitexceeded: return "VcpuLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// The function's X-Ray tracing configuration.
    public struct TracingConfigResponse: Swift.Sendable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init(
            mode: LambdaClientTypes.TracingMode? = nil
        ) {
            self.mode = mode
        }
    }
}

extension LambdaClientTypes {

    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct VpcConfigResponse: Swift.Sendable {
        /// Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        public var ipv6AllowedForDualStack: Swift.Bool?
        /// A list of VPC security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            ipv6AllowedForDualStack: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        ) {
            self.ipv6AllowedForDualStack = ipv6AllowedForDualStack
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

/// Details about a function's configuration.
public struct CreateFunctionOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The SHA256 hash of the function configuration.
    public var configSha256: Swift.String?
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's durable execution configuration settings, if the function is configured for durability.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The function's tenant isolation configuration settings. Determines whether the Lambda function runs on a shared or dedicated infrastructure per unique tenant.
    public var tenancyConfig: LambdaClientTypes.TenancyConfig?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        configSha256: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    ) {
        self.architectures = architectures
        self.capacityProviderConfig = capacityProviderConfig
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.configSha256 = configSha256
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.tenancyConfig = tenancyConfig
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

extension LambdaClientTypes {

    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your Lambda function URL. Use CORS to grant access to your function URL from any origin. You can also use CORS to control access for specific HTTP headers and methods in requests to your function URL.
    public struct Cors: Swift.Sendable {
        /// Whether to allow cookies or other credentials in requests to your function URL. The default is false.
        public var allowCredentials: Swift.Bool?
        /// The HTTP headers that origins can include in requests to your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public var allowHeaders: [Swift.String]?
        /// The HTTP methods that are allowed when calling your function URL. For example: GET, POST, DELETE, or the wildcard character (*).
        public var allowMethods: [Swift.String]?
        /// The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: https://www.example.com, http://localhost:60905. Alternatively, you can grant access to all origins using the wildcard character (*).
        public var allowOrigins: [Swift.String]?
        /// The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public var exposeHeaders: [Swift.String]?
        /// The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to 0, which means that the browser doesn't cache results.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        ) {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }
}

extension LambdaClientTypes {

    public enum InvokeMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case buffered
        case responseStream
        case sdkUnknown(Swift.String)

        public static var allCases: [InvokeMode] {
            return [
                .buffered,
                .responseStream
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .buffered: return "BUFFERED"
            case .responseStream: return "RESPONSE_STREAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFunctionUrlConfigInput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Control access to Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 200 MB.
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        functionName: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.authType = authType
        self.cors = cors
        self.functionName = functionName
        self.invokeMode = invokeMode
        self.qualifier = qualifier
    }
}

public struct CreateFunctionUrlConfigOutput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Control access to Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 200 MB.
    public var invokeMode: LambdaClientTypes.InvokeMode?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil
    ) {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
    }
}

public struct DeleteFunctionCodeSigningConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    ) {
        self.functionName = functionName
    }
}

public struct DeleteFunctionConcurrencyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    ) {
        self.functionName = functionName
    }
}

public struct DeleteFunctionUrlConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetFunctionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    /// Details about a function's deployment package.
    public struct FunctionCodeLocation: Swift.Sendable {
        /// URI of a container image in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// A presigned URL that you can use to download the deployment package.
        public var location: Swift.String?
        /// The service that's hosting the file.
        public var repositoryType: Swift.String?
        /// The resolved URI for the image.
        public var resolvedImageUri: Swift.String?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's .zip deployment package. If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk).
        public var sourceKMSKeyArn: Swift.String?

        public init(
            imageUri: Swift.String? = nil,
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil,
            resolvedImageUri: Swift.String? = nil,
            sourceKMSKeyArn: Swift.String? = nil
        ) {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
            self.sourceKMSKeyArn = sourceKMSKeyArn
        }
    }
}

extension LambdaClientTypes {

    public struct Concurrency: Swift.Sendable {
        /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Lambda reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
        public var reservedConcurrentExecutions: Swift.Int?

        public init(
            reservedConcurrentExecutions: Swift.Int? = nil
        ) {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }
    }
}

extension LambdaClientTypes {

    /// Details about a function's configuration.
    public struct FunctionConfiguration: Swift.Sendable {
        /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
        public var architectures: [LambdaClientTypes.Architecture]?
        /// Configuration for the capacity provider that manages compute resources for Lambda functions.
        public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The size of the function's deployment package, in bytes.
        public var codeSize: Swift.Int
        /// The SHA256 hash of the function configuration.
        public var configSha256: Swift.String?
        /// The function's dead letter queue.
        public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
        /// The function's description.
        public var description: Swift.String?
        /// The function's durable execution configuration settings, if the function is configured for durability.
        public var durableConfig: LambdaClientTypes.DurableConfig?
        /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
        public var environment: LambdaClientTypes.EnvironmentResponse?
        /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
        public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
        /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
        public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public var functionArn: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin running your function.
        public var handler: Swift.String?
        /// The function's image configuration values.
        public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
        /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
        ///
        /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
        ///
        /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
        ///
        /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
        ///
        /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
        ///
        ///
        /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
        public var kmsKeyArn: Swift.String?
        /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var lastModified: Swift.String?
        /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
        public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public var lastUpdateStatusReason: Swift.String?
        /// The reason code for the last update that was performed on the function.
        public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
        /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
        public var layers: [LambdaClientTypes.Layer]?
        /// The function's Amazon CloudWatch Logs configuration settings.
        public var loggingConfig: LambdaClientTypes.LoggingConfig?
        /// For Lambda@Edge functions, the ARN of the main function.
        public var masterArn: Swift.String?
        /// The amount of memory available to the function at runtime.
        public var memorySize: Swift.Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: LambdaClientTypes.PackageType?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
        public var runtime: LambdaClientTypes.Runtime?
        /// The ARN of the runtime and any errors that occured.
        public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
        /// The ARN of the signing job.
        public var signingJobArn: Swift.String?
        /// The ARN of the signing profile version.
        public var signingProfileVersionArn: Swift.String?
        /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
        public var snapStart: LambdaClientTypes.SnapStartResponse?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
        public var state: LambdaClientTypes.State?
        /// The reason for the function's current state.
        public var stateReason: Swift.String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
        public var stateReasonCode: LambdaClientTypes.StateReasonCode?
        /// The function's tenant isolation configuration settings. Determines whether the Lambda function runs on a shared or dedicated infrastructure per unique tenant.
        public var tenancyConfig: LambdaClientTypes.TenancyConfig?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int?
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

        public init(
            architectures: [LambdaClientTypes.Architecture]? = nil,
            capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            configSha256: Swift.String? = nil,
            deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
            description: Swift.String? = nil,
            durableConfig: LambdaClientTypes.DurableConfig? = nil,
            environment: LambdaClientTypes.EnvironmentResponse? = nil,
            ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
            fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
            functionArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
            lastUpdateStatusReason: Swift.String? = nil,
            lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
            layers: [LambdaClientTypes.Layer]? = nil,
            loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            packageType: LambdaClientTypes.PackageType? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: LambdaClientTypes.Runtime? = nil,
            runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil,
            snapStart: LambdaClientTypes.SnapStartResponse? = nil,
            state: LambdaClientTypes.State? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
            tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
            timeout: Swift.Int? = nil,
            tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
            version: Swift.String? = nil,
            vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
        ) {
            self.architectures = architectures
            self.capacityProviderConfig = capacityProviderConfig
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.configSha256 = configSha256
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.durableConfig = durableConfig
            self.environment = environment
            self.ephemeralStorage = ephemeralStorage
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.loggingConfig = loggingConfig
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.runtimeVersionConfig = runtimeVersionConfig
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.snapStart = snapStart
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.tenancyConfig = tenancyConfig
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }
}

extension LambdaClientTypes {

    /// An object that contains details about an error related to retrieving tags.
    public struct TagsError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.message = message
        }
    }
}

public struct GetFunctionOutput: Swift.Sendable {
    /// The deployment package of the function or version.
    public var code: LambdaClientTypes.FunctionCodeLocation?
    /// The function's [reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html).
    public var concurrency: LambdaClientTypes.Concurrency?
    /// The configuration of the function or version.
    public var configuration: LambdaClientTypes.FunctionConfiguration?
    /// The function's [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html). Lambda returns tag data only if you have explicit allow permissions for [lambda:ListTags](https://docs.aws.amazon.com/lambda/latest/api/API_ListTags.html).
    public var tags: [Swift.String: Swift.String]?
    /// An object that contains details about an error related to retrieving tags.
    public var tagsError: LambdaClientTypes.TagsError?

    public init(
        code: LambdaClientTypes.FunctionCodeLocation? = nil,
        concurrency: LambdaClientTypes.Concurrency? = nil,
        configuration: LambdaClientTypes.FunctionConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tagsError: LambdaClientTypes.TagsError? = nil
    ) {
        self.code = code
        self.concurrency = concurrency
        self.configuration = configuration
        self.tags = tags
        self.tagsError = tagsError
    }
}

public struct GetFunctionCodeSigningConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    ) {
        self.functionName = functionName
    }
}

public struct GetFunctionCodeSigningConfigOutput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    ) {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

public struct GetFunctionConcurrencyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    ) {
        self.functionName = functionName
    }
}

public struct GetFunctionConcurrencyOutput: Swift.Sendable {
    /// The number of simultaneous executions that are reserved for the function.
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        reservedConcurrentExecutions: Swift.Int? = nil
    ) {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct GetFunctionConfigurationInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

/// Details about a function's configuration.
public struct GetFunctionConfigurationOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The SHA256 hash of the function configuration.
    public var configSha256: Swift.String?
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's durable execution configuration settings, if the function is configured for durability.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The function's tenant isolation configuration settings. Determines whether the Lambda function runs on a shared or dedicated infrastructure per unique tenant.
    public var tenancyConfig: LambdaClientTypes.TenancyConfig?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        configSha256: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    ) {
        self.architectures = architectures
        self.capacityProviderConfig = capacityProviderConfig
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.configSha256 = configSha256
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.tenancyConfig = tenancyConfig
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct GetFunctionRecursionConfigInput: Swift.Sendable {
    /// The name of the function.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    ) {
        self.functionName = functionName
    }
}

extension LambdaClientTypes {

    public enum RecursiveLoop: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [RecursiveLoop] {
            return [
                .allow,
                .terminate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "Allow"
            case .terminate: return "Terminate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFunctionRecursionConfigOutput: Swift.Sendable {
    /// If your function's recursive loop detection configuration is Allow, Lambda doesn't take any action when it detects your function being invoked as part of a recursive loop. If your function's recursive loop detection configuration is Terminate, Lambda stops your function being invoked and notifies you when it detects your function being invoked as part of a recursive loop. By default, Lambda sets your function's configuration to Terminate. You can update this configuration using the [PutFunctionRecursionConfig] action.
    public var recursiveLoop: LambdaClientTypes.RecursiveLoop?

    public init(
        recursiveLoop: LambdaClientTypes.RecursiveLoop? = nil
    ) {
        self.recursiveLoop = recursiveLoop
    }
}

public struct GetFunctionScalingConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get the scaling configuration for a published version of the function.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    /// Configuration that defines the scaling behavior for a Lambda Managed Instances function, including the minimum and maximum number of execution environments that can be provisioned.
    public struct FunctionScalingConfig: Swift.Sendable {
        /// The maximum number of execution environments that can be provisioned for the function.
        public var maxExecutionEnvironments: Swift.Int?
        /// The minimum number of execution environments to maintain for the function.
        public var minExecutionEnvironments: Swift.Int?

        public init(
            maxExecutionEnvironments: Swift.Int? = nil,
            minExecutionEnvironments: Swift.Int? = nil
        ) {
            self.maxExecutionEnvironments = maxExecutionEnvironments
            self.minExecutionEnvironments = minExecutionEnvironments
        }
    }
}

public struct GetFunctionScalingConfigOutput: Swift.Sendable {
    /// The scaling configuration that is currently applied to the function. This represents the actual scaling settings in effect.
    public var appliedFunctionScalingConfig: LambdaClientTypes.FunctionScalingConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The scaling configuration that was requested for the function.
    public var requestedFunctionScalingConfig: LambdaClientTypes.FunctionScalingConfig?

    public init(
        appliedFunctionScalingConfig: LambdaClientTypes.FunctionScalingConfig? = nil,
        functionArn: Swift.String? = nil,
        requestedFunctionScalingConfig: LambdaClientTypes.FunctionScalingConfig? = nil
    ) {
        self.appliedFunctionScalingConfig = appliedFunctionScalingConfig
        self.functionArn = functionArn
        self.requestedFunctionScalingConfig = requestedFunctionScalingConfig
    }
}

public struct GetFunctionUrlConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetFunctionUrlConfigOutput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Control access to Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 200 MB.
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var lastModifiedTime: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        lastModifiedTime: Swift.String? = nil
    ) {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
        self.lastModifiedTime = lastModifiedTime
    }
}

public struct GetPolicyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get the policy for that resource.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetPolicyOutput: Swift.Sendable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    ) {
        self.policy = policy
        self.revisionId = revisionId
    }
}

public struct GetRuntimeManagementConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the $LATEST version is returned.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

extension LambdaClientTypes {

    public enum UpdateRuntimeOn: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case functionupdate
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRuntimeOn] {
            return [
                .auto,
                .functionupdate,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .functionupdate: return "FunctionUpdate"
            case .manual: return "Manual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetRuntimeManagementConfigOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of your function.
    public var functionArn: Swift.String?
    /// The ARN of the runtime the function is configured to use. If the runtime update mode is Manual, the ARN is returned, otherwise null is returned.
    public var runtimeVersionArn: Swift.String?
    /// The current runtime update mode of the function.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionArn: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    ) {
        self.functionArn = functionArn
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

/// The durable execution with the specified name has already been started. Each durable execution name must be unique within the function. Use a different name or check the status of the existing execution.
public struct DurableExecutionAlreadyStartedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DurableExecutionAlreadyStartedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Need additional permissions to configure VPC settings.
public struct EC2AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Amazon EC2 throttled Lambda during Lambda function initialization using the execution role provided for the function.
public struct EC2ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda function.
public struct EC2UnexpectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var ec2ErrorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2UnexpectedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        ec2ErrorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.ec2ErrorCode = ec2ErrorCode
        self.properties.message = message
        self.properties.type = type
    }
}

/// An error occurred when reading from or writing to a connected file system.
public struct EFSIOException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSIOException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda function couldn't make a network connection to the configured file system.
public struct EFSMountConnectivityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountConnectivityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda function couldn't mount the configured file system due to a permission or configuration issue.
public struct EFSMountFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The Lambda function made a network connection to the configured file system, but the mount operation timed out.
public struct EFSMountTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct ENILimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ENILimitReachedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The request body could not be parsed as JSON, or a request header is invalid. For example, the 'x-amzn-RequestId' header is not a valid UUID string.
public struct InvalidRequestContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestContentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The runtime or runtime version specified is not supported.
public struct InvalidRuntimeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuntimeException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The security group ID provided in the Lambda function VPC configuration is not valid.
public struct InvalidSecurityGroupIDException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurityGroupIDException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The subnet ID provided in the Lambda function VPC configuration is not valid.
public struct InvalidSubnetIDException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnetIDException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda could not unzip the deployment package.
public struct InvalidZipFileException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidZipFileException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.
public struct KMSAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.
public struct KMSDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabledException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because the state of the KMS key used is not valid for Decrypt. Check the function's KMS key settings.
public struct KMSInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.
public struct KMSNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The function has no published versions available.
public struct NoPublishedVersionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoPublishedVersionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda has detected your function being invoked in a recursive loop with other Amazon Web Services resources and stopped your function's invocation.
public struct RecursiveInvocationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RecursiveInvocationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The request payload exceeded the Invoke request body JSON input quota. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct RequestTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The request payload exceeded the maximum allowed size for serialized request entities.
public struct SerializedRequestEntityTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The error type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SerializedRequestEntityTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The afterRestore()[runtime hook](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-runtime-hooks.html) encountered an error. For more information, check the Amazon CloudWatch logs.
public struct SnapStartException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda is initializing your function. You can invoke the function when the [function state](https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html) becomes Active.
public struct SnapStartNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't restore the snapshot within the timeout limit.
public struct SnapStartTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// Lambda couldn't set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.
public struct SubnetIPAddressLimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetIPAddressLimitReachedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

/// The content type of the Invoke request body is not JSON.
public struct UnsupportedMediaTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedMediaTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

extension LambdaClientTypes {

    public enum InvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dryrun
        case event
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .dryrun,
                .event,
                .requestresponse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .event: return "Event"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    public enum LogType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case tail
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .none,
                .tail
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .tail: return "Tail"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeInput: Swift.Sendable {
    /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object. Lambda passes the ClientContext object to your function for synchronous invocations only.
    public var clientContext: Swift.String?
    /// Optional unique name for the durable execution. When you start your special function, you can give it a unique name to identify this specific execution. It's like giving a nickname to a task.
    public var durableExecutionName: Swift.String?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Choose from the following options.
    ///
    /// * RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API response includes the function response and additional data.
    ///
    /// * Event – Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if one is configured). The API response only includes a status code.
    ///
    /// * DryRun – Validate parameter values and verify that the user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.InvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. The maximum payload size is 6 MB for synchronous invocations and 1 MB for asynchronous invocations. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: Foundation.Data?
    /// Specify a version or alias to invoke a published version of the function.
    public var qualifier: Swift.String?
    /// The identifier of the tenant in a multi-tenant Lambda function.
    public var tenantId: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        durableExecutionName: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.InvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: Foundation.Data? = nil,
        qualifier: Swift.String? = nil,
        tenantId: Swift.String? = nil
    ) {
        self.clientContext = clientContext
        self.durableExecutionName = durableExecutionName
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
        self.tenantId = tenantId
    }
}

extension InvokeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeInput(clientContext: \(Swift.String(describing: clientContext)), durableExecutionName: \(Swift.String(describing: durableExecutionName)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), qualifier: \(Swift.String(describing: qualifier)), tenantId: \(Swift.String(describing: tenantId)), payload: \"CONTENT_REDACTED\")"}
}

public struct InvokeOutput: Swift.Sendable {
    /// The ARN of the durable execution that was started. This is returned when invoking a durable function and provides a unique identifier for tracking the execution.
    public var durableExecutionArn: Swift.String?
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// If present, indicates that an error occurred during function execution. Details about the error are included in the response payload.
    public var functionError: Swift.String?
    /// The last 4 KB of the execution log, which is base64-encoded.
    public var logResult: Swift.String?
    /// The response from the function, or an error object.
    public var payload: Foundation.Data?
    /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse invocation type, this status code is 200. For the Event invocation type, this status code is 202. For the DryRun invocation type, the status code is 204.
    public var statusCode: Swift.Int

    public init(
        durableExecutionArn: Swift.String? = nil,
        executedVersion: Swift.String? = nil,
        functionError: Swift.String? = nil,
        logResult: Swift.String? = nil,
        payload: Foundation.Data? = nil,
        statusCode: Swift.Int = 0
    ) {
        self.durableExecutionArn = durableExecutionArn
        self.executedVersion = executedVersion
        self.functionError = functionError
        self.logResult = logResult
        self.payload = payload
        self.statusCode = statusCode
    }
}

extension InvokeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeOutput(durableExecutionArn: \(Swift.String(describing: durableExecutionArn)), executedVersion: \(Swift.String(describing: executedVersion)), functionError: \(Swift.String(describing: functionError)), logResult: \(Swift.String(describing: logResult)), statusCode: \(Swift.String(describing: statusCode)), payload: \"CONTENT_REDACTED\")"}
}

@available(*, deprecated)
public struct InvokeAsyncInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The JSON that you want to provide to your Lambda function as input.
    /// This member is required.
    public var invokeArgs: Smithy.ByteStream?

    public init(
        functionName: Swift.String? = nil,
        invokeArgs: Smithy.ByteStream? = nil
    ) {
        self.functionName = functionName
        self.invokeArgs = invokeArgs
    }
}

/// A success response (202 Accepted) indicates that the request is queued for invocation.
@available(*, deprecated)
public struct InvokeAsyncOutput: Swift.Sendable {
    /// The status code.
    public var status: Swift.Int

    public init(
        status: Swift.Int = 0
    ) {
        self.status = status
    }
}

extension LambdaClientTypes {

    public enum ResponseStreamingInvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dryrun
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseStreamingInvocationType] {
            return [
                .dryrun,
                .requestresponse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeWithResponseStreamInput: Swift.Sendable {
    /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
    public var clientContext: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API operation response includes the function response and additional data.
    ///
    /// * DryRun – Validate parameter values and verify that the IAM user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.ResponseStreamingInvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: Foundation.Data?
    /// The alias name.
    public var qualifier: Swift.String?
    /// The identifier of the tenant in a multi-tenant Lambda function.
    public var tenantId: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.ResponseStreamingInvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: Foundation.Data? = nil,
        qualifier: Swift.String? = nil,
        tenantId: Swift.String? = nil
    ) {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
        self.tenantId = tenantId
    }
}

extension InvokeWithResponseStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeWithResponseStreamInput(clientContext: \(Swift.String(describing: clientContext)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), qualifier: \(Swift.String(describing: qualifier)), tenantId: \(Swift.String(describing: tenantId)), payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// A response confirming that the event stream is complete.
    public struct InvokeWithResponseStreamCompleteEvent: Swift.Sendable {
        /// An error code.
        public var errorCode: Swift.String?
        /// The details of any returned error.
        public var errorDetails: Swift.String?
        /// The last 4 KB of the execution log, which is base64-encoded.
        public var logResult: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorDetails: Swift.String? = nil,
            logResult: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
            self.logResult = logResult
        }
    }
}

extension LambdaClientTypes {

    /// A chunk of the streamed response payload.
    public struct InvokeResponseStreamUpdate: Swift.Sendable {
        /// Data returned by your Lambda function.
        public var payload: Foundation.Data?

        public init(
            payload: Foundation.Data? = nil
        ) {
            self.payload = payload
        }
    }
}

extension LambdaClientTypes.InvokeResponseStreamUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeResponseStreamUpdate(payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// An object that includes a chunk of the response payload. When the stream has ended, Lambda includes a InvokeComplete object.
    public enum InvokeWithResponseStreamResponseEvent: Swift.Sendable {
        /// A chunk of the streamed response payload.
        case payloadchunk(LambdaClientTypes.InvokeResponseStreamUpdate)
        /// An object that's returned when the stream has ended and all the payload chunks have been returned.
        case invokecomplete(LambdaClientTypes.InvokeWithResponseStreamCompleteEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeWithResponseStreamOutput: Swift.Sendable {
    /// The stream of response payloads.
    public var eventStream: AsyncThrowingStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent, Swift.Error>?
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// The type of data the stream is returning.
    public var responseStreamContentType: Swift.String?
    /// For a successful request, the HTTP status code is in the 200 range. For the RequestResponse invocation type, this status code is 200. For the DryRun invocation type, this status code is 204.
    public var statusCode: Swift.Int

    public init(
        eventStream: AsyncThrowingStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent, Swift.Error>? = nil,
        executedVersion: Swift.String? = nil,
        responseStreamContentType: Swift.String? = nil,
        statusCode: Swift.Int = 0
    ) {
        self.eventStream = eventStream
        self.executedVersion = executedVersion
        self.responseStreamContentType = responseStreamContentType
        self.statusCode = statusCode
    }
}

extension LambdaClientTypes {

    public enum FunctionVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionVersion] {
            return [
                .all
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListFunctionsInput: Swift.Sendable {
    /// Set to ALL to include entries for all published versions of each function.
    public var functionVersion: LambdaClientTypes.FunctionVersion?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// For Lambda@Edge functions, the Amazon Web Services Region of the master function. For example, us-east-1 filters the list of functions to include only Lambda@Edge functions replicated from a master function in US East (N. Virginia). If specified, you must set FunctionVersion to ALL.
    public var masterRegion: Swift.String?
    /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionVersion: LambdaClientTypes.FunctionVersion? = nil,
        marker: Swift.String? = nil,
        masterRegion: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.functionVersion = functionVersion
        self.marker = marker
        self.masterRegion = masterRegion
        self.maxItems = maxItems
    }
}

/// A list of Lambda functions.
public struct ListFunctionsOutput: Swift.Sendable {
    /// A list of Lambda functions.
    public var functions: [LambdaClientTypes.FunctionConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functions: [LambdaClientTypes.FunctionConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.functions = functions
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionUrlConfigsInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of function URLs to return in the response. Note that ListFunctionUrlConfigs returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// Details about a Lambda function URL.
    public struct FunctionUrlConfig: Swift.Sendable {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
        /// This member is required.
        public var authType: LambdaClientTypes.FunctionUrlAuthType?
        /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
        public var cors: LambdaClientTypes.Cors?
        /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var creationTime: Swift.String?
        /// The Amazon Resource Name (ARN) of your function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// The HTTP URL endpoint for your function.
        /// This member is required.
        public var functionUrl: Swift.String?
        /// Use one of the following options:
        ///
        /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
        ///
        /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 200 MB.
        public var invokeMode: LambdaClientTypes.InvokeMode?
        /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModifiedTime: Swift.String?

        public init(
            authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
            cors: LambdaClientTypes.Cors? = nil,
            creationTime: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionUrl: Swift.String? = nil,
            invokeMode: LambdaClientTypes.InvokeMode? = nil,
            lastModifiedTime: Swift.String? = nil
        ) {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct ListFunctionUrlConfigsOutput: Swift.Sendable {
    /// A list of function URL configurations.
    /// This member is required.
    public var functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.functionUrlConfigs = functionUrlConfigs
        self.nextMarker = nextMarker
    }
}

public struct ListProvisionedConcurrencyConfigsInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Specify a number to limit the number of configurations returned.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    public enum ProvisionedConcurrencyStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedConcurrencyStatusEnum] {
            return [
                .failed,
                .inProgress,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Details about the provisioned concurrency configuration for a function alias or version.
    public struct ProvisionedConcurrencyConfigListItem: Swift.Sendable {
        /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
        public var allocatedProvisionedConcurrentExecutions: Swift.Int?
        /// The amount of provisioned concurrency available.
        public var availableProvisionedConcurrentExecutions: Swift.Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public var functionArn: Swift.String?
        /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
        public var lastModified: Swift.String?
        /// The amount of provisioned concurrency requested.
        public var requestedProvisionedConcurrentExecutions: Swift.Int?
        /// The status of the allocation process.
        public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public var statusReason: Swift.String?

        public init(
            allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
            availableProvisionedConcurrentExecutions: Swift.Int? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
            status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListProvisionedConcurrencyConfigsOutput: Swift.Sendable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of provisioned concurrency configurations.
    public var provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?

    public init(
        nextMarker: Swift.String? = nil,
        provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
    ) {
        self.nextMarker = nextMarker
        self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
    }
}

public struct PutFunctionCodeSigningConfigInput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    ) {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

public struct PutFunctionCodeSigningConfigOutput: Swift.Sendable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    ) {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

public struct PutFunctionConcurrencyInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The number of simultaneous executions to reserve for the function.
    /// This member is required.
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        reservedConcurrentExecutions: Swift.Int? = nil
    ) {
        self.functionName = functionName
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct PutFunctionConcurrencyOutput: Swift.Sendable {
    /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Lambda reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        reservedConcurrentExecutions: Swift.Int? = nil
    ) {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct PutFunctionRecursionConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// If you set your function's recursive loop detection configuration to Allow, Lambda doesn't take any action when it detects your function being invoked as part of a recursive loop. We recommend that you only use this setting if your design intentionally uses a Lambda function to write data back to the same Amazon Web Services resource that invokes it. If you set your function's recursive loop detection configuration to Terminate, Lambda stops your function being invoked and notifies you when it detects your function being invoked as part of a recursive loop. By default, Lambda sets your function's configuration to Terminate. If your design intentionally uses a Lambda function to write data back to the same Amazon Web Services resource that invokes the function, then use caution and implement suitable guard rails to prevent unexpected charges being billed to your Amazon Web Services account. To learn more about best practices for using recursive invocation patterns, see [Recursive patterns that cause run-away Lambda functions](https://serverlessland.com/content/service/lambda/guides/aws-lambda-operator-guide/recursive-runaway) in Serverless Land.
    /// This member is required.
    public var recursiveLoop: LambdaClientTypes.RecursiveLoop?

    public init(
        functionName: Swift.String? = nil,
        recursiveLoop: LambdaClientTypes.RecursiveLoop? = nil
    ) {
        self.functionName = functionName
        self.recursiveLoop = recursiveLoop
    }
}

public struct PutFunctionRecursionConfigOutput: Swift.Sendable {
    /// The status of your function's recursive loop detection configuration. When this value is set to Allowand Lambda detects your function being invoked as part of a recursive loop, it doesn't take any action. When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive loop, it stops your function being invoked and notifies you.
    public var recursiveLoop: LambdaClientTypes.RecursiveLoop?

    public init(
        recursiveLoop: LambdaClientTypes.RecursiveLoop? = nil
    ) {
        self.recursiveLoop = recursiveLoop
    }
}

public struct PutFunctionScalingConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function.
    /// This member is required.
    public var functionName: Swift.String?
    /// The scaling configuration to apply to the function, including minimum and maximum execution environment limits.
    public var functionScalingConfig: LambdaClientTypes.FunctionScalingConfig?
    /// Specify a version or alias to set the scaling configuration for a published version of the function.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        functionScalingConfig: LambdaClientTypes.FunctionScalingConfig? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.functionScalingConfig = functionScalingConfig
        self.qualifier = qualifier
    }
}

public struct PutFunctionScalingConfigOutput: Swift.Sendable {
    /// The current state of the function after applying the scaling configuration.
    public var functionState: LambdaClientTypes.State?

    public init(
        functionState: LambdaClientTypes.State? = nil
    ) {
        self.functionState = functionState
    }
}

public struct PutRuntimeManagementConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the $LATEST version is returned.
    public var qualifier: Swift.String?
    /// The ARN of the runtime version you want the function to use. This is only required if you're using the Manual runtime update mode.
    public var runtimeVersionArn: Swift.String?
    /// Specify the runtime update mode.
    ///
    /// * Auto (default) - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
    ///
    /// * Function update - Lambda updates the runtime of your function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
    ///
    /// * Manual - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
    /// This member is required.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

public struct PutRuntimeManagementConfigOutput: Swift.Sendable {
    /// The ARN of the function
    /// This member is required.
    public var functionArn: Swift.String?
    /// The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
    public var runtimeVersionArn: Swift.String?
    /// The runtime update mode.
    /// This member is required.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionArn: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    ) {
        self.functionArn = functionArn
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

public struct UpdateFunctionCodeInput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Set to true to validate the request parameters and access permissions without modifying the function code.
    public var dryRun: Swift.Bool?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// URI of a container image in the Amazon ECR registry. Do not use for a function defined with a .zip file archive.
    public var imageUri: Swift.String?
    /// Set to true to publish a new version of the function after updating the code. This has the same effect as calling [PublishVersion] separately.
    public var publish: Swift.Bool?
    /// Specifies where to publish the function version or configuration.
    public var publishTo: LambdaClientTypes.FunctionVersionLatestPublished?
    /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account. Use only with a function defined with a .zip file archive deployment package.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 key of the deployment package. Use only with a function defined with a .zip file archive deployment package.
    public var s3Key: Swift.String?
    /// For versioned objects, the version of the deployment package object to use.
    public var s3ObjectVersion: Swift.String?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's .zip deployment package. If you don't provide a customer managed key, Lambda uses an Amazon Web Services managed key.
    public var sourceKMSKeyArn: Swift.String?
    /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you. Use only with a function defined with a .zip file archive deployment package.
    public var zipFile: Foundation.Data?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        dryRun: Swift.Bool? = false,
        functionName: Swift.String? = nil,
        imageUri: Swift.String? = nil,
        publish: Swift.Bool? = false,
        publishTo: LambdaClientTypes.FunctionVersionLatestPublished? = nil,
        revisionId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3Key: Swift.String? = nil,
        s3ObjectVersion: Swift.String? = nil,
        sourceKMSKeyArn: Swift.String? = nil,
        zipFile: Foundation.Data? = nil
    ) {
        self.architectures = architectures
        self.dryRun = dryRun
        self.functionName = functionName
        self.imageUri = imageUri
        self.publish = publish
        self.publishTo = publishTo
        self.revisionId = revisionId
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.sourceKMSKeyArn = sourceKMSKeyArn
        self.zipFile = zipFile
    }
}

extension UpdateFunctionCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionCodeInput(architectures: \(Swift.String(describing: architectures)), dryRun: \(Swift.String(describing: dryRun)), functionName: \(Swift.String(describing: functionName)), imageUri: \(Swift.String(describing: imageUri)), publish: \(Swift.String(describing: publish)), publishTo: \(Swift.String(describing: publishTo)), revisionId: \(Swift.String(describing: revisionId)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), sourceKMSKeyArn: \(Swift.String(describing: sourceKMSKeyArn)), zipFile: \"CONTENT_REDACTED\")"}
}

/// Details about a function's configuration.
public struct UpdateFunctionCodeOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The SHA256 hash of the function configuration.
    public var configSha256: Swift.String?
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's durable execution configuration settings, if the function is configured for durability.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The function's tenant isolation configuration settings. Determines whether the Lambda function runs on a shared or dedicated infrastructure per unique tenant.
    public var tenancyConfig: LambdaClientTypes.TenancyConfig?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        configSha256: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    ) {
        self.architectures = architectures
        self.capacityProviderConfig = capacityProviderConfig
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.configSha256 = configSha256
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.tenancyConfig = tenancyConfig
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateFunctionConfigurationInput: Swift.Sendable {
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Configuration settings for durable functions. Allows updating execution timeout and retention period for functions with durability enabled.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
    public var handler: Swift.String?
    /// [Container image configuration values](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms) that override the values in the container image Docker file.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public var snapStart: LambdaClientTypes.SnapStart?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init(
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        memorySize: Swift.Int? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        snapStart: LambdaClientTypes.SnapStart? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    ) {
        self.capacityProviderConfig = capacityProviderConfig
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kmsKeyArn = kmsKeyArn
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.snapStart = snapStart
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionConfigurationOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The SHA256 hash of the function configuration.
    public var configSha256: Swift.String?
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's durable execution configuration settings, if the function is configured for durability.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The function's tenant isolation configuration settings. Determines whether the Lambda function runs on a shared or dedicated infrastructure per unique tenant.
    public var tenancyConfig: LambdaClientTypes.TenancyConfig?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        configSha256: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    ) {
        self.architectures = architectures
        self.capacityProviderConfig = capacityProviderConfig
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.configSha256 = configSha256
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.tenancyConfig = tenancyConfig
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateFunctionUrlConfigInput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Control access to Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 200 MB.
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        functionName: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.authType = authType
        self.cors = cors
        self.functionName = functionName
        self.invokeMode = invokeMode
        self.qualifier = qualifier
    }
}

public struct UpdateFunctionUrlConfigOutput: Swift.Sendable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Control access to Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 200 MB.
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var lastModifiedTime: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        lastModifiedTime: Swift.String? = nil
    ) {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
        self.lastModifiedTime = lastModifiedTime
    }
}

public struct CreateAliasInput: Swift.Sendable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    ) {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.routingConfig = routingConfig
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct CreateAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    ) {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

public struct DeleteAliasInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.name = name
    }
}

public struct GetAliasInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.name = name
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct GetAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    ) {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

public struct ListAliasesInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a function version to only list aliases that invoke that version.
    public var functionVersion: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Limit the number of aliases returned.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListAliasesOutput: Swift.Sendable {
    /// A list of aliases.
    public var aliases: [LambdaClientTypes.AliasConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        aliases: [LambdaClientTypes.AliasConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.aliases = aliases
        self.nextMarker = nextMarker
    }
}

public struct UpdateAliasInput: Swift.Sendable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    ) {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct UpdateAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    ) {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

public struct ListVersionsByFunctionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListVersionsByFunctionOutput: Swift.Sendable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of Lambda function versions.
    public var versions: [LambdaClientTypes.FunctionConfiguration]?

    public init(
        nextMarker: Swift.String? = nil,
        versions: [LambdaClientTypes.FunctionConfiguration]? = nil
    ) {
        self.nextMarker = nextMarker
        self.versions = versions
    }
}

public struct PublishVersionInput: Swift.Sendable {
    /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of [UpdateFunctionCode].
    public var codeSha256: Swift.String?
    /// A description for the version to override the description in the function configuration.
    public var description: Swift.String?
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specifies where to publish the function version or configuration.
    public var publishTo: LambdaClientTypes.FunctionVersionLatestPublished?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.
    public var revisionId: Swift.String?

    public init(
        codeSha256: Swift.String? = nil,
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        publishTo: LambdaClientTypes.FunctionVersionLatestPublished? = nil,
        revisionId: Swift.String? = nil
    ) {
        self.codeSha256 = codeSha256
        self.description = description
        self.functionName = functionName
        self.publishTo = publishTo
        self.revisionId = revisionId
    }
}

/// Details about a function's configuration.
public struct PublishVersionOutput: Swift.Sendable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Configuration for the capacity provider that manages compute resources for Lambda functions.
    public var capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The SHA256 hash of the function configuration.
    public var configSha256: Swift.String?
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's durable execution configuration settings, if the function is configured for durability.
    public var durableConfig: LambdaClientTypes.DurableConfig?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see [Configuring ephemeral storage (console)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage).
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt the following resources:
    ///
    /// * The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
    ///
    /// * The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) snapshots.
    ///
    /// * When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see [ Specifying a customer managed key for Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
    ///
    /// * The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see [Function lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
    ///
    ///
    /// If you don't provide a customer managed key, Lambda uses an [Amazon Web Services owned key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) or an [Amazon Web Services managed key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// The function's Amazon CloudWatch Logs configuration settings.
    public var loggingConfig: LambdaClientTypes.LoggingConfig?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [ runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you're deploying a function using a container image. The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The function's tenant isolation configuration settings. Determines whether the Lambda function runs on a shared or dedicated infrastructure per unique tenant.
    public var tenancyConfig: LambdaClientTypes.TenancyConfig?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        capacityProviderConfig: LambdaClientTypes.CapacityProviderConfig? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        configSha256: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        durableConfig: LambdaClientTypes.DurableConfig? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        loggingConfig: LambdaClientTypes.LoggingConfig? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        tenancyConfig: LambdaClientTypes.TenancyConfig? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    ) {
        self.architectures = architectures
        self.capacityProviderConfig = capacityProviderConfig
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.configSha256 = configSha256
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.durableConfig = durableConfig
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.loggingConfig = loggingConfig
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.tenancyConfig = tenancyConfig
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

public struct GetAccountSettingsInput: Swift.Sendable {

    public init() { }
}

public struct GetAccountSettingsOutput: Swift.Sendable {
    /// Limits that are related to concurrency and code storage.
    public var accountLimit: LambdaClientTypes.AccountLimit?
    /// The number of functions and amount of storage in use.
    public var accountUsage: LambdaClientTypes.AccountUsage?

    public init(
        accountLimit: LambdaClientTypes.AccountLimit? = nil,
        accountUsage: LambdaClientTypes.AccountUsage? = nil
    ) {
        self.accountLimit = accountLimit
        self.accountUsage = accountUsage
    }
}

public struct GetDurableExecutionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the durable execution.
    /// This member is required.
    public var durableExecutionArn: Swift.String?

    public init(
        durableExecutionArn: Swift.String? = nil
    ) {
        self.durableExecutionArn = durableExecutionArn
    }
}

extension LambdaClientTypes {

    public enum ExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case stopped
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .failed,
                .running,
                .stopped,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Contains trace headers for the Lambda durable execution.
    public struct TraceHeader: Swift.Sendable {
        /// The X-Ray trace header associated with the durable execution.
        public var xAmznTraceId: Swift.String?

        public init(
            xAmznTraceId: Swift.String? = nil
        ) {
            self.xAmznTraceId = xAmznTraceId
        }
    }
}

/// The response from the GetDurableExecution operation, containing detailed information about the durable execution.
public struct GetDurableExecutionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the durable execution.
    /// This member is required.
    public var durableExecutionArn: Swift.String?
    /// The name of the durable execution. This is either the name you provided when invoking the function, or a system-generated unique identifier if no name was provided.
    /// This member is required.
    public var durableExecutionName: Swift.String?
    /// The date and time when the durable execution ended, in Unix timestamp format. This field is only present if the execution has completed (status is SUCCEEDED, FAILED, TIMED_OUT, or STOPPED).
    public var endTimestamp: Foundation.Date?
    /// Error information if the durable execution failed. This field is only present when the execution status is FAILED, TIMED_OUT, or STOPPED. The combined size of all error fields is limited to 256 KB.
    public var error: LambdaClientTypes.ErrorObject?
    /// The Amazon Resource Name (ARN) of the Lambda function that was invoked to start this durable execution.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The JSON input payload that was provided when the durable execution was started. For asynchronous invocations, this is limited to 256 KB. For synchronous invocations, this can be up to 6 MB.
    public var inputPayload: Swift.String?
    /// The JSON result returned by the durable execution if it completed successfully. This field is only present when the execution status is SUCCEEDED. The result is limited to 256 KB.
    public var result: Swift.String?
    /// The date and time when the durable execution started, in Unix timestamp format.
    /// This member is required.
    public var startTimestamp: Foundation.Date?
    /// The current status of the durable execution. Valid values are RUNNING, SUCCEEDED, FAILED, TIMED_OUT, and STOPPED.
    /// This member is required.
    public var status: LambdaClientTypes.ExecutionStatus?
    /// The trace headers associated with the durable execution.
    public var traceHeader: LambdaClientTypes.TraceHeader?
    /// The version of the Lambda function that was invoked for this durable execution. This ensures that all replays during the execution use the same function version.
    public var version: Swift.String?

    public init(
        durableExecutionArn: Swift.String? = nil,
        durableExecutionName: Swift.String? = nil,
        endTimestamp: Foundation.Date? = nil,
        error: LambdaClientTypes.ErrorObject? = nil,
        functionArn: Swift.String? = nil,
        inputPayload: Swift.String? = nil,
        result: Swift.String? = nil,
        startTimestamp: Foundation.Date? = nil,
        status: LambdaClientTypes.ExecutionStatus? = nil,
        traceHeader: LambdaClientTypes.TraceHeader? = nil,
        version: Swift.String? = nil
    ) {
        self.durableExecutionArn = durableExecutionArn
        self.durableExecutionName = durableExecutionName
        self.endTimestamp = endTimestamp
        self.error = error
        self.functionArn = functionArn
        self.inputPayload = inputPayload
        self.result = result
        self.startTimestamp = startTimestamp
        self.status = status
        self.traceHeader = traceHeader
        self.version = version
    }
}

extension GetDurableExecutionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDurableExecutionOutput(durableExecutionArn: \(Swift.String(describing: durableExecutionArn)), durableExecutionName: \(Swift.String(describing: durableExecutionName)), endTimestamp: \(Swift.String(describing: endTimestamp)), error: \(Swift.String(describing: error)), functionArn: \(Swift.String(describing: functionArn)), startTimestamp: \(Swift.String(describing: startTimestamp)), status: \(Swift.String(describing: status)), traceHeader: \(Swift.String(describing: traceHeader)), version: \(Swift.String(describing: version)), inputPayload: \"CONTENT_REDACTED\", result: \"CONTENT_REDACTED\")"}
}

public struct GetDurableExecutionHistoryInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the durable execution.
    /// This member is required.
    public var durableExecutionArn: Swift.String?
    /// Specifies whether to include execution data such as step results and callback payloads in the history events. Set to true to include data, or false to exclude it for a more compact response. The default is true.
    public var includeExecutionData: Swift.Bool?
    /// If NextMarker was returned from a previous request, use this value to retrieve the next page of results. Each pagination token expires after 24 hours.
    public var marker: Swift.String?
    /// The maximum number of history events to return per call. You can use Marker to retrieve additional pages of results. The default is 100 and the maximum allowed is 1000. A value of 0 uses the default.
    public var maxItems: Swift.Int?
    /// When set to true, returns the history events in reverse chronological order (newest first). By default, events are returned in chronological order (oldest first).
    public var reverseOrder: Swift.Bool?

    public init(
        durableExecutionArn: Swift.String? = nil,
        includeExecutionData: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = 0,
        reverseOrder: Swift.Bool? = nil
    ) {
        self.durableExecutionArn = durableExecutionArn
        self.includeExecutionData = includeExecutionData
        self.marker = marker
        self.maxItems = maxItems
        self.reverseOrder = reverseOrder
    }
}

extension LambdaClientTypes {

    /// Error information for an event.
    public struct EventError: Swift.Sendable {
        /// The error payload.
        public var payload: LambdaClientTypes.ErrorObject?
        /// Indicates if the error payload was truncated due to size limits.
        public var truncated: Swift.Bool?

        public init(
            payload: LambdaClientTypes.ErrorObject? = nil,
            truncated: Swift.Bool? = nil
        ) {
            self.payload = payload
            self.truncated = truncated
        }
    }
}

extension LambdaClientTypes {

    /// Contains details about a failed callback operation, including error information and the reason for failure.
    public struct CallbackFailedDetails: Swift.Sendable {
        /// An error object that contains details about the failure.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Contains details about a callback operation that has started, including timing information and callback metadata.
    public struct CallbackStartedDetails: Swift.Sendable {
        /// The callback ID. Callback IDs are generated by the DurableContext when a durable function calls ctx.waitForCallback.
        /// This member is required.
        public var callbackId: Swift.String?
        /// The heartbeat timeout value, in seconds.
        public var heartbeatTimeout: Swift.Int?
        /// The timeout value, in seconds.
        public var timeout: Swift.Int?

        public init(
            callbackId: Swift.String? = nil,
            heartbeatTimeout: Swift.Int? = nil,
            timeout: Swift.Int? = nil
        ) {
            self.callbackId = callbackId
            self.heartbeatTimeout = heartbeatTimeout
            self.timeout = timeout
        }
    }
}

extension LambdaClientTypes {

    /// Result information for an event.
    public struct EventResult: Swift.Sendable {
        /// The result payload.
        public var payload: Swift.String?
        /// Indicates if the error payload was truncated due to size limits.
        public var truncated: Swift.Bool?

        public init(
            payload: Swift.String? = nil,
            truncated: Swift.Bool? = nil
        ) {
            self.payload = payload
            self.truncated = truncated
        }
    }
}

extension LambdaClientTypes.EventResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventResult(truncated: \(Swift.String(describing: truncated)), payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Contains details about a successfully completed callback operation, including the result data and completion timestamp.
    public struct CallbackSucceededDetails: Swift.Sendable {
        /// The response payload from the successful operation.
        /// This member is required.
        public var result: LambdaClientTypes.EventResult?

        public init(
            result: LambdaClientTypes.EventResult? = nil
        ) {
            self.result = result
        }
    }
}

extension LambdaClientTypes {

    /// Contains details about a callback operation that timed out, including timeout duration and any partial results.
    public struct CallbackTimedOutDetails: Swift.Sendable {
        /// Details about the callback timeout.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Contains details about a failed chained function invocation, including error information and failure reason.
    public struct ChainedInvokeFailedDetails: Swift.Sendable {
        /// Details about the chained invocation failure.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Input information for an event.
    public struct EventInput: Swift.Sendable {
        /// The input payload.
        public var payload: Swift.String?
        /// Indicates if the error payload was truncated due to size limits.
        public var truncated: Swift.Bool?

        public init(
            payload: Swift.String? = nil,
            truncated: Swift.Bool? = nil
        ) {
            self.payload = payload
            self.truncated = truncated
        }
    }
}

extension LambdaClientTypes.EventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventInput(truncated: \(Swift.String(describing: truncated)), payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {

    /// Contains details about a chained function invocation that has started execution, including start time and execution context.
    public struct ChainedInvokeStartedDetails: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the durable execution.
        public var durableExecutionArn: Swift.String?
        /// The version of the function that was executed.
        public var executedVersion: Swift.String?
        /// The name or ARN of the Lambda function being invoked.
        /// This member is required.
        public var functionName: Swift.String?
        /// The JSON input payload provided to the chained invocation.
        public var input: LambdaClientTypes.EventInput?
        /// The tenant identifier for the chained invocation.
        public var tenantId: Swift.String?

        public init(
            durableExecutionArn: Swift.String? = nil,
            executedVersion: Swift.String? = nil,
            functionName: Swift.String? = nil,
            input: LambdaClientTypes.EventInput? = nil,
            tenantId: Swift.String? = nil
        ) {
            self.durableExecutionArn = durableExecutionArn
            self.executedVersion = executedVersion
            self.functionName = functionName
            self.input = input
            self.tenantId = tenantId
        }
    }
}

extension LambdaClientTypes {

    /// Details about a chained invocation that was stopped.
    public struct ChainedInvokeStoppedDetails: Swift.Sendable {
        /// Details about why the chained invocation stopped.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a chained invocation that succeeded.
    public struct ChainedInvokeSucceededDetails: Swift.Sendable {
        /// The response payload from the successful operation.
        /// This member is required.
        public var result: LambdaClientTypes.EventResult?

        public init(
            result: LambdaClientTypes.EventResult? = nil
        ) {
            self.result = result
        }
    }
}

extension LambdaClientTypes {

    /// Details about a chained invocation that timed out.
    public struct ChainedInvokeTimedOutDetails: Swift.Sendable {
        /// Details about the chained invocation timeout.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a context that failed.
    public struct ContextFailedDetails: Swift.Sendable {
        /// Details about the context failure.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a context that has started.
    public struct ContextStartedDetails: Swift.Sendable {

        public init() { }
    }
}

extension LambdaClientTypes {

    /// Details about a context that succeeded.
    public struct ContextSucceededDetails: Swift.Sendable {
        /// The JSON response payload from the successful context.
        /// This member is required.
        public var result: LambdaClientTypes.EventResult?

        public init(
            result: LambdaClientTypes.EventResult? = nil
        ) {
            self.result = result
        }
    }
}

extension LambdaClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case callbackfailed
        case callbackstarted
        case callbacksucceeded
        case callbacktimedout
        case chainedinvokefailed
        case chainedinvokestarted
        case chainedinvokestopped
        case chainedinvokesucceeded
        case chainedinvoketimedout
        case contextfailed
        case contextstarted
        case contextsucceeded
        case executionfailed
        case executionstarted
        case executionstopped
        case executionsucceeded
        case executiontimedout
        case invocationcompleted
        case stepfailed
        case stepstarted
        case stepsucceeded
        case waitcancelled
        case waitstarted
        case waitsucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .callbackfailed,
                .callbackstarted,
                .callbacksucceeded,
                .callbacktimedout,
                .chainedinvokefailed,
                .chainedinvokestarted,
                .chainedinvokestopped,
                .chainedinvokesucceeded,
                .chainedinvoketimedout,
                .contextfailed,
                .contextstarted,
                .contextsucceeded,
                .executionfailed,
                .executionstarted,
                .executionstopped,
                .executionsucceeded,
                .executiontimedout,
                .invocationcompleted,
                .stepfailed,
                .stepstarted,
                .stepsucceeded,
                .waitcancelled,
                .waitstarted,
                .waitsucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .callbackfailed: return "CallbackFailed"
            case .callbackstarted: return "CallbackStarted"
            case .callbacksucceeded: return "CallbackSucceeded"
            case .callbacktimedout: return "CallbackTimedOut"
            case .chainedinvokefailed: return "ChainedInvokeFailed"
            case .chainedinvokestarted: return "ChainedInvokeStarted"
            case .chainedinvokestopped: return "ChainedInvokeStopped"
            case .chainedinvokesucceeded: return "ChainedInvokeSucceeded"
            case .chainedinvoketimedout: return "ChainedInvokeTimedOut"
            case .contextfailed: return "ContextFailed"
            case .contextstarted: return "ContextStarted"
            case .contextsucceeded: return "ContextSucceeded"
            case .executionfailed: return "ExecutionFailed"
            case .executionstarted: return "ExecutionStarted"
            case .executionstopped: return "ExecutionStopped"
            case .executionsucceeded: return "ExecutionSucceeded"
            case .executiontimedout: return "ExecutionTimedOut"
            case .invocationcompleted: return "InvocationCompleted"
            case .stepfailed: return "StepFailed"
            case .stepstarted: return "StepStarted"
            case .stepsucceeded: return "StepSucceeded"
            case .waitcancelled: return "WaitCancelled"
            case .waitstarted: return "WaitStarted"
            case .waitsucceeded: return "WaitSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LambdaClientTypes {

    /// Details about a failed [durable execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html).
    public struct ExecutionFailedDetails: Swift.Sendable {
        /// Details about the execution failure.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a durable execution that started.
    public struct ExecutionStartedDetails: Swift.Sendable {
        /// The maximum amount of time that the durable execution is allowed to run, in seconds.
        /// This member is required.
        public var executionTimeout: Swift.Int?
        /// The input payload provided for the durable execution.
        /// This member is required.
        public var input: LambdaClientTypes.EventInput?

        public init(
            executionTimeout: Swift.Int? = nil,
            input: LambdaClientTypes.EventInput? = nil
        ) {
            self.executionTimeout = executionTimeout
            self.input = input
        }
    }
}

extension LambdaClientTypes {

    /// Details about a [durable execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html) that stopped.
    public struct ExecutionStoppedDetails: Swift.Sendable {
        /// Details about why the execution stopped.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a [durable execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html) that succeeded.
    public struct ExecutionSucceededDetails: Swift.Sendable {
        /// The response payload from the successful operation.
        /// This member is required.
        public var result: LambdaClientTypes.EventResult?

        public init(
            result: LambdaClientTypes.EventResult? = nil
        ) {
            self.result = result
        }
    }
}

extension LambdaClientTypes {

    /// Details about a [durable execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html) that timed out.
    public struct ExecutionTimedOutDetails: Swift.Sendable {
        /// Details about the execution timeout.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a function invocation that completed.
    public struct InvocationCompletedDetails: Swift.Sendable {
        /// The date and time when the invocation ended, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var endTimestamp: Foundation.Date?
        /// Details about the invocation failure.
        public var error: LambdaClientTypes.EventError?
        /// The request ID for the invocation.
        /// This member is required.
        public var requestId: Swift.String?
        /// The date and time when the invocation started, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var startTimestamp: Foundation.Date?

        public init(
            endTimestamp: Foundation.Date? = nil,
            error: LambdaClientTypes.EventError? = nil,
            requestId: Swift.String? = nil,
            startTimestamp: Foundation.Date? = nil
        ) {
            self.endTimestamp = endTimestamp
            self.error = error
            self.requestId = requestId
            self.startTimestamp = startTimestamp
        }
    }
}

extension LambdaClientTypes {

    /// Information about retry attempts for an operation.
    public struct RetryDetails: Swift.Sendable {
        /// The current attempt number for this operation.
        public var currentAttempt: Swift.Int
        /// The delay before the next retry attempt, in seconds.
        public var nextAttemptDelaySeconds: Swift.Int?

        public init(
            currentAttempt: Swift.Int = 0,
            nextAttemptDelaySeconds: Swift.Int? = nil
        ) {
            self.currentAttempt = currentAttempt
            self.nextAttemptDelaySeconds = nextAttemptDelaySeconds
        }
    }
}

extension LambdaClientTypes {

    /// Details about a step that failed.
    public struct StepFailedDetails: Swift.Sendable {
        /// Details about the step failure.
        /// This member is required.
        public var error: LambdaClientTypes.EventError?
        /// Information about retry attempts for this step operation.
        /// This member is required.
        public var retryDetails: LambdaClientTypes.RetryDetails?

        public init(
            error: LambdaClientTypes.EventError? = nil,
            retryDetails: LambdaClientTypes.RetryDetails? = nil
        ) {
            self.error = error
            self.retryDetails = retryDetails
        }
    }
}

extension LambdaClientTypes {

    /// Details about a step that has started.
    public struct StepStartedDetails: Swift.Sendable {

        public init() { }
    }
}

extension LambdaClientTypes {

    /// Details about a step that succeeded.
    public struct StepSucceededDetails: Swift.Sendable {
        /// The response payload from the successful operation.
        /// This member is required.
        public var result: LambdaClientTypes.EventResult?
        /// Information about retry attempts for this step operation.
        /// This member is required.
        public var retryDetails: LambdaClientTypes.RetryDetails?

        public init(
            result: LambdaClientTypes.EventResult? = nil,
            retryDetails: LambdaClientTypes.RetryDetails? = nil
        ) {
            self.result = result
            self.retryDetails = retryDetails
        }
    }
}

extension LambdaClientTypes {

    /// Details about a wait operation that was cancelled.
    public struct WaitCancelledDetails: Swift.Sendable {
        /// Details about why the wait operation was cancelled.
        public var error: LambdaClientTypes.EventError?

        public init(
            error: LambdaClientTypes.EventError? = nil
        ) {
            self.error = error
        }
    }
}

extension LambdaClientTypes {

    /// Details about a wait operation that has started.
    public struct WaitStartedDetails: Swift.Sendable {
        /// The duration to wait, in seconds.
        /// This member is required.
        public var duration: Swift.Int?
        /// The date and time when the wait operation is scheduled to complete, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var scheduledEndTimestamp: Foundation.Date?

        public init(
            duration: Swift.Int? = nil,
            scheduledEndTimestamp: Foundation.Date? = nil
        ) {
            self.duration = duration
            self.scheduledEndTimestamp = scheduledEndTimestamp
        }
    }
}

extension LambdaClientTypes {

    /// Details about a wait operation that succeeded.
    public struct WaitSucceededDetails: Swift.Sendable {
        /// The wait duration, in seconds.
        public var duration: Swift.Int?

        public init(
            duration: Swift.Int? = nil
        ) {
            self.duration = duration
        }
    }
}

extension LambdaClientTypes {

    /// An event that occurred during the execution of a durable function.
    public struct Event: Swift.Sendable {
        /// Contains details about a failed callback operation, including error information and the reason for failure.
        public var callbackFailedDetails: LambdaClientTypes.CallbackFailedDetails?
        /// Contains details about a callback operation that has started, including timing information and callback metadata.
        public var callbackStartedDetails: LambdaClientTypes.CallbackStartedDetails?
        /// Contains details about a successfully completed callback operation, including the result data and completion timestamp.
        public var callbackSucceededDetails: LambdaClientTypes.CallbackSucceededDetails?
        /// Contains details about a callback operation that timed out, including timeout duration and any partial results.
        public var callbackTimedOutDetails: LambdaClientTypes.CallbackTimedOutDetails?
        /// Contains details about a failed chained function invocation, including error information and failure reason.
        public var chainedInvokeFailedDetails: LambdaClientTypes.ChainedInvokeFailedDetails?
        /// Contains details about a chained function invocation that has started execution, including start time and execution context.
        public var chainedInvokeStartedDetails: LambdaClientTypes.ChainedInvokeStartedDetails?
        /// Details about a chained invocation that was stopped.
        public var chainedInvokeStoppedDetails: LambdaClientTypes.ChainedInvokeStoppedDetails?
        /// Details about a chained invocation that succeeded.
        public var chainedInvokeSucceededDetails: LambdaClientTypes.ChainedInvokeSucceededDetails?
        /// Details about a chained invocation that timed out.
        public var chainedInvokeTimedOutDetails: LambdaClientTypes.ChainedInvokeTimedOutDetails?
        /// Details about a context that failed.
        public var contextFailedDetails: LambdaClientTypes.ContextFailedDetails?
        /// Details about a context that started.
        public var contextStartedDetails: LambdaClientTypes.ContextStartedDetails?
        /// Details about a context that succeeded.
        public var contextSucceededDetails: LambdaClientTypes.ContextSucceededDetails?
        /// The unique identifier for this event. Event IDs increment sequentially.
        public var eventId: Swift.Int?
        /// The date and time when this event occurred, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var eventTimestamp: Foundation.Date?
        /// The type of event that occurred.
        public var eventType: LambdaClientTypes.EventType?
        /// Details about an execution that failed.
        public var executionFailedDetails: LambdaClientTypes.ExecutionFailedDetails?
        /// Details about an execution that started.
        public var executionStartedDetails: LambdaClientTypes.ExecutionStartedDetails?
        /// Details about an execution that was stopped.
        public var executionStoppedDetails: LambdaClientTypes.ExecutionStoppedDetails?
        /// Details about an execution that succeeded.
        public var executionSucceededDetails: LambdaClientTypes.ExecutionSucceededDetails?
        /// Details about an execution that timed out.
        public var executionTimedOutDetails: LambdaClientTypes.ExecutionTimedOutDetails?
        /// The unique identifier for this operation.
        public var id: Swift.String?
        /// Details about a function invocation that completed.
        public var invocationCompletedDetails: LambdaClientTypes.InvocationCompletedDetails?
        /// The customer-provided name for this operation.
        public var name: Swift.String?
        /// The unique identifier of the parent operation, if this operation is running within a child context.
        public var parentId: Swift.String?
        /// Details about a step that failed.
        public var stepFailedDetails: LambdaClientTypes.StepFailedDetails?
        /// Details about a step that started.
        public var stepStartedDetails: LambdaClientTypes.StepStartedDetails?
        /// Details about a step that succeeded.
        public var stepSucceededDetails: LambdaClientTypes.StepSucceededDetails?
        /// The subtype of the event, providing additional categorization.
        public var subType: Swift.String?
        /// Details about a wait operation that was cancelled.
        public var waitCancelledDetails: LambdaClientTypes.WaitCancelledDetails?
        /// Details about a wait operation that started.
        public var waitStartedDetails: LambdaClientTypes.WaitStartedDetails?
        /// Details about a wait operation that succeeded.
        public var waitSucceededDetails: LambdaClientTypes.WaitSucceededDetails?

        public init(
            callbackFailedDetails: LambdaClientTypes.CallbackFailedDetails? = nil,
            callbackStartedDetails: LambdaClientTypes.CallbackStartedDetails? = nil,
            callbackSucceededDetails: LambdaClientTypes.CallbackSucceededDetails? = nil,
            callbackTimedOutDetails: LambdaClientTypes.CallbackTimedOutDetails? = nil,
            chainedInvokeFailedDetails: LambdaClientTypes.ChainedInvokeFailedDetails? = nil,
            chainedInvokeStartedDetails: LambdaClientTypes.ChainedInvokeStartedDetails? = nil,
            chainedInvokeStoppedDetails: LambdaClientTypes.ChainedInvokeStoppedDetails? = nil,
            chainedInvokeSucceededDetails: LambdaClientTypes.ChainedInvokeSucceededDetails? = nil,
            chainedInvokeTimedOutDetails: LambdaClientTypes.ChainedInvokeTimedOutDetails? = nil,
            contextFailedDetails: LambdaClientTypes.ContextFailedDetails? = nil,
            contextStartedDetails: LambdaClientTypes.ContextStartedDetails? = nil,
            contextSucceededDetails: LambdaClientTypes.ContextSucceededDetails? = nil,
            eventId: Swift.Int? = 1,
            eventTimestamp: Foundation.Date? = nil,
            eventType: LambdaClientTypes.EventType? = nil,
            executionFailedDetails: LambdaClientTypes.ExecutionFailedDetails? = nil,
            executionStartedDetails: LambdaClientTypes.ExecutionStartedDetails? = nil,
            executionStoppedDetails: LambdaClientTypes.ExecutionStoppedDetails? = nil,
            executionSucceededDetails: LambdaClientTypes.ExecutionSucceededDetails? = nil,
            executionTimedOutDetails: LambdaClientTypes.ExecutionTimedOutDetails? = nil,
            id: Swift.String? = nil,
            invocationCompletedDetails: LambdaClientTypes.InvocationCompletedDetails? = nil,
            name: Swift.String? = nil,
            parentId: Swift.String? = nil,
            stepFailedDetails: LambdaClientTypes.StepFailedDetails? = nil,
            stepStartedDetails: LambdaClientTypes.StepStartedDetails? = nil,
            stepSucceededDetails: LambdaClientTypes.StepSucceededDetails? = nil,
            subType: Swift.String? = nil,
            waitCancelledDetails: LambdaClientTypes.WaitCancelledDetails? = nil,
            waitStartedDetails: LambdaClientTypes.WaitStartedDetails? = nil,
            waitSucceededDetails: LambdaClientTypes.WaitSucceededDetails? = nil
        ) {
            self.callbackFailedDetails = callbackFailedDetails
            self.callbackStartedDetails = callbackStartedDetails
            self.callbackSucceededDetails = callbackSucceededDetails
            self.callbackTimedOutDetails = callbackTimedOutDetails
            self.chainedInvokeFailedDetails = chainedInvokeFailedDetails
            self.chainedInvokeStartedDetails = chainedInvokeStartedDetails
            self.chainedInvokeStoppedDetails = chainedInvokeStoppedDetails
            self.chainedInvokeSucceededDetails = chainedInvokeSucceededDetails
            self.chainedInvokeTimedOutDetails = chainedInvokeTimedOutDetails
            self.contextFailedDetails = contextFailedDetails
            self.contextStartedDetails = contextStartedDetails
            self.contextSucceededDetails = contextSucceededDetails
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventType = eventType
            self.executionFailedDetails = executionFailedDetails
            self.executionStartedDetails = executionStartedDetails
            self.executionStoppedDetails = executionStoppedDetails
            self.executionSucceededDetails = executionSucceededDetails
            self.executionTimedOutDetails = executionTimedOutDetails
            self.id = id
            self.invocationCompletedDetails = invocationCompletedDetails
            self.name = name
            self.parentId = parentId
            self.stepFailedDetails = stepFailedDetails
            self.stepStartedDetails = stepStartedDetails
            self.stepSucceededDetails = stepSucceededDetails
            self.subType = subType
            self.waitCancelledDetails = waitCancelledDetails
            self.waitStartedDetails = waitStartedDetails
            self.waitSucceededDetails = waitSucceededDetails
        }
    }
}

/// The response from the GetDurableExecutionHistory operation, containing the execution history and events.
public struct GetDurableExecutionHistoryOutput: Swift.Sendable {
    /// An array of execution history events, ordered chronologically unless ReverseOrder is set to true. Each event represents a significant occurrence during the execution, such as step completion or callback resolution.
    /// This member is required.
    public var events: [LambdaClientTypes.Event]?
    /// If present, indicates that more history events are available. Use this value as the Marker parameter in a subsequent request to retrieve the next page of results.
    public var nextMarker: Swift.String?

    public init(
        events: [LambdaClientTypes.Event]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.events = events
        self.nextMarker = nextMarker
    }
}

public struct GetDurableExecutionStateInput: Swift.Sendable {
    /// A checkpoint token that identifies the current state of the execution. This token is provided by the Lambda runtime and ensures that state retrieval is consistent with the current execution context.
    /// This member is required.
    public var checkpointToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the durable execution.
    /// This member is required.
    public var durableExecutionArn: Swift.String?
    /// If NextMarker was returned from a previous request, use this value to retrieve the next page of operations. Each pagination token expires after 24 hours.
    public var marker: Swift.String?
    /// The maximum number of operations to return per call. You can use Marker to retrieve additional pages of results. The default is 100 and the maximum allowed is 1000. A value of 0 uses the default.
    public var maxItems: Swift.Int?

    public init(
        checkpointToken: Swift.String? = nil,
        durableExecutionArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = 0
    ) {
        self.checkpointToken = checkpointToken
        self.durableExecutionArn = durableExecutionArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

/// The response from the GetDurableExecutionState operation, containing the current execution state for replay.
public struct GetDurableExecutionStateOutput: Swift.Sendable {
    /// If present, indicates that more operations are available. Use this value as the Marker parameter in a subsequent request to retrieve the next page of results.
    public var nextMarker: Swift.String?
    /// An array of operations that represent the current state of the durable execution. Operations are ordered by their start sequence number in ascending order and include information needed for replay processing.
    /// This member is required.
    public var operations: [LambdaClientTypes.Operation]?

    public init(
        nextMarker: Swift.String? = nil,
        operations: [LambdaClientTypes.Operation]? = nil
    ) {
        self.nextMarker = nextMarker
        self.operations = operations
    }
}

public struct GetFunctionEventInvokeConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetFunctionEventInvokeConfigOutput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Bucket - The ARN of an Amazon S3 bucket.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    /// S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: Foundation.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    ) {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

public struct ListLayersInput: Swift.Sendable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of layers to return.
    public var maxItems: Swift.Int?

    public init(
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionsListItem: Swift.Sendable {
        /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
        public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
        /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
        public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public var createdDate: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// The ARN of the layer version.
        public var layerVersionArn: Swift.String?
        /// The layer's open-source license.
        public var licenseInfo: Swift.String?
        /// The version number.
        public var version: Swift.Int

        public init(
            compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
            compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            layerVersionArn: Swift.String? = nil,
            licenseInfo: Swift.String? = nil,
            version: Swift.Int = 0
        ) {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }
    }
}

extension LambdaClientTypes {

    /// Details about an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayersListItem: Swift.Sendable {
        /// The newest version of the layer.
        public var latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public var layerArn: Swift.String?
        /// The name of the layer.
        public var layerName: Swift.String?

        public init(
            latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem? = nil,
            layerArn: Swift.String? = nil,
            layerName: Swift.String? = nil
        ) {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }
    }
}

public struct ListLayersOutput: Swift.Sendable {
    /// A list of function layers.
    public var layers: [LambdaClientTypes.LayersListItem]?
    /// A pagination token returned when the response doesn't contain all layers.
    public var nextMarker: Swift.String?

    public init(
        layers: [LambdaClientTypes.LayersListItem]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.layers = layers
        self.nextMarker = nextMarker
    }
}

public struct DeleteLayerVersionInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    ) {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

public struct GetLayerVersionInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    ) {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

extension LambdaClientTypes {

    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionContentOutput: Swift.Sendable {
        /// The SHA-256 hash of the layer archive.
        public var codeSha256: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public var location: Swift.String?
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init(
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            location: Swift.String? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        ) {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }
}

public struct GetLayerVersionOutput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    ) {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

public struct GetLayerVersionByArnInput: Swift.Sendable {
    /// The ARN of the layer version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct GetLayerVersionByArnOutput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    ) {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

public struct GetLayerVersionPolicyInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    ) {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

public struct GetLayerVersionPolicyOutput: Swift.Sendable {
    /// The policy document.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    ) {
        self.policy = policy
        self.revisionId = revisionId
    }
}

public struct ListLayerVersionsInput: Swift.Sendable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of versions to return.
    public var maxItems: Swift.Int?

    public init(
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        layerName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.layerName = layerName
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListLayerVersionsOutput: Swift.Sendable {
    /// A list of versions.
    public var layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
    /// A pagination token returned when the response doesn't contain all versions.
    public var nextMarker: Swift.String?

    public init(
        layerVersions: [LambdaClientTypes.LayerVersionsListItem]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.layerVersions = layerVersions
        self.nextMarker = nextMarker
    }
}

extension LambdaClientTypes {

    /// A ZIP archive that contains the contents of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). You can specify either an Amazon S3 location, or upload a layer archive directly.
    public struct LayerVersionContentInput: Swift.Sendable {
        /// The Amazon S3 bucket of the layer archive.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the layer archive.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the layer archive object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: Foundation.Data?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: Foundation.Data? = nil
        ) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }
}

extension LambdaClientTypes.LayerVersionContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerVersionContentInput(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

public struct PublishLayerVersionInput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// A list of compatible [function runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Used for filtering with [ListLayers] and [ListLayerVersions]. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// The function layer archive.
    /// This member is required.
    public var content: LambdaClientTypes.LayerVersionContentInput?
    /// The description of the version.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The layer's software license. It can be any of the following:
    ///
    /// * An [SPDX license identifier](https://spdx.org/licenses/). For example, MIT.
    ///
    /// * The URL of a license hosted on the internet. For example, https://opensource.org/licenses/MIT.
    ///
    /// * The full text of the license.
    public var licenseInfo: Swift.String?

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentInput? = nil,
        description: Swift.String? = nil,
        layerName: Swift.String? = nil,
        licenseInfo: Swift.String? = nil
    ) {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.description = description
        self.layerName = layerName
        self.licenseInfo = licenseInfo
    }
}

public struct PublishLayerVersionOutput: Swift.Sendable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime use after deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels). For a list of all currently supported runtimes, see [Supported runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    ) {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

public struct RemoveLayerVersionPermissionInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The identifier that was specified when the statement was added.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int? = 0
    ) {
        self.layerName = layerName
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

public struct ListDurableExecutionsByFunctionInput: Swift.Sendable {
    /// Filter executions by name. Only executions with names that contain this string are returned.
    public var durableExecutionName: Swift.String?
    /// The name or ARN of the Lambda function. You can specify a function name, a partial ARN, or a full ARN.
    /// This member is required.
    public var functionName: Swift.String?
    /// Pagination token from a previous request to continue retrieving results.
    public var marker: Swift.String?
    /// Maximum number of executions to return (1-1000). Default is 100.
    public var maxItems: Swift.Int?
    /// The function version or alias. If not specified, lists executions for the $LATEST version.
    public var qualifier: Swift.String?
    /// Set to true to return results in reverse chronological order (newest first). Default is false.
    public var reverseOrder: Swift.Bool?
    /// Filter executions that started after this timestamp (ISO 8601 format).
    public var startedAfter: Foundation.Date?
    /// Filter executions that started before this timestamp (ISO 8601 format).
    public var startedBefore: Foundation.Date?
    /// Filter executions by status. Valid values: RUNNING, SUCCEEDED, FAILED, TIMED_OUT, STOPPED.
    public var statuses: [LambdaClientTypes.ExecutionStatus]?

    public init(
        durableExecutionName: Swift.String? = nil,
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = 0,
        qualifier: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil,
        startedAfter: Foundation.Date? = nil,
        startedBefore: Foundation.Date? = nil,
        statuses: [LambdaClientTypes.ExecutionStatus]? = nil
    ) {
        self.durableExecutionName = durableExecutionName
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
        self.qualifier = qualifier
        self.reverseOrder = reverseOrder
        self.startedAfter = startedAfter
        self.startedBefore = startedBefore
        self.statuses = statuses
    }
}

extension LambdaClientTypes {

    /// Information about a [durable execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html).
    public struct Execution: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the durable execution, if this execution is a durable execution.
        /// This member is required.
        public var durableExecutionArn: Swift.String?
        /// The unique name of the durable execution, if one was provided when the execution was started.
        /// This member is required.
        public var durableExecutionName: Swift.String?
        /// The date and time when the durable execution ended, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var endTimestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the Lambda function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// The date and time when the durable execution started, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var startTimestamp: Foundation.Date?
        /// The current status of the durable execution.
        /// This member is required.
        public var status: LambdaClientTypes.ExecutionStatus?

        public init(
            durableExecutionArn: Swift.String? = nil,
            durableExecutionName: Swift.String? = nil,
            endTimestamp: Foundation.Date? = nil,
            functionArn: Swift.String? = nil,
            startTimestamp: Foundation.Date? = nil,
            status: LambdaClientTypes.ExecutionStatus? = nil
        ) {
            self.durableExecutionArn = durableExecutionArn
            self.durableExecutionName = durableExecutionName
            self.endTimestamp = endTimestamp
            self.functionArn = functionArn
            self.startTimestamp = startTimestamp
            self.status = status
        }
    }
}

/// The response from the ListDurableExecutionsByFunction operation, containing a list of durable executions and pagination information.
public struct ListDurableExecutionsByFunctionOutput: Swift.Sendable {
    /// List of durable execution summaries matching the filter criteria.
    public var durableExecutions: [LambdaClientTypes.Execution]?
    /// Pagination token for retrieving additional results. Present only if there are more results available.
    public var nextMarker: Swift.String?

    public init(
        durableExecutions: [LambdaClientTypes.Execution]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.durableExecutions = durableExecutions
        self.nextMarker = nextMarker
    }
}

public struct ListFunctionEventInvokeConfigsInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of configurations to return.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    ) {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension LambdaClientTypes {

    public struct FunctionEventInvokeConfig: Swift.Sendable {
        /// A destination for events after they have been sent to a function for processing. Destinations
        ///
        /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
        ///
        /// * Queue - The ARN of a standard SQS queue.
        ///
        /// * Bucket - The ARN of an Amazon S3 bucket.
        ///
        /// * Topic - The ARN of a standard SNS topic.
        ///
        /// * Event Bus - The ARN of an Amazon EventBridge event bus.
        ///
        ///
        /// S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public var functionArn: Swift.String?
        /// The date and time that the configuration was last updated.
        public var lastModified: Foundation.Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of times to retry when the function returns an error.
        public var maximumRetryAttempts: Swift.Int?

        public init(
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        ) {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }
}

public struct ListFunctionEventInvokeConfigsOutput: Swift.Sendable {
    /// A list of configurations.
    public var functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]? = nil,
        nextMarker: Swift.String? = nil
    ) {
        self.functionEventInvokeConfigs = functionEventInvokeConfigs
        self.nextMarker = nextMarker
    }
}

public struct ListTagsInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN). Note: Lambda does not support adding tags to function aliases or versions.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    ) {
        self.resource = resource
    }
}

public struct ListTagsOutput: Swift.Sendable {
    /// The function's tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct RemovePermissionInput: Swift.Sendable {
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to remove permissions from a published version of the function.
    public var qualifier: Swift.String?
    /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// Statement ID of the permission to remove.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

public struct DeleteProvisionedConcurrencyConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

/// The specified configuration does not exist.
public struct ProvisionedConcurrencyConfigNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProvisionedConcurrencyConfigNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

public struct GetProvisionedConcurrencyConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

public struct GetProvisionedConcurrencyConfigOutput: Swift.Sendable {
    /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init(
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

public struct PutProvisionedConcurrencyConfigInput: Swift.Sendable {
    /// The name or ARN of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The amount of provisioned concurrency to allocate for the version or alias.
    /// This member is required.
    public var provisionedConcurrentExecutions: Swift.Int?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        provisionedConcurrentExecutions: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.functionName = functionName
        self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
        self.qualifier = qualifier
    }
}

public struct PutProvisionedConcurrencyConfigOutput: Swift.Sendable {
    /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init(
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

public struct PutFunctionEventInvokeConfigInput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Bucket - The ARN of an Amazon S3 bucket.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    /// S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

public struct PutFunctionEventInvokeConfigOutput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Bucket - The ARN of an Amazon S3 bucket.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    /// S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: Foundation.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    ) {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

/// The callback ID token has either expired or the callback associated with the token has already been closed.
public struct CallbackTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CallbackTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.type = type
    }
}

public struct SendDurableExecutionCallbackFailureInput: Swift.Sendable {
    /// The unique identifier for the callback operation.
    /// This member is required.
    public var callbackId: Swift.String?
    /// Error details describing why the callback operation failed.
    public var error: LambdaClientTypes.ErrorObject?

    public init(
        callbackId: Swift.String? = nil,
        error: LambdaClientTypes.ErrorObject? = nil
    ) {
        self.callbackId = callbackId
        self.error = error
    }
}

public struct SendDurableExecutionCallbackFailureOutput: Swift.Sendable {

    public init() { }
}

public struct SendDurableExecutionCallbackHeartbeatInput: Swift.Sendable {
    /// The unique identifier for the callback operation.
    /// This member is required.
    public var callbackId: Swift.String?

    public init(
        callbackId: Swift.String? = nil
    ) {
        self.callbackId = callbackId
    }
}

public struct SendDurableExecutionCallbackHeartbeatOutput: Swift.Sendable {

    public init() { }
}

public struct SendDurableExecutionCallbackSuccessInput: Swift.Sendable {
    /// The unique identifier for the callback operation.
    /// This member is required.
    public var callbackId: Swift.String?
    /// The result data from the successful callback operation. Maximum size is 256 KB.
    public var result: Foundation.Data?

    public init(
        callbackId: Swift.String? = nil,
        result: Foundation.Data? = nil
    ) {
        self.callbackId = callbackId
        self.result = result
    }
}

extension SendDurableExecutionCallbackSuccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendDurableExecutionCallbackSuccessInput(callbackId: \(Swift.String(describing: callbackId)), result: \"CONTENT_REDACTED\")"}
}

public struct SendDurableExecutionCallbackSuccessOutput: Swift.Sendable {

    public init() { }
}

public struct StopDurableExecutionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the durable execution.
    /// This member is required.
    public var durableExecutionArn: Swift.String?
    /// Optional error details explaining why the execution is being stopped.
    public var error: LambdaClientTypes.ErrorObject?

    public init(
        durableExecutionArn: Swift.String? = nil,
        error: LambdaClientTypes.ErrorObject? = nil
    ) {
        self.durableExecutionArn = durableExecutionArn
        self.error = error
    }
}

public struct StopDurableExecutionOutput: Swift.Sendable {
    /// The timestamp when the execution was stopped (ISO 8601 format).
    /// This member is required.
    public var stopTimestamp: Foundation.Date?

    public init(
        stopTimestamp: Foundation.Date? = nil
    ) {
        self.stopTimestamp = stopTimestamp
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resource = resource
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

public struct UpdateFunctionEventInvokeConfigInput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Bucket - The ARN of an Amazon S3 bucket.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    /// S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name or ARN of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    ) {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

public struct UpdateFunctionEventInvokeConfigOutput: Swift.Sendable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Bucket - The ARN of an Amazon S3 bucket.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    /// S3 buckets are supported only for on-failure destinations. To retain records of successful invocations, use another destination type.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: Foundation.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    ) {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

extension AddLayerVersionPermissionInput {

    static func urlPathProvider(_ value: AddLayerVersionPermissionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

extension AddLayerVersionPermissionInput {

    static func queryItemProvider(_ value: AddLayerVersionPermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = Smithy.URIQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension AddPermissionInput {

    static func urlPathProvider(_ value: AddPermissionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

extension AddPermissionInput {

    static func queryItemProvider(_ value: AddPermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension CheckpointDurableExecutionInput {

    static func urlPathProvider(_ value: CheckpointDurableExecutionInput) -> Swift.String? {
        guard let durableExecutionArn = value.durableExecutionArn else {
            return nil
        }
        return "/2025-12-01/durable-executions/\(durableExecutionArn.urlPercentEncoding())/checkpoint"
    }
}

extension CreateAliasInput {

    static func urlPathProvider(_ value: CreateAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

extension CreateCapacityProviderInput {

    static func urlPathProvider(_ value: CreateCapacityProviderInput) -> Swift.String? {
        return "/2025-11-30/capacity-providers"
    }
}

extension CreateCodeSigningConfigInput {

    static func urlPathProvider(_ value: CreateCodeSigningConfigInput) -> Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

extension CreateEventSourceMappingInput {

    static func urlPathProvider(_ value: CreateEventSourceMappingInput) -> Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

extension CreateFunctionInput {

    static func urlPathProvider(_ value: CreateFunctionInput) -> Swift.String? {
        return "/2015-03-31/functions"
    }
}

extension CreateFunctionUrlConfigInput {

    static func urlPathProvider(_ value: CreateFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension CreateFunctionUrlConfigInput {

    static func queryItemProvider(_ value: CreateFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteAliasInput {

    static func urlPathProvider(_ value: DeleteAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

extension DeleteCapacityProviderInput {

    static func urlPathProvider(_ value: DeleteCapacityProviderInput) -> Swift.String? {
        guard let capacityProviderName = value.capacityProviderName else {
            return nil
        }
        return "/2025-11-30/capacity-providers/\(capacityProviderName.urlPercentEncoding())"
    }
}

extension DeleteCodeSigningConfigInput {

    static func urlPathProvider(_ value: DeleteCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

extension DeleteEventSourceMappingInput {

    static func urlPathProvider(_ value: DeleteEventSourceMappingInput) -> Swift.String? {
        guard let uuid = value.uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

extension DeleteFunctionInput {

    static func urlPathProvider(_ value: DeleteFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

extension DeleteFunctionInput {

    static func queryItemProvider(_ value: DeleteFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteFunctionCodeSigningConfigInput {

    static func urlPathProvider(_ value: DeleteFunctionCodeSigningConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

extension DeleteFunctionConcurrencyInput {

    static func urlPathProvider(_ value: DeleteFunctionConcurrencyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

extension DeleteFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: DeleteFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension DeleteFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: DeleteFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteFunctionUrlConfigInput {

    static func urlPathProvider(_ value: DeleteFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension DeleteFunctionUrlConfigInput {

    static func queryItemProvider(_ value: DeleteFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension DeleteLayerVersionInput {

    static func urlPathProvider(_ value: DeleteLayerVersionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension DeleteProvisionedConcurrencyConfigInput {

    static func urlPathProvider(_ value: DeleteProvisionedConcurrencyConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension DeleteProvisionedConcurrencyConfigInput {

    static func queryItemProvider(_ value: DeleteProvisionedConcurrencyConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension GetAccountSettingsInput {

    static func urlPathProvider(_ value: GetAccountSettingsInput) -> Swift.String? {
        return "/2016-08-19/account-settings"
    }
}

extension GetAliasInput {

    static func urlPathProvider(_ value: GetAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

extension GetCapacityProviderInput {

    static func urlPathProvider(_ value: GetCapacityProviderInput) -> Swift.String? {
        guard let capacityProviderName = value.capacityProviderName else {
            return nil
        }
        return "/2025-11-30/capacity-providers/\(capacityProviderName.urlPercentEncoding())"
    }
}

extension GetCodeSigningConfigInput {

    static func urlPathProvider(_ value: GetCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

extension GetDurableExecutionInput {

    static func urlPathProvider(_ value: GetDurableExecutionInput) -> Swift.String? {
        guard let durableExecutionArn = value.durableExecutionArn else {
            return nil
        }
        return "/2025-12-01/durable-executions/\(durableExecutionArn.urlPercentEncoding())"
    }
}

extension GetDurableExecutionHistoryInput {

    static func urlPathProvider(_ value: GetDurableExecutionHistoryInput) -> Swift.String? {
        guard let durableExecutionArn = value.durableExecutionArn else {
            return nil
        }
        return "/2025-12-01/durable-executions/\(durableExecutionArn.urlPercentEncoding())/history"
    }
}

extension GetDurableExecutionHistoryInput {

    static func queryItemProvider(_ value: GetDurableExecutionHistoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeExecutionData = value.includeExecutionData {
            let includeExecutionDataQueryItem = Smithy.URIQueryItem(name: "IncludeExecutionData".urlPercentEncoding(), value: Swift.String(includeExecutionData).urlPercentEncoding())
            items.append(includeExecutionDataQueryItem)
        }
        if let reverseOrder = value.reverseOrder {
            let reverseOrderQueryItem = Smithy.URIQueryItem(name: "ReverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
            items.append(reverseOrderQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension GetDurableExecutionStateInput {

    static func urlPathProvider(_ value: GetDurableExecutionStateInput) -> Swift.String? {
        guard let durableExecutionArn = value.durableExecutionArn else {
            return nil
        }
        return "/2025-12-01/durable-executions/\(durableExecutionArn.urlPercentEncoding())/state"
    }
}

extension GetDurableExecutionStateInput {

    static func queryItemProvider(_ value: GetDurableExecutionStateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        guard let checkpointToken = value.checkpointToken else {
            let message = "Creating a URL Query Item failed. checkpointToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let checkpointTokenQueryItem = Smithy.URIQueryItem(name: "CheckpointToken".urlPercentEncoding(), value: Swift.String(checkpointToken).urlPercentEncoding())
        items.append(checkpointTokenQueryItem)
        return items
    }
}

extension GetEventSourceMappingInput {

    static func urlPathProvider(_ value: GetEventSourceMappingInput) -> Swift.String? {
        guard let uuid = value.uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

extension GetFunctionInput {

    static func urlPathProvider(_ value: GetFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

extension GetFunctionInput {

    static func queryItemProvider(_ value: GetFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionCodeSigningConfigInput {

    static func urlPathProvider(_ value: GetFunctionCodeSigningConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

extension GetFunctionConcurrencyInput {

    static func urlPathProvider(_ value: GetFunctionConcurrencyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

extension GetFunctionConfigurationInput {

    static func urlPathProvider(_ value: GetFunctionConfigurationInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

extension GetFunctionConfigurationInput {

    static func queryItemProvider(_ value: GetFunctionConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: GetFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension GetFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: GetFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetFunctionRecursionConfigInput {

    static func urlPathProvider(_ value: GetFunctionRecursionConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2024-08-31/functions/\(functionName.urlPercentEncoding())/recursion-config"
    }
}

extension GetFunctionScalingConfigInput {

    static func urlPathProvider(_ value: GetFunctionScalingConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2025-11-30/functions/\(functionName.urlPercentEncoding())/function-scaling-config"
    }
}

extension GetFunctionScalingConfigInput {

    static func queryItemProvider(_ value: GetFunctionScalingConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension GetFunctionUrlConfigInput {

    static func urlPathProvider(_ value: GetFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension GetFunctionUrlConfigInput {

    static func queryItemProvider(_ value: GetFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetLayerVersionInput {

    static func urlPathProvider(_ value: GetLayerVersionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension GetLayerVersionByArnInput {

    static func urlPathProvider(_ value: GetLayerVersionByArnInput) -> Swift.String? {
        return "/2018-10-31/layers"
    }
}

extension GetLayerVersionByArnInput {

    static func queryItemProvider(_ value: GetLayerVersionByArnInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "find", value: "LayerVersion"))
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension GetLayerVersionPolicyInput {

    static func urlPathProvider(_ value: GetLayerVersionPolicyInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

extension GetPolicyInput {

    static func queryItemProvider(_ value: GetPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension GetProvisionedConcurrencyConfigInput {

    static func urlPathProvider(_ value: GetProvisionedConcurrencyConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension GetProvisionedConcurrencyConfigInput {

    static func queryItemProvider(_ value: GetProvisionedConcurrencyConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension GetRuntimeManagementConfigInput {

    static func urlPathProvider(_ value: GetRuntimeManagementConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-07-20/functions/\(functionName.urlPercentEncoding())/runtime-management-config"
    }
}

extension GetRuntimeManagementConfigInput {

    static func queryItemProvider(_ value: GetRuntimeManagementConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeInput {

    static func urlPathProvider(_ value: InvokeInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/invocations"
    }
}

extension InvokeInput {

    static func headerProvider(_ value: InvokeInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientContext = value.clientContext {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let durableExecutionName = value.durableExecutionName {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Durable-Execution-Name", value: Swift.String(durableExecutionName)))
        }
        if let invocationType = value.invocationType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = value.logType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        if let tenantId = value.tenantId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Tenant-Id", value: Swift.String(tenantId)))
        }
        return items
    }
}

extension InvokeInput {

    static func queryItemProvider(_ value: InvokeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension InvokeAsyncInput {

    static func urlPathProvider(_ value: InvokeAsyncInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2014-11-13/functions/\(functionName.urlPercentEncoding())/invoke-async"
    }
}

extension InvokeWithResponseStreamInput {

    static func urlPathProvider(_ value: InvokeWithResponseStreamInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-11-15/functions/\(functionName.urlPercentEncoding())/response-streaming-invocations"
    }
}

extension InvokeWithResponseStreamInput {

    static func headerProvider(_ value: InvokeWithResponseStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientContext = value.clientContext {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let invocationType = value.invocationType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = value.logType {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        if let tenantId = value.tenantId {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Tenant-Id", value: Swift.String(tenantId)))
        }
        return items
    }
}

extension InvokeWithResponseStreamInput {

    static func queryItemProvider(_ value: InvokeWithResponseStreamInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension ListAliasesInput {

    static func urlPathProvider(_ value: ListAliasesInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

extension ListAliasesInput {

    static func queryItemProvider(_ value: ListAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let functionVersion = value.functionVersion {
            let functionVersionQueryItem = Smithy.URIQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion).urlPercentEncoding())
            items.append(functionVersionQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCapacityProvidersInput {

    static func urlPathProvider(_ value: ListCapacityProvidersInput) -> Swift.String? {
        return "/2025-11-30/capacity-providers"
    }
}

extension ListCapacityProvidersInput {

    static func queryItemProvider(_ value: ListCapacityProvidersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "State".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCodeSigningConfigsInput {

    static func urlPathProvider(_ value: ListCodeSigningConfigsInput) -> Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

extension ListCodeSigningConfigsInput {

    static func queryItemProvider(_ value: ListCodeSigningConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDurableExecutionsByFunctionInput {

    static func urlPathProvider(_ value: ListDurableExecutionsByFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2025-12-01/functions/\(functionName.urlPercentEncoding())/durable-executions"
    }
}

extension ListDurableExecutionsByFunctionInput {

    static func queryItemProvider(_ value: ListDurableExecutionsByFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let durableExecutionName = value.durableExecutionName {
            let durableExecutionNameQueryItem = Smithy.URIQueryItem(name: "DurableExecutionName".urlPercentEncoding(), value: Swift.String(durableExecutionName).urlPercentEncoding())
            items.append(durableExecutionNameQueryItem)
        }
        if let statuses = value.statuses {
            statuses.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "Statuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let startedAfter = value.startedAfter {
            let startedAfterQueryItem = Smithy.URIQueryItem(name: "StartedAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startedAfter)).urlPercentEncoding())
            items.append(startedAfterQueryItem)
        }
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        if let reverseOrder = value.reverseOrder {
            let reverseOrderQueryItem = Smithy.URIQueryItem(name: "ReverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
            items.append(reverseOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let startedBefore = value.startedBefore {
            let startedBeforeQueryItem = Smithy.URIQueryItem(name: "StartedBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startedBefore)).urlPercentEncoding())
            items.append(startedBeforeQueryItem)
        }
        return items
    }
}

extension ListEventSourceMappingsInput {

    static func urlPathProvider(_ value: ListEventSourceMappingsInput) -> Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

extension ListEventSourceMappingsInput {

    static func queryItemProvider(_ value: ListEventSourceMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let functionName = value.functionName {
            let functionNameQueryItem = Smithy.URIQueryItem(name: "FunctionName".urlPercentEncoding(), value: Swift.String(functionName).urlPercentEncoding())
            items.append(functionNameQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let eventSourceArn = value.eventSourceArn {
            let eventSourceArnQueryItem = Smithy.URIQueryItem(name: "EventSourceArn".urlPercentEncoding(), value: Swift.String(eventSourceArn).urlPercentEncoding())
            items.append(eventSourceArnQueryItem)
        }
        return items
    }
}

extension ListFunctionEventInvokeConfigsInput {

    static func urlPathProvider(_ value: ListFunctionEventInvokeConfigsInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config/list"
    }
}

extension ListFunctionEventInvokeConfigsInput {

    static func queryItemProvider(_ value: ListFunctionEventInvokeConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput {

    static func urlPathProvider(_ value: ListFunctionsInput) -> Swift.String? {
        return "/2015-03-31/functions"
    }
}

extension ListFunctionsInput {

    static func queryItemProvider(_ value: ListFunctionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let masterRegion = value.masterRegion {
            let masterRegionQueryItem = Smithy.URIQueryItem(name: "MasterRegion".urlPercentEncoding(), value: Swift.String(masterRegion).urlPercentEncoding())
            items.append(masterRegionQueryItem)
        }
        if let functionVersion = value.functionVersion {
            let functionVersionQueryItem = Smithy.URIQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion.rawValue).urlPercentEncoding())
            items.append(functionVersionQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsByCodeSigningConfigInput {

    static func urlPathProvider(_ value: ListFunctionsByCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())/functions"
    }
}

extension ListFunctionsByCodeSigningConfigInput {

    static func queryItemProvider(_ value: ListFunctionsByCodeSigningConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionUrlConfigsInput {

    static func urlPathProvider(_ value: ListFunctionUrlConfigsInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/urls"
    }
}

extension ListFunctionUrlConfigsInput {

    static func queryItemProvider(_ value: ListFunctionUrlConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionVersionsByCapacityProviderInput {

    static func urlPathProvider(_ value: ListFunctionVersionsByCapacityProviderInput) -> Swift.String? {
        guard let capacityProviderName = value.capacityProviderName else {
            return nil
        }
        return "/2025-11-30/capacity-providers/\(capacityProviderName.urlPercentEncoding())/function-versions"
    }
}

extension ListFunctionVersionsByCapacityProviderInput {

    static func queryItemProvider(_ value: ListFunctionVersionsByCapacityProviderInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListLayersInput {

    static func urlPathProvider(_ value: ListLayersInput) -> Swift.String? {
        return "/2018-10-31/layers"
    }
}

extension ListLayersInput {

    static func queryItemProvider(_ value: ListLayersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let compatibleRuntime = value.compatibleRuntime {
            let compatibleRuntimeQueryItem = Smithy.URIQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            items.append(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = value.compatibleArchitecture {
            let compatibleArchitectureQueryItem = Smithy.URIQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            items.append(compatibleArchitectureQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListLayerVersionsInput {

    static func urlPathProvider(_ value: ListLayerVersionsInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

extension ListLayerVersionsInput {

    static func queryItemProvider(_ value: ListLayerVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let compatibleRuntime = value.compatibleRuntime {
            let compatibleRuntimeQueryItem = Smithy.URIQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            items.append(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = value.compatibleArchitecture {
            let compatibleArchitectureQueryItem = Smithy.URIQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            items.append(compatibleArchitectureQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListProvisionedConcurrencyConfigsInput {

    static func urlPathProvider(_ value: ListProvisionedConcurrencyConfigsInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension ListProvisionedConcurrencyConfigsInput {

    static func queryItemProvider(_ value: ListProvisionedConcurrencyConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: "ALL"))
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        guard let resource = value.resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

extension ListVersionsByFunctionInput {

    static func urlPathProvider(_ value: ListVersionsByFunctionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

extension ListVersionsByFunctionInput {

    static func queryItemProvider(_ value: ListVersionsByFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension PublishLayerVersionInput {

    static func urlPathProvider(_ value: PublishLayerVersionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

extension PublishVersionInput {

    static func urlPathProvider(_ value: PublishVersionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

extension PutFunctionCodeSigningConfigInput {

    static func urlPathProvider(_ value: PutFunctionCodeSigningConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

extension PutFunctionConcurrencyInput {

    static func urlPathProvider(_ value: PutFunctionConcurrencyInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

extension PutFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: PutFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension PutFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: PutFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension PutFunctionRecursionConfigInput {

    static func urlPathProvider(_ value: PutFunctionRecursionConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2024-08-31/functions/\(functionName.urlPercentEncoding())/recursion-config"
    }
}

extension PutFunctionScalingConfigInput {

    static func urlPathProvider(_ value: PutFunctionScalingConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2025-11-30/functions/\(functionName.urlPercentEncoding())/function-scaling-config"
    }
}

extension PutFunctionScalingConfigInput {

    static func queryItemProvider(_ value: PutFunctionScalingConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension PutProvisionedConcurrencyConfigInput {

    static func urlPathProvider(_ value: PutProvisionedConcurrencyConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

extension PutProvisionedConcurrencyConfigInput {

    static func queryItemProvider(_ value: PutProvisionedConcurrencyConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let qualifier = value.qualifier else {
            let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
        items.append(qualifierQueryItem)
        return items
    }
}

extension PutRuntimeManagementConfigInput {

    static func urlPathProvider(_ value: PutRuntimeManagementConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-07-20/functions/\(functionName.urlPercentEncoding())/runtime-management-config"
    }
}

extension PutRuntimeManagementConfigInput {

    static func queryItemProvider(_ value: PutRuntimeManagementConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension RemoveLayerVersionPermissionInput {

    static func urlPathProvider(_ value: RemoveLayerVersionPermissionInput) -> Swift.String? {
        guard let layerName = value.layerName else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy/\(statementId.urlPercentEncoding())"
    }
}

extension RemoveLayerVersionPermissionInput {

    static func queryItemProvider(_ value: RemoveLayerVersionPermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = Smithy.URIQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension RemovePermissionInput {

    static func urlPathProvider(_ value: RemovePermissionInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy/\(statementId.urlPercentEncoding())"
    }
}

extension RemovePermissionInput {

    static func queryItemProvider(_ value: RemovePermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = Smithy.URIQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension SendDurableExecutionCallbackFailureInput {

    static func urlPathProvider(_ value: SendDurableExecutionCallbackFailureInput) -> Swift.String? {
        guard let callbackId = value.callbackId else {
            return nil
        }
        return "/2025-12-01/durable-execution-callbacks/\(callbackId.urlPercentEncoding())/fail"
    }
}

extension SendDurableExecutionCallbackHeartbeatInput {

    static func urlPathProvider(_ value: SendDurableExecutionCallbackHeartbeatInput) -> Swift.String? {
        guard let callbackId = value.callbackId else {
            return nil
        }
        return "/2025-12-01/durable-execution-callbacks/\(callbackId.urlPercentEncoding())/heartbeat"
    }
}

extension SendDurableExecutionCallbackSuccessInput {

    static func urlPathProvider(_ value: SendDurableExecutionCallbackSuccessInput) -> Swift.String? {
        guard let callbackId = value.callbackId else {
            return nil
        }
        return "/2025-12-01/durable-execution-callbacks/\(callbackId.urlPercentEncoding())/succeed"
    }
}

extension StopDurableExecutionInput {

    static func urlPathProvider(_ value: StopDurableExecutionInput) -> Swift.String? {
        guard let durableExecutionArn = value.durableExecutionArn else {
            return nil
        }
        return "/2025-12-01/durable-executions/\(durableExecutionArn.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resource = value.resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resource = value.resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAliasInput {

    static func urlPathProvider(_ value: UpdateAliasInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

extension UpdateCapacityProviderInput {

    static func urlPathProvider(_ value: UpdateCapacityProviderInput) -> Swift.String? {
        guard let capacityProviderName = value.capacityProviderName else {
            return nil
        }
        return "/2025-11-30/capacity-providers/\(capacityProviderName.urlPercentEncoding())"
    }
}

extension UpdateCodeSigningConfigInput {

    static func urlPathProvider(_ value: UpdateCodeSigningConfigInput) -> Swift.String? {
        guard let codeSigningConfigArn = value.codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

extension UpdateEventSourceMappingInput {

    static func urlPathProvider(_ value: UpdateEventSourceMappingInput) -> Swift.String? {
        guard let uuid = value.uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

extension UpdateFunctionCodeInput {

    static func urlPathProvider(_ value: UpdateFunctionCodeInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/code"
    }
}

extension UpdateFunctionConfigurationInput {

    static func urlPathProvider(_ value: UpdateFunctionConfigurationInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

extension UpdateFunctionEventInvokeConfigInput {

    static func urlPathProvider(_ value: UpdateFunctionEventInvokeConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

extension UpdateFunctionEventInvokeConfigInput {

    static func queryItemProvider(_ value: UpdateFunctionEventInvokeConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension UpdateFunctionUrlConfigInput {

    static func urlPathProvider(_ value: UpdateFunctionUrlConfigInput) -> Swift.String? {
        guard let functionName = value.functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

extension UpdateFunctionUrlConfigInput {

    static func queryItemProvider(_ value: UpdateFunctionUrlConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qualifier = value.qualifier {
            let qualifierQueryItem = Smithy.URIQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
        }
        return items
    }
}

extension AddLayerVersionPermissionInput {

    static func write(value: AddLayerVersionPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Principal"].write(value.principal)
        try writer["StatementId"].write(value.statementId)
    }
}

extension AddPermissionInput {

    static func write(value: AddPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["EventSourceToken"].write(value.eventSourceToken)
        try writer["FunctionUrlAuthType"].write(value.functionUrlAuthType)
        try writer["InvokedViaFunctionUrl"].write(value.invokedViaFunctionUrl)
        try writer["Principal"].write(value.principal)
        try writer["PrincipalOrgID"].write(value.principalOrgID)
        try writer["RevisionId"].write(value.revisionId)
        try writer["SourceAccount"].write(value.sourceAccount)
        try writer["SourceArn"].write(value.sourceArn)
        try writer["StatementId"].write(value.statementId)
    }
}

extension CheckpointDurableExecutionInput {

    static func write(value: CheckpointDurableExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CheckpointToken"].write(value.checkpointToken)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Updates"].writeList(value.updates, memberWritingClosure: LambdaClientTypes.OperationUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAliasInput {

    static func write(value: CreateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FunctionVersion"].write(value.functionVersion)
        try writer["Name"].write(value.name)
        try writer["RoutingConfig"].write(value.routingConfig, with: LambdaClientTypes.AliasRoutingConfiguration.write(value:to:))
    }
}

extension CreateCapacityProviderInput {

    static func write(value: CreateCapacityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityProviderName"].write(value.capacityProviderName)
        try writer["CapacityProviderScalingConfig"].write(value.capacityProviderScalingConfig, with: LambdaClientTypes.CapacityProviderScalingConfig.write(value:to:))
        try writer["InstanceRequirements"].write(value.instanceRequirements, with: LambdaClientTypes.InstanceRequirements.write(value:to:))
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["PermissionsConfig"].write(value.permissionsConfig, with: LambdaClientTypes.CapacityProviderPermissionsConfig.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VpcConfig"].write(value.vpcConfig, with: LambdaClientTypes.CapacityProviderVpcConfig.write(value:to:))
    }
}

extension CreateCodeSigningConfigInput {

    static func write(value: CreateCodeSigningConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedPublishers"].write(value.allowedPublishers, with: LambdaClientTypes.AllowedPublishers.write(value:to:))
        try writer["CodeSigningPolicies"].write(value.codeSigningPolicies, with: LambdaClientTypes.CodeSigningPolicies.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEventSourceMappingInput {

    static func write(value: CreateEventSourceMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonManagedKafkaEventSourceConfig"].write(value.amazonManagedKafkaEventSourceConfig, with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.write(value:to:))
        try writer["BatchSize"].write(value.batchSize)
        try writer["BisectBatchOnFunctionError"].write(value.bisectBatchOnFunctionError)
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["DocumentDBEventSourceConfig"].write(value.documentDBEventSourceConfig, with: LambdaClientTypes.DocumentDBEventSourceConfig.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["EventSourceArn"].write(value.eventSourceArn)
        try writer["FilterCriteria"].write(value.filterCriteria, with: LambdaClientTypes.FilterCriteria.write(value:to:))
        try writer["FunctionName"].write(value.functionName)
        try writer["FunctionResponseTypes"].writeList(value.functionResponseTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.FunctionResponseType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["MaximumBatchingWindowInSeconds"].write(value.maximumBatchingWindowInSeconds)
        try writer["MaximumRecordAgeInSeconds"].write(value.maximumRecordAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
        try writer["MetricsConfig"].write(value.metricsConfig, with: LambdaClientTypes.EventSourceMappingMetricsConfig.write(value:to:))
        try writer["ParallelizationFactor"].write(value.parallelizationFactor)
        try writer["ProvisionedPollerConfig"].write(value.provisionedPollerConfig, with: LambdaClientTypes.ProvisionedPollerConfig.write(value:to:))
        try writer["Queues"].writeList(value.queues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScalingConfig"].write(value.scalingConfig, with: LambdaClientTypes.ScalingConfig.write(value:to:))
        try writer["SelfManagedEventSource"].write(value.selfManagedEventSource, with: LambdaClientTypes.SelfManagedEventSource.write(value:to:))
        try writer["SelfManagedKafkaEventSourceConfig"].write(value.selfManagedKafkaEventSourceConfig, with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.write(value:to:))
        try writer["SourceAccessConfigurations"].writeList(value.sourceAccessConfigurations, memberWritingClosure: LambdaClientTypes.SourceAccessConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartingPosition"].write(value.startingPosition)
        try writer["StartingPositionTimestamp"].writeTimestamp(value.startingPositionTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Topics"].writeList(value.topics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TumblingWindowInSeconds"].write(value.tumblingWindowInSeconds)
    }
}

extension CreateFunctionInput {

    static func write(value: CreateFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architectures"].writeList(value.architectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CapacityProviderConfig"].write(value.capacityProviderConfig, with: LambdaClientTypes.CapacityProviderConfig.write(value:to:))
        try writer["Code"].write(value.code, with: LambdaClientTypes.FunctionCode.write(value:to:))
        try writer["CodeSigningConfigArn"].write(value.codeSigningConfigArn)
        try writer["DeadLetterConfig"].write(value.deadLetterConfig, with: LambdaClientTypes.DeadLetterConfig.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DurableConfig"].write(value.durableConfig, with: LambdaClientTypes.DurableConfig.write(value:to:))
        try writer["Environment"].write(value.environment, with: LambdaClientTypes.Environment.write(value:to:))
        try writer["EphemeralStorage"].write(value.ephemeralStorage, with: LambdaClientTypes.EphemeralStorage.write(value:to:))
        try writer["FileSystemConfigs"].writeList(value.fileSystemConfigs, memberWritingClosure: LambdaClientTypes.FileSystemConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FunctionName"].write(value.functionName)
        try writer["Handler"].write(value.handler)
        try writer["ImageConfig"].write(value.imageConfig, with: LambdaClientTypes.ImageConfig.write(value:to:))
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["Layers"].writeList(value.layers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoggingConfig"].write(value.loggingConfig, with: LambdaClientTypes.LoggingConfig.write(value:to:))
        try writer["MemorySize"].write(value.memorySize)
        try writer["PackageType"].write(value.packageType)
        try writer["Publish"].write(value.publish)
        try writer["PublishTo"].write(value.publishTo)
        try writer["Role"].write(value.role)
        try writer["Runtime"].write(value.runtime)
        try writer["SnapStart"].write(value.snapStart, with: LambdaClientTypes.SnapStart.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TenancyConfig"].write(value.tenancyConfig, with: LambdaClientTypes.TenancyConfig.write(value:to:))
        try writer["Timeout"].write(value.timeout)
        try writer["TracingConfig"].write(value.tracingConfig, with: LambdaClientTypes.TracingConfig.write(value:to:))
        try writer["VpcConfig"].write(value.vpcConfig, with: LambdaClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateFunctionUrlConfigInput {

    static func write(value: CreateFunctionUrlConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthType"].write(value.authType)
        try writer["Cors"].write(value.cors, with: LambdaClientTypes.Cors.write(value:to:))
        try writer["InvokeMode"].write(value.invokeMode)
    }
}

extension InvokeInput {

    static func write(value: InvokeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Payload"].write(value.payload)
    }
}

extension InvokeAsyncInput {

    static func write(value: InvokeAsyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvokeArgs"].write(value.invokeArgs)
    }
}

extension InvokeWithResponseStreamInput {

    static func write(value: InvokeWithResponseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Payload"].write(value.payload)
    }
}

extension PublishLayerVersionInput {

    static func write(value: PublishLayerVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompatibleArchitectures"].writeList(value.compatibleArchitectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CompatibleRuntimes"].writeList(value.compatibleRuntimes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Runtime>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Content"].write(value.content, with: LambdaClientTypes.LayerVersionContentInput.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["LicenseInfo"].write(value.licenseInfo)
    }
}

extension PublishVersionInput {

    static func write(value: PublishVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeSha256"].write(value.codeSha256)
        try writer["Description"].write(value.description)
        try writer["PublishTo"].write(value.publishTo)
        try writer["RevisionId"].write(value.revisionId)
    }
}

extension PutFunctionCodeSigningConfigInput {

    static func write(value: PutFunctionCodeSigningConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeSigningConfigArn"].write(value.codeSigningConfigArn)
    }
}

extension PutFunctionConcurrencyInput {

    static func write(value: PutFunctionConcurrencyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReservedConcurrentExecutions"].write(value.reservedConcurrentExecutions)
    }
}

extension PutFunctionEventInvokeConfigInput {

    static func write(value: PutFunctionEventInvokeConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["MaximumEventAgeInSeconds"].write(value.maximumEventAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
    }
}

extension PutFunctionRecursionConfigInput {

    static func write(value: PutFunctionRecursionConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecursiveLoop"].write(value.recursiveLoop)
    }
}

extension PutFunctionScalingConfigInput {

    static func write(value: PutFunctionScalingConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunctionScalingConfig"].write(value.functionScalingConfig, with: LambdaClientTypes.FunctionScalingConfig.write(value:to:))
    }
}

extension PutProvisionedConcurrencyConfigInput {

    static func write(value: PutProvisionedConcurrencyConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProvisionedConcurrentExecutions"].write(value.provisionedConcurrentExecutions)
    }
}

extension PutRuntimeManagementConfigInput {

    static func write(value: PutRuntimeManagementConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuntimeVersionArn"].write(value.runtimeVersionArn)
        try writer["UpdateRuntimeOn"].write(value.updateRuntimeOn)
    }
}

extension SendDurableExecutionCallbackFailureInput {

    static func write(value: SendDurableExecutionCallbackFailureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Error"].write(value.error, with: LambdaClientTypes.ErrorObject.write(value:to:))
    }
}

extension SendDurableExecutionCallbackSuccessInput {

    static func write(value: SendDurableExecutionCallbackSuccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Result"].write(value.result)
    }
}

extension StopDurableExecutionInput {

    static func write(value: StopDurableExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Error"].write(value.error, with: LambdaClientTypes.ErrorObject.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAliasInput {

    static func write(value: UpdateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FunctionVersion"].write(value.functionVersion)
        try writer["RevisionId"].write(value.revisionId)
        try writer["RoutingConfig"].write(value.routingConfig, with: LambdaClientTypes.AliasRoutingConfiguration.write(value:to:))
    }
}

extension UpdateCapacityProviderInput {

    static func write(value: UpdateCapacityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityProviderScalingConfig"].write(value.capacityProviderScalingConfig, with: LambdaClientTypes.CapacityProviderScalingConfig.write(value:to:))
    }
}

extension UpdateCodeSigningConfigInput {

    static func write(value: UpdateCodeSigningConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedPublishers"].write(value.allowedPublishers, with: LambdaClientTypes.AllowedPublishers.write(value:to:))
        try writer["CodeSigningPolicies"].write(value.codeSigningPolicies, with: LambdaClientTypes.CodeSigningPolicies.write(value:to:))
        try writer["Description"].write(value.description)
    }
}

extension UpdateEventSourceMappingInput {

    static func write(value: UpdateEventSourceMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonManagedKafkaEventSourceConfig"].write(value.amazonManagedKafkaEventSourceConfig, with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.write(value:to:))
        try writer["BatchSize"].write(value.batchSize)
        try writer["BisectBatchOnFunctionError"].write(value.bisectBatchOnFunctionError)
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["DocumentDBEventSourceConfig"].write(value.documentDBEventSourceConfig, with: LambdaClientTypes.DocumentDBEventSourceConfig.write(value:to:))
        try writer["Enabled"].write(value.enabled)
        try writer["FilterCriteria"].write(value.filterCriteria, with: LambdaClientTypes.FilterCriteria.write(value:to:))
        try writer["FunctionName"].write(value.functionName)
        try writer["FunctionResponseTypes"].writeList(value.functionResponseTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.FunctionResponseType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["MaximumBatchingWindowInSeconds"].write(value.maximumBatchingWindowInSeconds)
        try writer["MaximumRecordAgeInSeconds"].write(value.maximumRecordAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
        try writer["MetricsConfig"].write(value.metricsConfig, with: LambdaClientTypes.EventSourceMappingMetricsConfig.write(value:to:))
        try writer["ParallelizationFactor"].write(value.parallelizationFactor)
        try writer["ProvisionedPollerConfig"].write(value.provisionedPollerConfig, with: LambdaClientTypes.ProvisionedPollerConfig.write(value:to:))
        try writer["ScalingConfig"].write(value.scalingConfig, with: LambdaClientTypes.ScalingConfig.write(value:to:))
        try writer["SelfManagedKafkaEventSourceConfig"].write(value.selfManagedKafkaEventSourceConfig, with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.write(value:to:))
        try writer["SourceAccessConfigurations"].writeList(value.sourceAccessConfigurations, memberWritingClosure: LambdaClientTypes.SourceAccessConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TumblingWindowInSeconds"].write(value.tumblingWindowInSeconds)
    }
}

extension UpdateFunctionCodeInput {

    static func write(value: UpdateFunctionCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architectures"].writeList(value.architectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DryRun"].write(value.dryRun)
        try writer["ImageUri"].write(value.imageUri)
        try writer["Publish"].write(value.publish)
        try writer["PublishTo"].write(value.publishTo)
        try writer["RevisionId"].write(value.revisionId)
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["SourceKMSKeyArn"].write(value.sourceKMSKeyArn)
        try writer["ZipFile"].write(value.zipFile)
    }
}

extension UpdateFunctionConfigurationInput {

    static func write(value: UpdateFunctionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityProviderConfig"].write(value.capacityProviderConfig, with: LambdaClientTypes.CapacityProviderConfig.write(value:to:))
        try writer["DeadLetterConfig"].write(value.deadLetterConfig, with: LambdaClientTypes.DeadLetterConfig.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DurableConfig"].write(value.durableConfig, with: LambdaClientTypes.DurableConfig.write(value:to:))
        try writer["Environment"].write(value.environment, with: LambdaClientTypes.Environment.write(value:to:))
        try writer["EphemeralStorage"].write(value.ephemeralStorage, with: LambdaClientTypes.EphemeralStorage.write(value:to:))
        try writer["FileSystemConfigs"].writeList(value.fileSystemConfigs, memberWritingClosure: LambdaClientTypes.FileSystemConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Handler"].write(value.handler)
        try writer["ImageConfig"].write(value.imageConfig, with: LambdaClientTypes.ImageConfig.write(value:to:))
        try writer["KMSKeyArn"].write(value.kmsKeyArn)
        try writer["Layers"].writeList(value.layers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoggingConfig"].write(value.loggingConfig, with: LambdaClientTypes.LoggingConfig.write(value:to:))
        try writer["MemorySize"].write(value.memorySize)
        try writer["RevisionId"].write(value.revisionId)
        try writer["Role"].write(value.role)
        try writer["Runtime"].write(value.runtime)
        try writer["SnapStart"].write(value.snapStart, with: LambdaClientTypes.SnapStart.write(value:to:))
        try writer["Timeout"].write(value.timeout)
        try writer["TracingConfig"].write(value.tracingConfig, with: LambdaClientTypes.TracingConfig.write(value:to:))
        try writer["VpcConfig"].write(value.vpcConfig, with: LambdaClientTypes.VpcConfig.write(value:to:))
    }
}

extension UpdateFunctionEventInvokeConfigInput {

    static func write(value: UpdateFunctionEventInvokeConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfig"].write(value.destinationConfig, with: LambdaClientTypes.DestinationConfig.write(value:to:))
        try writer["MaximumEventAgeInSeconds"].write(value.maximumEventAgeInSeconds)
        try writer["MaximumRetryAttempts"].write(value.maximumRetryAttempts)
    }
}

extension UpdateFunctionUrlConfigInput {

    static func write(value: UpdateFunctionUrlConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthType"].write(value.authType)
        try writer["Cors"].write(value.cors, with: LambdaClientTypes.Cors.write(value:to:))
        try writer["InvokeMode"].write(value.invokeMode)
    }
}

extension AddLayerVersionPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddLayerVersionPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddLayerVersionPermissionOutput()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.statement = try reader["Statement"].readIfPresent()
        return value
    }
}

extension AddPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddPermissionOutput()
        value.statement = try reader["Statement"].readIfPresent()
        return value
    }
}

extension CheckpointDurableExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckpointDurableExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckpointDurableExecutionOutput()
        value.checkpointToken = try reader["CheckpointToken"].readIfPresent()
        value.newExecutionState = try reader["NewExecutionState"].readIfPresent(with: LambdaClientTypes.CheckpointUpdatedExecutionState.read(from:))
        return value
    }
}

extension CreateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAliasOutput()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        return value
    }
}

extension CreateCapacityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCapacityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCapacityProviderOutput()
        value.capacityProvider = try reader["CapacityProvider"].readIfPresent(with: LambdaClientTypes.CapacityProvider.read(from:))
        return value
    }
}

extension CreateCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCodeSigningConfigOutput()
        value.codeSigningConfig = try reader["CodeSigningConfig"].readIfPresent(with: LambdaClientTypes.CodeSigningConfig.read(from:))
        return value
    }
}

extension CreateEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.metricsConfig = try reader["MetricsConfig"].readIfPresent(with: LambdaClientTypes.EventSourceMappingMetricsConfig.read(from:))
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.provisionedPollerConfig = try reader["ProvisionedPollerConfig"].readIfPresent(with: LambdaClientTypes.ProvisionedPollerConfig.read(from:))
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension CreateFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityProviderConfig = try reader["CapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderConfig.read(from:))
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.configSha256 = try reader["ConfigSha256"].readIfPresent()
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.durableConfig = try reader["DurableConfig"].readIfPresent(with: LambdaClientTypes.DurableConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.tenancyConfig = try reader["TenancyConfig"].readIfPresent(with: LambdaClientTypes.TenancyConfig.read(from:))
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension CreateFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionUrlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionUrlConfigOutput()
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        return value
    }
}

extension DeleteAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAliasOutput {
        return DeleteAliasOutput()
    }
}

extension DeleteCapacityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCapacityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCapacityProviderOutput()
        value.capacityProvider = try reader["CapacityProvider"].readIfPresent(with: LambdaClientTypes.CapacityProvider.read(from:))
        return value
    }
}

extension DeleteCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCodeSigningConfigOutput {
        return DeleteCodeSigningConfigOutput()
    }
}

extension DeleteEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.metricsConfig = try reader["MetricsConfig"].readIfPresent(with: LambdaClientTypes.EventSourceMappingMetricsConfig.read(from:))
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.provisionedPollerConfig = try reader["ProvisionedPollerConfig"].readIfPresent(with: LambdaClientTypes.ProvisionedPollerConfig.read(from:))
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension DeleteFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionOutput {
        var value = DeleteFunctionOutput()
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteFunctionCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionCodeSigningConfigOutput {
        return DeleteFunctionCodeSigningConfigOutput()
    }
}

extension DeleteFunctionConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionConcurrencyOutput {
        return DeleteFunctionConcurrencyOutput()
    }
}

extension DeleteFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionEventInvokeConfigOutput {
        return DeleteFunctionEventInvokeConfigOutput()
    }
}

extension DeleteFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionUrlConfigOutput {
        return DeleteFunctionUrlConfigOutput()
    }
}

extension DeleteLayerVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLayerVersionOutput {
        return DeleteLayerVersionOutput()
    }
}

extension DeleteProvisionedConcurrencyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisionedConcurrencyConfigOutput {
        return DeleteProvisionedConcurrencyConfigOutput()
    }
}

extension GetAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountSettingsOutput()
        value.accountLimit = try reader["AccountLimit"].readIfPresent(with: LambdaClientTypes.AccountLimit.read(from:))
        value.accountUsage = try reader["AccountUsage"].readIfPresent(with: LambdaClientTypes.AccountUsage.read(from:))
        return value
    }
}

extension GetAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAliasOutput()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        return value
    }
}

extension GetCapacityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCapacityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCapacityProviderOutput()
        value.capacityProvider = try reader["CapacityProvider"].readIfPresent(with: LambdaClientTypes.CapacityProvider.read(from:))
        return value
    }
}

extension GetCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCodeSigningConfigOutput()
        value.codeSigningConfig = try reader["CodeSigningConfig"].readIfPresent(with: LambdaClientTypes.CodeSigningConfig.read(from:))
        return value
    }
}

extension GetDurableExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDurableExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDurableExecutionOutput()
        value.durableExecutionArn = try reader["DurableExecutionArn"].readIfPresent() ?? ""
        value.durableExecutionName = try reader["DurableExecutionName"].readIfPresent() ?? ""
        value.endTimestamp = try reader["EndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ErrorObject.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.inputPayload = try reader["InputPayload"].readIfPresent()
        value.result = try reader["Result"].readIfPresent()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.traceHeader = try reader["TraceHeader"].readIfPresent(with: LambdaClientTypes.TraceHeader.read(from:))
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetDurableExecutionHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDurableExecutionHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDurableExecutionHistoryOutput()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension GetDurableExecutionStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDurableExecutionStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDurableExecutionStateOutput()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.operations = try reader["Operations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Operation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.metricsConfig = try reader["MetricsConfig"].readIfPresent(with: LambdaClientTypes.EventSourceMappingMetricsConfig.read(from:))
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.provisionedPollerConfig = try reader["ProvisionedPollerConfig"].readIfPresent(with: LambdaClientTypes.ProvisionedPollerConfig.read(from:))
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension GetFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionOutput()
        value.code = try reader["Code"].readIfPresent(with: LambdaClientTypes.FunctionCodeLocation.read(from:))
        value.concurrency = try reader["Concurrency"].readIfPresent(with: LambdaClientTypes.Concurrency.read(from:))
        value.configuration = try reader["Configuration"].readIfPresent(with: LambdaClientTypes.FunctionConfiguration.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tagsError = try reader["TagsError"].readIfPresent(with: LambdaClientTypes.TagsError.read(from:))
        return value
    }
}

extension GetFunctionCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionCodeSigningConfigOutput()
        value.codeSigningConfigArn = try reader["CodeSigningConfigArn"].readIfPresent() ?? ""
        value.functionName = try reader["FunctionName"].readIfPresent() ?? ""
        return value
    }
}

extension GetFunctionConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionConcurrencyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionConcurrencyOutput()
        value.reservedConcurrentExecutions = try reader["ReservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension GetFunctionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionConfigurationOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityProviderConfig = try reader["CapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderConfig.read(from:))
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.configSha256 = try reader["ConfigSha256"].readIfPresent()
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.durableConfig = try reader["DurableConfig"].readIfPresent(with: LambdaClientTypes.DurableConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.tenancyConfig = try reader["TenancyConfig"].readIfPresent(with: LambdaClientTypes.TenancyConfig.read(from:))
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension GetFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionEventInvokeConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionEventInvokeConfigOutput()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        return value
    }
}

extension GetFunctionRecursionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionRecursionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionRecursionConfigOutput()
        value.recursiveLoop = try reader["RecursiveLoop"].readIfPresent()
        return value
    }
}

extension GetFunctionScalingConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionScalingConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionScalingConfigOutput()
        value.appliedFunctionScalingConfig = try reader["AppliedFunctionScalingConfig"].readIfPresent(with: LambdaClientTypes.FunctionScalingConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.requestedFunctionScalingConfig = try reader["RequestedFunctionScalingConfig"].readIfPresent(with: LambdaClientTypes.FunctionScalingConfig.read(from:))
        return value
    }
}

extension GetFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionUrlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionUrlConfigOutput()
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? ""
        return value
    }
}

extension GetLayerVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayerVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayerVersionOutput()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent(with: LambdaClientTypes.LayerVersionContentOutput.read(from:))
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension GetLayerVersionByArnOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayerVersionByArnOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayerVersionByArnOutput()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent(with: LambdaClientTypes.LayerVersionContentOutput.read(from:))
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension GetLayerVersionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayerVersionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayerVersionPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension GetProvisionedConcurrencyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisionedConcurrencyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedConcurrencyConfigOutput()
        value.allocatedProvisionedConcurrentExecutions = try reader["AllocatedProvisionedConcurrentExecutions"].readIfPresent()
        value.availableProvisionedConcurrentExecutions = try reader["AvailableProvisionedConcurrentExecutions"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.requestedProvisionedConcurrentExecutions = try reader["RequestedProvisionedConcurrentExecutions"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension GetRuntimeManagementConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuntimeManagementConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuntimeManagementConfigOutput()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.runtimeVersionArn = try reader["RuntimeVersionArn"].readIfPresent()
        value.updateRuntimeOn = try reader["UpdateRuntimeOn"].readIfPresent()
        return value
    }
}

extension InvokeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeOutput {
        var value = InvokeOutput()
        if let durableExecutionArnHeaderValue = httpResponse.headers.value(for: "X-Amz-Durable-Execution-Arn") {
            value.durableExecutionArn = durableExecutionArnHeaderValue
        }
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            value.executedVersion = executedVersionHeaderValue
        }
        if let functionErrorHeaderValue = httpResponse.headers.value(for: "X-Amz-Function-Error") {
            value.functionError = functionErrorHeaderValue
        }
        if let logResultHeaderValue = httpResponse.headers.value(for: "X-Amz-Log-Result") {
            value.logResult = logResultHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension InvokeAsyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeAsyncOutput {
        var value = InvokeAsyncOutput()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension InvokeWithResponseStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeWithResponseStreamOutput {
        var value = InvokeWithResponseStreamOutput()
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            value.executedVersion = executedVersionHeaderValue
        }
        if let responseStreamContentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.responseStreamContentType = responseStreamContentTypeHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: LambdaClientTypes.InvokeWithResponseStreamResponseEvent.unmarshal)
            value.eventStream = decoderStream.toAsyncStream()
        }
        value.statusCode = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAliasesOutput()
        value.aliases = try reader["Aliases"].readListIfPresent(memberReadingClosure: LambdaClientTypes.AliasConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListCapacityProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCapacityProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCapacityProvidersOutput()
        value.capacityProviders = try reader["CapacityProviders"].readListIfPresent(memberReadingClosure: LambdaClientTypes.CapacityProvider.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListCodeSigningConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCodeSigningConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCodeSigningConfigsOutput()
        value.codeSigningConfigs = try reader["CodeSigningConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.CodeSigningConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListDurableExecutionsByFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDurableExecutionsByFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDurableExecutionsByFunctionOutput()
        value.durableExecutions = try reader["DurableExecutions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Execution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListEventSourceMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventSourceMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventSourceMappingsOutput()
        value.eventSourceMappings = try reader["EventSourceMappings"].readListIfPresent(memberReadingClosure: LambdaClientTypes.EventSourceMappingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionEventInvokeConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionEventInvokeConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionEventInvokeConfigsOutput()
        value.functionEventInvokeConfigs = try reader["FunctionEventInvokeConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionEventInvokeConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionsOutput()
        value.functions = try reader["Functions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionsByCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionsByCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionsByCodeSigningConfigOutput()
        value.functionArns = try reader["FunctionArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionUrlConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionUrlConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionUrlConfigsOutput()
        value.functionUrlConfigs = try reader["FunctionUrlConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionUrlConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListFunctionVersionsByCapacityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionVersionsByCapacityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionVersionsByCapacityProviderOutput()
        value.capacityProviderArn = try reader["CapacityProviderArn"].readIfPresent() ?? ""
        value.functionVersions = try reader["FunctionVersions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionVersionsByCapacityProviderListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListLayersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLayersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLayersOutput()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.LayersListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListLayerVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLayerVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLayerVersionsOutput()
        value.layerVersions = try reader["LayerVersions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.LayerVersionsListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension ListProvisionedConcurrencyConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisionedConcurrencyConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedConcurrencyConfigsOutput()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.provisionedConcurrencyConfigs = try reader["ProvisionedConcurrencyConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.ProvisionedConcurrencyConfigListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListVersionsByFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVersionsByFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVersionsByFunctionOutput()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FunctionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PublishLayerVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishLayerVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PublishLayerVersionOutput()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent(with: LambdaClientTypes.LayerVersionContentOutput.read(from:))
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension PublishVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PublishVersionOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityProviderConfig = try reader["CapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderConfig.read(from:))
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.configSha256 = try reader["ConfigSha256"].readIfPresent()
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.durableConfig = try reader["DurableConfig"].readIfPresent(with: LambdaClientTypes.DurableConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.tenancyConfig = try reader["TenancyConfig"].readIfPresent(with: LambdaClientTypes.TenancyConfig.read(from:))
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension PutFunctionCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionCodeSigningConfigOutput()
        value.codeSigningConfigArn = try reader["CodeSigningConfigArn"].readIfPresent() ?? ""
        value.functionName = try reader["FunctionName"].readIfPresent() ?? ""
        return value
    }
}

extension PutFunctionConcurrencyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionConcurrencyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionConcurrencyOutput()
        value.reservedConcurrentExecutions = try reader["ReservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension PutFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionEventInvokeConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionEventInvokeConfigOutput()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        return value
    }
}

extension PutFunctionRecursionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionRecursionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionRecursionConfigOutput()
        value.recursiveLoop = try reader["RecursiveLoop"].readIfPresent()
        return value
    }
}

extension PutFunctionScalingConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFunctionScalingConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFunctionScalingConfigOutput()
        value.functionState = try reader["FunctionState"].readIfPresent()
        return value
    }
}

extension PutProvisionedConcurrencyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProvisionedConcurrencyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProvisionedConcurrencyConfigOutput()
        value.allocatedProvisionedConcurrentExecutions = try reader["AllocatedProvisionedConcurrentExecutions"].readIfPresent()
        value.availableProvisionedConcurrentExecutions = try reader["AvailableProvisionedConcurrentExecutions"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.requestedProvisionedConcurrentExecutions = try reader["RequestedProvisionedConcurrentExecutions"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension PutRuntimeManagementConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRuntimeManagementConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRuntimeManagementConfigOutput()
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.runtimeVersionArn = try reader["RuntimeVersionArn"].readIfPresent()
        value.updateRuntimeOn = try reader["UpdateRuntimeOn"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RemoveLayerVersionPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveLayerVersionPermissionOutput {
        return RemoveLayerVersionPermissionOutput()
    }
}

extension RemovePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemovePermissionOutput {
        return RemovePermissionOutput()
    }
}

extension SendDurableExecutionCallbackFailureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDurableExecutionCallbackFailureOutput {
        return SendDurableExecutionCallbackFailureOutput()
    }
}

extension SendDurableExecutionCallbackHeartbeatOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDurableExecutionCallbackHeartbeatOutput {
        return SendDurableExecutionCallbackHeartbeatOutput()
    }
}

extension SendDurableExecutionCallbackSuccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDurableExecutionCallbackSuccessOutput {
        return SendDurableExecutionCallbackSuccessOutput()
    }
}

extension StopDurableExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopDurableExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopDurableExecutionOutput()
        value.stopTimestamp = try reader["StopTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAliasOutput()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        return value
    }
}

extension UpdateCapacityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCapacityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCapacityProviderOutput()
        value.capacityProvider = try reader["CapacityProvider"].readIfPresent(with: LambdaClientTypes.CapacityProvider.read(from:))
        return value
    }
}

extension UpdateCodeSigningConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCodeSigningConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCodeSigningConfigOutput()
        value.codeSigningConfig = try reader["CodeSigningConfig"].readIfPresent(with: LambdaClientTypes.CodeSigningConfig.read(from:))
        return value
    }
}

extension UpdateEventSourceMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventSourceMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEventSourceMappingOutput()
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.metricsConfig = try reader["MetricsConfig"].readIfPresent(with: LambdaClientTypes.EventSourceMappingMetricsConfig.read(from:))
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.provisionedPollerConfig = try reader["ProvisionedPollerConfig"].readIfPresent(with: LambdaClientTypes.ProvisionedPollerConfig.read(from:))
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.uuid = try reader["UUID"].readIfPresent()
        return value
    }
}

extension UpdateFunctionCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionCodeOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityProviderConfig = try reader["CapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderConfig.read(from:))
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.configSha256 = try reader["ConfigSha256"].readIfPresent()
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.durableConfig = try reader["DurableConfig"].readIfPresent(with: LambdaClientTypes.DurableConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.tenancyConfig = try reader["TenancyConfig"].readIfPresent(with: LambdaClientTypes.TenancyConfig.read(from:))
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension UpdateFunctionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionConfigurationOutput()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityProviderConfig = try reader["CapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderConfig.read(from:))
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.configSha256 = try reader["ConfigSha256"].readIfPresent()
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.durableConfig = try reader["DurableConfig"].readIfPresent(with: LambdaClientTypes.DurableConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.tenancyConfig = try reader["TenancyConfig"].readIfPresent(with: LambdaClientTypes.TenancyConfig.read(from:))
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        return value
    }
}

extension UpdateFunctionEventInvokeConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionEventInvokeConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionEventInvokeConfigOutput()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        return value
    }
}

extension UpdateFunctionUrlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionUrlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionUrlConfigOutput()
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? ""
        return value
    }
}

enum AddLayerVersionPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PolicyLengthExceededException": return try PolicyLengthExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PolicyLengthExceededException": return try PolicyLengthExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckpointDurableExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCapacityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CapacityProviderLimitExceededException": return try CapacityProviderLimitExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "CodeVerificationFailedException": return try CodeVerificationFailedException.makeError(baseError: baseError)
            case "FunctionVersionsPerCapacityProviderLimitExceededException": return try FunctionVersionsPerCapacityProviderLimitExceededException.makeError(baseError: baseError)
            case "InvalidCodeSignatureException": return try InvalidCodeSignatureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCapacityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLayerVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisionedConcurrencyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCapacityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDurableExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDurableExecutionHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDurableExecutionStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionRecursionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionScalingConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayerVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayerVersionByArnOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayerVersionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisionedConcurrencyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ProvisionedConcurrencyConfigNotFoundException": return try ProvisionedConcurrencyConfigNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuntimeManagementConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DurableExecutionAlreadyStartedException": return try DurableExecutionAlreadyStartedException.makeError(baseError: baseError)
            case "EC2AccessDeniedException": return try EC2AccessDeniedException.makeError(baseError: baseError)
            case "EC2ThrottledException": return try EC2ThrottledException.makeError(baseError: baseError)
            case "EC2UnexpectedException": return try EC2UnexpectedException.makeError(baseError: baseError)
            case "EFSIOException": return try EFSIOException.makeError(baseError: baseError)
            case "EFSMountConnectivityException": return try EFSMountConnectivityException.makeError(baseError: baseError)
            case "EFSMountFailureException": return try EFSMountFailureException.makeError(baseError: baseError)
            case "EFSMountTimeoutException": return try EFSMountTimeoutException.makeError(baseError: baseError)
            case "ENILimitReachedException": return try ENILimitReachedException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestContentException": return try InvalidRequestContentException.makeError(baseError: baseError)
            case "InvalidRuntimeException": return try InvalidRuntimeException.makeError(baseError: baseError)
            case "InvalidSecurityGroupIDException": return try InvalidSecurityGroupIDException.makeError(baseError: baseError)
            case "InvalidSubnetIDException": return try InvalidSubnetIDException.makeError(baseError: baseError)
            case "InvalidZipFileException": return try InvalidZipFileException.makeError(baseError: baseError)
            case "KMSAccessDeniedException": return try KMSAccessDeniedException.makeError(baseError: baseError)
            case "KMSDisabledException": return try KMSDisabledException.makeError(baseError: baseError)
            case "KMSInvalidStateException": return try KMSInvalidStateException.makeError(baseError: baseError)
            case "KMSNotFoundException": return try KMSNotFoundException.makeError(baseError: baseError)
            case "NoPublishedVersionException": return try NoPublishedVersionException.makeError(baseError: baseError)
            case "RecursiveInvocationException": return try RecursiveInvocationException.makeError(baseError: baseError)
            case "RequestTooLargeException": return try RequestTooLargeException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "SerializedRequestEntityTooLargeException": return try SerializedRequestEntityTooLargeException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "SnapStartException": return try SnapStartException.makeError(baseError: baseError)
            case "SnapStartNotReadyException": return try SnapStartNotReadyException.makeError(baseError: baseError)
            case "SnapStartTimeoutException": return try SnapStartTimeoutException.makeError(baseError: baseError)
            case "SubnetIPAddressLimitReachedException": return try SubnetIPAddressLimitReachedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedMediaTypeException": return try UnsupportedMediaTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeAsyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestContentException": return try InvalidRequestContentException.makeError(baseError: baseError)
            case "InvalidRuntimeException": return try InvalidRuntimeException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeWithResponseStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EC2AccessDeniedException": return try EC2AccessDeniedException.makeError(baseError: baseError)
            case "EC2ThrottledException": return try EC2ThrottledException.makeError(baseError: baseError)
            case "EC2UnexpectedException": return try EC2UnexpectedException.makeError(baseError: baseError)
            case "EFSIOException": return try EFSIOException.makeError(baseError: baseError)
            case "EFSMountConnectivityException": return try EFSMountConnectivityException.makeError(baseError: baseError)
            case "EFSMountFailureException": return try EFSMountFailureException.makeError(baseError: baseError)
            case "EFSMountTimeoutException": return try EFSMountTimeoutException.makeError(baseError: baseError)
            case "ENILimitReachedException": return try ENILimitReachedException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestContentException": return try InvalidRequestContentException.makeError(baseError: baseError)
            case "InvalidRuntimeException": return try InvalidRuntimeException.makeError(baseError: baseError)
            case "InvalidSecurityGroupIDException": return try InvalidSecurityGroupIDException.makeError(baseError: baseError)
            case "InvalidSubnetIDException": return try InvalidSubnetIDException.makeError(baseError: baseError)
            case "InvalidZipFileException": return try InvalidZipFileException.makeError(baseError: baseError)
            case "KMSAccessDeniedException": return try KMSAccessDeniedException.makeError(baseError: baseError)
            case "KMSDisabledException": return try KMSDisabledException.makeError(baseError: baseError)
            case "KMSInvalidStateException": return try KMSInvalidStateException.makeError(baseError: baseError)
            case "KMSNotFoundException": return try KMSNotFoundException.makeError(baseError: baseError)
            case "NoPublishedVersionException": return try NoPublishedVersionException.makeError(baseError: baseError)
            case "RecursiveInvocationException": return try RecursiveInvocationException.makeError(baseError: baseError)
            case "RequestTooLargeException": return try RequestTooLargeException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "SerializedRequestEntityTooLargeException": return try SerializedRequestEntityTooLargeException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "SnapStartException": return try SnapStartException.makeError(baseError: baseError)
            case "SnapStartNotReadyException": return try SnapStartNotReadyException.makeError(baseError: baseError)
            case "SnapStartTimeoutException": return try SnapStartTimeoutException.makeError(baseError: baseError)
            case "SubnetIPAddressLimitReachedException": return try SubnetIPAddressLimitReachedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnsupportedMediaTypeException": return try UnsupportedMediaTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCapacityProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCodeSigningConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDurableExecutionsByFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventSourceMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionEventInvokeConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionsByCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionUrlConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionVersionsByCapacityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLayersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLayerVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisionedConcurrencyConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVersionsByFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishLayerVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "FunctionVersionsPerCapacityProviderLimitExceededException": return try FunctionVersionsPerCapacityProviderLimitExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionConcurrencyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionRecursionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFunctionScalingConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProvisionedConcurrencyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRuntimeManagementConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveLayerVersionPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemovePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDurableExecutionCallbackFailureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallbackTimeoutException": return try CallbackTimeoutException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDurableExecutionCallbackHeartbeatOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallbackTimeoutException": return try CallbackTimeoutException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDurableExecutionCallbackSuccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CallbackTimeoutException": return try CallbackTimeoutException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopDurableExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCapacityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCodeSigningConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventSourceMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "CodeStorageExceededException": return try CodeStorageExceededException.makeError(baseError: baseError)
            case "CodeVerificationFailedException": return try CodeVerificationFailedException.makeError(baseError: baseError)
            case "InvalidCodeSignatureException": return try InvalidCodeSignatureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeSigningConfigNotFoundException": return try CodeSigningConfigNotFoundException.makeError(baseError: baseError)
            case "CodeVerificationFailedException": return try CodeVerificationFailedException.makeError(baseError: baseError)
            case "InvalidCodeSignatureException": return try InvalidCodeSignatureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionEventInvokeConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionUrlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceException": return try ServiceException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyLengthExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PolicyLengthExceededException {
        let reader = baseError.errorBodyReader
        var value = PolicyLengthExceededException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceConflictException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceException {
        let reader = baseError.errorBodyReader
        var value = ServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = TooManyRequestsException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CapacityProviderLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CapacityProviderLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CapacityProviderLimitExceededException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeSigningConfigNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CodeSigningConfigNotFoundException {
        let reader = baseError.errorBodyReader
        var value = CodeSigningConfigNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeStorageExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CodeStorageExceededException {
        let reader = baseError.errorBodyReader
        var value = CodeStorageExceededException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeVerificationFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CodeVerificationFailedException {
        let reader = baseError.errorBodyReader
        var value = CodeVerificationFailedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FunctionVersionsPerCapacityProviderLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FunctionVersionsPerCapacityProviderLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = FunctionVersionsPerCapacityProviderLimitExceededException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCodeSignatureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidCodeSignatureException {
        let reader = baseError.errorBodyReader
        var value = InvalidCodeSignatureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ProvisionedConcurrencyConfigNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ProvisionedConcurrencyConfigNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ProvisionedConcurrencyConfigNotFoundException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DurableExecutionAlreadyStartedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DurableExecutionAlreadyStartedException {
        let reader = baseError.errorBodyReader
        var value = DurableExecutionAlreadyStartedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EC2AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EC2AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = EC2AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EC2ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EC2ThrottledException {
        let reader = baseError.errorBodyReader
        var value = EC2ThrottledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EC2UnexpectedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EC2UnexpectedException {
        let reader = baseError.errorBodyReader
        var value = EC2UnexpectedException()
        value.properties.ec2ErrorCode = try reader["EC2ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSIOException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSIOException {
        let reader = baseError.errorBodyReader
        var value = EFSIOException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSMountConnectivityException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSMountConnectivityException {
        let reader = baseError.errorBodyReader
        var value = EFSMountConnectivityException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSMountFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSMountFailureException {
        let reader = baseError.errorBodyReader
        var value = EFSMountFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EFSMountTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EFSMountTimeoutException {
        let reader = baseError.errorBodyReader
        var value = EFSMountTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ENILimitReachedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ENILimitReachedException {
        let reader = baseError.errorBodyReader
        var value = ENILimitReachedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestContentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestContentException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestContentException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRuntimeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRuntimeException {
        let reader = baseError.errorBodyReader
        var value = InvalidRuntimeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSecurityGroupIDException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSecurityGroupIDException {
        let reader = baseError.errorBodyReader
        var value = InvalidSecurityGroupIDException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSubnetIDException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSubnetIDException {
        let reader = baseError.errorBodyReader
        var value = InvalidSubnetIDException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidZipFileException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidZipFileException {
        let reader = baseError.errorBodyReader
        var value = InvalidZipFileException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = KMSAccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSDisabledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSDisabledException {
        let reader = baseError.errorBodyReader
        var value = KMSDisabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSInvalidStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSInvalidStateException {
        let reader = baseError.errorBodyReader
        var value = KMSInvalidStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSNotFoundException {
        let reader = baseError.errorBodyReader
        var value = KMSNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoPublishedVersionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NoPublishedVersionException {
        let reader = baseError.errorBodyReader
        var value = NoPublishedVersionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RecursiveInvocationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RecursiveInvocationException {
        let reader = baseError.errorBodyReader
        var value = RecursiveInvocationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestTooLargeException {
        let reader = baseError.errorBodyReader
        var value = RequestTooLargeException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotReadyException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SerializedRequestEntityTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SerializedRequestEntityTooLargeException {
        let reader = baseError.errorBodyReader
        var value = SerializedRequestEntityTooLargeException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapStartException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SnapStartException {
        let reader = baseError.errorBodyReader
        var value = SnapStartException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapStartNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SnapStartNotReadyException {
        let reader = baseError.errorBodyReader
        var value = SnapStartNotReadyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnapStartTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SnapStartTimeoutException {
        let reader = baseError.errorBodyReader
        var value = SnapStartTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetIPAddressLimitReachedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SubnetIPAddressLimitReachedException {
        let reader = baseError.errorBodyReader
        var value = SubnetIPAddressLimitReachedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedMediaTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedMediaTypeException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedMediaTypeException()
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CallbackTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CallbackTimeoutException {
        let reader = baseError.errorBodyReader
        var value = CallbackTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LambdaClientTypes.InvokeWithResponseStreamResponseEvent {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<LambdaClientTypes.InvokeWithResponseStreamResponseEvent> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "PayloadChunk":
                    var event = LambdaClientTypes.InvokeResponseStreamUpdate()
                    event.payload = message.payload
                    return .payloadchunk(event)
                case "InvokeComplete":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: LambdaClientTypes.InvokeWithResponseStreamCompleteEvent.read(from:))
                    return .invokecomplete(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension LambdaClientTypes.CheckpointUpdatedExecutionState {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CheckpointUpdatedExecutionState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CheckpointUpdatedExecutionState()
        value.operations = try reader["Operations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Operation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.Operation {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Operation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Operation()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.parentId = try reader["ParentId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.subType = try reader["SubType"].readIfPresent()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTimestamp = try reader["EndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.executionDetails = try reader["ExecutionDetails"].readIfPresent(with: LambdaClientTypes.ExecutionDetails.read(from:))
        value.contextDetails = try reader["ContextDetails"].readIfPresent(with: LambdaClientTypes.ContextDetails.read(from:))
        value.stepDetails = try reader["StepDetails"].readIfPresent(with: LambdaClientTypes.StepDetails.read(from:))
        value.waitDetails = try reader["WaitDetails"].readIfPresent(with: LambdaClientTypes.WaitDetails.read(from:))
        value.callbackDetails = try reader["CallbackDetails"].readIfPresent(with: LambdaClientTypes.CallbackDetails.read(from:))
        value.chainedInvokeDetails = try reader["ChainedInvokeDetails"].readIfPresent(with: LambdaClientTypes.ChainedInvokeDetails.read(from:))
        return value
    }
}

extension LambdaClientTypes.ChainedInvokeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ChainedInvokeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ChainedInvokeDetails()
        value.result = try reader["Result"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ErrorObject.read(from:))
        return value
    }
}

extension LambdaClientTypes.ErrorObject {

    static func write(value: LambdaClientTypes.ErrorObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ErrorData"].write(value.errorData)
        try writer["ErrorMessage"].write(value.errorMessage)
        try writer["ErrorType"].write(value.errorType)
        try writer["StackTrace"].writeList(value.stackTrace, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ErrorObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ErrorObject()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorType = try reader["ErrorType"].readIfPresent()
        value.errorData = try reader["ErrorData"].readIfPresent()
        value.stackTrace = try reader["StackTrace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.CallbackDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CallbackDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CallbackDetails()
        value.callbackId = try reader["CallbackId"].readIfPresent()
        value.result = try reader["Result"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ErrorObject.read(from:))
        return value
    }
}

extension LambdaClientTypes.WaitDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.WaitDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.WaitDetails()
        value.scheduledEndTimestamp = try reader["ScheduledEndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LambdaClientTypes.StepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.StepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.StepDetails()
        value.attempt = try reader["Attempt"].readIfPresent() ?? 0
        value.nextAttemptTimestamp = try reader["NextAttemptTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.result = try reader["Result"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ErrorObject.read(from:))
        return value
    }
}

extension LambdaClientTypes.ContextDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ContextDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ContextDetails()
        value.replayChildren = try reader["ReplayChildren"].readIfPresent()
        value.result = try reader["Result"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ErrorObject.read(from:))
        return value
    }
}

extension LambdaClientTypes.ExecutionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ExecutionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ExecutionDetails()
        value.inputPayload = try reader["InputPayload"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AliasRoutingConfiguration {

    static func write(value: LambdaClientTypes.AliasRoutingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalVersionWeights"].writeMap(value.additionalVersionWeights, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AliasRoutingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AliasRoutingConfiguration()
        value.additionalVersionWeights = try reader["AdditionalVersionWeights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.CapacityProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CapacityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CapacityProvider()
        value.capacityProviderArn = try reader["CapacityProviderArn"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderVpcConfig.read(from:))
        value.permissionsConfig = try reader["PermissionsConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderPermissionsConfig.read(from:))
        value.instanceRequirements = try reader["InstanceRequirements"].readIfPresent(with: LambdaClientTypes.InstanceRequirements.read(from:))
        value.capacityProviderScalingConfig = try reader["CapacityProviderScalingConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderScalingConfig.read(from:))
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.CapacityProviderScalingConfig {

    static func write(value: LambdaClientTypes.CapacityProviderScalingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxVCpuCount"].write(value.maxVCpuCount)
        try writer["ScalingMode"].write(value.scalingMode)
        try writer["ScalingPolicies"].writeList(value.scalingPolicies, memberWritingClosure: LambdaClientTypes.TargetTrackingScalingPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CapacityProviderScalingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CapacityProviderScalingConfig()
        value.maxVCpuCount = try reader["MaxVCpuCount"].readIfPresent()
        value.scalingMode = try reader["ScalingMode"].readIfPresent()
        value.scalingPolicies = try reader["ScalingPolicies"].readListIfPresent(memberReadingClosure: LambdaClientTypes.TargetTrackingScalingPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.TargetTrackingScalingPolicy {

    static func write(value: LambdaClientTypes.TargetTrackingScalingPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PredefinedMetricType"].write(value.predefinedMetricType)
        try writer["TargetValue"].write(value.targetValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TargetTrackingScalingPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TargetTrackingScalingPolicy()
        value.predefinedMetricType = try reader["PredefinedMetricType"].readIfPresent() ?? .sdkUnknown("")
        value.targetValue = try reader["TargetValue"].readIfPresent() ?? 0.0
        return value
    }
}

extension LambdaClientTypes.InstanceRequirements {

    static func write(value: LambdaClientTypes.InstanceRequirements?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedInstanceTypes"].writeList(value.allowedInstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Architectures"].writeList(value.architectures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.Architecture>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludedInstanceTypes"].writeList(value.excludedInstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.InstanceRequirements {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.InstanceRequirements()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedInstanceTypes = try reader["AllowedInstanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.excludedInstanceTypes = try reader["ExcludedInstanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.CapacityProviderPermissionsConfig {

    static func write(value: LambdaClientTypes.CapacityProviderPermissionsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityProviderOperatorRoleArn"].write(value.capacityProviderOperatorRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CapacityProviderPermissionsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CapacityProviderPermissionsConfig()
        value.capacityProviderOperatorRoleArn = try reader["CapacityProviderOperatorRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.CapacityProviderVpcConfig {

    static func write(value: LambdaClientTypes.CapacityProviderVpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CapacityProviderVpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CapacityProviderVpcConfig()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LambdaClientTypes.CodeSigningConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CodeSigningConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CodeSigningConfig()
        value.codeSigningConfigId = try reader["CodeSigningConfigId"].readIfPresent() ?? ""
        value.codeSigningConfigArn = try reader["CodeSigningConfigArn"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.allowedPublishers = try reader["AllowedPublishers"].readIfPresent(with: LambdaClientTypes.AllowedPublishers.read(from:))
        value.codeSigningPolicies = try reader["CodeSigningPolicies"].readIfPresent(with: LambdaClientTypes.CodeSigningPolicies.read(from:))
        value.lastModified = try reader["LastModified"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.CodeSigningPolicies {

    static func write(value: LambdaClientTypes.CodeSigningPolicies?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UntrustedArtifactOnDeployment"].write(value.untrustedArtifactOnDeployment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CodeSigningPolicies {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CodeSigningPolicies()
        value.untrustedArtifactOnDeployment = try reader["UntrustedArtifactOnDeployment"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AllowedPublishers {

    static func write(value: LambdaClientTypes.AllowedPublishers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SigningProfileVersionArns"].writeList(value.signingProfileVersionArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AllowedPublishers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AllowedPublishers()
        value.signingProfileVersionArns = try reader["SigningProfileVersionArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LambdaClientTypes.FilterCriteria {

    static func write(value: LambdaClientTypes.FilterCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LambdaClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FilterCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FilterCriteria()
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Filter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.Filter {

    static func write(value: LambdaClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Pattern"].write(value.pattern)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Filter()
        value.pattern = try reader["Pattern"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DestinationConfig {

    static func write(value: LambdaClientTypes.DestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OnFailure"].write(value.onFailure, with: LambdaClientTypes.OnFailure.write(value:to:))
        try writer["OnSuccess"].write(value.onSuccess, with: LambdaClientTypes.OnSuccess.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DestinationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DestinationConfig()
        value.onSuccess = try reader["OnSuccess"].readIfPresent(with: LambdaClientTypes.OnSuccess.read(from:))
        value.onFailure = try reader["OnFailure"].readIfPresent(with: LambdaClientTypes.OnFailure.read(from:))
        return value
    }
}

extension LambdaClientTypes.OnFailure {

    static func write(value: LambdaClientTypes.OnFailure?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.OnFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.OnFailure()
        value.destination = try reader["Destination"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.OnSuccess {

    static func write(value: LambdaClientTypes.OnSuccess?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.OnSuccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.OnSuccess()
        value.destination = try reader["Destination"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.SourceAccessConfiguration {

    static func write(value: LambdaClientTypes.SourceAccessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["URI"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SourceAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SourceAccessConfiguration()
        value.type = try reader["Type"].readIfPresent()
        value.uri = try reader["URI"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.SelfManagedEventSource {

    static func write(value: LambdaClientTypes.SelfManagedEventSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Endpoints"].writeMap(value.endpoints, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SelfManagedEventSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SelfManagedEventSource()
        value.endpoints = try reader["Endpoints"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.AmazonManagedKafkaEventSourceConfig {

    static func write(value: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumerGroupId"].write(value.consumerGroupId)
        try writer["SchemaRegistryConfig"].write(value.schemaRegistryConfig, with: LambdaClientTypes.KafkaSchemaRegistryConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AmazonManagedKafkaEventSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AmazonManagedKafkaEventSourceConfig()
        value.consumerGroupId = try reader["ConsumerGroupId"].readIfPresent()
        value.schemaRegistryConfig = try reader["SchemaRegistryConfig"].readIfPresent(with: LambdaClientTypes.KafkaSchemaRegistryConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.KafkaSchemaRegistryConfig {

    static func write(value: LambdaClientTypes.KafkaSchemaRegistryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessConfigs"].writeList(value.accessConfigs, memberWritingClosure: LambdaClientTypes.KafkaSchemaRegistryAccessConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EventRecordFormat"].write(value.eventRecordFormat)
        try writer["SchemaRegistryURI"].write(value.schemaRegistryURI)
        try writer["SchemaValidationConfigs"].writeList(value.schemaValidationConfigs, memberWritingClosure: LambdaClientTypes.KafkaSchemaValidationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.KafkaSchemaRegistryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.KafkaSchemaRegistryConfig()
        value.schemaRegistryURI = try reader["SchemaRegistryURI"].readIfPresent()
        value.eventRecordFormat = try reader["EventRecordFormat"].readIfPresent()
        value.accessConfigs = try reader["AccessConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.KafkaSchemaRegistryAccessConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.schemaValidationConfigs = try reader["SchemaValidationConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.KafkaSchemaValidationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.KafkaSchemaValidationConfig {

    static func write(value: LambdaClientTypes.KafkaSchemaValidationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attribute"].write(value.attribute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.KafkaSchemaValidationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.KafkaSchemaValidationConfig()
        value.attribute = try reader["Attribute"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.KafkaSchemaRegistryAccessConfig {

    static func write(value: LambdaClientTypes.KafkaSchemaRegistryAccessConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["URI"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.KafkaSchemaRegistryAccessConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.KafkaSchemaRegistryAccessConfig()
        value.type = try reader["Type"].readIfPresent()
        value.uri = try reader["URI"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.SelfManagedKafkaEventSourceConfig {

    static func write(value: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsumerGroupId"].write(value.consumerGroupId)
        try writer["SchemaRegistryConfig"].write(value.schemaRegistryConfig, with: LambdaClientTypes.KafkaSchemaRegistryConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SelfManagedKafkaEventSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SelfManagedKafkaEventSourceConfig()
        value.consumerGroupId = try reader["ConsumerGroupId"].readIfPresent()
        value.schemaRegistryConfig = try reader["SchemaRegistryConfig"].readIfPresent(with: LambdaClientTypes.KafkaSchemaRegistryConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.ScalingConfig {

    static func write(value: LambdaClientTypes.ScalingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumConcurrency"].write(value.maximumConcurrency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ScalingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ScalingConfig()
        value.maximumConcurrency = try reader["MaximumConcurrency"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DocumentDBEventSourceConfig {

    static func write(value: LambdaClientTypes.DocumentDBEventSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectionName"].write(value.collectionName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["FullDocument"].write(value.fullDocument)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DocumentDBEventSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DocumentDBEventSourceConfig()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.collectionName = try reader["CollectionName"].readIfPresent()
        value.fullDocument = try reader["FullDocument"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FilterCriteriaError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FilterCriteriaError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FilterCriteriaError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EventSourceMappingMetricsConfig {

    static func write(value: LambdaClientTypes.EventSourceMappingMetricsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LambdaClientTypes.EventSourceMappingMetric>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EventSourceMappingMetricsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EventSourceMappingMetricsConfig()
        value.metrics = try reader["Metrics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.EventSourceMappingMetric>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.ProvisionedPollerConfig {

    static func write(value: LambdaClientTypes.ProvisionedPollerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumPollers"].write(value.maximumPollers)
        try writer["MinimumPollers"].write(value.minimumPollers)
        try writer["PollerGroupName"].write(value.pollerGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ProvisionedPollerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ProvisionedPollerConfig()
        value.minimumPollers = try reader["MinimumPollers"].readIfPresent()
        value.maximumPollers = try reader["MaximumPollers"].readIfPresent()
        value.pollerGroupName = try reader["PollerGroupName"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.VpcConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.VpcConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.VpcConfigResponse()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.ipv6AllowedForDualStack = try reader["Ipv6AllowedForDualStack"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DeadLetterConfig {

    static func write(value: LambdaClientTypes.DeadLetterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DeadLetterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DeadLetterConfig()
        value.targetArn = try reader["TargetArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EnvironmentResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EnvironmentResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EnvironmentResponse()
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EnvironmentError.read(from:))
        return value
    }
}

extension LambdaClientTypes.EnvironmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EnvironmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EnvironmentError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.TracingConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TracingConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TracingConfigResponse()
        value.mode = try reader["Mode"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.Layer {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Layer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Layer()
        value.arn = try reader["Arn"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FileSystemConfig {

    static func write(value: LambdaClientTypes.FileSystemConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["LocalMountPath"].write(value.localMountPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FileSystemConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FileSystemConfig()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.localMountPath = try reader["LocalMountPath"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.ImageConfigResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ImageConfigResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ImageConfigResponse()
        value.imageConfig = try reader["ImageConfig"].readIfPresent(with: LambdaClientTypes.ImageConfig.read(from:))
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.ImageConfigError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ImageConfigError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ImageConfigError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ImageConfigError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.ImageConfig {

    static func write(value: LambdaClientTypes.ImageConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Command"].writeList(value.command, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EntryPoint"].writeList(value.entryPoint, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkingDirectory"].write(value.workingDirectory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ImageConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ImageConfig()
        value.entryPoint = try reader["EntryPoint"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.command = try reader["Command"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.workingDirectory = try reader["WorkingDirectory"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EphemeralStorage {

    static func write(value: LambdaClientTypes.EphemeralStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Size"].write(value.size)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EphemeralStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EphemeralStorage()
        value.size = try reader["Size"].readIfPresent() ?? 0
        return value
    }
}

extension LambdaClientTypes.SnapStartResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.SnapStartResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.SnapStartResponse()
        value.applyOn = try reader["ApplyOn"].readIfPresent()
        value.optimizationStatus = try reader["OptimizationStatus"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.RuntimeVersionConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.RuntimeVersionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.RuntimeVersionConfig()
        value.runtimeVersionArn = try reader["RuntimeVersionArn"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.RuntimeVersionError.read(from:))
        return value
    }
}

extension LambdaClientTypes.RuntimeVersionError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.RuntimeVersionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.RuntimeVersionError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.LoggingConfig {

    static func write(value: LambdaClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationLogLevel"].write(value.applicationLogLevel)
        try writer["LogFormat"].write(value.logFormat)
        try writer["LogGroup"].write(value.logGroup)
        try writer["SystemLogLevel"].write(value.systemLogLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LoggingConfig()
        value.logFormat = try reader["LogFormat"].readIfPresent()
        value.applicationLogLevel = try reader["ApplicationLogLevel"].readIfPresent()
        value.systemLogLevel = try reader["SystemLogLevel"].readIfPresent()
        value.logGroup = try reader["LogGroup"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.CapacityProviderConfig {

    static func write(value: LambdaClientTypes.CapacityProviderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaManagedInstancesCapacityProviderConfig"].write(value.lambdaManagedInstancesCapacityProviderConfig, with: LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CapacityProviderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CapacityProviderConfig()
        value.lambdaManagedInstancesCapacityProviderConfig = try reader["LambdaManagedInstancesCapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig {

    static func write(value: LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityProviderArn"].write(value.capacityProviderArn)
        try writer["ExecutionEnvironmentMemoryGiBPerVCpu"].write(value.executionEnvironmentMemoryGiBPerVCpu)
        try writer["PerExecutionEnvironmentMaxConcurrency"].write(value.perExecutionEnvironmentMaxConcurrency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LambdaManagedInstancesCapacityProviderConfig()
        value.capacityProviderArn = try reader["CapacityProviderArn"].readIfPresent() ?? ""
        value.perExecutionEnvironmentMaxConcurrency = try reader["PerExecutionEnvironmentMaxConcurrency"].readIfPresent()
        value.executionEnvironmentMemoryGiBPerVCpu = try reader["ExecutionEnvironmentMemoryGiBPerVCpu"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.DurableConfig {

    static func write(value: LambdaClientTypes.DurableConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionTimeout"].write(value.executionTimeout)
        try writer["RetentionPeriodInDays"].write(value.retentionPeriodInDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.DurableConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.DurableConfig()
        value.retentionPeriodInDays = try reader["RetentionPeriodInDays"].readIfPresent()
        value.executionTimeout = try reader["ExecutionTimeout"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.TenancyConfig {

    static func write(value: LambdaClientTypes.TenancyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TenantIsolationMode"].write(value.tenantIsolationMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TenancyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TenancyConfig()
        value.tenantIsolationMode = try reader["TenantIsolationMode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension LambdaClientTypes.Cors {

    static func write(value: LambdaClientTypes.Cors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCredentials"].write(value.allowCredentials)
        try writer["AllowHeaders"].writeList(value.allowHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowMethods"].writeList(value.allowMethods, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowOrigins"].writeList(value.allowOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExposeHeaders"].writeList(value.exposeHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxAge"].write(value.maxAge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Cors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Cors()
        value.allowCredentials = try reader["AllowCredentials"].readIfPresent()
        value.allowHeaders = try reader["AllowHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowMethods = try reader["AllowMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowOrigins = try reader["AllowOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exposeHeaders = try reader["ExposeHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxAge = try reader["MaxAge"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AccountLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AccountLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AccountLimit()
        value.totalCodeSize = try reader["TotalCodeSize"].readIfPresent() ?? 0
        value.codeSizeUnzipped = try reader["CodeSizeUnzipped"].readIfPresent() ?? 0
        value.codeSizeZipped = try reader["CodeSizeZipped"].readIfPresent() ?? 0
        value.concurrentExecutions = try reader["ConcurrentExecutions"].readIfPresent() ?? 0
        value.unreservedConcurrentExecutions = try reader["UnreservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AccountUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AccountUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AccountUsage()
        value.totalCodeSize = try reader["TotalCodeSize"].readIfPresent() ?? 0
        value.functionCount = try reader["FunctionCount"].readIfPresent() ?? 0
        return value
    }
}

extension LambdaClientTypes.TraceHeader {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TraceHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TraceHeader()
        value.xAmznTraceId = try reader["XAmznTraceId"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Event()
        value.eventType = try reader["EventType"].readIfPresent()
        value.subType = try reader["SubType"].readIfPresent()
        value.eventId = try reader["EventId"].readIfPresent() ?? 1
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.eventTimestamp = try reader["EventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.parentId = try reader["ParentId"].readIfPresent()
        value.executionStartedDetails = try reader["ExecutionStartedDetails"].readIfPresent(with: LambdaClientTypes.ExecutionStartedDetails.read(from:))
        value.executionSucceededDetails = try reader["ExecutionSucceededDetails"].readIfPresent(with: LambdaClientTypes.ExecutionSucceededDetails.read(from:))
        value.executionFailedDetails = try reader["ExecutionFailedDetails"].readIfPresent(with: LambdaClientTypes.ExecutionFailedDetails.read(from:))
        value.executionTimedOutDetails = try reader["ExecutionTimedOutDetails"].readIfPresent(with: LambdaClientTypes.ExecutionTimedOutDetails.read(from:))
        value.executionStoppedDetails = try reader["ExecutionStoppedDetails"].readIfPresent(with: LambdaClientTypes.ExecutionStoppedDetails.read(from:))
        value.contextStartedDetails = try reader["ContextStartedDetails"].readIfPresent(with: LambdaClientTypes.ContextStartedDetails.read(from:))
        value.contextSucceededDetails = try reader["ContextSucceededDetails"].readIfPresent(with: LambdaClientTypes.ContextSucceededDetails.read(from:))
        value.contextFailedDetails = try reader["ContextFailedDetails"].readIfPresent(with: LambdaClientTypes.ContextFailedDetails.read(from:))
        value.waitStartedDetails = try reader["WaitStartedDetails"].readIfPresent(with: LambdaClientTypes.WaitStartedDetails.read(from:))
        value.waitSucceededDetails = try reader["WaitSucceededDetails"].readIfPresent(with: LambdaClientTypes.WaitSucceededDetails.read(from:))
        value.waitCancelledDetails = try reader["WaitCancelledDetails"].readIfPresent(with: LambdaClientTypes.WaitCancelledDetails.read(from:))
        value.stepStartedDetails = try reader["StepStartedDetails"].readIfPresent(with: LambdaClientTypes.StepStartedDetails.read(from:))
        value.stepSucceededDetails = try reader["StepSucceededDetails"].readIfPresent(with: LambdaClientTypes.StepSucceededDetails.read(from:))
        value.stepFailedDetails = try reader["StepFailedDetails"].readIfPresent(with: LambdaClientTypes.StepFailedDetails.read(from:))
        value.chainedInvokeStartedDetails = try reader["ChainedInvokeStartedDetails"].readIfPresent(with: LambdaClientTypes.ChainedInvokeStartedDetails.read(from:))
        value.chainedInvokeSucceededDetails = try reader["ChainedInvokeSucceededDetails"].readIfPresent(with: LambdaClientTypes.ChainedInvokeSucceededDetails.read(from:))
        value.chainedInvokeFailedDetails = try reader["ChainedInvokeFailedDetails"].readIfPresent(with: LambdaClientTypes.ChainedInvokeFailedDetails.read(from:))
        value.chainedInvokeTimedOutDetails = try reader["ChainedInvokeTimedOutDetails"].readIfPresent(with: LambdaClientTypes.ChainedInvokeTimedOutDetails.read(from:))
        value.chainedInvokeStoppedDetails = try reader["ChainedInvokeStoppedDetails"].readIfPresent(with: LambdaClientTypes.ChainedInvokeStoppedDetails.read(from:))
        value.callbackStartedDetails = try reader["CallbackStartedDetails"].readIfPresent(with: LambdaClientTypes.CallbackStartedDetails.read(from:))
        value.callbackSucceededDetails = try reader["CallbackSucceededDetails"].readIfPresent(with: LambdaClientTypes.CallbackSucceededDetails.read(from:))
        value.callbackFailedDetails = try reader["CallbackFailedDetails"].readIfPresent(with: LambdaClientTypes.CallbackFailedDetails.read(from:))
        value.callbackTimedOutDetails = try reader["CallbackTimedOutDetails"].readIfPresent(with: LambdaClientTypes.CallbackTimedOutDetails.read(from:))
        value.invocationCompletedDetails = try reader["InvocationCompletedDetails"].readIfPresent(with: LambdaClientTypes.InvocationCompletedDetails.read(from:))
        return value
    }
}

extension LambdaClientTypes.InvocationCompletedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.InvocationCompletedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.InvocationCompletedDetails()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTimestamp = try reader["EndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.requestId = try reader["RequestId"].readIfPresent() ?? ""
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.EventError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EventError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EventError()
        value.payload = try reader["Payload"].readIfPresent(with: LambdaClientTypes.ErrorObject.read(from:))
        value.truncated = try reader["Truncated"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.CallbackTimedOutDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CallbackTimedOutDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CallbackTimedOutDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.CallbackFailedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CallbackFailedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CallbackFailedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.CallbackSucceededDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CallbackSucceededDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CallbackSucceededDetails()
        value.result = try reader["Result"].readIfPresent(with: LambdaClientTypes.EventResult.read(from:))
        return value
    }
}

extension LambdaClientTypes.EventResult {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EventResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EventResult()
        value.payload = try reader["Payload"].readIfPresent()
        value.truncated = try reader["Truncated"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.CallbackStartedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.CallbackStartedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.CallbackStartedDetails()
        value.callbackId = try reader["CallbackId"].readIfPresent() ?? ""
        value.heartbeatTimeout = try reader["HeartbeatTimeout"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.ChainedInvokeStoppedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ChainedInvokeStoppedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ChainedInvokeStoppedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ChainedInvokeTimedOutDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ChainedInvokeTimedOutDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ChainedInvokeTimedOutDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ChainedInvokeFailedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ChainedInvokeFailedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ChainedInvokeFailedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ChainedInvokeSucceededDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ChainedInvokeSucceededDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ChainedInvokeSucceededDetails()
        value.result = try reader["Result"].readIfPresent(with: LambdaClientTypes.EventResult.read(from:))
        return value
    }
}

extension LambdaClientTypes.ChainedInvokeStartedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ChainedInvokeStartedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ChainedInvokeStartedDetails()
        value.functionName = try reader["FunctionName"].readIfPresent() ?? ""
        value.tenantId = try reader["TenantId"].readIfPresent()
        value.input = try reader["Input"].readIfPresent(with: LambdaClientTypes.EventInput.read(from:))
        value.executedVersion = try reader["ExecutedVersion"].readIfPresent()
        value.durableExecutionArn = try reader["DurableExecutionArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.EventInput {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EventInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EventInput()
        value.payload = try reader["Payload"].readIfPresent()
        value.truncated = try reader["Truncated"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.StepFailedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.StepFailedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.StepFailedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        value.retryDetails = try reader["RetryDetails"].readIfPresent(with: LambdaClientTypes.RetryDetails.read(from:))
        return value
    }
}

extension LambdaClientTypes.RetryDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.RetryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.RetryDetails()
        value.currentAttempt = try reader["CurrentAttempt"].readIfPresent() ?? 0
        value.nextAttemptDelaySeconds = try reader["NextAttemptDelaySeconds"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.StepSucceededDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.StepSucceededDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.StepSucceededDetails()
        value.result = try reader["Result"].readIfPresent(with: LambdaClientTypes.EventResult.read(from:))
        value.retryDetails = try reader["RetryDetails"].readIfPresent(with: LambdaClientTypes.RetryDetails.read(from:))
        return value
    }
}

extension LambdaClientTypes.StepStartedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.StepStartedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return LambdaClientTypes.StepStartedDetails()
    }
}

extension LambdaClientTypes.WaitCancelledDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.WaitCancelledDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.WaitCancelledDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.WaitSucceededDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.WaitSucceededDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.WaitSucceededDetails()
        value.duration = try reader["Duration"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.WaitStartedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.WaitStartedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.WaitStartedDetails()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.scheduledEndTimestamp = try reader["ScheduledEndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension LambdaClientTypes.ContextFailedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ContextFailedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ContextFailedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ContextSucceededDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ContextSucceededDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ContextSucceededDetails()
        value.result = try reader["Result"].readIfPresent(with: LambdaClientTypes.EventResult.read(from:))
        return value
    }
}

extension LambdaClientTypes.ContextStartedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ContextStartedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return LambdaClientTypes.ContextStartedDetails()
    }
}

extension LambdaClientTypes.ExecutionStoppedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ExecutionStoppedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ExecutionStoppedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ExecutionTimedOutDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ExecutionTimedOutDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ExecutionTimedOutDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ExecutionFailedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ExecutionFailedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ExecutionFailedDetails()
        value.error = try reader["Error"].readIfPresent(with: LambdaClientTypes.EventError.read(from:))
        return value
    }
}

extension LambdaClientTypes.ExecutionSucceededDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ExecutionSucceededDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ExecutionSucceededDetails()
        value.result = try reader["Result"].readIfPresent(with: LambdaClientTypes.EventResult.read(from:))
        return value
    }
}

extension LambdaClientTypes.ExecutionStartedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ExecutionStartedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ExecutionStartedDetails()
        value.input = try reader["Input"].readIfPresent(with: LambdaClientTypes.EventInput.read(from:))
        value.executionTimeout = try reader["ExecutionTimeout"].readIfPresent() ?? 0
        return value
    }
}

extension LambdaClientTypes.FunctionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionConfiguration()
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: LambdaClientTypes.VpcConfigResponse.read(from:))
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: LambdaClientTypes.DeadLetterConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: LambdaClientTypes.EnvironmentResponse.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: LambdaClientTypes.TracingConfigResponse.read(from:))
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: LambdaClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        value.stateReasonCode = try reader["StateReasonCode"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateStatusReason = try reader["LastUpdateStatusReason"].readIfPresent()
        value.lastUpdateStatusReasonCode = try reader["LastUpdateStatusReasonCode"].readIfPresent()
        value.fileSystemConfigs = try reader["FileSystemConfigs"].readListIfPresent(memberReadingClosure: LambdaClientTypes.FileSystemConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.packageType = try reader["PackageType"].readIfPresent()
        value.imageConfigResponse = try reader["ImageConfigResponse"].readIfPresent(with: LambdaClientTypes.ImageConfigResponse.read(from:))
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ephemeralStorage = try reader["EphemeralStorage"].readIfPresent(with: LambdaClientTypes.EphemeralStorage.read(from:))
        value.snapStart = try reader["SnapStart"].readIfPresent(with: LambdaClientTypes.SnapStartResponse.read(from:))
        value.runtimeVersionConfig = try reader["RuntimeVersionConfig"].readIfPresent(with: LambdaClientTypes.RuntimeVersionConfig.read(from:))
        value.loggingConfig = try reader["LoggingConfig"].readIfPresent(with: LambdaClientTypes.LoggingConfig.read(from:))
        value.capacityProviderConfig = try reader["CapacityProviderConfig"].readIfPresent(with: LambdaClientTypes.CapacityProviderConfig.read(from:))
        value.configSha256 = try reader["ConfigSha256"].readIfPresent()
        value.durableConfig = try reader["DurableConfig"].readIfPresent(with: LambdaClientTypes.DurableConfig.read(from:))
        value.tenancyConfig = try reader["TenancyConfig"].readIfPresent(with: LambdaClientTypes.TenancyConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.FunctionCodeLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionCodeLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionCodeLocation()
        value.repositoryType = try reader["RepositoryType"].readIfPresent()
        value.location = try reader["Location"].readIfPresent()
        value.imageUri = try reader["ImageUri"].readIfPresent()
        value.resolvedImageUri = try reader["ResolvedImageUri"].readIfPresent()
        value.sourceKMSKeyArn = try reader["SourceKMSKeyArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.TagsError {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.TagsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.TagsError()
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension LambdaClientTypes.Concurrency {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Concurrency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Concurrency()
        value.reservedConcurrentExecutions = try reader["ReservedConcurrentExecutions"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FunctionScalingConfig {

    static func write(value: LambdaClientTypes.FunctionScalingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxExecutionEnvironments"].write(value.maxExecutionEnvironments)
        try writer["MinExecutionEnvironments"].write(value.minExecutionEnvironments)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionScalingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionScalingConfig()
        value.minExecutionEnvironments = try reader["MinExecutionEnvironments"].readIfPresent()
        value.maxExecutionEnvironments = try reader["MaxExecutionEnvironments"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.LayerVersionContentOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LayerVersionContentOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LayerVersionContentOutput()
        value.location = try reader["Location"].readIfPresent()
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent() ?? 0
        value.signingProfileVersionArn = try reader["SigningProfileVersionArn"].readIfPresent()
        value.signingJobArn = try reader["SigningJobArn"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.InvokeWithResponseStreamCompleteEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.InvokeWithResponseStreamCompleteEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.InvokeWithResponseStreamCompleteEvent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readIfPresent()
        value.logResult = try reader["LogResult"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.InvokeResponseStreamUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.InvokeResponseStreamUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.InvokeResponseStreamUpdate()
        value.payload = try reader["Payload"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.AliasConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.AliasConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.AliasConfiguration()
        value.aliasArn = try reader["AliasArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.functionVersion = try reader["FunctionVersion"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: LambdaClientTypes.AliasRoutingConfiguration.read(from:))
        value.revisionId = try reader["RevisionId"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.Execution {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.Execution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.Execution()
        value.durableExecutionArn = try reader["DurableExecutionArn"].readIfPresent() ?? ""
        value.durableExecutionName = try reader["DurableExecutionName"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTimestamp = try reader["EndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LambdaClientTypes.EventSourceMappingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.EventSourceMappingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.EventSourceMappingConfiguration()
        value.uuid = try reader["UUID"].readIfPresent()
        value.startingPosition = try reader["StartingPosition"].readIfPresent()
        value.startingPositionTimestamp = try reader["StartingPositionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.batchSize = try reader["BatchSize"].readIfPresent()
        value.maximumBatchingWindowInSeconds = try reader["MaximumBatchingWindowInSeconds"].readIfPresent()
        value.parallelizationFactor = try reader["ParallelizationFactor"].readIfPresent()
        value.eventSourceArn = try reader["EventSourceArn"].readIfPresent()
        value.filterCriteria = try reader["FilterCriteria"].readIfPresent(with: LambdaClientTypes.FilterCriteria.read(from:))
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastProcessingResult = try reader["LastProcessingResult"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.stateTransitionReason = try reader["StateTransitionReason"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.queues = try reader["Queues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceAccessConfigurations = try reader["SourceAccessConfigurations"].readListIfPresent(memberReadingClosure: LambdaClientTypes.SourceAccessConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selfManagedEventSource = try reader["SelfManagedEventSource"].readIfPresent(with: LambdaClientTypes.SelfManagedEventSource.read(from:))
        value.maximumRecordAgeInSeconds = try reader["MaximumRecordAgeInSeconds"].readIfPresent()
        value.bisectBatchOnFunctionError = try reader["BisectBatchOnFunctionError"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.tumblingWindowInSeconds = try reader["TumblingWindowInSeconds"].readIfPresent()
        value.functionResponseTypes = try reader["FunctionResponseTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.FunctionResponseType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.amazonManagedKafkaEventSourceConfig = try reader["AmazonManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.read(from:))
        value.selfManagedKafkaEventSourceConfig = try reader["SelfManagedKafkaEventSourceConfig"].readIfPresent(with: LambdaClientTypes.SelfManagedKafkaEventSourceConfig.read(from:))
        value.scalingConfig = try reader["ScalingConfig"].readIfPresent(with: LambdaClientTypes.ScalingConfig.read(from:))
        value.documentDBEventSourceConfig = try reader["DocumentDBEventSourceConfig"].readIfPresent(with: LambdaClientTypes.DocumentDBEventSourceConfig.read(from:))
        value.kmsKeyArn = try reader["KMSKeyArn"].readIfPresent()
        value.filterCriteriaError = try reader["FilterCriteriaError"].readIfPresent(with: LambdaClientTypes.FilterCriteriaError.read(from:))
        value.eventSourceMappingArn = try reader["EventSourceMappingArn"].readIfPresent()
        value.metricsConfig = try reader["MetricsConfig"].readIfPresent(with: LambdaClientTypes.EventSourceMappingMetricsConfig.read(from:))
        value.provisionedPollerConfig = try reader["ProvisionedPollerConfig"].readIfPresent(with: LambdaClientTypes.ProvisionedPollerConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.FunctionEventInvokeConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionEventInvokeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionEventInvokeConfig()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.maximumRetryAttempts = try reader["MaximumRetryAttempts"].readIfPresent()
        value.maximumEventAgeInSeconds = try reader["MaximumEventAgeInSeconds"].readIfPresent()
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: LambdaClientTypes.DestinationConfig.read(from:))
        return value
    }
}

extension LambdaClientTypes.FunctionUrlConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionUrlConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionUrlConfig()
        value.functionUrl = try reader["FunctionUrl"].readIfPresent() ?? ""
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? ""
        value.cors = try reader["Cors"].readIfPresent(with: LambdaClientTypes.Cors.read(from:))
        value.authType = try reader["AuthType"].readIfPresent() ?? .sdkUnknown("")
        value.invokeMode = try reader["InvokeMode"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.FunctionVersionsByCapacityProviderListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.FunctionVersionsByCapacityProviderListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.FunctionVersionsByCapacityProviderListItem()
        value.functionArn = try reader["FunctionArn"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension LambdaClientTypes.LayersListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LayersListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LayersListItem()
        value.layerName = try reader["LayerName"].readIfPresent()
        value.layerArn = try reader["LayerArn"].readIfPresent()
        value.latestMatchingVersion = try reader["LatestMatchingVersion"].readIfPresent(with: LambdaClientTypes.LayerVersionsListItem.read(from:))
        return value
    }
}

extension LambdaClientTypes.LayerVersionsListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.LayerVersionsListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.LayerVersionsListItem()
        value.layerVersionArn = try reader["LayerVersionArn"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Runtime>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseInfo = try reader["LicenseInfo"].readIfPresent()
        value.compatibleArchitectures = try reader["CompatibleArchitectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LambdaClientTypes.Architecture>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LambdaClientTypes.ProvisionedConcurrencyConfigListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> LambdaClientTypes.ProvisionedConcurrencyConfigListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LambdaClientTypes.ProvisionedConcurrencyConfigListItem()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.requestedProvisionedConcurrentExecutions = try reader["RequestedProvisionedConcurrentExecutions"].readIfPresent()
        value.availableProvisionedConcurrentExecutions = try reader["AvailableProvisionedConcurrentExecutions"].readIfPresent()
        value.allocatedProvisionedConcurrentExecutions = try reader["AllocatedProvisionedConcurrentExecutions"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        return value
    }
}

extension LambdaClientTypes.OperationUpdate {

    static func write(value: LambdaClientTypes.OperationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["CallbackOptions"].write(value.callbackOptions, with: LambdaClientTypes.CallbackOptions.write(value:to:))
        try writer["ChainedInvokeOptions"].write(value.chainedInvokeOptions, with: LambdaClientTypes.ChainedInvokeOptions.write(value:to:))
        try writer["ContextOptions"].write(value.contextOptions, with: LambdaClientTypes.ContextOptions.write(value:to:))
        try writer["Error"].write(value.error, with: LambdaClientTypes.ErrorObject.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ParentId"].write(value.parentId)
        try writer["Payload"].write(value.payload)
        try writer["StepOptions"].write(value.stepOptions, with: LambdaClientTypes.StepOptions.write(value:to:))
        try writer["SubType"].write(value.subType)
        try writer["Type"].write(value.type)
        try writer["WaitOptions"].write(value.waitOptions, with: LambdaClientTypes.WaitOptions.write(value:to:))
    }
}

extension LambdaClientTypes.ChainedInvokeOptions {

    static func write(value: LambdaClientTypes.ChainedInvokeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunctionName"].write(value.functionName)
        try writer["TenantId"].write(value.tenantId)
    }
}

extension LambdaClientTypes.CallbackOptions {

    static func write(value: LambdaClientTypes.CallbackOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HeartbeatTimeoutSeconds"].write(value.heartbeatTimeoutSeconds)
        try writer["TimeoutSeconds"].write(value.timeoutSeconds)
    }
}

extension LambdaClientTypes.WaitOptions {

    static func write(value: LambdaClientTypes.WaitOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WaitSeconds"].write(value.waitSeconds)
    }
}

extension LambdaClientTypes.StepOptions {

    static func write(value: LambdaClientTypes.StepOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextAttemptDelaySeconds"].write(value.nextAttemptDelaySeconds)
    }
}

extension LambdaClientTypes.ContextOptions {

    static func write(value: LambdaClientTypes.ContextOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplayChildren"].write(value.replayChildren)
    }
}

extension LambdaClientTypes.FunctionCode {

    static func write(value: LambdaClientTypes.FunctionCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageUri"].write(value.imageUri)
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["SourceKMSKeyArn"].write(value.sourceKMSKeyArn)
        try writer["ZipFile"].write(value.zipFile)
    }
}

extension LambdaClientTypes.VpcConfig {

    static func write(value: LambdaClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6AllowedForDualStack"].write(value.ipv6AllowedForDualStack)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LambdaClientTypes.Environment {

    static func write(value: LambdaClientTypes.Environment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension LambdaClientTypes.TracingConfig {

    static func write(value: LambdaClientTypes.TracingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mode"].write(value.mode)
    }
}

extension LambdaClientTypes.SnapStart {

    static func write(value: LambdaClientTypes.SnapStart?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplyOn"].write(value.applyOn)
    }
}

extension LambdaClientTypes.LayerVersionContentInput {

    static func write(value: LambdaClientTypes.LayerVersionContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["ZipFile"].write(value.zipFile)
    }
}

public enum LambdaClientTypes {}
