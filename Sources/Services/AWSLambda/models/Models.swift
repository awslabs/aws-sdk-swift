// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LambdaClientTypes.AccountLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSizeUnzipped = "CodeSizeUnzipped"
        case codeSizeZipped = "CodeSizeZipped"
        case concurrentExecutions = "ConcurrentExecutions"
        case totalCodeSize = "TotalCodeSize"
        case unreservedConcurrentExecutions = "UnreservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if codeSizeUnzipped != 0 {
            try encodeContainer.encode(codeSizeUnzipped, forKey: .codeSizeUnzipped)
        }
        if codeSizeZipped != 0 {
            try encodeContainer.encode(codeSizeZipped, forKey: .codeSizeZipped)
        }
        if concurrentExecutions != 0 {
            try encodeContainer.encode(concurrentExecutions, forKey: .concurrentExecutions)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
        if let unreservedConcurrentExecutions = self.unreservedConcurrentExecutions {
            try encodeContainer.encode(unreservedConcurrentExecutions, forKey: .unreservedConcurrentExecutions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCodeSize) ?? 0
        totalCodeSize = totalCodeSizeDecoded
        let codeSizeUnzippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSizeUnzipped) ?? 0
        codeSizeUnzipped = codeSizeUnzippedDecoded
        let codeSizeZippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSizeZipped) ?? 0
        codeSizeZipped = codeSizeZippedDecoded
        let concurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentExecutions) ?? 0
        concurrentExecutions = concurrentExecutionsDecoded
        let unreservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unreservedConcurrentExecutions)
        unreservedConcurrentExecutions = unreservedConcurrentExecutionsDecoded
    }
}

extension LambdaClientTypes {
    /// Limits that are related to concurrency and storage. All file and storage sizes are in bytes.
    public struct AccountLimit: Swift.Equatable {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public var codeSizeUnzipped: Swift.Int
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger files.
        public var codeSizeZipped: Swift.Int
        /// The maximum number of simultaneous function executions.
        public var concurrentExecutions: Swift.Int
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public var totalCodeSize: Swift.Int
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual functions with [PutFunctionConcurrency].
        public var unreservedConcurrentExecutions: Swift.Int?

        public init(
            codeSizeUnzipped: Swift.Int = 0,
            codeSizeZipped: Swift.Int = 0,
            concurrentExecutions: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0,
            unreservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }
    }

}

extension LambdaClientTypes.AccountUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCount = "FunctionCount"
        case totalCodeSize = "TotalCodeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if functionCount != 0 {
            try encodeContainer.encode(functionCount, forKey: .functionCount)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCodeSize) ?? 0
        totalCodeSize = totalCodeSizeDecoded
        let functionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .functionCount) ?? 0
        functionCount = functionCountDecoded
    }
}

extension LambdaClientTypes {
    /// The number of functions and amount of storage in use.
    public struct AccountUsage: Swift.Equatable {
        /// The number of Lambda functions.
        public var functionCount: Swift.Int
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public var totalCodeSize: Swift.Int

        public init(
            functionCount: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0
        )
        {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }
    }

}

extension AddLayerVersionPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension AddLayerVersionPermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revisionId = revisionId {
                let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
                items.append(revisionIdQueryItem)
            }
            return items
        }
    }
}

extension AddLayerVersionPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

public struct AddLayerVersionPermissionInput: Swift.Equatable {
    /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
    /// This member is required.
    public var action: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// With the principal set to *, grant permission to all accounts in the specified organization.
    public var organizationId: Swift.String?
    /// An account ID, or * to grant layer usage permission to all accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified). For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
    /// This member is required.
    public var principal: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An identifier that distinguishes the policy from others on the same layer version.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        action: Swift.String? = nil,
        layerName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        principal: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.action = action
        self.layerName = layerName
        self.organizationId = organizationId
        self.principal = principal
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct AddLayerVersionPermissionInputBody: Swift.Equatable {
    let statementId: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let organizationId: Swift.String?
}

extension AddLayerVersionPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension AddLayerVersionPermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddLayerVersionPermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
            self.statement = output.statement
        } else {
            self.revisionId = nil
            self.statement = nil
        }
    }
}

public struct AddLayerVersionPermissionOutput: Swift.Equatable {
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?
    /// The permission statement.
    public var statement: Swift.String?

    public init(
        revisionId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
        self.statement = statement
    }
}

struct AddLayerVersionPermissionOutputBody: Swift.Equatable {
    let statement: Swift.String?
    let revisionId: Swift.String?
}

extension AddLayerVersionPermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId = "RevisionId"
        case statement = "Statement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum AddLayerVersionPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyLengthExceededException": return try await PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case functionUrlAuthType = "FunctionUrlAuthType"
        case principal = "Principal"
        case principalOrgID = "PrincipalOrgID"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let eventSourceToken = self.eventSourceToken {
            try encodeContainer.encode(eventSourceToken, forKey: .eventSourceToken)
        }
        if let functionUrlAuthType = self.functionUrlAuthType {
            try encodeContainer.encode(functionUrlAuthType.rawValue, forKey: .functionUrlAuthType)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let principalOrgID = self.principalOrgID {
            try encodeContainer.encode(principalOrgID, forKey: .principalOrgID)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceAccount = self.sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

extension AddPermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension AddPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

public struct AddPermissionInput: Swift.Equatable {
    /// The action that the principal can use on the function. For example, lambda:InvokeFunction or lambda:GetFunction.
    /// This member is required.
    public var action: Swift.String?
    /// For Alexa Smart Home functions, a token that the invoker must supply.
    public var eventSourceToken: Swift.String?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    public var functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType?
    /// The Amazon Web Service or Amazon Web Services account that invokes the function. If you specify a service, use SourceArn or SourceAccount to limit who can invoke the function through that service.
    /// This member is required.
    public var principal: Swift.String?
    /// The identifier for your organization in Organizations. Use this to grant permissions to all the Amazon Web Services accounts under this organization.
    public var principalOrgID: Swift.String?
    /// Specify a version or alias to add permissions to a published version of the function.
    public var qualifier: Swift.String?
    /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// For Amazon Web Service, the ID of the Amazon Web Services account that owns the resource. Use this together with SourceArn to ensure that the specified account owns the resource. It is possible for an Amazon S3 bucket to be deleted by its owner and recreated by another account.
    public var sourceAccount: Swift.String?
    /// For Amazon Web Services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or Amazon SNS topic. Note that Lambda configures the comparison using the StringLike operator.
    public var sourceArn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: Swift.String? = nil,
        eventSourceToken: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        principal: Swift.String? = nil,
        principalOrgID: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceAccount: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.eventSourceToken = eventSourceToken
        self.functionName = functionName
        self.functionUrlAuthType = functionUrlAuthType
        self.principal = principal
        self.principalOrgID = principalOrgID
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.sourceAccount = sourceAccount
        self.sourceArn = sourceArn
        self.statementId = statementId
    }
}

struct AddPermissionInputBody: Swift.Equatable {
    let statementId: Swift.String?
    let action: Swift.String?
    let principal: Swift.String?
    let sourceArn: Swift.String?
    let sourceAccount: Swift.String?
    let eventSourceToken: Swift.String?
    let revisionId: Swift.String?
    let principalOrgID: Swift.String?
    let functionUrlAuthType: LambdaClientTypes.FunctionUrlAuthType?
}

extension AddPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case functionUrlAuthType = "FunctionUrlAuthType"
        case principal = "Principal"
        case principalOrgID = "PrincipalOrgID"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let eventSourceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceToken)
        eventSourceToken = eventSourceTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let principalOrgIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalOrgID)
        principalOrgID = principalOrgIDDecoded
        let functionUrlAuthTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .functionUrlAuthType)
        functionUrlAuthType = functionUrlAuthTypeDecoded
    }
}

extension AddPermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddPermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.statement = output.statement
        } else {
            self.statement = nil
        }
    }
}

public struct AddPermissionOutput: Swift.Equatable {
    /// The permission statement that's added to the function policy.
    public var statement: Swift.String?

    public init(
        statement: Swift.String? = nil
    )
    {
        self.statement = statement
    }
}

struct AddPermissionOutputBody: Swift.Equatable {
    let statement: Swift.String?
}

extension AddPermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statement = "Statement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

enum AddPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyLengthExceededException": return try await PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes.AliasConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = self.aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = self.routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension LambdaClientTypes {
    /// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
    public struct AliasConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the alias.
        public var aliasArn: Swift.String?
        /// A description of the alias.
        public var description: Swift.String?
        /// The function version that the alias invokes.
        public var functionVersion: Swift.String?
        /// The name of the alias.
        public var name: Swift.String?
        /// A unique identifier that changes when you update the alias.
        public var revisionId: Swift.String?
        /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
        public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

        public init(
            aliasArn: Swift.String? = nil,
            description: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
        )
        {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }
    }

}

extension LambdaClientTypes.AliasRoutingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalVersionWeights = "AdditionalVersionWeights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalVersionWeights = additionalVersionWeights {
            var additionalVersionWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalVersionWeights)
            for (dictKey0, additionalVersionWeights0) in additionalVersionWeights {
                try additionalVersionWeightsContainer.encode(additionalVersionWeights0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalVersionWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .additionalVersionWeights)
        var additionalVersionWeightsDecoded0: [Swift.String:Swift.Double]? = nil
        if let additionalVersionWeightsContainer = additionalVersionWeightsContainer {
            additionalVersionWeightsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, weight0) in additionalVersionWeightsContainer {
                if let weight0 = weight0 {
                    additionalVersionWeightsDecoded0?[key0] = weight0
                }
            }
        }
        additionalVersionWeights = additionalVersionWeightsDecoded0
    }
}

extension LambdaClientTypes {
    /// The [traffic-shifting](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) configuration of a Lambda function alias.
    public struct AliasRoutingConfiguration: Swift.Equatable {
        /// The second version, and the percentage of traffic that's routed to it.
        public var additionalVersionWeights: [Swift.String:Swift.Double]?

        public init(
            additionalVersionWeights: [Swift.String:Swift.Double]? = nil
        )
        {
            self.additionalVersionWeights = additionalVersionWeights
        }
    }

}

extension LambdaClientTypes.AllowedPublishers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingProfileVersionArns = "SigningProfileVersionArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingProfileVersionArns = signingProfileVersionArns {
            var signingProfileVersionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signingProfileVersionArns)
            for arn0 in signingProfileVersionArns {
                try signingProfileVersionArnsContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingProfileVersionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .signingProfileVersionArns)
        var signingProfileVersionArnsDecoded0:[Swift.String]? = nil
        if let signingProfileVersionArnsContainer = signingProfileVersionArnsContainer {
            signingProfileVersionArnsDecoded0 = [Swift.String]()
            for string0 in signingProfileVersionArnsContainer {
                if let string0 = string0 {
                    signingProfileVersionArnsDecoded0?.append(string0)
                }
            }
        }
        signingProfileVersionArns = signingProfileVersionArnsDecoded0
    }
}

extension LambdaClientTypes {
    /// List of signing profiles that can sign a code package.
    public struct AllowedPublishers: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        /// This member is required.
        public var signingProfileVersionArns: [Swift.String]?

        public init(
            signingProfileVersionArns: [Swift.String]? = nil
        )
        {
            self.signingProfileVersionArns = signingProfileVersionArns
        }
    }

}

extension LambdaClientTypes.AmazonManagedKafkaEventSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerGroupId = "ConsumerGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerGroupId = self.consumerGroupId {
            try encodeContainer.encode(consumerGroupId, forKey: .consumerGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerGroupId)
        consumerGroupId = consumerGroupIdDecoded
    }
}

extension LambdaClientTypes {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public struct AmazonManagedKafkaEventSourceConfig: Swift.Equatable {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        public var consumerGroupId: Swift.String?

        public init(
            consumerGroupId: Swift.String? = nil
        )
        {
            self.consumerGroupId = consumerGroupId
        }
    }

}

extension LambdaClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.CodeSigningConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case codeSigningConfigId = "CodeSigningConfigId"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = self.allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningConfigArn = self.codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let codeSigningConfigId = self.codeSigningConfigId {
            try encodeContainer.encode(codeSigningConfigId, forKey: .codeSigningConfigId)
        }
        if let codeSigningPolicies = self.codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigId)
        codeSigningConfigId = codeSigningConfigIdDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a [Code signing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
    public struct CodeSigningConfig: Swift.Equatable {
        /// List of allowed publishers.
        /// This member is required.
        public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigArn: Swift.String?
        /// Unique identifer for the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigId: Swift.String?
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        /// This member is required.
        public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
        /// Code signing configuration description.
        public var description: Swift.String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModified: Swift.String?

        public init(
            allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
            codeSigningConfigArn: Swift.String? = nil,
            codeSigningConfigId: Swift.String? = nil,
            codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
            description: Swift.String? = nil,
            lastModified: Swift.String? = nil
        )
        {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }
    }

}

extension CodeSigningConfigNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CodeSigningConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified code signing configuration does not exist.
public struct CodeSigningConfigNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeSigningConfigNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct CodeSigningConfigNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension CodeSigningConfigNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.CodeSigningPolicies: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case untrustedArtifactOnDeployment = "UntrustedArtifactOnDeployment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let untrustedArtifactOnDeployment = self.untrustedArtifactOnDeployment {
            try encodeContainer.encode(untrustedArtifactOnDeployment.rawValue, forKey: .untrustedArtifactOnDeployment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let untrustedArtifactOnDeploymentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicy.self, forKey: .untrustedArtifactOnDeployment)
        untrustedArtifactOnDeployment = untrustedArtifactOnDeploymentDecoded
    }
}

extension LambdaClientTypes {
    /// Code signing configuration [policies](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies) specify the validation failure action for signature mismatch or expiry.
    public struct CodeSigningPolicies: Swift.Equatable {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Default value: Warn
        public var untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy?

        public init(
            untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy? = nil
        )
        {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }
    }

}

extension LambdaClientTypes {
    public enum CodeSigningPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enforce
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSigningPolicy] {
            return [
                .enforce,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "Enforce"
            case .warn: return "Warn"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeSigningPolicy(rawValue: rawValue) ?? CodeSigningPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CodeStorageExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CodeStorageExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your Amazon Web Services account has exceeded its maximum total code size. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct CodeStorageExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeStorageExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct CodeStorageExceededExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension CodeStorageExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeVerificationFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CodeVerificationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.
public struct CodeVerificationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeVerificationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct CodeVerificationFailedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension CodeVerificationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.Concurrency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = self.reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension LambdaClientTypes {
    public struct Concurrency: Swift.Equatable {
        /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Lambda reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
        public var reservedConcurrentExecutions: Swift.Int?

        public init(
            reservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }
    }

}

extension LambdaClientTypes.Cors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCredentials = "AllowCredentials"
        case allowHeaders = "AllowHeaders"
        case allowMethods = "AllowMethods"
        case allowOrigins = "AllowOrigins"
        case exposeHeaders = "ExposeHeaders"
        case maxAge = "MaxAge"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCredentials = self.allowCredentials {
            try encodeContainer.encode(allowCredentials, forKey: .allowCredentials)
        }
        if let allowHeaders = allowHeaders {
            var allowHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowHeaders)
            for header0 in allowHeaders {
                try allowHeadersContainer.encode(header0)
            }
        }
        if let allowMethods = allowMethods {
            var allowMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowMethods)
            for method0 in allowMethods {
                try allowMethodsContainer.encode(method0)
            }
        }
        if let allowOrigins = allowOrigins {
            var allowOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowOrigins)
            for origin0 in allowOrigins {
                try allowOriginsContainer.encode(origin0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for header0 in exposeHeaders {
                try exposeHeadersContainer.encode(header0)
            }
        }
        if let maxAge = self.maxAge {
            try encodeContainer.encode(maxAge, forKey: .maxAge)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCredentials)
        allowCredentials = allowCredentialsDecoded
        let allowHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowHeaders)
        var allowHeadersDecoded0:[Swift.String]? = nil
        if let allowHeadersContainer = allowHeadersContainer {
            allowHeadersDecoded0 = [Swift.String]()
            for string0 in allowHeadersContainer {
                if let string0 = string0 {
                    allowHeadersDecoded0?.append(string0)
                }
            }
        }
        allowHeaders = allowHeadersDecoded0
        let allowMethodsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowMethods)
        var allowMethodsDecoded0:[Swift.String]? = nil
        if let allowMethodsContainer = allowMethodsContainer {
            allowMethodsDecoded0 = [Swift.String]()
            for string0 in allowMethodsContainer {
                if let string0 = string0 {
                    allowMethodsDecoded0?.append(string0)
                }
            }
        }
        allowMethods = allowMethodsDecoded0
        let allowOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowOrigins)
        var allowOriginsDecoded0:[Swift.String]? = nil
        if let allowOriginsContainer = allowOriginsContainer {
            allowOriginsDecoded0 = [Swift.String]()
            for string0 in allowOriginsContainer {
                if let string0 = string0 {
                    allowOriginsDecoded0?.append(string0)
                }
            }
        }
        allowOrigins = allowOriginsDecoded0
        let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[Swift.String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [Swift.String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
        let maxAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAge)
        maxAge = maxAgeDecoded
    }
}

extension LambdaClientTypes {
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your Lambda function URL. Use CORS to grant access to your function URL from any origin. You can also use CORS to control access for specific HTTP headers and methods in requests to your function URL.
    public struct Cors: Swift.Equatable {
        /// Whether to allow cookies or other credentials in requests to your function URL. The default is false.
        public var allowCredentials: Swift.Bool?
        /// The HTTP headers that origins can include in requests to your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public var allowHeaders: [Swift.String]?
        /// The HTTP methods that are allowed when calling your function URL. For example: GET, POST, DELETE, or the wildcard character (*).
        public var allowMethods: [Swift.String]?
        /// The origins that can access your function URL. You can list any number of specific origins, separated by a comma. For example: https://www.example.com, http://localhost:60905. Alternatively, you can grant access to all origins using the wildcard character (*).
        public var allowOrigins: [Swift.String]?
        /// The HTTP headers in your function response that you want to expose to origins that call your function URL. For example: Date, Keep-Alive, X-Custom-Header.
        public var exposeHeaders: [Swift.String]?
        /// The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to 0, which means that the browser doesn't cache results.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }

}

extension CreateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routingConfig = self.routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

extension CreateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

public struct CreateAliasInput: Swift.Equatable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.routingConfig = routingConfig
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
    }
}

extension CreateAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct CreateAliasOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct CreateAliasOutputBody: Swift.Equatable {
    let aliasArn: Swift.String?
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension CreateAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum CreateAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCodeSigningConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = self.allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = self.codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

public struct CreateCodeSigningConfigInput: Swift.Equatable {
    /// Signing profiles for this code signing configuration.
    /// This member is required.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The code signing policies define the actions to take if the validation checks fail.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init(
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct CreateCodeSigningConfigInputBody: Swift.Equatable {
    let description: Swift.String?
    let allowedPublishers: LambdaClientTypes.AllowedPublishers?
    let codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
}

extension CreateCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension CreateCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCodeSigningConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct CreateCodeSigningConfigOutput: Swift.Equatable {
    /// The code signing configuration.
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct CreateCodeSigningConfigOutputBody: Swift.Equatable {
    let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension CreateCodeSigningConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

enum CreateCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventSourceMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonManagedKafkaEventSourceConfig = self.amazonManagedKafkaEventSourceConfig {
            try encodeContainer.encode(amazonManagedKafkaEventSourceConfig, forKey: .amazonManagedKafkaEventSourceConfig)
        }
        if let batchSize = self.batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = self.bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let documentDBEventSourceConfig = self.documentDBEventSourceConfig {
            try encodeContainer.encode(documentDBEventSourceConfig, forKey: .documentDBEventSourceConfig)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetype0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetype0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = self.maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = self.maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = self.parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queue0 in queues {
                try queuesContainer.encode(queue0)
            }
        }
        if let scalingConfig = self.scalingConfig {
            try encodeContainer.encode(scalingConfig, forKey: .scalingConfig)
        }
        if let selfManagedEventSource = self.selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let selfManagedKafkaEventSourceConfig = self.selfManagedKafkaEventSourceConfig {
            try encodeContainer.encode(selfManagedKafkaEventSourceConfig, forKey: .selfManagedKafkaEventSourceConfig)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfiguration0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfiguration0)
            }
        }
        if let startingPosition = self.startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = self.startingPositionTimestamp {
            try encodeContainer.encodeTimestamp(startingPositionTimestamp, format: .epochSeconds, forKey: .startingPositionTimestamp)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topic0 in topics {
                try topicsContainer.encode(topic0)
            }
        }
        if let tumblingWindowInSeconds = self.tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

extension CreateEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

public struct CreateEventSourceMappingInput: Swift.Equatable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis – Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams – Default 100. Max 10,000.
    ///
    /// * Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Self-managed Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
    ///
    /// * DocumentDB – Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis and DynamoDB Streams only) A standard Amazon SQS queue or standard Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis – The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams – The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service – The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – The ARN of the cluster.
    ///
    /// * Amazon MQ – The ARN of the broker.
    ///
    /// * Amazon DocumentDB – The ARN of the DocumentDB change stream.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster to receive records from.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        enabled: Swift.Bool? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.enabled = enabled
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
    }
}

struct CreateEventSourceMappingInputBody: Swift.Equatable {
    let eventSourceArn: Swift.String?
    let functionName: Swift.String?
    let enabled: Swift.Bool?
    let batchSize: Swift.Int?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    let amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    let selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    let scalingConfig: LambdaClientTypes.ScalingConfig?
    let documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
}

extension CreateEventSourceMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let amazonManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.self, forKey: .amazonManagedKafkaEventSourceConfig)
        amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfigDecoded
        let selfManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedKafkaEventSourceConfig.self, forKey: .selfManagedKafkaEventSourceConfig)
        selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfigDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

extension CreateEventSourceMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventSourceMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.amazonManagedKafkaEventSourceConfig = output.amazonManagedKafkaEventSourceConfig
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.documentDBEventSourceConfig = output.documentDBEventSourceConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.scalingConfig = output.scalingConfig
            self.selfManagedEventSource = output.selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = output.selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uuid = output.uuid
        } else {
            self.amazonManagedKafkaEventSourceConfig = nil
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.documentDBEventSourceConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.scalingConfig = nil
            self.selfManagedEventSource = nil
            self.selfManagedKafkaEventSourceConfig = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uuid = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct CreateEventSourceMappingOutput: Swift.Equatable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

struct CreateEventSourceMappingOutputBody: Swift.Equatable {
    let uuid: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    let amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    let selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    let scalingConfig: LambdaClientTypes.ScalingConfig?
    let documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
}

extension CreateEventSourceMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uuid = "UUID"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let amazonManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.self, forKey: .amazonManagedKafkaEventSourceConfig)
        amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfigDecoded
        let selfManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedKafkaEventSourceConfig.self, forKey: .selfManagedKafkaEventSourceConfig)
        selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfigDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

enum CreateEventSourceMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kmsKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case snapStart = "SnapStart"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecture0 in architectures {
                try architecturesContainer.encode(architecture0.rawValue)
            }
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let codeSigningConfigArn = self.codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let deadLetterConfig = self.deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let ephemeralStorage = self.ephemeralStorage {
            try encodeContainer.encode(ephemeralStorage, forKey: .ephemeralStorage)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfig0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfig0)
            }
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = self.handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = self.imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerversionarn0 in layers {
                try layersContainer.encode(layerversionarn0)
            }
        }
        if let memorySize = self.memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let publish = self.publish {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let snapStart = self.snapStart {
            try encodeContainer.encode(snapStart, forKey: .snapStart)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = self.tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/functions"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The code for the function.
    /// This member is required.
    public var code: LambdaClientTypes.FunctionCode?
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
    public var codeSigningConfigArn: Swift.String?
    /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
    public var handler: Swift.String?
    /// Container image [configuration values](https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings) that override the values in the container image Dockerfile.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
    public var kmsKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// Set to true to publish the first version of the function during creation.
    public var publish: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    /// This member is required.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public var snapStart: LambdaClientTypes.SnapStart?
    /// A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
    public var tags: [Swift.String:Swift.String]?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        code: LambdaClientTypes.FunctionCode? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        publish: Swift.Bool? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        snapStart: LambdaClientTypes.SnapStart? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.architectures = architectures
        self.code = code
        self.codeSigningConfigArn = codeSigningConfigArn
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kmsKeyArn = kmsKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.packageType = packageType
        self.publish = publish
        self.role = role
        self.runtime = runtime
        self.snapStart = snapStart
        self.tags = tags
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    let functionName: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let code: LambdaClientTypes.FunctionCode?
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let publish: Swift.Bool?
    let vpcConfig: LambdaClientTypes.VpcConfig?
    let packageType: LambdaClientTypes.PackageType?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.Environment?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfig?
    let tags: [Swift.String:Swift.String]?
    let layers: [Swift.String]?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let imageConfig: LambdaClientTypes.ImageConfig?
    let codeSigningConfigArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStart?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kmsKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case snapStart = "SnapStart"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionCode.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let publishDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publish)
        publish = publishDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStart.self, forKey: .snapStart)
        snapStart = snapStartDecoded
    }
}

extension CreateFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.ephemeralStorage = output.ephemeralStorage
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.runtimeVersionConfig = output.runtimeVersionConfig
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.snapStart = output.snapStart
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.ephemeralStorage = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kmsKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.runtimeVersionConfig = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.snapStart = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct CreateFunctionOutput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionOutputBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStartResponse?
    let runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
}

extension CreateFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kmsKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case runtimeVersionConfig = "RuntimeVersionConfig"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case snapStart = "SnapStart"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartResponse.self, forKey: .snapStart)
        snapStart = snapStartDecoded
        let runtimeVersionConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionConfig.self, forKey: .runtimeVersionConfig)
        runtimeVersionConfig = runtimeVersionConfigDecoded
    }
}

enum CreateFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeSigningConfigNotFoundException": return try await CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CodeStorageExceededException": return try await CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CodeVerificationFailedException": return try await CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCodeSignatureException": return try await InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFunctionUrlConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case invokeMode = "InvokeMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let cors = self.cors {
            try encodeContainer.encode(cors, forKey: .cors)
        }
        if let invokeMode = self.invokeMode {
            try encodeContainer.encode(invokeMode.rawValue, forKey: .invokeMode)
        }
    }
}

extension CreateFunctionUrlConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension CreateFunctionUrlConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

public struct CreateFunctionUrlConfigInput: Swift.Equatable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        functionName: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.functionName = functionName
        self.invokeMode = invokeMode
        self.qualifier = qualifier
    }
}

struct CreateFunctionUrlConfigInputBody: Swift.Equatable {
    let authType: LambdaClientTypes.FunctionUrlAuthType?
    let cors: LambdaClientTypes.Cors?
    let invokeMode: LambdaClientTypes.InvokeMode?
}

extension CreateFunctionUrlConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case invokeMode = "InvokeMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let corsDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Cors.self, forKey: .cors)
        cors = corsDecoded
        let invokeModeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.InvokeMode.self, forKey: .invokeMode)
        invokeMode = invokeModeDecoded
    }
}

extension CreateFunctionUrlConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFunctionUrlConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.cors = output.cors
            self.creationTime = output.creationTime
            self.functionArn = output.functionArn
            self.functionUrl = output.functionUrl
            self.invokeMode = output.invokeMode
        } else {
            self.authType = nil
            self.cors = nil
            self.creationTime = nil
            self.functionArn = nil
            self.functionUrl = nil
            self.invokeMode = nil
        }
    }
}

public struct CreateFunctionUrlConfigOutput: Swift.Equatable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
    }
}

struct CreateFunctionUrlConfigOutputBody: Swift.Equatable {
    let functionUrl: Swift.String?
    let functionArn: Swift.String?
    let authType: LambdaClientTypes.FunctionUrlAuthType?
    let cors: LambdaClientTypes.Cors?
    let creationTime: Swift.String?
    let invokeMode: LambdaClientTypes.InvokeMode?
}

extension CreateFunctionUrlConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case creationTime = "CreationTime"
        case functionArn = "FunctionArn"
        case functionUrl = "FunctionUrl"
        case invokeMode = "InvokeMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionUrl)
        functionUrl = functionUrlDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let corsDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Cors.self, forKey: .cors)
        cors = corsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let invokeModeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.InvokeMode.self, forKey: .invokeMode)
        invokeMode = invokeModeDecoded
    }
}

enum CreateFunctionUrlConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes.DeadLetterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension LambdaClientTypes {
    /// The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq) for failed asynchronous invocations.
    public struct DeadLetterConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public var targetArn: Swift.String?

        public init(
            targetArn: Swift.String? = nil
        )
        {
            self.targetArn = targetArn
        }
    }

}

extension DeleteAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAliasInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct DeleteAliasInputBody: Swift.Equatable {
}

extension DeleteAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

public struct DeleteCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct DeleteCodeSigningConfigInputBody: Swift.Equatable {
}

extension DeleteCodeSigningConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCodeSigningConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let uuid = uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

public struct DeleteEventSourceMappingInput: Swift.Equatable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        uuid: Swift.String? = nil
    )
    {
        self.uuid = uuid
    }
}

struct DeleteEventSourceMappingInputBody: Swift.Equatable {
}

extension DeleteEventSourceMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventSourceMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEventSourceMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.amazonManagedKafkaEventSourceConfig = output.amazonManagedKafkaEventSourceConfig
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.documentDBEventSourceConfig = output.documentDBEventSourceConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.scalingConfig = output.scalingConfig
            self.selfManagedEventSource = output.selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = output.selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uuid = output.uuid
        } else {
            self.amazonManagedKafkaEventSourceConfig = nil
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.documentDBEventSourceConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.scalingConfig = nil
            self.selfManagedEventSource = nil
            self.selfManagedKafkaEventSourceConfig = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uuid = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct DeleteEventSourceMappingOutput: Swift.Equatable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

struct DeleteEventSourceMappingOutputBody: Swift.Equatable {
    let uuid: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    let amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    let selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    let scalingConfig: LambdaClientTypes.ScalingConfig?
    let documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
}

extension DeleteEventSourceMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uuid = "UUID"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let amazonManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.self, forKey: .amazonManagedKafkaEventSourceConfig)
        amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfigDecoded
        let selfManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedKafkaEventSourceConfig.self, forKey: .selfManagedKafkaEventSourceConfig)
        selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfigDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

enum DeleteEventSourceMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

public struct DeleteFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionCodeSigningConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionCodeSigningConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionCodeSigningConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeSigningConfigNotFoundException": return try await CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

public struct DeleteFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionConcurrencyInputBody: Swift.Equatable {
}

extension DeleteFunctionConcurrencyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionConcurrencyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionConcurrencyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionConcurrencyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension DeleteFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct DeleteFunctionEventInvokeConfigInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionEventInvokeConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionEventInvokeConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionEventInvokeConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionEventInvokeConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension DeleteFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The name of the Lambda function or version. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:1 (with version).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version to delete. You can't delete a version that an alias references.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionUrlConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension DeleteFunctionUrlConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

public struct DeleteFunctionUrlConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionUrlConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionUrlConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionUrlConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionUrlConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionUrlConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLayerVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

public struct DeleteLayerVersionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct DeleteLayerVersionInputBody: Swift.Equatable {
}

extension DeleteLayerVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLayerVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLayerVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLayerVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProvisionedConcurrencyConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let qualifier = qualifier else {
                let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
            return items
        }
    }
}

extension DeleteProvisionedConcurrencyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct DeleteProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteProvisionedConcurrencyConfigInputBody: Swift.Equatable {
}

extension DeleteProvisionedConcurrencyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisionedConcurrencyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProvisionedConcurrencyConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes.DestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onFailure = "OnFailure"
        case onSuccess = "OnSuccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onFailure = self.onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let onSuccess = self.onSuccess {
            try encodeContainer.encode(onSuccess, forKey: .onSuccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onSuccessDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.OnSuccess.self, forKey: .onSuccess)
        onSuccess = onSuccessDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.OnFailure.self, forKey: .onFailure)
        onFailure = onFailureDecoded
    }
}

extension LambdaClientTypes {
    /// A configuration object that specifies the destination of an event after Lambda processes it.
    public struct DestinationConfig: Swift.Equatable {
        /// The destination configuration for failed invocations.
        public var onFailure: LambdaClientTypes.OnFailure?
        /// The destination configuration for successful invocations.
        public var onSuccess: LambdaClientTypes.OnSuccess?

        public init(
            onFailure: LambdaClientTypes.OnFailure? = nil,
            onSuccess: LambdaClientTypes.OnSuccess? = nil
        )
        {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }
    }

}

extension LambdaClientTypes.DocumentDBEventSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case databaseName = "DatabaseName"
        case fullDocument = "FullDocument"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = self.collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let fullDocument = self.fullDocument {
            try encodeContainer.encode(fullDocument.rawValue, forKey: .fullDocument)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let fullDocumentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FullDocument.self, forKey: .fullDocument)
        fullDocument = fullDocumentDecoded
    }
}

extension LambdaClientTypes {
    /// Specific configuration settings for a DocumentDB event source.
    public struct DocumentDBEventSourceConfig: Swift.Equatable {
        /// The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        public var collectionName: Swift.String?
        /// The name of the database to consume within the DocumentDB cluster.
        public var databaseName: Swift.String?
        /// Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
        public var fullDocument: LambdaClientTypes.FullDocument?

        public init(
            collectionName: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fullDocument: LambdaClientTypes.FullDocument? = nil
        )
        {
            self.collectionName = collectionName
            self.databaseName = databaseName
            self.fullDocument = fullDocument
        }
    }

}

extension EC2AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EC2AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Need additional permissions to configure VPC settings.
public struct EC2AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2AccessDeniedException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct EC2AccessDeniedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EC2AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2ThrottledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EC2ThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon EC2 throttled Lambda during Lambda function initialization using the execution role provided for the function.
public struct EC2ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2ThrottledException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct EC2ThrottledExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EC2ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2UnexpectedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EC2UnexpectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.ec2ErrorCode = output.ec2ErrorCode
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.ec2ErrorCode = nil
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda function.
public struct EC2UnexpectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var ec2ErrorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EC2UnexpectedException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        ec2ErrorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.ec2ErrorCode = ec2ErrorCode
        self.properties.message = message
        self.properties.type = type
    }
}

struct EC2UnexpectedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
    let ec2ErrorCode: Swift.String?
}

extension EC2UnexpectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2ErrorCode = "EC2ErrorCode"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let ec2ErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ErrorCode)
        ec2ErrorCode = ec2ErrorCodeDecoded
    }
}

extension EFSIOException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EFSIOExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error occurred when reading from or writing to a connected file system.
public struct EFSIOException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSIOException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct EFSIOExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSIOExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountConnectivityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EFSMountConnectivityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Lambda function couldn't make a network connection to the configured file system.
public struct EFSMountConnectivityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountConnectivityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct EFSMountConnectivityExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSMountConnectivityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EFSMountFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Lambda function couldn't mount the configured file system due to a permission or configuration issue.
public struct EFSMountFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountFailureException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct EFSMountFailureExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSMountFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EFSMountTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Lambda function made a network connection to the configured file system, but the mount operation timed out.
public struct EFSMountTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EFSMountTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct EFSMountTimeoutExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension EFSMountTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ENILimitReachedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ENILimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct ENILimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ENILimitReachedException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ENILimitReachedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ENILimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum EndPointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kafkaBootstrapServers
        case sdkUnknown(Swift.String)

        public static var allCases: [EndPointType] {
            return [
                .kafkaBootstrapServers,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndPointType(rawValue: rawValue) ?? EndPointType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, environmentVariables0) in variables {
                try variablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension LambdaClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(variables: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
    public struct Environment: Swift.Equatable {
        /// Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        public var variables: [Swift.String:Swift.String]?

        public init(
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.variables = variables
        }
    }

}

extension LambdaClientTypes.EnvironmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.EnvironmentError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// Error messages for environment variables that couldn't be applied.
    public struct EnvironmentError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.EnvironmentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, environmentVariables0) in variables {
                try variablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes.EnvironmentResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentResponse(error: \(Swift.String(describing: error)), variables: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// The results of an operation to update or read environment variables. If the operation succeeds, the response contains the environment variables. If it fails, the response contains details about the error.
    public struct EnvironmentResponse: Swift.Equatable {
        /// Error messages for environment variables that couldn't be applied.
        public var error: LambdaClientTypes.EnvironmentError?
        /// Environment variable key-value pairs. Omitted from CloudTrail logs.
        public var variables: [Swift.String:Swift.String]?

        public init(
            error: LambdaClientTypes.EnvironmentError? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.error = error
            self.variables = variables
        }
    }

}

extension LambdaClientTypes.EphemeralStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension LambdaClientTypes {
    /// The size of the function's /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
    public struct EphemeralStorage: Swift.Equatable {
        /// The size of the function's /tmp directory.
        /// This member is required.
        public var size: Swift.Int?

        public init(
            size: Swift.Int? = nil
        )
        {
            self.size = size
        }
    }

}

extension LambdaClientTypes.EventSourceMappingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uuid = "UUID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonManagedKafkaEventSourceConfig = self.amazonManagedKafkaEventSourceConfig {
            try encodeContainer.encode(amazonManagedKafkaEventSourceConfig, forKey: .amazonManagedKafkaEventSourceConfig)
        }
        if let batchSize = self.batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = self.bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let documentDBEventSourceConfig = self.documentDBEventSourceConfig {
            try encodeContainer.encode(documentDBEventSourceConfig, forKey: .documentDBEventSourceConfig)
        }
        if let eventSourceArn = self.eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetype0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetype0.rawValue)
            }
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let lastProcessingResult = self.lastProcessingResult {
            try encodeContainer.encode(lastProcessingResult, forKey: .lastProcessingResult)
        }
        if let maximumBatchingWindowInSeconds = self.maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = self.maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = self.parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queue0 in queues {
                try queuesContainer.encode(queue0)
            }
        }
        if let scalingConfig = self.scalingConfig {
            try encodeContainer.encode(scalingConfig, forKey: .scalingConfig)
        }
        if let selfManagedEventSource = self.selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let selfManagedKafkaEventSourceConfig = self.selfManagedKafkaEventSourceConfig {
            try encodeContainer.encode(selfManagedKafkaEventSourceConfig, forKey: .selfManagedKafkaEventSourceConfig)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfiguration0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfiguration0)
            }
        }
        if let startingPosition = self.startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = self.startingPositionTimestamp {
            try encodeContainer.encodeTimestamp(startingPositionTimestamp, format: .epochSeconds, forKey: .startingPositionTimestamp)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stateTransitionReason = self.stateTransitionReason {
            try encodeContainer.encode(stateTransitionReason, forKey: .stateTransitionReason)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topic0 in topics {
                try topicsContainer.encode(topic0)
            }
        }
        if let tumblingWindowInSeconds = self.tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
        if let uuid = self.uuid {
            try encodeContainer.encode(uuid, forKey: .uuid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let amazonManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.self, forKey: .amazonManagedKafkaEventSourceConfig)
        amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfigDecoded
        let selfManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedKafkaEventSourceConfig.self, forKey: .selfManagedKafkaEventSourceConfig)
        selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfigDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

extension LambdaClientTypes {
    /// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
    public struct EventSourceMappingConfiguration: Swift.Equatable {
        /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
        public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var batchSize: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
        public var bisectBatchOnFunctionError: Swift.Bool?
        /// (Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// Specific configuration settings for a DocumentDB event source.
        public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public var eventSourceArn: Swift.String?
        /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
        public var filterCriteria: LambdaClientTypes.FilterCriteria?
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
        public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
        /// The date that the event source mapping was last updated or that its state changed.
        public var lastModified: ClientRuntime.Date?
        /// The result of the last Lambda invocation of your function.
        public var lastProcessingResult: Swift.String?
        /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var maximumBatchingWindowInSeconds: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
        public var maximumRecordAgeInSeconds: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public var maximumRetryAttempts: Swift.Int?
        /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
        public var parallelizationFactor: Swift.Int?
        /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
        public var queues: [Swift.String]?
        /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
        public var scalingConfig: LambdaClientTypes.ScalingConfig?
        /// The self-managed Apache Kafka cluster for your event source.
        public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
        /// Specific configuration settings for a self-managed Apache Kafka event source.
        public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
        /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
        public var startingPosition: LambdaClientTypes.EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
        public var startingPositionTimestamp: ClientRuntime.Date?
        /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
        public var state: Swift.String?
        /// Indicates whether a user or Lambda made the last change to the event source mapping.
        public var stateTransitionReason: Swift.String?
        /// The name of the Kafka topic.
        public var topics: [Swift.String]?
        /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
        public var tumblingWindowInSeconds: Swift.Int?
        /// The identifier of the event source mapping.
        public var uuid: Swift.String?

        public init(
            amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
            batchSize: Swift.Int? = nil,
            bisectBatchOnFunctionError: Swift.Bool? = nil,
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
            eventSourceArn: Swift.String? = nil,
            filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
            functionArn: Swift.String? = nil,
            functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lastProcessingResult: Swift.String? = nil,
            maximumBatchingWindowInSeconds: Swift.Int? = nil,
            maximumRecordAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil,
            parallelizationFactor: Swift.Int? = nil,
            queues: [Swift.String]? = nil,
            scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
            selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
            selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
            sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
            startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
            startingPositionTimestamp: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            stateTransitionReason: Swift.String? = nil,
            topics: [Swift.String]? = nil,
            tumblingWindowInSeconds: Swift.Int? = nil,
            uuid: Swift.String? = nil
        )
        {
            self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.documentDBEventSourceConfig = documentDBEventSourceConfig
            self.eventSourceArn = eventSourceArn
            self.filterCriteria = filterCriteria
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.queues = queues
            self.scalingConfig = scalingConfig
            self.selfManagedEventSource = selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uuid = uuid
        }
    }

}

extension LambdaClientTypes {
    public enum EventSourcePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case atTimestamp
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourcePosition] {
            return [
                .atTimestamp,
                .latest,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .atTimestamp: return "AT_TIMESTAMP"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourcePosition(rawValue: rawValue) ?? EventSourcePosition.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.FileSystemConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case localMountPath = "LocalMountPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let localMountPath = self.localMountPath {
            try encodeContainer.encode(localMountPath, forKey: .localMountPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let localMountPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localMountPath)
        localMountPath = localMountPathDecoded
    }
}

extension LambdaClientTypes {
    /// Details about the connection between a Lambda function and an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public struct FileSystemConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        /// This member is required.
        public var arn: Swift.String?
        /// The path where the function can access the file system, starting with /mnt/.
        /// This member is required.
        public var localMountPath: Swift.String?

        public init(
            arn: Swift.String? = nil,
            localMountPath: Swift.String? = nil
        )
        {
            self.arn = arn
            self.localMountPath = localMountPath
        }
    }

}

extension LambdaClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pattern = "Pattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
    }
}

extension LambdaClientTypes {
    /// A structure within a FilterCriteria object that defines an event filtering pattern.
    public struct Filter: Swift.Equatable {
        /// A filter pattern. For more information on the syntax of a filter pattern, see [ Filter rule syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        public var pattern: Swift.String?

        public init(
            pattern: Swift.String? = nil
        )
        {
            self.pattern = pattern
        }
    }

}

extension LambdaClientTypes.FilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LambdaClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LambdaClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension LambdaClientTypes {
    /// An object that contains the filters for an event source.
    public struct FilterCriteria: Swift.Equatable {
        /// A list of filters.
        public var filters: [LambdaClientTypes.Filter]?

        public init(
            filters: [LambdaClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension LambdaClientTypes {
    public enum FullDocument: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case updatelookup
        case sdkUnknown(Swift.String)

        public static var allCases: [FullDocument] {
            return [
                .default,
                .updatelookup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .updatelookup: return "UpdateLookup"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FullDocument(rawValue: rawValue) ?? FullDocument.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.FunctionCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri = "ImageUri"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = self.imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = self.s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = self.zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
    }
}

extension LambdaClientTypes.FunctionCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionCode(imageUri: \(Swift.String(describing: imageUri)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// The code for the Lambda function. You can either specify an object in Amazon S3, upload a .zip file archive deployment package directly, or specify the URI of a container image.
    public struct FunctionCode: Swift.Equatable {
        /// URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you.
        public var zipFile: ClientRuntime.Data?

        public init(
            imageUri: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension LambdaClientTypes.FunctionCodeLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri = "ImageUri"
        case location = "Location"
        case repositoryType = "RepositoryType"
        case resolvedImageUri = "ResolvedImageUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = self.imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = self.repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
        if let resolvedImageUri = self.resolvedImageUri {
            try encodeContainer.encode(resolvedImageUri, forKey: .resolvedImageUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let resolvedImageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedImageUri)
        resolvedImageUri = resolvedImageUriDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a function's deployment package.
    public struct FunctionCodeLocation: Swift.Equatable {
        /// URI of a container image in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// A presigned URL that you can use to download the deployment package.
        public var location: Swift.String?
        /// The service that's hosting the file.
        public var repositoryType: Swift.String?
        /// The resolved URI for the image.
        public var resolvedImageUri: Swift.String?

        public init(
            imageUri: Swift.String? = nil,
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil,
            resolvedImageUri: Swift.String? = nil
        )
        {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
        }
    }

}

extension LambdaClientTypes.FunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kmsKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case runtimeVersionConfig = "RuntimeVersionConfig"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case snapStart = "SnapStart"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecture0 in architectures {
                try architecturesContainer.encode(architecture0.rawValue)
            }
        }
        if let codeSha256 = self.codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let deadLetterConfig = self.deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let ephemeralStorage = self.ephemeralStorage {
            try encodeContainer.encode(ephemeralStorage, forKey: .ephemeralStorage)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfig0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfig0)
            }
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = self.handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfigResponse = self.imageConfigResponse {
            try encodeContainer.encode(imageConfigResponse, forKey: .imageConfigResponse)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let lastUpdateStatus = self.lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus.rawValue, forKey: .lastUpdateStatus)
        }
        if let lastUpdateStatusReason = self.lastUpdateStatusReason {
            try encodeContainer.encode(lastUpdateStatusReason, forKey: .lastUpdateStatusReason)
        }
        if let lastUpdateStatusReasonCode = self.lastUpdateStatusReasonCode {
            try encodeContainer.encode(lastUpdateStatusReasonCode.rawValue, forKey: .lastUpdateStatusReasonCode)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layer0 in layers {
                try layersContainer.encode(layer0)
            }
        }
        if let masterArn = self.masterArn {
            try encodeContainer.encode(masterArn, forKey: .masterArn)
        }
        if let memorySize = self.memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let runtimeVersionConfig = self.runtimeVersionConfig {
            try encodeContainer.encode(runtimeVersionConfig, forKey: .runtimeVersionConfig)
        }
        if let signingJobArn = self.signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = self.signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
        if let snapStart = self.snapStart {
            try encodeContainer.encode(snapStart, forKey: .snapStart)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = self.stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = self.tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartResponse.self, forKey: .snapStart)
        snapStart = snapStartDecoded
        let runtimeVersionConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionConfig.self, forKey: .runtimeVersionConfig)
        runtimeVersionConfig = runtimeVersionConfigDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a function's configuration.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
        public var architectures: [LambdaClientTypes.Architecture]?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The size of the function's deployment package, in bytes.
        public var codeSize: Swift.Int
        /// The function's dead letter queue.
        public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
        /// The function's description.
        public var description: Swift.String?
        /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
        public var environment: LambdaClientTypes.EnvironmentResponse?
        /// The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
        public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
        /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
        public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public var functionArn: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin running your function.
        public var handler: Swift.String?
        /// The function's image configuration values.
        public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
        /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
        public var kmsKeyArn: Swift.String?
        /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        public var lastModified: Swift.String?
        /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
        public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public var lastUpdateStatusReason: Swift.String?
        /// The reason code for the last update that was performed on the function.
        public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
        /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
        public var layers: [LambdaClientTypes.Layer]?
        /// For Lambda@Edge functions, the ARN of the main function.
        public var masterArn: Swift.String?
        /// The amount of memory available to the function at runtime.
        public var memorySize: Swift.Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: LambdaClientTypes.PackageType?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
        public var runtime: LambdaClientTypes.Runtime?
        /// The ARN of the runtime and any errors that occured.
        public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
        /// The ARN of the signing job.
        public var signingJobArn: Swift.String?
        /// The ARN of the signing profile version.
        public var signingProfileVersionArn: Swift.String?
        /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
        public var snapStart: LambdaClientTypes.SnapStartResponse?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
        public var state: LambdaClientTypes.State?
        /// The reason for the function's current state.
        public var stateReason: Swift.String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
        public var stateReasonCode: LambdaClientTypes.StateReasonCode?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int?
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

        public init(
            architectures: [LambdaClientTypes.Architecture]? = nil,
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
            description: Swift.String? = nil,
            environment: LambdaClientTypes.EnvironmentResponse? = nil,
            ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
            fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
            functionArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
            lastUpdateStatusReason: Swift.String? = nil,
            lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
            layers: [LambdaClientTypes.Layer]? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            packageType: LambdaClientTypes.PackageType? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: LambdaClientTypes.Runtime? = nil,
            runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil,
            snapStart: LambdaClientTypes.SnapStartResponse? = nil,
            state: LambdaClientTypes.State? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
            timeout: Swift.Int? = nil,
            tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
            version: Swift.String? = nil,
            vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
        )
        {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.ephemeralStorage = ephemeralStorage
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.runtimeVersionConfig = runtimeVersionConfig
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.snapStart = snapStart
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

extension LambdaClientTypes.FunctionEventInvokeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let maximumEventAgeInSeconds = self.maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension LambdaClientTypes {
    public struct FunctionEventInvokeConfig: Swift.Equatable {
        /// A destination for events after they have been sent to a function for processing. Destinations
        ///
        /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
        ///
        /// * Queue - The ARN of a standard SQS queue.
        ///
        /// * Topic - The ARN of a standard SNS topic.
        ///
        /// * Event Bus - The ARN of an Amazon EventBridge event bus.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public var functionArn: Swift.String?
        /// The date and time that the configuration was last updated.
        public var lastModified: ClientRuntime.Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of times to retry when the function returns an error.
        public var maximumRetryAttempts: Swift.Int?

        public init(
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            functionArn: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }

}

extension LambdaClientTypes {
    public enum FunctionResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportbatchitemfailures
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionResponseType] {
            return [
                .reportbatchitemfailures,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportbatchitemfailures: return "ReportBatchItemFailures"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionResponseType(rawValue: rawValue) ?? FunctionResponseType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum FunctionUrlAuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionUrlAuthType] {
            return [
                .awsIam,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionUrlAuthType(rawValue: rawValue) ?? FunctionUrlAuthType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.FunctionUrlConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case creationTime = "CreationTime"
        case functionArn = "FunctionArn"
        case functionUrl = "FunctionUrl"
        case invokeMode = "InvokeMode"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let cors = self.cors {
            try encodeContainer.encode(cors, forKey: .cors)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionUrl = self.functionUrl {
            try encodeContainer.encode(functionUrl, forKey: .functionUrl)
        }
        if let invokeMode = self.invokeMode {
            try encodeContainer.encode(invokeMode.rawValue, forKey: .invokeMode)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionUrl)
        functionUrl = functionUrlDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let corsDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Cors.self, forKey: .cors)
        cors = corsDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let invokeModeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.InvokeMode.self, forKey: .invokeMode)
        invokeMode = invokeModeDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a Lambda function URL.
    public struct FunctionUrlConfig: Swift.Equatable {
        /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
        /// This member is required.
        public var authType: LambdaClientTypes.FunctionUrlAuthType?
        /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
        public var cors: LambdaClientTypes.Cors?
        /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var creationTime: Swift.String?
        /// The Amazon Resource Name (ARN) of your function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// The HTTP URL endpoint for your function.
        /// This member is required.
        public var functionUrl: Swift.String?
        /// Use one of the following options:
        ///
        /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
        ///
        /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
        public var invokeMode: LambdaClientTypes.InvokeMode?
        /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModifiedTime: Swift.String?

        public init(
            authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
            cors: LambdaClientTypes.Cors? = nil,
            creationTime: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionUrl: Swift.String? = nil,
            invokeMode: LambdaClientTypes.InvokeMode? = nil,
            lastModifiedTime: Swift.String? = nil
        )
        {
            self.authType = authType
            self.cors = cors
            self.creationTime = creationTime
            self.functionArn = functionArn
            self.functionUrl = functionUrl
            self.invokeMode = invokeMode
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension LambdaClientTypes {
    public enum FunctionVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionVersion] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionVersion(rawValue: rawValue) ?? FunctionVersion.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2016-08-19/account-settings"
    }
}

public struct GetAccountSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountLimit = output.accountLimit
            self.accountUsage = output.accountUsage
        } else {
            self.accountLimit = nil
            self.accountUsage = nil
        }
    }
}

public struct GetAccountSettingsOutput: Swift.Equatable {
    /// Limits that are related to concurrency and code storage.
    public var accountLimit: LambdaClientTypes.AccountLimit?
    /// The number of functions and amount of storage in use.
    public var accountUsage: LambdaClientTypes.AccountUsage?

    public init(
        accountLimit: LambdaClientTypes.AccountLimit? = nil,
        accountUsage: LambdaClientTypes.AccountUsage? = nil
    )
    {
        self.accountLimit = accountLimit
        self.accountUsage = accountUsage
    }
}

struct GetAccountSettingsOutputBody: Swift.Equatable {
    let accountLimit: LambdaClientTypes.AccountLimit?
    let accountUsage: LambdaClientTypes.AccountUsage?
}

extension GetAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLimit = "AccountLimit"
        case accountUsage = "AccountUsage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLimitDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AccountLimit.self, forKey: .accountLimit)
        accountLimit = accountLimitDecoded
        let accountUsageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AccountUsage.self, forKey: .accountUsage)
        accountUsage = accountUsageDecoded
    }
}

enum GetAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

public struct GetAliasInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct GetAliasInputBody: Swift.Equatable {
}

extension GetAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct GetAliasOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct GetAliasOutputBody: Swift.Equatable {
    let aliasArn: Swift.String?
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension GetAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum GetAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

public struct GetCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct GetCodeSigningConfigInputBody: Swift.Equatable {
}

extension GetCodeSigningConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCodeSigningConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct GetCodeSigningConfigOutput: Swift.Equatable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct GetCodeSigningConfigOutputBody: Swift.Equatable {
    let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension GetCodeSigningConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

enum GetCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let uuid = uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

public struct GetEventSourceMappingInput: Swift.Equatable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        uuid: Swift.String? = nil
    )
    {
        self.uuid = uuid
    }
}

struct GetEventSourceMappingInputBody: Swift.Equatable {
}

extension GetEventSourceMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEventSourceMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventSourceMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.amazonManagedKafkaEventSourceConfig = output.amazonManagedKafkaEventSourceConfig
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.documentDBEventSourceConfig = output.documentDBEventSourceConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.scalingConfig = output.scalingConfig
            self.selfManagedEventSource = output.selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = output.selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uuid = output.uuid
        } else {
            self.amazonManagedKafkaEventSourceConfig = nil
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.documentDBEventSourceConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.scalingConfig = nil
            self.selfManagedEventSource = nil
            self.selfManagedKafkaEventSourceConfig = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uuid = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct GetEventSourceMappingOutput: Swift.Equatable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

struct GetEventSourceMappingOutputBody: Swift.Equatable {
    let uuid: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    let amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    let selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    let scalingConfig: LambdaClientTypes.ScalingConfig?
    let documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
}

extension GetEventSourceMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uuid = "UUID"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let amazonManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.self, forKey: .amazonManagedKafkaEventSourceConfig)
        amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfigDecoded
        let selfManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedKafkaEventSourceConfig.self, forKey: .selfManagedKafkaEventSourceConfig)
        selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfigDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

enum GetEventSourceMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

public struct GetFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigInputBody: Swift.Equatable {
}

extension GetFunctionCodeSigningConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionCodeSigningConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct GetFunctionCodeSigningConfigOutput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigOutputBody: Swift.Equatable {
    let codeSigningConfigArn: Swift.String?
    let functionName: Swift.String?
}

extension GetFunctionCodeSigningConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

enum GetFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

public struct GetFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionConcurrencyInputBody: Swift.Equatable {
}

extension GetFunctionConcurrencyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionConcurrencyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionConcurrencyOutputBody = try responseDecoder.decode(responseBody: data)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct GetFunctionConcurrencyOutput: Swift.Equatable {
    /// The number of simultaneous executions that are reserved for the function.
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct GetFunctionConcurrencyOutputBody: Swift.Equatable {
    let reservedConcurrentExecutions: Swift.Int?
}

extension GetFunctionConcurrencyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

enum GetFunctionConcurrencyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

public struct GetFunctionConfigurationInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionConfigurationInputBody: Swift.Equatable {
}

extension GetFunctionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.ephemeralStorage = output.ephemeralStorage
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.runtimeVersionConfig = output.runtimeVersionConfig
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.snapStart = output.snapStart
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.ephemeralStorage = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kmsKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.runtimeVersionConfig = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.snapStart = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct GetFunctionConfigurationOutput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct GetFunctionConfigurationOutputBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStartResponse?
    let runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
}

extension GetFunctionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kmsKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case runtimeVersionConfig = "RuntimeVersionConfig"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case snapStart = "SnapStart"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartResponse.self, forKey: .snapStart)
        snapStart = snapStartDecoded
        let runtimeVersionConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionConfig.self, forKey: .runtimeVersionConfig)
        runtimeVersionConfig = runtimeVersionConfigDecoded
    }
}

enum GetFunctionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct GetFunctionEventInvokeConfigInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionEventInvokeConfigInputBody: Swift.Equatable {
}

extension GetFunctionEventInvokeConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionEventInvokeConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionEventInvokeConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct GetFunctionEventInvokeConfigOutput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct GetFunctionEventInvokeConfigOutputBody: Swift.Equatable {
    let lastModified: ClientRuntime.Date?
    let functionArn: Swift.String?
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension GetFunctionEventInvokeConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

enum GetFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.concurrency = output.concurrency
            self.configuration = output.configuration
            self.tags = output.tags
        } else {
            self.code = nil
            self.concurrency = nil
            self.configuration = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionOutput: Swift.Equatable {
    /// The deployment package of the function or version.
    public var code: LambdaClientTypes.FunctionCodeLocation?
    /// The function's [reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html).
    public var concurrency: LambdaClientTypes.Concurrency?
    /// The configuration of the function or version.
    public var configuration: LambdaClientTypes.FunctionConfiguration?
    /// The function's [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init(
        code: LambdaClientTypes.FunctionCodeLocation? = nil,
        concurrency: LambdaClientTypes.Concurrency? = nil,
        configuration: LambdaClientTypes.FunctionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.code = code
        self.concurrency = concurrency
        self.configuration = configuration
        self.tags = tags
    }
}

struct GetFunctionOutputBody: Swift.Equatable {
    let configuration: LambdaClientTypes.FunctionConfiguration?
    let code: LambdaClientTypes.FunctionCodeLocation?
    let tags: [Swift.String:Swift.String]?
    let concurrency: LambdaClientTypes.Concurrency?
}

extension GetFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case concurrency = "Concurrency"
        case configuration = "Configuration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let codeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionCodeLocation.self, forKey: .code)
        code = codeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let concurrencyDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Concurrency.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
    }
}

enum GetFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionUrlConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionUrlConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

public struct GetFunctionUrlConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionUrlConfigInputBody: Swift.Equatable {
}

extension GetFunctionUrlConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionUrlConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionUrlConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.cors = output.cors
            self.creationTime = output.creationTime
            self.functionArn = output.functionArn
            self.functionUrl = output.functionUrl
            self.invokeMode = output.invokeMode
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.authType = nil
            self.cors = nil
            self.creationTime = nil
            self.functionArn = nil
            self.functionUrl = nil
            self.invokeMode = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct GetFunctionUrlConfigOutput: Swift.Equatable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var lastModifiedTime: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        lastModifiedTime: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
        self.lastModifiedTime = lastModifiedTime
    }
}

struct GetFunctionUrlConfigOutputBody: Swift.Equatable {
    let functionUrl: Swift.String?
    let functionArn: Swift.String?
    let authType: LambdaClientTypes.FunctionUrlAuthType?
    let cors: LambdaClientTypes.Cors?
    let creationTime: Swift.String?
    let lastModifiedTime: Swift.String?
    let invokeMode: LambdaClientTypes.InvokeMode?
}

extension GetFunctionUrlConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case creationTime = "CreationTime"
        case functionArn = "FunctionArn"
        case functionUrl = "FunctionUrl"
        case invokeMode = "InvokeMode"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionUrl)
        functionUrl = functionUrlDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let corsDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Cors.self, forKey: .cors)
        cors = corsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let invokeModeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.InvokeMode.self, forKey: .invokeMode)
        invokeMode = invokeModeDecoded
    }
}

enum GetFunctionUrlConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLayerVersionByArnInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "find", value: "LayerVersion"))
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension GetLayerVersionByArnInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2018-10-31/layers"
    }
}

public struct GetLayerVersionByArnInput: Swift.Equatable {
    /// The ARN of the layer version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetLayerVersionByArnInputBody: Swift.Equatable {
}

extension GetLayerVersionByArnInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionByArnOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLayerVersionByArnOutputBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionByArnOutput: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionByArnOutputBody: Swift.Equatable {
    let content: LambdaClientTypes.LayerVersionContentOutput?
    let layerArn: Swift.String?
    let layerVersionArn: Swift.String?
    let description: Swift.String?
    let createdDate: Swift.String?
    let version: Swift.Int
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension GetLayerVersionByArnOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for enum0 in compatibleRuntimesContainer {
                if let enum0 = enum0 {
                    compatibleRuntimesDecoded0?.append(enum0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in compatibleArchitecturesContainer {
                if let enum0 = enum0 {
                    compatibleArchitecturesDecoded0?.append(enum0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

enum GetLayerVersionByArnOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLayerVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

public struct GetLayerVersionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionInputBody: Swift.Equatable {
}

extension GetLayerVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLayerVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionOutput: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionOutputBody: Swift.Equatable {
    let content: LambdaClientTypes.LayerVersionContentOutput?
    let layerArn: Swift.String?
    let layerVersionArn: Swift.String?
    let description: Swift.String?
    let createdDate: Swift.String?
    let version: Swift.Int
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension GetLayerVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for enum0 in compatibleRuntimesContainer {
                if let enum0 = enum0 {
                    compatibleRuntimesDecoded0?.append(enum0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in compatibleArchitecturesContainer {
                if let enum0 = enum0 {
                    compatibleArchitecturesDecoded0?.append(enum0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

enum GetLayerVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLayerVersionPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
    }
}

public struct GetLayerVersionPolicyInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionPolicyInputBody: Swift.Equatable {
}

extension GetLayerVersionPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLayerVersionPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetLayerVersionPolicyOutput: Swift.Equatable {
    /// The policy document.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetLayerVersionPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetLayerVersionPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum GetLayerVersionPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get the policy for that resource.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetPolicyInputBody: Swift.Equatable {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetPolicyOutput: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum GetPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProvisionedConcurrencyConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let qualifier = qualifier else {
                let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
            return items
        }
    }
}

extension GetProvisionedConcurrencyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct GetProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetProvisionedConcurrencyConfigInputBody: Swift.Equatable {
}

extension GetProvisionedConcurrencyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProvisionedConcurrencyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProvisionedConcurrencyConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetProvisionedConcurrencyConfigOutput: Swift.Equatable {
    /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init(
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetProvisionedConcurrencyConfigOutputBody: Swift.Equatable {
    let requestedProvisionedConcurrentExecutions: Swift.Int?
    let availableProvisionedConcurrentExecutions: Swift.Int?
    let allocatedProvisionedConcurrentExecutions: Swift.Int?
    let status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    let statusReason: Swift.String?
    let lastModified: Swift.String?
}

extension GetProvisionedConcurrencyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

enum GetProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProvisionedConcurrencyConfigNotFoundException": return try await ProvisionedConcurrencyConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRuntimeManagementConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension GetRuntimeManagementConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-07-20/functions/\(functionName.urlPercentEncoding())/runtime-management-config"
    }
}

public struct GetRuntimeManagementConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the $LATEST version is returned.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetRuntimeManagementConfigInputBody: Swift.Equatable {
}

extension GetRuntimeManagementConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRuntimeManagementConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRuntimeManagementConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionArn = output.functionArn
            self.runtimeVersionArn = output.runtimeVersionArn
            self.updateRuntimeOn = output.updateRuntimeOn
        } else {
            self.functionArn = nil
            self.runtimeVersionArn = nil
            self.updateRuntimeOn = nil
        }
    }
}

public struct GetRuntimeManagementConfigOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of your function.
    public var functionArn: Swift.String?
    /// The ARN of the runtime the function is configured to use. If the runtime update mode is Manual, the ARN is returned, otherwise null is returned.
    public var runtimeVersionArn: Swift.String?
    /// The current runtime update mode of the function.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionArn: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    )
    {
        self.functionArn = functionArn
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

struct GetRuntimeManagementConfigOutputBody: Swift.Equatable {
    let updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?
    let runtimeVersionArn: Swift.String?
    let functionArn: Swift.String?
}

extension GetRuntimeManagementConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case runtimeVersionArn = "RuntimeVersionArn"
        case updateRuntimeOn = "UpdateRuntimeOn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRuntimeOnDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.UpdateRuntimeOn.self, forKey: .updateRuntimeOn)
        updateRuntimeOn = updateRuntimeOnDecoded
        let runtimeVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersionArn)
        runtimeVersionArn = runtimeVersionArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

enum GetRuntimeManagementConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes.ImageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
        case entryPoint = "EntryPoint"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for string0 in command {
                try commandContainer.encode(string0)
            }
        }
        if let entryPoint = entryPoint {
            var entryPointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPoint)
            for string0 in entryPoint {
                try entryPointContainer.encode(string0)
            }
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPoint)
        var entryPointDecoded0:[Swift.String]? = nil
        if let entryPointContainer = entryPointContainer {
            entryPointDecoded0 = [Swift.String]()
            for string0 in entryPointContainer {
                if let string0 = string0 {
                    entryPointDecoded0?.append(string0)
                }
            }
        }
        entryPoint = entryPointDecoded0
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
    }
}

extension LambdaClientTypes {
    /// Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
    public struct ImageConfig: Swift.Equatable {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public var command: [Swift.String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime executable.
        public var entryPoint: [Swift.String]?
        /// Specifies the working directory.
        public var workingDirectory: Swift.String?

        public init(
            command: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }
    }

}

extension LambdaClientTypes.ImageConfigError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.ImageConfigError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfigError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// Error response to GetFunctionConfiguration.
    public struct ImageConfigError: Swift.Equatable {
        /// Error code.
        public var errorCode: Swift.String?
        /// Error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.ImageConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case imageConfig = "ImageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let imageConfig = self.imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes {
    /// Response to a GetFunctionConfiguration request.
    public struct ImageConfigResponse: Swift.Equatable {
        /// Error response to GetFunctionConfiguration.
        public var error: LambdaClientTypes.ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public var imageConfig: LambdaClientTypes.ImageConfig?

        public init(
            error: LambdaClientTypes.ImageConfigError? = nil,
            imageConfig: LambdaClientTypes.ImageConfig? = nil
        )
        {
            self.error = error
            self.imageConfig = imageConfig
        }
    }

}

extension InvalidCodeSignatureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCodeSignatureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The code signature failed the integrity check. If the integrity check fails, then Lambda blocks deployment, even if the code signing policy is set to WARN.
public struct InvalidCodeSignatureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCodeSignatureException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidCodeSignatureExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidCodeSignatureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the parameters in the request is not valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestContentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request body could not be parsed as JSON.
public struct InvalidRequestContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestContentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidRequestContentExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidRequestContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuntimeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRuntimeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The runtime or runtime version specified is not supported.
public struct InvalidRuntimeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuntimeException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidRuntimeExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidRuntimeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupIDException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSecurityGroupIDExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The security group ID provided in the Lambda function VPC configuration is not valid.
public struct InvalidSecurityGroupIDException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurityGroupIDException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidSecurityGroupIDExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidSecurityGroupIDExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetIDException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSubnetIDExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The subnet ID provided in the Lambda function VPC configuration is not valid.
public struct InvalidSubnetIDException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnetIDException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidSubnetIDExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidSubnetIDExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidZipFileException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidZipFileExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda could not unzip the deployment package.
public struct InvalidZipFileException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidZipFileException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InvalidZipFileExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension InvalidZipFileExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dryrun
        case event
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .dryrun,
                .event,
                .requestresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .event: return "Event"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

public struct InvokeAsyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeAsyncInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InvokeAsyncOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let invokeArgs = input.operationInput.invokeArgs {
            let invokeArgsBody = ClientRuntime.HttpBody(byteStream: invokeArgs)
            input.builder.withBody(invokeArgsBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension InvokeAsyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokeArgs = self.invokeArgs {
            try encodeContainer.encode(invokeArgs, forKey: .invokeArgs)
        }
    }
}

extension InvokeAsyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2014-11-13/functions/\(functionName.urlPercentEncoding())/invoke-async"
    }
}

@available(*, deprecated)
public struct InvokeAsyncInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The JSON that you want to provide to your Lambda function as input.
    /// This member is required.
    public var invokeArgs: ClientRuntime.ByteStream?

    public init(
        functionName: Swift.String? = nil,
        invokeArgs: ClientRuntime.ByteStream? = nil
    )
    {
        self.functionName = functionName
        self.invokeArgs = invokeArgs
    }
}

struct InvokeAsyncInputBody: Swift.Equatable {
    let invokeArgs: ClientRuntime.ByteStream?
}

extension InvokeAsyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invokeArgsDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .invokeArgs)
        invokeArgs = invokeArgsDecoded
    }
}

extension InvokeAsyncOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        self.status = httpResponse.statusCode.rawValue
    }
}

/// A success response (202 Accepted) indicates that the request is queued for invocation.
@available(*, deprecated)
public struct InvokeAsyncOutput: Swift.Equatable {
    /// The status code.
    public var status: Swift.Int

    public init(
        status: Swift.Int = 0
    )
    {
        self.status = status
    }
}

struct InvokeAsyncOutputBody: Swift.Equatable {
    let status: Swift.Int
}

extension InvokeAsyncOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

enum InvokeAsyncOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestContentException": return try await InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuntimeException": return try await InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct InvokeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InvokeOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let payload = input.operationInput.payload {
            let payloadData = payload
            let payloadBody = ClientRuntime.HttpBody.data(payloadData)
            input.builder.withBody(payloadBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension InvokeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeInput(clientContext: \(Swift.String(describing: clientContext)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), qualifier: \(Swift.String(describing: qualifier)), payload: \"CONTENT_REDACTED\")"}
}

extension InvokeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

extension InvokeInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientContext = clientContext {
            items.add(Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let invocationType = invocationType {
            items.add(Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = logType {
            items.add(Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        return items
    }
}

extension InvokeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension InvokeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/invocations"
    }
}

public struct InvokeInput: Swift.Equatable {
    /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
    public var clientContext: Swift.String?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Choose from the following options.
    ///
    /// * RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API response includes the function response and additional data.
    ///
    /// * Event – Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if one is configured). The API response only includes a status code.
    ///
    /// * DryRun – Validate parameter values and verify that the user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.InvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: ClientRuntime.Data?
    /// Specify a version or alias to invoke a published version of the function.
    public var qualifier: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.InvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: ClientRuntime.Data? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

struct InvokeInputBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension InvokeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension LambdaClientTypes {
    public enum InvokeMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case buffered
        case responseStream
        case sdkUnknown(Swift.String)

        public static var allCases: [InvokeMode] {
            return [
                .buffered,
                .responseStream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .buffered: return "BUFFERED"
            case .responseStream: return "RESPONSE_STREAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvokeMode(rawValue: rawValue) ?? InvokeMode.sdkUnknown(rawValue)
        }
    }
}

extension InvokeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeOutput(executedVersion: \(Swift.String(describing: executedVersion)), functionError: \(Swift.String(describing: functionError)), logResult: \(Swift.String(describing: logResult)), statusCode: \(Swift.String(describing: statusCode)), payload: \"CONTENT_REDACTED\")"}
}

extension InvokeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            self.executedVersion = executedVersionHeaderValue
        } else {
            self.executedVersion = nil
        }
        if let functionErrorHeaderValue = httpResponse.headers.value(for: "X-Amz-Function-Error") {
            self.functionError = functionErrorHeaderValue
        } else {
            self.functionError = nil
        }
        if let logResultHeaderValue = httpResponse.headers.value(for: "X-Amz-Log-Result") {
            self.logResult = logResultHeaderValue
        } else {
            self.logResult = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.payload = data
        case .stream(let stream):
            self.payload = try stream.readToEnd()
        case .none:
            self.payload = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct InvokeOutput: Swift.Equatable {
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// If present, indicates that an error occurred during function execution. Details about the error are included in the response payload.
    public var functionError: Swift.String?
    /// The last 4 KB of the execution log, which is base64-encoded.
    public var logResult: Swift.String?
    /// The response from the function, or an error object.
    public var payload: ClientRuntime.Data?
    /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse invocation type, this status code is 200. For the Event invocation type, this status code is 202. For the DryRun invocation type, the status code is 204.
    public var statusCode: Swift.Int

    public init(
        executedVersion: Swift.String? = nil,
        functionError: Swift.String? = nil,
        logResult: Swift.String? = nil,
        payload: ClientRuntime.Data? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.executedVersion = executedVersion
        self.functionError = functionError
        self.logResult = logResult
        self.payload = payload
        self.statusCode = statusCode
    }
}

struct InvokeOutputBody: Swift.Equatable {
    let statusCode: Swift.Int
    let payload: ClientRuntime.Data?
}

extension InvokeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
        case statusCode = "StatusCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum InvokeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EC2AccessDeniedException": return try await EC2AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EC2ThrottledException": return try await EC2ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EC2UnexpectedException": return try await EC2UnexpectedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSIOException": return try await EFSIOException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSMountConnectivityException": return try await EFSMountConnectivityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSMountFailureException": return try await EFSMountFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSMountTimeoutException": return try await EFSMountTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ENILimitReachedException": return try await ENILimitReachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestContentException": return try await InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuntimeException": return try await InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSecurityGroupIDException": return try await InvalidSecurityGroupIDException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnetIDException": return try await InvalidSubnetIDException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidZipFileException": return try await InvalidZipFileException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSAccessDeniedException": return try await KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSDisabledException": return try await KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidStateException": return try await KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSNotFoundException": return try await KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RecursiveInvocationException": return try await RecursiveInvocationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTooLargeException": return try await RequestTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapStartException": return try await SnapStartException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapStartNotReadyException": return try await SnapStartNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapStartTimeoutException": return try await SnapStartTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetIPAddressLimitReachedException": return try await SubnetIPAddressLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedMediaTypeException": return try await UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes.InvokeResponseStreamUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension LambdaClientTypes.InvokeResponseStreamUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeResponseStreamUpdate(payload: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// A chunk of the streamed response payload.
    public struct InvokeResponseStreamUpdate: Swift.Equatable {
        /// Data returned by your Lambda function.
        public var payload: ClientRuntime.Data?

        public init(
            payload: ClientRuntime.Data? = nil
        )
        {
            self.payload = payload
        }
    }

}

extension LambdaClientTypes.InvokeWithResponseStreamCompleteEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorDetails = "ErrorDetails"
        case logResult = "LogResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let logResult = self.logResult {
            try encodeContainer.encode(logResult, forKey: .logResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let logResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logResult)
        logResult = logResultDecoded
    }
}

extension LambdaClientTypes {
    /// A response confirming that the event stream is complete.
    public struct InvokeWithResponseStreamCompleteEvent: Swift.Equatable {
        /// An error code.
        public var errorCode: Swift.String?
        /// The details of any returned error.
        public var errorDetails: Swift.String?
        /// The last 4 KB of the execution log, which is base64-encoded.
        public var logResult: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorDetails: Swift.String? = nil,
            logResult: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDetails = errorDetails
            self.logResult = logResult
        }
    }

}

public struct InvokeWithResponseStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeWithResponseStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeWithResponseStreamInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<InvokeWithResponseStreamOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let payload = input.operationInput.payload {
            let payloadData = payload
            let payloadBody = ClientRuntime.HttpBody.data(payloadData)
            input.builder.withBody(payloadBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeWithResponseStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeWithResponseStreamOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension InvokeWithResponseStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeWithResponseStreamInput(clientContext: \(Swift.String(describing: clientContext)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), qualifier: \(Swift.String(describing: qualifier)), payload: \"CONTENT_REDACTED\")"}
}

extension InvokeWithResponseStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

extension InvokeWithResponseStreamInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientContext = clientContext {
            items.add(Header(name: "X-Amz-Client-Context", value: Swift.String(clientContext)))
        }
        if let invocationType = invocationType {
            items.add(Header(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue)))
        }
        if let logType = logType {
            items.add(Header(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue)))
        }
        return items
    }
}

extension InvokeWithResponseStreamInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension InvokeWithResponseStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-11-15/functions/\(functionName.urlPercentEncoding())/response-streaming-invocations"
    }
}

public struct InvokeWithResponseStreamInput: Swift.Equatable {
    /// Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the context object.
    public var clientContext: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * RequestResponse (default) – Invoke the function synchronously. Keep the connection open until the function returns a response or times out. The API operation response includes the function response and additional data.
    ///
    /// * DryRun – Validate parameter values and verify that the IAM user or role has permission to invoke the function.
    public var invocationType: LambdaClientTypes.ResponseStreamingInvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input. You can enter the JSON directly. For example, --payload '{ "key": "value" }'. You can also specify a file path. For example, --payload file://payload.json.
    public var payload: ClientRuntime.Data?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.ResponseStreamingInvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: ClientRuntime.Data? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

struct InvokeWithResponseStreamInputBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension InvokeWithResponseStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InvokeWithResponseStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            self.executedVersion = executedVersionHeaderValue
        } else {
            self.executedVersion = nil
        }
        if let responseStreamContentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.responseStreamContentType = responseStreamContentTypeHeaderValue
        } else {
            self.responseStreamContentType = nil
        }
        if case let .stream(stream) = httpResponse.body, let responseDecoder = decoder {
            let messageDecoder = AWSClientRuntime.AWSEventStream.AWSMessageDecoder()
            let decoderStream = ClientRuntime.EventStream.DefaultMessageDecoderStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent>(stream: stream, messageDecoder: messageDecoder, responseDecoder: responseDecoder)
            self.eventStream = decoderStream.toAsyncStream()
        } else {
            self.eventStream = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct InvokeWithResponseStreamOutput: Swift.Equatable {
    /// The stream of response payloads.
    public var eventStream: AsyncThrowingStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent, Swift.Error>?
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which version the alias resolved to.
    public var executedVersion: Swift.String?
    /// The type of data the stream is returning.
    public var responseStreamContentType: Swift.String?
    /// For a successful request, the HTTP status code is in the 200 range. For the RequestResponse invocation type, this status code is 200. For the DryRun invocation type, this status code is 204.
    public var statusCode: Swift.Int

    public init(
        eventStream: AsyncThrowingStream<LambdaClientTypes.InvokeWithResponseStreamResponseEvent, Swift.Error>? = nil,
        executedVersion: Swift.String? = nil,
        responseStreamContentType: Swift.String? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.eventStream = eventStream
        self.executedVersion = executedVersion
        self.responseStreamContentType = responseStreamContentType
        self.statusCode = statusCode
    }
}

enum InvokeWithResponseStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EC2AccessDeniedException": return try await EC2AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EC2ThrottledException": return try await EC2ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EC2UnexpectedException": return try await EC2UnexpectedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSIOException": return try await EFSIOException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSMountConnectivityException": return try await EFSMountConnectivityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSMountFailureException": return try await EFSMountFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EFSMountTimeoutException": return try await EFSMountTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ENILimitReachedException": return try await ENILimitReachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestContentException": return try await InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuntimeException": return try await InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSecurityGroupIDException": return try await InvalidSecurityGroupIDException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnetIDException": return try await InvalidSubnetIDException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidZipFileException": return try await InvalidZipFileException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSAccessDeniedException": return try await KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSDisabledException": return try await KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidStateException": return try await KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSNotFoundException": return try await KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RecursiveInvocationException": return try await RecursiveInvocationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTooLargeException": return try await RequestTooLargeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapStartException": return try await SnapStartException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapStartNotReadyException": return try await SnapStartNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapStartTimeoutException": return try await SnapStartTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetIPAddressLimitReachedException": return try await SubnetIPAddressLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedMediaTypeException": return try await UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes.InvokeWithResponseStreamResponseEvent: ClientRuntime.MessageUnmarshallable {
    public init(message: ClientRuntime.EventStream.Message, decoder: ClientRuntime.ResponseDecoder) throws {
        switch try message.type() {
        case .event(let params):
            switch params.eventType {
            case "PayloadChunk":
                var event = LambdaClientTypes.InvokeResponseStreamUpdate()
                event.payload = message.payload
                self = .payloadchunk(event)
            case "InvokeComplete":
                self = .invokecomplete(try decoder.decode(responseBody: message.payload))
            default:
                self = .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
            }
        case .exception(let params):
            let makeError: (ClientRuntime.EventStream.Message, ClientRuntime.EventStream.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                switch params.exceptionType {
                default:
                    let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                    return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                }
            }
            let error = try makeError(message, params)
            throw error
        case .error(let params):
            let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
            throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
        case .unknown(messageType: let messageType):
            throw ClientRuntime.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
        }
    }
}

extension LambdaClientTypes {
    /// An object that includes a chunk of the response payload. When the stream has ended, Lambda includes a InvokeComplete object.
    public enum InvokeWithResponseStreamResponseEvent: Swift.Equatable {
        /// A chunk of the streamed response payload.
        case payloadchunk(LambdaClientTypes.InvokeResponseStreamUpdate)
        /// An object that's returned when the stream has ended and all the payload chunks have been returned.
        case invokecomplete(LambdaClientTypes.InvokeWithResponseStreamCompleteEvent)
        case sdkUnknown(Swift.String)
    }

}

extension KMSAccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.
public struct KMSAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDeniedException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct KMSAccessDeniedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.
public struct KMSDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabledException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct KMSDisabledExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't decrypt the environment variables because the state of the KMS key used is not valid for Decrypt. Check the function's KMS key settings.
public struct KMSInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidStateException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct KMSInvalidStateExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSInvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.
public struct KMSNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFoundException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct KMSNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension KMSNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum LastUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatus] {
            return [
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastUpdateStatus(rawValue: rawValue) ?? LastUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum LastUpdateStatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabledkmskey
        case efsioerror
        case efsmountconnectivityerror
        case efsmountfailure
        case efsmounttimeout
        case enilimitexceeded
        case functionerror
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidruntime
        case invalidsecuritygroup
        case invalidstatekmskey
        case invalidsubnet
        case invalidzipfileexception
        case kmskeyaccessdenied
        case kmskeynotfound
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatusReasonCode] {
            return [
                .disabledkmskey,
                .efsioerror,
                .efsmountconnectivityerror,
                .efsmountfailure,
                .efsmounttimeout,
                .enilimitexceeded,
                .functionerror,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidruntime,
                .invalidsecuritygroup,
                .invalidstatekmskey,
                .invalidsubnet,
                .invalidzipfileexception,
                .kmskeyaccessdenied,
                .kmskeynotfound,
                .subnetoutofipaddresses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabledkmskey: return "DisabledKMSKey"
            case .efsioerror: return "EFSIOError"
            case .efsmountconnectivityerror: return "EFSMountConnectivityError"
            case .efsmountfailure: return "EFSMountFailure"
            case .efsmounttimeout: return "EFSMountTimeout"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .functionerror: return "FunctionError"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidruntime: return "InvalidRuntime"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidstatekmskey: return "InvalidStateKMSKey"
            case .invalidsubnet: return "InvalidSubnet"
            case .invalidzipfileexception: return "InvalidZipFileException"
            case .kmskeyaccessdenied: return "KMSKeyAccessDenied"
            case .kmskeynotfound: return "KMSKeyNotFound"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastUpdateStatusReasonCode(rawValue: rawValue) ?? LastUpdateStatusReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.Layer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case codeSize = "CodeSize"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let signingJobArn = self.signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = self.signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LambdaClientTypes {
    /// An [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct Layer: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }

}

extension LambdaClientTypes.LayerVersionContentInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = self.s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = self.zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
    }
}

extension LambdaClientTypes.LayerVersionContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerVersionContentInput(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// A ZIP archive that contains the contents of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html). You can specify either an Amazon S3 location, or upload a layer archive directly.
    public struct LayerVersionContentInput: Swift.Equatable {
        /// The Amazon S3 bucket of the layer archive.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the layer archive.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the layer archive object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: ClientRuntime.Data?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension LambdaClientTypes.LayerVersionContentOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case location = "Location"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = self.codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let signingJobArn = self.signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = self.signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LambdaClientTypes {
    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionContentOutput: Swift.Equatable {
        /// The SHA-256 hash of the layer archive.
        public var codeSha256: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public var location: Swift.String?
        /// The Amazon Resource Name (ARN) of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init(
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            location: Swift.String? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }

}

extension LambdaClientTypes.LayerVersionsListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleArchitectures = compatibleArchitectures {
            var compatibleArchitecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleArchitectures)
            for architecture0 in compatibleArchitectures {
                try compatibleArchitecturesContainer.encode(architecture0.rawValue)
            }
        }
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for runtime0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(runtime0.rawValue)
            }
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layerVersionArn = self.layerVersionArn {
            try encodeContainer.encode(layerVersionArn, forKey: .layerVersionArn)
        }
        if let licenseInfo = self.licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for enum0 in compatibleRuntimesContainer {
                if let enum0 = enum0 {
                    compatibleRuntimesDecoded0?.append(enum0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in compatibleArchitecturesContainer {
                if let enum0 = enum0 {
                    compatibleArchitecturesDecoded0?.append(enum0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension LambdaClientTypes {
    /// Details about a version of an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayerVersionsListItem: Swift.Equatable {
        /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
        public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
        /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
        public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public var createdDate: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// The ARN of the layer version.
        public var layerVersionArn: Swift.String?
        /// The layer's open-source license.
        public var licenseInfo: Swift.String?
        /// The version number.
        public var version: Swift.Int

        public init(
            compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
            compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            layerVersionArn: Swift.String? = nil,
            licenseInfo: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }
    }

}

extension LambdaClientTypes.LayersListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestMatchingVersion = "LatestMatchingVersion"
        case layerArn = "LayerArn"
        case layerName = "LayerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestMatchingVersion = self.latestMatchingVersion {
            try encodeContainer.encode(latestMatchingVersion, forKey: .latestMatchingVersion)
        }
        if let layerArn = self.layerArn {
            try encodeContainer.encode(layerArn, forKey: .layerArn)
        }
        if let layerName = self.layerName {
            try encodeContainer.encode(layerName, forKey: .layerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerName)
        layerName = layerNameDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let latestMatchingVersionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionsListItem.self, forKey: .latestMatchingVersion)
        latestMatchingVersion = latestMatchingVersionDecoded
    }
}

extension LambdaClientTypes {
    /// Details about an [Lambda layer](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public struct LayersListItem: Swift.Equatable {
        /// The newest version of the layer.
        public var latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public var layerArn: Swift.String?
        /// The name of the layer.
        public var layerName: Swift.String?

        public init(
            latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem? = nil,
            layerArn: Swift.String? = nil,
            layerName: Swift.String? = nil
        )
        {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }
    }

}

extension ListAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let functionVersion = functionVersion {
                let functionVersionQueryItem = ClientRuntime.URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion).urlPercentEncoding())
                items.append(functionVersionQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
    }
}

public struct ListAliasesInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a function version to only list aliases that invoke that version.
    public var functionVersion: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Limit the number of aliases returned.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListAliasesInputBody: Swift.Equatable {
}

extension ListAliasesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextMarker = output.nextMarker
        } else {
            self.aliases = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAliasesOutput: Swift.Equatable {
    /// A list of aliases.
    public var aliases: [LambdaClientTypes.AliasConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        aliases: [LambdaClientTypes.AliasConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextMarker = nextMarker
    }
}

struct ListAliasesOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let aliases: [LambdaClientTypes.AliasConfiguration]?
}

extension ListAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.AliasConfiguration?].self, forKey: .aliases)
        var aliasesDecoded0:[LambdaClientTypes.AliasConfiguration]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [LambdaClientTypes.AliasConfiguration]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

enum ListAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCodeSigningConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListCodeSigningConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-04-22/code-signing-configs"
    }
}

public struct ListCodeSigningConfigsInput: Swift.Equatable {
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCodeSigningConfigsInputBody: Swift.Equatable {
}

extension ListCodeSigningConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCodeSigningConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCodeSigningConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigs = output.codeSigningConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.codeSigningConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListCodeSigningConfigsOutput: Swift.Equatable {
    /// The code signing configurations
    public var codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.codeSigningConfigs = codeSigningConfigs
        self.nextMarker = nextMarker
    }
}

struct ListCodeSigningConfigsOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
}

extension ListCodeSigningConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigs = "CodeSigningConfigs"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let codeSigningConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.CodeSigningConfig?].self, forKey: .codeSigningConfigs)
        var codeSigningConfigsDecoded0:[LambdaClientTypes.CodeSigningConfig]? = nil
        if let codeSigningConfigsContainer = codeSigningConfigsContainer {
            codeSigningConfigsDecoded0 = [LambdaClientTypes.CodeSigningConfig]()
            for structure0 in codeSigningConfigsContainer {
                if let structure0 = structure0 {
                    codeSigningConfigsDecoded0?.append(structure0)
                }
            }
        }
        codeSigningConfigs = codeSigningConfigsDecoded0
    }
}

enum ListCodeSigningConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventSourceMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let functionName = functionName {
                let functionNameQueryItem = ClientRuntime.URLQueryItem(name: "FunctionName".urlPercentEncoding(), value: Swift.String(functionName).urlPercentEncoding())
                items.append(functionNameQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let eventSourceArn = eventSourceArn {
                let eventSourceArnQueryItem = ClientRuntime.URLQueryItem(name: "EventSourceArn".urlPercentEncoding(), value: Swift.String(eventSourceArn).urlPercentEncoding())
                items.append(eventSourceArnQueryItem)
            }
            return items
        }
    }
}

extension ListEventSourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/event-source-mappings"
    }
}

public struct ListEventSourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    /// * Amazon Kinesis – The ARN of the data stream or a stream consumer.
    ///
    /// * Amazon DynamoDB Streams – The ARN of the stream.
    ///
    /// * Amazon Simple Queue Service – The ARN of the queue.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – The ARN of the cluster.
    ///
    /// * Amazon MQ – The ARN of the broker.
    ///
    /// * Amazon DocumentDB – The ARN of the DocumentDB change stream.
    public var eventSourceArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of event source mappings to return. Note that ListEventSourceMappings returns a maximum of 100 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        eventSourceArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListEventSourceMappingsInputBody: Swift.Equatable {
}

extension ListEventSourceMappingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEventSourceMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventSourceMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventSourceMappings = output.eventSourceMappings
            self.nextMarker = output.nextMarker
        } else {
            self.eventSourceMappings = nil
            self.nextMarker = nil
        }
    }
}

public struct ListEventSourceMappingsOutput: Swift.Equatable {
    /// A list of event source mappings.
    public var eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
    /// A pagination token that's returned when the response doesn't contain all event source mappings.
    public var nextMarker: Swift.String?

    public init(
        eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.eventSourceMappings = eventSourceMappings
        self.nextMarker = nextMarker
    }
}

struct ListEventSourceMappingsOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
}

extension ListEventSourceMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceMappings = "EventSourceMappings"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let eventSourceMappingsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.EventSourceMappingConfiguration?].self, forKey: .eventSourceMappings)
        var eventSourceMappingsDecoded0:[LambdaClientTypes.EventSourceMappingConfiguration]? = nil
        if let eventSourceMappingsContainer = eventSourceMappingsContainer {
            eventSourceMappingsDecoded0 = [LambdaClientTypes.EventSourceMappingConfiguration]()
            for structure0 in eventSourceMappingsContainer {
                if let structure0 = structure0 {
                    eventSourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        eventSourceMappings = eventSourceMappingsDecoded0
    }
}

enum ListEventSourceMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config/list"
    }
}

public struct ListFunctionEventInvokeConfigsInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - my-function.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of configurations to return.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionEventInvokeConfigsInputBody: Swift.Equatable {
}

extension ListFunctionEventInvokeConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionEventInvokeConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionEventInvokeConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionEventInvokeConfigs = output.functionEventInvokeConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.functionEventInvokeConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionEventInvokeConfigsOutput: Swift.Equatable {
    /// A list of configurations.
    public var functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionEventInvokeConfigs = functionEventInvokeConfigs
        self.nextMarker = nextMarker
    }
}

struct ListFunctionEventInvokeConfigsOutputBody: Swift.Equatable {
    let functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    let nextMarker: Swift.String?
}

extension ListFunctionEventInvokeConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionEventInvokeConfigs = "FunctionEventInvokeConfigs"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionEventInvokeConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionEventInvokeConfig?].self, forKey: .functionEventInvokeConfigs)
        var functionEventInvokeConfigsDecoded0:[LambdaClientTypes.FunctionEventInvokeConfig]? = nil
        if let functionEventInvokeConfigsContainer = functionEventInvokeConfigsContainer {
            functionEventInvokeConfigsDecoded0 = [LambdaClientTypes.FunctionEventInvokeConfig]()
            for structure0 in functionEventInvokeConfigsContainer {
                if let structure0 = structure0 {
                    functionEventInvokeConfigsDecoded0?.append(structure0)
                }
            }
        }
        functionEventInvokeConfigs = functionEventInvokeConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListFunctionEventInvokeConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionUrlConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionUrlConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/urls"
    }
}

public struct ListFunctionUrlConfigsInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of function URLs to return in the response. Note that ListFunctionUrlConfigs returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionUrlConfigsInputBody: Swift.Equatable {
}

extension ListFunctionUrlConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionUrlConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionUrlConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionUrlConfigs = output.functionUrlConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.functionUrlConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionUrlConfigsOutput: Swift.Equatable {
    /// A list of function URL configurations.
    /// This member is required.
    public var functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionUrlConfigs = functionUrlConfigs
        self.nextMarker = nextMarker
    }
}

struct ListFunctionUrlConfigsOutputBody: Swift.Equatable {
    let functionUrlConfigs: [LambdaClientTypes.FunctionUrlConfig]?
    let nextMarker: Swift.String?
}

extension ListFunctionUrlConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionUrlConfigs = "FunctionUrlConfigs"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionUrlConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionUrlConfig?].self, forKey: .functionUrlConfigs)
        var functionUrlConfigsDecoded0:[LambdaClientTypes.FunctionUrlConfig]? = nil
        if let functionUrlConfigsContainer = functionUrlConfigsContainer {
            functionUrlConfigsDecoded0 = [LambdaClientTypes.FunctionUrlConfig]()
            for structure0 in functionUrlConfigsContainer {
                if let structure0 = structure0 {
                    functionUrlConfigsDecoded0?.append(structure0)
                }
            }
        }
        functionUrlConfigs = functionUrlConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListFunctionUrlConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionsByCodeSigningConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionsByCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())/functions"
    }
}

public struct ListFunctionsByCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionsByCodeSigningConfigInputBody: Swift.Equatable {
}

extension ListFunctionsByCodeSigningConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsByCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionsByCodeSigningConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionArns = output.functionArns
            self.nextMarker = output.nextMarker
        } else {
            self.functionArns = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionsByCodeSigningConfigOutput: Swift.Equatable {
    /// The function ARNs.
    public var functionArns: [Swift.String]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functionArns: [Swift.String]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionArns = functionArns
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsByCodeSigningConfigOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let functionArns: [Swift.String]?
}

extension ListFunctionsByCodeSigningConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArns = "FunctionArns"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .functionArns)
        var functionArnsDecoded0:[Swift.String]? = nil
        if let functionArnsContainer = functionArnsContainer {
            functionArnsDecoded0 = [Swift.String]()
            for string0 in functionArnsContainer {
                if let string0 = string0 {
                    functionArnsDecoded0?.append(string0)
                }
            }
        }
        functionArns = functionArnsDecoded0
    }
}

enum ListFunctionsByCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let masterRegion = masterRegion {
                let masterRegionQueryItem = ClientRuntime.URLQueryItem(name: "MasterRegion".urlPercentEncoding(), value: Swift.String(masterRegion).urlPercentEncoding())
                items.append(masterRegionQueryItem)
            }
            if let functionVersion = functionVersion {
                let functionVersionQueryItem = ClientRuntime.URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion.rawValue).urlPercentEncoding())
                items.append(functionVersionQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-03-31/functions"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Set to ALL to include entries for all published versions of each function.
    public var functionVersion: LambdaClientTypes.FunctionVersion?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// For Lambda@Edge functions, the Amazon Web Services Region of the master function. For example, us-east-1 filters the list of functions to include only Lambda@Edge functions replicated from a master function in US East (N. Virginia). If specified, you must set FunctionVersion to ALL.
    public var masterRegion: Swift.String?
    /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionVersion: LambdaClientTypes.FunctionVersion? = nil,
        marker: Swift.String? = nil,
        masterRegion: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionVersion = functionVersion
        self.marker = marker
        self.masterRegion = masterRegion
        self.maxItems = maxItems
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.functions = output.functions
            self.nextMarker = output.nextMarker
        } else {
            self.functions = nil
            self.nextMarker = nil
        }
    }
}

/// A list of Lambda functions.
public struct ListFunctionsOutput: Swift.Equatable {
    /// A list of Lambda functions.
    public var functions: [LambdaClientTypes.FunctionConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init(
        functions: [LambdaClientTypes.FunctionConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let functions: [LambdaClientTypes.FunctionConfiguration]?
}

extension ListFunctionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions = "Functions"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[LambdaClientTypes.FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [LambdaClientTypes.FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

enum ListFunctionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLayerVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let compatibleRuntime = compatibleRuntime {
                let compatibleRuntimeQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
                items.append(compatibleRuntimeQueryItem)
            }
            if let compatibleArchitecture = compatibleArchitecture {
                let compatibleArchitectureQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
                items.append(compatibleArchitectureQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListLayerVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

public struct ListLayerVersionsInput: Swift.Equatable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. For example, go1.x. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of versions to return.
    public var maxItems: Swift.Int?

    public init(
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        layerName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.layerName = layerName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayerVersionsInputBody: Swift.Equatable {
}

extension ListLayerVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLayerVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLayerVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.layerVersions = output.layerVersions
            self.nextMarker = output.nextMarker
        } else {
            self.layerVersions = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayerVersionsOutput: Swift.Equatable {
    /// A list of versions.
    public var layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
    /// A pagination token returned when the response doesn't contain all versions.
    public var nextMarker: Swift.String?

    public init(
        layerVersions: [LambdaClientTypes.LayerVersionsListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layerVersions = layerVersions
        self.nextMarker = nextMarker
    }
}

struct ListLayerVersionsOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
}

extension ListLayerVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerVersions = "LayerVersions"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layerVersionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.LayerVersionsListItem?].self, forKey: .layerVersions)
        var layerVersionsDecoded0:[LambdaClientTypes.LayerVersionsListItem]? = nil
        if let layerVersionsContainer = layerVersionsContainer {
            layerVersionsDecoded0 = [LambdaClientTypes.LayerVersionsListItem]()
            for structure0 in layerVersionsContainer {
                if let structure0 = structure0 {
                    layerVersionsDecoded0?.append(structure0)
                }
            }
        }
        layerVersions = layerVersionsDecoded0
    }
}

enum ListLayerVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLayersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let compatibleRuntime = compatibleRuntime {
                let compatibleRuntimeQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
                items.append(compatibleRuntimeQueryItem)
            }
            if let compatibleArchitecture = compatibleArchitecture {
                let compatibleArchitectureQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
                items.append(compatibleArchitectureQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListLayersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2018-10-31/layers"
    }
}

public struct ListLayersInput: Swift.Equatable {
    /// The compatible [instruction set architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. For example, go1.x. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of layers to return.
    public var maxItems: Swift.Int?

    public init(
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayersInputBody: Swift.Equatable {
}

extension ListLayersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLayersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLayersOutputBody = try responseDecoder.decode(responseBody: data)
            self.layers = output.layers
            self.nextMarker = output.nextMarker
        } else {
            self.layers = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayersOutput: Swift.Equatable {
    /// A list of function layers.
    public var layers: [LambdaClientTypes.LayersListItem]?
    /// A pagination token returned when the response doesn't contain all layers.
    public var nextMarker: Swift.String?

    public init(
        layers: [LambdaClientTypes.LayersListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layers = layers
        self.nextMarker = nextMarker
    }
}

struct ListLayersOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let layers: [LambdaClientTypes.LayersListItem]?
}

extension ListLayersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layers = "Layers"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.LayersListItem?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.LayersListItem]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.LayersListItem]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

enum ListLayersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisionedConcurrencyConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "List", value: "ALL"))
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListProvisionedConcurrencyConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct ListProvisionedConcurrencyConfigsInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Specify a number to limit the number of configurations returned.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListProvisionedConcurrencyConfigsInputBody: Swift.Equatable {
}

extension ListProvisionedConcurrencyConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisionedConcurrencyConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisionedConcurrencyConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.provisionedConcurrencyConfigs = output.provisionedConcurrencyConfigs
        } else {
            self.nextMarker = nil
            self.provisionedConcurrencyConfigs = nil
        }
    }
}

public struct ListProvisionedConcurrencyConfigsOutput: Swift.Equatable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of provisioned concurrency configurations.
    public var provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?

    public init(
        nextMarker: Swift.String? = nil,
        provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
    }
}

struct ListProvisionedConcurrencyConfigsOutputBody: Swift.Equatable {
    let provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?
    let nextMarker: Swift.String?
}

extension ListProvisionedConcurrencyConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case provisionedConcurrencyConfigs = "ProvisionedConcurrencyConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrencyConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.ProvisionedConcurrencyConfigListItem?].self, forKey: .provisionedConcurrencyConfigs)
        var provisionedConcurrencyConfigsDecoded0:[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
        if let provisionedConcurrencyConfigsContainer = provisionedConcurrencyConfigsContainer {
            provisionedConcurrencyConfigsDecoded0 = [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]()
            for structure0 in provisionedConcurrencyConfigsContainer {
                if let structure0 = structure0 {
                    provisionedConcurrencyConfigsDecoded0?.append(structure0)
                }
            }
        }
        provisionedConcurrencyConfigs = provisionedConcurrencyConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListProvisionedConcurrencyConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resource = resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN). Note: Lambda does not support adding tags to aliases or versions.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutput: Swift.Equatable {
    /// The function's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVersionsByFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListVersionsByFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

public struct ListVersionsByFunctionInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListVersionsByFunctionInputBody: Swift.Equatable {
}

extension ListVersionsByFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVersionsByFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVersionsByFunctionOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.versions = output.versions
        } else {
            self.nextMarker = nil
            self.versions = nil
        }
    }
}

public struct ListVersionsByFunctionOutput: Swift.Equatable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of Lambda function versions.
    public var versions: [LambdaClientTypes.FunctionConfiguration]?

    public init(
        nextMarker: Swift.String? = nil,
        versions: [LambdaClientTypes.FunctionConfiguration]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.versions = versions
    }
}

struct ListVersionsByFunctionOutputBody: Swift.Equatable {
    let nextMarker: Swift.String?
    let versions: [LambdaClientTypes.FunctionConfiguration]?
}

extension ListVersionsByFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let versionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionConfiguration?].self, forKey: .versions)
        var versionsDecoded0:[LambdaClientTypes.FunctionConfiguration]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [LambdaClientTypes.FunctionConfiguration]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListVersionsByFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes {
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case tail
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .none,
                .tail,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .tail: return "Tail"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.OnFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LambdaClientTypes {
    /// A destination for events that failed processing.
    public struct OnFailure: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension LambdaClientTypes.OnSuccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LambdaClientTypes {
    /// A destination for events that were processed successfully.
    public struct OnSuccess: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension LambdaClientTypes {
    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .image: return "Image"
            case .zip: return "Zip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageType(rawValue: rawValue) ?? PackageType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyLengthExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The permissions policy for the resource is too large. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct PolicyLengthExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyLengthExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct PolicyLengthExceededExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension PolicyLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the GetFunction or the GetAlias API operation to retrieve the latest RevisionId for your resource.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.ProvisionedConcurrencyConfigListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedProvisionedConcurrentExecutions = self.allocatedProvisionedConcurrentExecutions {
            try encodeContainer.encode(allocatedProvisionedConcurrentExecutions, forKey: .allocatedProvisionedConcurrentExecutions)
        }
        if let availableProvisionedConcurrentExecutions = self.availableProvisionedConcurrentExecutions {
            try encodeContainer.encode(availableProvisionedConcurrentExecutions, forKey: .availableProvisionedConcurrentExecutions)
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let requestedProvisionedConcurrentExecutions = self.requestedProvisionedConcurrentExecutions {
            try encodeContainer.encode(requestedProvisionedConcurrentExecutions, forKey: .requestedProvisionedConcurrentExecutions)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes {
    /// Details about the provisioned concurrency configuration for a function alias or version.
    public struct ProvisionedConcurrencyConfigListItem: Swift.Equatable {
        /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
        public var allocatedProvisionedConcurrentExecutions: Swift.Int?
        /// The amount of provisioned concurrency available.
        public var availableProvisionedConcurrentExecutions: Swift.Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public var functionArn: Swift.String?
        /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
        public var lastModified: Swift.String?
        /// The amount of provisioned concurrency requested.
        public var requestedProvisionedConcurrentExecutions: Swift.Int?
        /// The status of the allocation process.
        public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public var statusReason: Swift.String?

        public init(
            allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
            availableProvisionedConcurrentExecutions: Swift.Int? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
            status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ProvisionedConcurrencyConfigNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvisionedConcurrencyConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified configuration does not exist.
public struct ProvisionedConcurrencyConfigNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProvisionedConcurrencyConfigNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ProvisionedConcurrencyConfigNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ProvisionedConcurrencyConfigNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum ProvisionedConcurrencyStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedConcurrencyStatusEnum] {
            return [
                .failed,
                .inProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedConcurrencyStatusEnum(rawValue: rawValue) ?? ProvisionedConcurrencyStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension PublishLayerVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleArchitectures = compatibleArchitectures {
            var compatibleArchitecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleArchitectures)
            for architecture0 in compatibleArchitectures {
                try compatibleArchitecturesContainer.encode(architecture0.rawValue)
            }
        }
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for runtime0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(runtime0.rawValue)
            }
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseInfo = self.licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
    }
}

extension PublishLayerVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
    }
}

public struct PublishLayerVersionInput: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// A list of compatible [function runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Used for filtering with [ListLayers] and [ListLayerVersions]. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// The function layer archive.
    /// This member is required.
    public var content: LambdaClientTypes.LayerVersionContentInput?
    /// The description of the version.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The layer's software license. It can be any of the following:
    ///
    /// * An [SPDX license identifier](https://spdx.org/licenses/). For example, MIT.
    ///
    /// * The URL of a license hosted on the internet. For example, https://opensource.org/licenses/MIT.
    ///
    /// * The full text of the license.
    public var licenseInfo: Swift.String?

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentInput? = nil,
        description: Swift.String? = nil,
        layerName: Swift.String? = nil,
        licenseInfo: Swift.String? = nil
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.description = description
        self.layerName = layerName
        self.licenseInfo = licenseInfo
    }
}

struct PublishLayerVersionInputBody: Swift.Equatable {
    let description: Swift.String?
    let content: LambdaClientTypes.LayerVersionContentInput?
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension PublishLayerVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentInput.self, forKey: .content)
        content = contentDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for enum0 in compatibleRuntimesContainer {
                if let enum0 = enum0 {
                    compatibleRuntimesDecoded0?.append(enum0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in compatibleArchitecturesContainer {
                if let enum0 = enum0 {
                    compatibleArchitecturesDecoded0?.append(enum0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension PublishLayerVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PublishLayerVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct PublishLayerVersionOutput: Swift.Equatable {
    /// A list of compatible [instruction set architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init(
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct PublishLayerVersionOutputBody: Swift.Equatable {
    let content: LambdaClientTypes.LayerVersionContentOutput?
    let layerArn: Swift.String?
    let layerVersionArn: Swift.String?
    let description: Swift.String?
    let createdDate: Swift.String?
    let version: Swift.Int
    let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    let licenseInfo: Swift.String?
    let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension PublishLayerVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for enum0 in compatibleRuntimesContainer {
                if let enum0 = enum0 {
                    compatibleRuntimesDecoded0?.append(enum0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in compatibleArchitecturesContainer {
                if let enum0 = enum0 {
                    compatibleArchitecturesDecoded0?.append(enum0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

enum PublishLayerVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeStorageExceededException": return try await CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PublishVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = self.codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension PublishVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
    }
}

public struct PublishVersionInput: Swift.Equatable {
    /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid publishing a version if the function code has changed since you last updated it. You can get the hash for the version that you uploaded from the output of [UpdateFunctionCode].
    public var codeSha256: Swift.String?
    /// A description for the version to override the description in the function configuration.
    public var description: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid publishing a version if the function configuration has changed since you last updated it.
    public var revisionId: Swift.String?

    public init(
        codeSha256: Swift.String? = nil,
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.description = description
        self.functionName = functionName
        self.revisionId = revisionId
    }
}

struct PublishVersionInputBody: Swift.Equatable {
    let codeSha256: Swift.String?
    let description: Swift.String?
    let revisionId: Swift.String?
}

extension PublishVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PublishVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PublishVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.ephemeralStorage = output.ephemeralStorage
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.runtimeVersionConfig = output.runtimeVersionConfig
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.snapStart = output.snapStart
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.ephemeralStorage = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kmsKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.runtimeVersionConfig = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.snapStart = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct PublishVersionOutput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct PublishVersionOutputBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStartResponse?
    let runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
}

extension PublishVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kmsKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case runtimeVersionConfig = "RuntimeVersionConfig"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case snapStart = "SnapStart"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartResponse.self, forKey: .snapStart)
        snapStart = snapStartDecoded
        let runtimeVersionConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionConfig.self, forKey: .runtimeVersionConfig)
        runtimeVersionConfig = runtimeVersionConfigDecoded
    }
}

enum PublishVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeStorageExceededException": return try await CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutFunctionCodeSigningConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSigningConfigArn = self.codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
    }
}

extension PutFunctionCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
    }
}

public struct PutFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigInputBody: Swift.Equatable {
    let codeSigningConfigArn: Swift.String?
}

extension PutFunctionCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
    }
}

extension PutFunctionCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFunctionCodeSigningConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct PutFunctionCodeSigningConfigOutput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init(
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigOutputBody: Swift.Equatable {
    let codeSigningConfigArn: Swift.String?
    let functionName: Swift.String?
}

extension PutFunctionCodeSigningConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

enum PutFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeSigningConfigNotFoundException": return try await CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutFunctionConcurrencyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = self.reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }
}

extension PutFunctionConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
    }
}

public struct PutFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The number of simultaneous executions to reserve for the function.
    /// This member is required.
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        functionName: Swift.String? = nil,
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyInputBody: Swift.Equatable {
    let reservedConcurrentExecutions: Swift.Int?
}

extension PutFunctionConcurrencyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension PutFunctionConcurrencyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFunctionConcurrencyOutputBody = try responseDecoder.decode(responseBody: data)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct PutFunctionConcurrencyOutput: Swift.Equatable {
    /// The number of concurrent executions that are reserved for this function. For more information, see [Managing Lambda reserved concurrency](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html).
    public var reservedConcurrentExecutions: Swift.Int?

    public init(
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyOutputBody: Swift.Equatable {
    let reservedConcurrentExecutions: Swift.Int?
}

extension PutFunctionConcurrencyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

enum PutFunctionConcurrencyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutFunctionEventInvokeConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = self.maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

extension PutFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension PutFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct PutFunctionEventInvokeConfigInput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct PutFunctionEventInvokeConfigInputBody: Swift.Equatable {
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension PutFunctionEventInvokeConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension PutFunctionEventInvokeConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFunctionEventInvokeConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct PutFunctionEventInvokeConfigOutput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct PutFunctionEventInvokeConfigOutputBody: Swift.Equatable {
    let lastModified: ClientRuntime.Date?
    let functionArn: Swift.String?
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension PutFunctionEventInvokeConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

enum PutFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutProvisionedConcurrencyConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedConcurrentExecutions = self.provisionedConcurrentExecutions {
            try encodeContainer.encode(provisionedConcurrentExecutions, forKey: .provisionedConcurrentExecutions)
        }
    }
}

extension PutProvisionedConcurrencyConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let qualifier = qualifier else {
                let message = "Creating a URL Query Item failed. qualifier is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            items.append(qualifierQueryItem)
            return items
        }
    }
}

extension PutProvisionedConcurrencyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
    }
}

public struct PutProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The amount of provisioned concurrency to allocate for the version or alias.
    /// This member is required.
    public var provisionedConcurrentExecutions: Swift.Int?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        provisionedConcurrentExecutions: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
        self.qualifier = qualifier
    }
}

struct PutProvisionedConcurrencyConfigInputBody: Swift.Equatable {
    let provisionedConcurrentExecutions: Swift.Int?
}

extension PutProvisionedConcurrencyConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedConcurrentExecutions)
        provisionedConcurrentExecutions = provisionedConcurrentExecutionsDecoded
    }
}

extension PutProvisionedConcurrencyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutProvisionedConcurrencyConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct PutProvisionedConcurrencyConfigOutput: Swift.Equatable {
    /// The amount of provisioned concurrency allocated. When a weighted alias is used during linear and canary deployments, this value fluctuates depending on the amount of concurrency that is provisioned for the function versions.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in [ISO 8601 format](https://www.iso.org/iso-8601-date-and-time-format.html).
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init(
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct PutProvisionedConcurrencyConfigOutputBody: Swift.Equatable {
    let requestedProvisionedConcurrentExecutions: Swift.Int?
    let availableProvisionedConcurrentExecutions: Swift.Int?
    let allocatedProvisionedConcurrentExecutions: Swift.Int?
    let status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    let statusReason: Swift.String?
    let lastModified: Swift.String?
}

extension PutProvisionedConcurrencyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

enum PutProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRuntimeManagementConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeVersionArn = "RuntimeVersionArn"
        case updateRuntimeOn = "UpdateRuntimeOn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runtimeVersionArn = self.runtimeVersionArn {
            try encodeContainer.encode(runtimeVersionArn, forKey: .runtimeVersionArn)
        }
        if let updateRuntimeOn = self.updateRuntimeOn {
            try encodeContainer.encode(updateRuntimeOn.rawValue, forKey: .updateRuntimeOn)
        }
    }
}

extension PutRuntimeManagementConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension PutRuntimeManagementConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-07-20/functions/\(functionName.urlPercentEncoding())/runtime-management-config"
    }
}

public struct PutRuntimeManagementConfigInput: Swift.Equatable {
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version of the function. This can be $LATEST or a published version number. If no value is specified, the configuration for the $LATEST version is returned.
    public var qualifier: Swift.String?
    /// The ARN of the runtime version you want the function to use. This is only required if you're using the Manual runtime update mode.
    public var runtimeVersionArn: Swift.String?
    /// Specify the runtime update mode.
    ///
    /// * Auto (default) - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
    ///
    /// * Function update - Lambda updates the runtime of your function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
    ///
    /// * Manual - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
    /// This member is required.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

struct PutRuntimeManagementConfigInputBody: Swift.Equatable {
    let updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?
    let runtimeVersionArn: Swift.String?
}

extension PutRuntimeManagementConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeVersionArn = "RuntimeVersionArn"
        case updateRuntimeOn = "UpdateRuntimeOn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRuntimeOnDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.UpdateRuntimeOn.self, forKey: .updateRuntimeOn)
        updateRuntimeOn = updateRuntimeOnDecoded
        let runtimeVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersionArn)
        runtimeVersionArn = runtimeVersionArnDecoded
    }
}

extension PutRuntimeManagementConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRuntimeManagementConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.functionArn = output.functionArn
            self.runtimeVersionArn = output.runtimeVersionArn
            self.updateRuntimeOn = output.updateRuntimeOn
        } else {
            self.functionArn = nil
            self.runtimeVersionArn = nil
            self.updateRuntimeOn = nil
        }
    }
}

public struct PutRuntimeManagementConfigOutput: Swift.Equatable {
    /// The ARN of the function
    /// This member is required.
    public var functionArn: Swift.String?
    /// The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
    public var runtimeVersionArn: Swift.String?
    /// The runtime update mode.
    /// This member is required.
    public var updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?

    public init(
        functionArn: Swift.String? = nil,
        runtimeVersionArn: Swift.String? = nil,
        updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn? = nil
    )
    {
        self.functionArn = functionArn
        self.runtimeVersionArn = runtimeVersionArn
        self.updateRuntimeOn = updateRuntimeOn
    }
}

struct PutRuntimeManagementConfigOutputBody: Swift.Equatable {
    let updateRuntimeOn: LambdaClientTypes.UpdateRuntimeOn?
    let functionArn: Swift.String?
    let runtimeVersionArn: Swift.String?
}

extension PutRuntimeManagementConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case runtimeVersionArn = "RuntimeVersionArn"
        case updateRuntimeOn = "UpdateRuntimeOn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRuntimeOnDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.UpdateRuntimeOn.self, forKey: .updateRuntimeOn)
        updateRuntimeOn = updateRuntimeOnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersionArn)
        runtimeVersionArn = runtimeVersionArnDecoded
    }
}

enum PutRuntimeManagementConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RecursiveInvocationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RecursiveInvocationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda has detected your function being invoked in a recursive loop with other Amazon Web Services resources and stopped your function's invocation.
public struct RecursiveInvocationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RecursiveInvocationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct RecursiveInvocationExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension RecursiveInvocationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RemoveLayerVersionPermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let revisionId = revisionId {
                let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
                items.append(revisionIdQueryItem)
            }
            return items
        }
    }
}

extension RemoveLayerVersionPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let layerName = layerName else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy/\(statementId.urlPercentEncoding())"
    }
}

public struct RemoveLayerVersionPermissionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The identifier that was specified when the statement was added.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        layerName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.layerName = layerName
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct RemoveLayerVersionPermissionInputBody: Swift.Equatable {
}

extension RemoveLayerVersionPermissionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveLayerVersionPermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveLayerVersionPermissionOutput: Swift.Equatable {

    public init() { }
}

enum RemoveLayerVersionPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemovePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            if let revisionId = revisionId {
                let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
                items.append(revisionIdQueryItem)
            }
            return items
        }
    }
}

extension RemovePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let statementId = statementId else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy/\(statementId.urlPercentEncoding())"
    }
}

public struct RemovePermissionInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name – my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to remove permissions from a published version of the function.
    public var qualifier: Swift.String?
    /// Update the policy only if the revision ID matches the ID that's specified. Use this option to avoid modifying a policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// Statement ID of the permission to remove.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
}

extension RemovePermissionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemovePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemovePermissionOutput: Swift.Equatable {

    public init() { }
}

enum RemovePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestTooLargeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request payload exceeded the Invoke request body JSON input quota. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html).
public struct RequestTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTooLargeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct RequestTooLargeExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension RequestTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists, or another operation is in progress.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation conflicts with the resource's availability. For example, you tried to update an event source mapping in the CREATING state, or you tried to delete an event source mapping currently UPDATING.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotReadyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
        /// The exception type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ResourceNotReadyExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ResourceNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum ResponseStreamingInvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dryrun
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseStreamingInvocationType] {
            return [
                .dryrun,
                .requestresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseStreamingInvocationType(rawValue: rawValue) ?? ResponseStreamingInvocationType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dotnet6
        case dotnetcore10
        case dotnetcore20
        case dotnetcore21
        case dotnetcore31
        case go1x
        case java11
        case java17
        case java8
        case java8al2
        case nodejs
        case nodejs10x
        case nodejs12x
        case nodejs14x
        case nodejs16x
        case nodejs18x
        case nodejs43
        case nodejs43edge
        case nodejs610
        case nodejs810
        case provided
        case providedal2
        case python27
        case python310
        case python311
        case python36
        case python37
        case python38
        case python39
        case ruby25
        case ruby27
        case ruby32
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .dotnet6,
                .dotnetcore10,
                .dotnetcore20,
                .dotnetcore21,
                .dotnetcore31,
                .go1x,
                .java11,
                .java17,
                .java8,
                .java8al2,
                .nodejs,
                .nodejs10x,
                .nodejs12x,
                .nodejs14x,
                .nodejs16x,
                .nodejs18x,
                .nodejs43,
                .nodejs43edge,
                .nodejs610,
                .nodejs810,
                .provided,
                .providedal2,
                .python27,
                .python310,
                .python311,
                .python36,
                .python37,
                .python38,
                .python39,
                .ruby25,
                .ruby27,
                .ruby32,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dotnet6: return "dotnet6"
            case .dotnetcore10: return "dotnetcore1.0"
            case .dotnetcore20: return "dotnetcore2.0"
            case .dotnetcore21: return "dotnetcore2.1"
            case .dotnetcore31: return "dotnetcore3.1"
            case .go1x: return "go1.x"
            case .java11: return "java11"
            case .java17: return "java17"
            case .java8: return "java8"
            case .java8al2: return "java8.al2"
            case .nodejs: return "nodejs"
            case .nodejs10x: return "nodejs10.x"
            case .nodejs12x: return "nodejs12.x"
            case .nodejs14x: return "nodejs14.x"
            case .nodejs16x: return "nodejs16.x"
            case .nodejs18x: return "nodejs18.x"
            case .nodejs43: return "nodejs4.3"
            case .nodejs43edge: return "nodejs4.3-edge"
            case .nodejs610: return "nodejs6.10"
            case .nodejs810: return "nodejs8.10"
            case .provided: return "provided"
            case .providedal2: return "provided.al2"
            case .python27: return "python2.7"
            case .python310: return "python3.10"
            case .python311: return "python3.11"
            case .python36: return "python3.6"
            case .python37: return "python3.7"
            case .python38: return "python3.8"
            case .python39: return "python3.9"
            case .ruby25: return "ruby2.5"
            case .ruby27: return "ruby2.7"
            case .ruby32: return "ruby3.2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.RuntimeVersionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case runtimeVersionArn = "RuntimeVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let runtimeVersionArn = self.runtimeVersionArn {
            try encodeContainer.encode(runtimeVersionArn, forKey: .runtimeVersionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeVersionArn)
        runtimeVersionArn = runtimeVersionArnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes {
    /// The ARN of the runtime and any errors that occured.
    public struct RuntimeVersionConfig: Swift.Equatable {
        /// Error response when Lambda is unable to retrieve the runtime version for a function.
        public var error: LambdaClientTypes.RuntimeVersionError?
        /// The ARN of the runtime version you want the function to use.
        public var runtimeVersionArn: Swift.String?

        public init(
            error: LambdaClientTypes.RuntimeVersionError? = nil,
            runtimeVersionArn: Swift.String? = nil
        )
        {
            self.error = error
            self.runtimeVersionArn = runtimeVersionArn
        }
    }

}

extension LambdaClientTypes.RuntimeVersionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.RuntimeVersionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuntimeVersionError(errorCode: \(Swift.String(describing: errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension LambdaClientTypes {
    /// Any error returned when the runtime version information for the function could not be retrieved.
    public struct RuntimeVersionError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.ScalingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumConcurrency = "MaximumConcurrency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumConcurrency = self.maximumConcurrency {
            try encodeContainer.encode(maximumConcurrency, forKey: .maximumConcurrency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumConcurrency)
        maximumConcurrency = maximumConcurrencyDecoded
    }
}

extension LambdaClientTypes {
    /// (Amazon SQS only) The scaling configuration for the event source. To remove the configuration, pass an empty value.
    public struct ScalingConfig: Swift.Equatable {
        /// Limits the number of concurrent instances that the Amazon SQS event source can invoke.
        public var maximumConcurrency: Swift.Int?

        public init(
            maximumConcurrency: Swift.Int? = nil
        )
        {
            self.maximumConcurrency = maximumConcurrency
        }
    }

}

extension LambdaClientTypes.SelfManagedEventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .endpoints)
            for (dictKey0, endpoints0) in endpoints {
                var endpoints0Container = endpointsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for endpoint1 in endpoints0 {
                    try endpoints0Container.encode(endpoint1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .endpoints)
        var endpointsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, endpointlists0) in endpointsContainer {
                var endpointlists0Decoded0: [Swift.String]? = nil
                if let endpointlists0 = endpointlists0 {
                    endpointlists0Decoded0 = [Swift.String]()
                    for string1 in endpointlists0 {
                        if let string1 = string1 {
                            endpointlists0Decoded0?.append(string1)
                        }
                    }
                }
                endpointsDecoded0?[key0] = endpointlists0Decoded0
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension LambdaClientTypes {
    /// The self-managed Apache Kafka cluster for your event source.
    public struct SelfManagedEventSource: Swift.Equatable {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public var endpoints: [Swift.String:[Swift.String]]?

        public init(
            endpoints: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.endpoints = endpoints
        }
    }

}

extension LambdaClientTypes.SelfManagedKafkaEventSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerGroupId = "ConsumerGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerGroupId = self.consumerGroupId {
            try encodeContainer.encode(consumerGroupId, forKey: .consumerGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerGroupId)
        consumerGroupId = consumerGroupIdDecoded
    }
}

extension LambdaClientTypes {
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public struct SelfManagedKafkaEventSourceConfig: Swift.Equatable {
        /// The identifier for the Kafka consumer group to join. The consumer group ID must be unique among all your Kafka event sources. After creating a Kafka event source mapping with the consumer group ID specified, you cannot update this value. For more information, see [Customizable consumer group ID](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-consumer-group-id).
        public var consumerGroupId: Swift.String?

        public init(
            consumerGroupId: Swift.String? = nil
        )
        {
            self.consumerGroupId = consumerGroupId
        }
    }

}

extension ServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Lambda service encountered an internal error.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.SnapStart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOn = "ApplyOn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyOn = self.applyOn {
            try encodeContainer.encode(applyOn.rawValue, forKey: .applyOn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyOnDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartApplyOn.self, forKey: .applyOn)
        applyOn = applyOnDecoded
    }
}

extension LambdaClientTypes {
    /// The function's [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting. Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
    public struct SnapStart: Swift.Equatable {
        /// Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.
        public var applyOn: LambdaClientTypes.SnapStartApplyOn?

        public init(
            applyOn: LambdaClientTypes.SnapStartApplyOn? = nil
        )
        {
            self.applyOn = applyOn
        }
    }

}

extension LambdaClientTypes {
    public enum SnapStartApplyOn: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case publishedversions
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapStartApplyOn] {
            return [
                .none,
                .publishedversions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .publishedversions: return "PublishedVersions"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapStartApplyOn(rawValue: rawValue) ?? SnapStartApplyOn.sdkUnknown(rawValue)
        }
    }
}

extension SnapStartException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapStartExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The afterRestore()[runtime hook](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-runtime-hooks.html) encountered an error. For more information, check the Amazon CloudWatch logs.
public struct SnapStartException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct SnapStartExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension SnapStartExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapStartNotReadyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapStartNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda is initializing your function. You can invoke the function when the [function state](https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html) becomes Active.
public struct SnapStartNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartNotReadyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct SnapStartNotReadyExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension SnapStartNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum SnapStartOptimizationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapStartOptimizationStatus] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapStartOptimizationStatus(rawValue: rawValue) ?? SnapStartOptimizationStatus.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.SnapStartResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyOn = "ApplyOn"
        case optimizationStatus = "OptimizationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyOn = self.applyOn {
            try encodeContainer.encode(applyOn.rawValue, forKey: .applyOn)
        }
        if let optimizationStatus = self.optimizationStatus {
            try encodeContainer.encode(optimizationStatus.rawValue, forKey: .optimizationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyOnDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartApplyOn.self, forKey: .applyOn)
        applyOn = applyOnDecoded
        let optimizationStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartOptimizationStatus.self, forKey: .optimizationStatus)
        optimizationStatus = optimizationStatusDecoded
    }
}

extension LambdaClientTypes {
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public struct SnapStartResponse: Swift.Equatable {
        /// When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
        public var applyOn: LambdaClientTypes.SnapStartApplyOn?
        /// When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
        public var optimizationStatus: LambdaClientTypes.SnapStartOptimizationStatus?

        public init(
            applyOn: LambdaClientTypes.SnapStartApplyOn? = nil,
            optimizationStatus: LambdaClientTypes.SnapStartOptimizationStatus? = nil
        )
        {
            self.applyOn = applyOn
            self.optimizationStatus = optimizationStatus
        }
    }

}

extension SnapStartTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapStartTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't restore the snapshot within the timeout limit.
public struct SnapStartTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapStartTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct SnapStartTimeoutExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension SnapStartTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.SourceAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case uri = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SourceAccessType.self, forKey: .type)
        type = typeDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension LambdaClientTypes {
    /// To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.
    public struct SourceAccessConfiguration: Swift.Equatable {
        /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".
        ///
        /// * BASIC_AUTH – (Amazon MQ) The Secrets Manager secret that stores your broker credentials.
        ///
        /// * BASIC_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
        ///
        /// * VPC_SUBNET – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
        ///
        /// * VPC_SECURITY_GROUP – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_256_AUTH – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * SASL_SCRAM_512_AUTH – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
        ///
        /// * VIRTUAL_HOST –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
        ///
        /// * CLIENT_CERTIFICATE_TLS_AUTH – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
        ///
        /// * SERVER_ROOT_CA_CERTIFICATE – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
        public var type: LambdaClientTypes.SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public var uri: Swift.String?

        public init(
            type: LambdaClientTypes.SourceAccessType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.type = type
            self.uri = uri
        }
    }

}

extension LambdaClientTypes {
    public enum SourceAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basicAuth
        case clientCertificateTlsAuth
        case saslScram256Auth
        case saslScram512Auth
        case serverRootCaCertificate
        case virtualHost
        case vpcSecurityGroup
        case vpcSubnet
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceAccessType] {
            return [
                .basicAuth,
                .clientCertificateTlsAuth,
                .saslScram256Auth,
                .saslScram512Auth,
                .serverRootCaCertificate,
                .virtualHost,
                .vpcSecurityGroup,
                .vpcSubnet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .clientCertificateTlsAuth: return "CLIENT_CERTIFICATE_TLS_AUTH"
            case .saslScram256Auth: return "SASL_SCRAM_256_AUTH"
            case .saslScram512Auth: return "SASL_SCRAM_512_AUTH"
            case .serverRootCaCertificate: return "SERVER_ROOT_CA_CERTIFICATE"
            case .virtualHost: return "VIRTUAL_HOST"
            case .vpcSecurityGroup: return "VPC_SECURITY_GROUP"
            case .vpcSubnet: return "VPC_SUBNET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceAccessType(rawValue: rawValue) ?? SourceAccessType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .failed,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case .inactive: return "Inactive"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum StateReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case disabledkmskey
        case efsioerror
        case efsmountconnectivityerror
        case efsmountfailure
        case efsmounttimeout
        case enilimitexceeded
        case functionerror
        case idle
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidruntime
        case invalidsecuritygroup
        case invalidstatekmskey
        case invalidsubnet
        case invalidzipfileexception
        case kmskeyaccessdenied
        case kmskeynotfound
        case restoring
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [StateReasonCode] {
            return [
                .creating,
                .disabledkmskey,
                .efsioerror,
                .efsmountconnectivityerror,
                .efsmountfailure,
                .efsmounttimeout,
                .enilimitexceeded,
                .functionerror,
                .idle,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidruntime,
                .invalidsecuritygroup,
                .invalidstatekmskey,
                .invalidsubnet,
                .invalidzipfileexception,
                .kmskeyaccessdenied,
                .kmskeynotfound,
                .restoring,
                .subnetoutofipaddresses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .disabledkmskey: return "DisabledKMSKey"
            case .efsioerror: return "EFSIOError"
            case .efsmountconnectivityerror: return "EFSMountConnectivityError"
            case .efsmountfailure: return "EFSMountFailure"
            case .efsmounttimeout: return "EFSMountTimeout"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .functionerror: return "FunctionError"
            case .idle: return "Idle"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidruntime: return "InvalidRuntime"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidstatekmskey: return "InvalidStateKMSKey"
            case .invalidsubnet: return "InvalidSubnet"
            case .invalidzipfileexception: return "InvalidZipFileException"
            case .kmskeyaccessdenied: return "KMSKeyAccessDenied"
            case .kmskeynotfound: return "KMSKeyNotFound"
            case .restoring: return "Restoring"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StateReasonCode(rawValue: rawValue) ?? StateReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension SubnetIPAddressLimitReachedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetIPAddressLimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Lambda couldn't set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.
public struct SubnetIPAddressLimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetIPAddressLimitReachedException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct SubnetIPAddressLimitReachedExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension SubnetIPAddressLimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resource = resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tags to apply to the function.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes {
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case callerratelimitexceeded
        case concurrentinvocationlimitexceeded
        case concurrentsnapshotcreatelimitexceeded
        case functioninvocationratelimitexceeded
        case reservedfunctionconcurrentinvocationlimitexceeded
        case reservedfunctioninvocationratelimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .callerratelimitexceeded,
                .concurrentinvocationlimitexceeded,
                .concurrentsnapshotcreatelimitexceeded,
                .functioninvocationratelimitexceeded,
                .reservedfunctionconcurrentinvocationlimitexceeded,
                .reservedfunctioninvocationratelimitexceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .callerratelimitexceeded: return "CallerRateLimitExceeded"
            case .concurrentinvocationlimitexceeded: return "ConcurrentInvocationLimitExceeded"
            case .concurrentsnapshotcreatelimitexceeded: return "ConcurrentSnapshotCreateLimitExceeded"
            case .functioninvocationratelimitexceeded: return "FunctionInvocationRateLimitExceeded"
            case .reservedfunctionconcurrentinvocationlimitexceeded: return "ReservedFunctionConcurrentInvocationLimitExceeded"
            case .reservedfunctioninvocationratelimitexceeded: return "ReservedFunctionInvocationRateLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.type = output.type
        } else {
            self.properties.reason = nil
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request throughput limit was exceeded. For more information, see [Lambda quotas](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html#api-requests).
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: LambdaClientTypes.ThrottleReason? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: LambdaClientTypes.ThrottleReason? = nil,
        retryAfterSeconds: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.type = type
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
    let reason: LambdaClientTypes.ThrottleReason?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension LambdaClientTypes.TracingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension LambdaClientTypes {
    /// The function's [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set Mode to Active.
    public struct TracingConfig: Swift.Equatable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init(
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension LambdaClientTypes.TracingConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension LambdaClientTypes {
    /// The function's X-Ray tracing configuration.
    public struct TracingConfigResponse: Swift.Equatable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init(
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension LambdaClientTypes {
    public enum TracingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingMode] {
            return [
                .active,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .passthrough: return "PassThrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TracingMode(rawValue: rawValue) ?? TracingMode.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedMediaTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedMediaTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The content type of the Invoke request body is not JSON.
public struct UnsupportedMediaTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedMediaTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct UnsupportedMediaTypeExceptionBody: Swift.Equatable {
    let type: Swift.String?
    let message: Swift.String?
}

extension UnsupportedMediaTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resource = resource else {
            return nil
        }
        return "/2017-03-31/tags/\(resource.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tag keys to remove from the function.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = self.routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

extension UpdateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
    }
}

public struct UpdateAliasInput: Swift.Equatable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name - MyFunction.
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying an alias that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasInputBody: Swift.Equatable {
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension UpdateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
public struct UpdateAliasOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The [routing configuration](https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html) of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init(
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasOutputBody: Swift.Equatable {
    let aliasArn: Swift.String?
    let name: Swift.String?
    let functionVersion: Swift.String?
    let description: Swift.String?
    let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    let revisionId: Swift.String?
}

extension UpdateAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum UpdateAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCodeSigningConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = self.allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = self.codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateCodeSigningConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let codeSigningConfigArn = codeSigningConfigArn else {
            return nil
        }
        return "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
    }
}

public struct UpdateCodeSigningConfigInput: Swift.Equatable {
    /// Signing profiles for this code signing configuration.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The code signing policy.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init(
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct UpdateCodeSigningConfigInputBody: Swift.Equatable {
    let description: Swift.String?
    let allowedPublishers: LambdaClientTypes.AllowedPublishers?
    let codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
}

extension UpdateCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension UpdateCodeSigningConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCodeSigningConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct UpdateCodeSigningConfigOutput: Swift.Equatable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init(
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct UpdateCodeSigningConfigOutputBody: Swift.Equatable {
    let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension UpdateCodeSigningConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

enum UpdateCodeSigningConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventSourceMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case enabled = "Enabled"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case scalingConfig = "ScalingConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = self.batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = self.bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let documentDBEventSourceConfig = self.documentDBEventSourceConfig {
            try encodeContainer.encode(documentDBEventSourceConfig, forKey: .documentDBEventSourceConfig)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetype0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetype0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = self.maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = self.maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = self.parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let scalingConfig = self.scalingConfig {
            try encodeContainer.encode(scalingConfig, forKey: .scalingConfig)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfiguration0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfiguration0)
            }
        }
        if let tumblingWindowInSeconds = self.tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

extension UpdateEventSourceMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let uuid = uuid else {
            return nil
        }
        return "/2015-03-31/event-source-mappings/\(uuid.urlPercentEncoding())"
    }
}

public struct UpdateEventSourceMappingInput: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///
    /// * Amazon Kinesis – Default 100. Max 10,000.
    ///
    /// * Amazon DynamoDB Streams – Default 100. Max 10,000.
    ///
    /// * Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    /// * Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Self-managed Apache Kafka – Default 100. Max 10,000.
    ///
    /// * Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
    ///
    /// * DocumentDB – Default 100. Max 10,000.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis and DynamoDB Streams only) A standard Amazon SQS queue or standard Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation. Default: True
    public var enabled: Swift.Bool?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – MyFunction.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    /// * Version or Alias ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    /// * Partial ARN – 123456789012:function:MyFunction.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64 characters in length.
    public var functionName: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uuid: Swift.String?

    public init(
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        enabled: Swift.Bool? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.enabled = enabled
        self.filterCriteria = filterCriteria
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.scalingConfig = scalingConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

struct UpdateEventSourceMappingInputBody: Swift.Equatable {
    let functionName: Swift.String?
    let enabled: Swift.Bool?
    let batchSize: Swift.Int?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    let scalingConfig: LambdaClientTypes.ScalingConfig?
    let documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
}

extension UpdateEventSourceMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case enabled = "Enabled"
        case filterCriteria = "FilterCriteria"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case scalingConfig = "ScalingConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

extension UpdateEventSourceMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEventSourceMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.amazonManagedKafkaEventSourceConfig = output.amazonManagedKafkaEventSourceConfig
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.documentDBEventSourceConfig = output.documentDBEventSourceConfig
            self.eventSourceArn = output.eventSourceArn
            self.filterCriteria = output.filterCriteria
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.scalingConfig = output.scalingConfig
            self.selfManagedEventSource = output.selfManagedEventSource
            self.selfManagedKafkaEventSourceConfig = output.selfManagedKafkaEventSourceConfig
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uuid = output.uuid
        } else {
            self.amazonManagedKafkaEventSourceConfig = nil
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.documentDBEventSourceConfig = nil
            self.eventSourceArn = nil
            self.filterCriteria = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.scalingConfig = nil
            self.selfManagedEventSource = nil
            self.selfManagedKafkaEventSourceConfig = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uuid = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see [CreateEventSourceMapping].
public struct UpdateEventSourceMappingOutput: Swift.Equatable {
    /// Specific configuration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) event source.
    public var amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB). Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100. Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// Specific configuration settings for a DocumentDB event source.
    public var documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// An object that defines the filter criteria that determine whether Lambda should process an event. For more information, see [Lambda event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
    public var filterCriteria: LambdaClientTypes.FilterCriteria?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to 300 seconds in increments of seconds. For streams and Amazon SQS event sources, the default batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event sources, the default batching window is 500 ms. Note that because you can only change MaximumBatchingWindowInSeconds in increments of seconds, you cannot revert back to the 500 ms default batching window after you have changed it. To restore the default batching window, you must create a new event source mapping. Related setting: For streams and Amazon SQS event sources, when you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records. The minimum valid value for maximum record age is 60s. Although values less than 60 and greater than -1 fall within the parameter's absolute range, they are not allowed
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    /// (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// (Amazon SQS only) The scaling configuration for the event source. For more information, see [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
    public var scalingConfig: LambdaClientTypes.ScalingConfig?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// Specific configuration settings for a self-managed Apache Kafka event source.
    public var selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Stream event sources. AT_TIMESTAMP is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start reading. StartingPositionTimestamp cannot be in the future.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating, Enabling, Enabled, Disabling, Disabled, Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uuid: Swift.String?

    public init(
        amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig? = nil,
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        filterCriteria: LambdaClientTypes.FilterCriteria? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        scalingConfig: LambdaClientTypes.ScalingConfig? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uuid: Swift.String? = nil
    )
    {
        self.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.documentDBEventSourceConfig = documentDBEventSourceConfig
        self.eventSourceArn = eventSourceArn
        self.filterCriteria = filterCriteria
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.scalingConfig = scalingConfig
        self.selfManagedEventSource = selfManagedEventSource
        self.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uuid = uuid
    }
}

struct UpdateEventSourceMappingOutputBody: Swift.Equatable {
    let uuid: Swift.String?
    let startingPosition: LambdaClientTypes.EventSourcePosition?
    let startingPositionTimestamp: ClientRuntime.Date?
    let batchSize: Swift.Int?
    let maximumBatchingWindowInSeconds: Swift.Int?
    let parallelizationFactor: Swift.Int?
    let eventSourceArn: Swift.String?
    let filterCriteria: LambdaClientTypes.FilterCriteria?
    let functionArn: Swift.String?
    let lastModified: ClientRuntime.Date?
    let lastProcessingResult: Swift.String?
    let state: Swift.String?
    let stateTransitionReason: Swift.String?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
    let topics: [Swift.String]?
    let queues: [Swift.String]?
    let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    let maximumRecordAgeInSeconds: Swift.Int?
    let bisectBatchOnFunctionError: Swift.Bool?
    let maximumRetryAttempts: Swift.Int?
    let tumblingWindowInSeconds: Swift.Int?
    let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    let amazonManagedKafkaEventSourceConfig: LambdaClientTypes.AmazonManagedKafkaEventSourceConfig?
    let selfManagedKafkaEventSourceConfig: LambdaClientTypes.SelfManagedKafkaEventSourceConfig?
    let scalingConfig: LambdaClientTypes.ScalingConfig?
    let documentDBEventSourceConfig: LambdaClientTypes.DocumentDBEventSourceConfig?
}

extension UpdateEventSourceMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonManagedKafkaEventSourceConfig = "AmazonManagedKafkaEventSourceConfig"
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case documentDBEventSourceConfig = "DocumentDBEventSourceConfig"
        case eventSourceArn = "EventSourceArn"
        case filterCriteria = "FilterCriteria"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case scalingConfig = "ScalingConfig"
        case selfManagedEventSource = "SelfManagedEventSource"
        case selfManagedKafkaEventSourceConfig = "SelfManagedKafkaEventSourceConfig"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uuid = "UUID"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for enum0 in functionResponseTypesContainer {
                if let enum0 = enum0 {
                    functionResponseTypesDecoded0?.append(enum0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
        let amazonManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AmazonManagedKafkaEventSourceConfig.self, forKey: .amazonManagedKafkaEventSourceConfig)
        amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfigDecoded
        let selfManagedKafkaEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedKafkaEventSourceConfig.self, forKey: .selfManagedKafkaEventSourceConfig)
        selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfigDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let documentDBEventSourceConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DocumentDBEventSourceConfig.self, forKey: .documentDBEventSourceConfig)
        documentDBEventSourceConfig = documentDBEventSourceConfigDecoded
    }
}

enum UpdateEventSourceMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFunctionCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionCodeInput(architectures: \(Swift.String(describing: architectures)), dryRun: \(Swift.String(describing: dryRun)), functionName: \(Swift.String(describing: functionName)), imageUri: \(Swift.String(describing: imageUri)), publish: \(Swift.String(describing: publish)), revisionId: \(Swift.String(describing: revisionId)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \"CONTENT_REDACTED\")"}
}

extension UpdateFunctionCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecture0 in architectures {
                try architecturesContainer.encode(architecture0.rawValue)
            }
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let imageUri = self.imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let publish = self.publish {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = self.s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = self.zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }
}

extension UpdateFunctionCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/code"
    }
}

public struct UpdateFunctionCodeInput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Set to true to validate the request parameters and access permissions without modifying the function code.
    public var dryRun: Swift.Bool?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// URI of a container image in the Amazon ECR registry. Do not use for a function defined with a .zip file archive.
    public var imageUri: Swift.String?
    /// Set to true to publish a new version of the function after updating the code. This has the same effect as calling [PublishVersion] separately.
    public var publish: Swift.Bool?
    /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account. Use only with a function defined with a .zip file archive deployment package.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 key of the deployment package. Use only with a function defined with a .zip file archive deployment package.
    public var s3Key: Swift.String?
    /// For versioned objects, the version of the deployment package object to use.
    public var s3ObjectVersion: Swift.String?
    /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and CLI clients handle the encoding for you. Use only with a function defined with a .zip file archive deployment package.
    public var zipFile: ClientRuntime.Data?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        dryRun: Swift.Bool? = nil,
        functionName: Swift.String? = nil,
        imageUri: Swift.String? = nil,
        publish: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3Key: Swift.String? = nil,
        s3ObjectVersion: Swift.String? = nil,
        zipFile: ClientRuntime.Data? = nil
    )
    {
        self.architectures = architectures
        self.dryRun = dryRun
        self.functionName = functionName
        self.imageUri = imageUri
        self.publish = publish
        self.revisionId = revisionId
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

struct UpdateFunctionCodeInputBody: Swift.Equatable {
    let zipFile: ClientRuntime.Data?
    let s3Bucket: Swift.String?
    let s3Key: Swift.String?
    let s3ObjectVersion: Swift.String?
    let imageUri: Swift.String?
    let publish: Swift.Bool?
    let dryRun: Swift.Bool?
    let revisionId: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let publishDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publish)
        publish = publishDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension UpdateFunctionCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFunctionCodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.ephemeralStorage = output.ephemeralStorage
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.runtimeVersionConfig = output.runtimeVersionConfig
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.snapStart = output.snapStart
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.ephemeralStorage = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kmsKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.runtimeVersionConfig = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.snapStart = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionCodeOutput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionCodeOutputBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStartResponse?
    let runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
}

extension UpdateFunctionCodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kmsKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case runtimeVersionConfig = "RuntimeVersionConfig"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case snapStart = "SnapStart"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartResponse.self, forKey: .snapStart)
        snapStart = snapStartDecoded
        let runtimeVersionConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionConfig.self, forKey: .runtimeVersionConfig)
        runtimeVersionConfig = runtimeVersionConfigDecoded
    }
}

enum UpdateFunctionCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeSigningConfigNotFoundException": return try await CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CodeStorageExceededException": return try await CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CodeVerificationFailedException": return try await CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCodeSignatureException": return try await InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFunctionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kmsKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case snapStart = "SnapStart"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterConfig = self.deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let ephemeralStorage = self.ephemeralStorage {
            try encodeContainer.encode(ephemeralStorage, forKey: .ephemeralStorage)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfig0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfig0)
            }
        }
        if let handler = self.handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = self.imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerversionarn0 in layers {
                try layersContainer.encode(layerversionarn0)
            }
        }
        if let memorySize = self.memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let snapStart = self.snapStart {
            try encodeContainer.encode(snapStart, forKey: .snapStart)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = self.tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateFunctionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
    }
}

public struct UpdateFunctionConfigurationInput: Swift.Equatable {
    /// A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// The size of the function's /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
    public var handler: Swift.String?
    /// [Container image configuration values](https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html) that override the values in the container image Docker file.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Key Management Service (KMS) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
    public var kmsKeyArn: Swift.String?
    /// A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
    public var snapStart: LambdaClientTypes.SnapStart?
    /// The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init(
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        memorySize: Swift.Int? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        snapStart: LambdaClientTypes.SnapStart? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kmsKeyArn = kmsKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.snapStart = snapStart
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationInputBody: Swift.Equatable {
    let role: Swift.String?
    let handler: Swift.String?
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let vpcConfig: LambdaClientTypes.VpcConfig?
    let environment: LambdaClientTypes.Environment?
    let runtime: LambdaClientTypes.Runtime?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfig?
    let revisionId: Swift.String?
    let layers: [Swift.String]?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let imageConfig: LambdaClientTypes.ImageConfig?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStart?
}

extension UpdateFunctionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kmsKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case snapStart = "SnapStart"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStart.self, forKey: .snapStart)
        snapStart = snapStartDecoded
    }
}

extension UpdateFunctionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFunctionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.ephemeralStorage = output.ephemeralStorage
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.runtimeVersionConfig = output.runtimeVersionConfig
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.snapStart = output.snapStart
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.ephemeralStorage = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kmsKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.runtimeVersionConfig = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.snapStart = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionConfigurationOutput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html). Omitted from CloudTrail logs.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
    public var ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    /// Connection settings for an [Amazon EFS file system](https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html).
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin running your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, this key is also used to encrypt the function's snapshot. This key is returned only if you've configured a customer managed key.
    public var kmsKeyArn: Swift.String?
    /// The date and time that the function was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's [layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html).
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the main function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the runtime and any errors that occured.
    public var runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see [Improving startup performance with Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html).
    public var snapStart: LambdaClientTypes.SnapStartResponse?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init(
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        ephemeralStorage: LambdaClientTypes.EphemeralStorage? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        snapStart: LambdaClientTypes.SnapStartResponse? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.ephemeralStorage = ephemeralStorage
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kmsKeyArn = kmsKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.runtimeVersionConfig = runtimeVersionConfig
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.snapStart = snapStart
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationOutputBody: Swift.Equatable {
    let functionName: Swift.String?
    let functionArn: Swift.String?
    let runtime: LambdaClientTypes.Runtime?
    let role: Swift.String?
    let handler: Swift.String?
    let codeSize: Swift.Int
    let description: Swift.String?
    let timeout: Swift.Int?
    let memorySize: Swift.Int?
    let lastModified: Swift.String?
    let codeSha256: Swift.String?
    let version: Swift.String?
    let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    let environment: LambdaClientTypes.EnvironmentResponse?
    let kmsKeyArn: Swift.String?
    let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    let masterArn: Swift.String?
    let revisionId: Swift.String?
    let layers: [LambdaClientTypes.Layer]?
    let state: LambdaClientTypes.State?
    let stateReason: Swift.String?
    let stateReasonCode: LambdaClientTypes.StateReasonCode?
    let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    let lastUpdateStatusReason: Swift.String?
    let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    let packageType: LambdaClientTypes.PackageType?
    let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    let signingProfileVersionArn: Swift.String?
    let signingJobArn: Swift.String?
    let architectures: [LambdaClientTypes.Architecture]?
    let ephemeralStorage: LambdaClientTypes.EphemeralStorage?
    let snapStart: LambdaClientTypes.SnapStartResponse?
    let runtimeVersionConfig: LambdaClientTypes.RuntimeVersionConfig?
}

extension UpdateFunctionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case ephemeralStorage = "EphemeralStorage"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kmsKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case runtimeVersionConfig = "RuntimeVersionConfig"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case snapStart = "SnapStart"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for enum0 in architecturesContainer {
                if let enum0 = enum0 {
                    architecturesDecoded0?.append(enum0)
                }
            }
        }
        architectures = architecturesDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let snapStartDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SnapStartResponse.self, forKey: .snapStart)
        snapStart = snapStartDecoded
        let runtimeVersionConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.RuntimeVersionConfig.self, forKey: .runtimeVersionConfig)
        runtimeVersionConfig = runtimeVersionConfigDecoded
    }
}

enum UpdateFunctionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CodeSigningConfigNotFoundException": return try await CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CodeVerificationFailedException": return try await CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCodeSignatureException": return try await InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFunctionEventInvokeConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = self.maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

extension UpdateFunctionEventInvokeConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension UpdateFunctionEventInvokeConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
    }
}

public struct UpdateFunctionEventInvokeConfigInput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name of the Lambda function, version, or alias. Name formats
    ///
    /// * Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    /// * Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN - 123456789012:function:my-function.
    ///
    ///
    /// You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct UpdateFunctionEventInvokeConfigInputBody: Swift.Equatable {
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension UpdateFunctionEventInvokeConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFunctionEventInvokeConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct UpdateFunctionEventInvokeConfigOutput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing. Destinations
    ///
    /// * Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    /// * Queue - The ARN of a standard SQS queue.
    ///
    /// * Topic - The ARN of a standard SNS topic.
    ///
    /// * Event Bus - The ARN of an Amazon EventBridge event bus.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init(
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct UpdateFunctionEventInvokeConfigOutputBody: Swift.Equatable {
    let lastModified: ClientRuntime.Date?
    let functionArn: Swift.String?
    let maximumRetryAttempts: Swift.Int?
    let maximumEventAgeInSeconds: Swift.Int?
    let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

enum UpdateFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFunctionUrlConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case invokeMode = "InvokeMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let cors = self.cors {
            try encodeContainer.encode(cors, forKey: .cors)
        }
        if let invokeMode = self.invokeMode {
            try encodeContainer.encode(invokeMode.rawValue, forKey: .invokeMode)
        }
    }
}

extension UpdateFunctionUrlConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let qualifier = qualifier {
                let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
                items.append(qualifierQueryItem)
            }
            return items
        }
    }
}

extension UpdateFunctionUrlConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionName = functionName else {
            return nil
        }
        return "/2021-10-31/functions/\(functionName.urlPercentEncoding())/url"
    }
}

public struct UpdateFunctionUrlConfigInput: Swift.Equatable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// The name of the Lambda function. Name formats
    ///
    /// * Function name – my-function.
    ///
    /// * Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    /// * Partial ARN – 123456789012:function:my-function.
    ///
    ///
    /// The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// The alias name.
    public var qualifier: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        functionName: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.functionName = functionName
        self.invokeMode = invokeMode
        self.qualifier = qualifier
    }
}

struct UpdateFunctionUrlConfigInputBody: Swift.Equatable {
    let authType: LambdaClientTypes.FunctionUrlAuthType?
    let cors: LambdaClientTypes.Cors?
    let invokeMode: LambdaClientTypes.InvokeMode?
}

extension UpdateFunctionUrlConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case invokeMode = "InvokeMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let corsDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Cors.self, forKey: .cors)
        cors = corsDecoded
        let invokeModeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.InvokeMode.self, forKey: .invokeMode)
        invokeMode = invokeModeDecoded
    }
}

extension UpdateFunctionUrlConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFunctionUrlConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.cors = output.cors
            self.creationTime = output.creationTime
            self.functionArn = output.functionArn
            self.functionUrl = output.functionUrl
            self.invokeMode = output.invokeMode
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.authType = nil
            self.cors = nil
            self.creationTime = nil
            self.functionArn = nil
            self.functionUrl = nil
            self.invokeMode = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateFunctionUrlConfigOutput: Swift.Equatable {
    /// The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// This member is required.
    public var authType: LambdaClientTypes.FunctionUrlAuthType?
    /// The [cross-origin resource sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) settings for your function URL.
    public var cors: LambdaClientTypes.Cors?
    /// When the function URL was created, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var creationTime: Swift.String?
    /// The Amazon Resource Name (ARN) of your function.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The HTTP URL endpoint for your function.
    /// This member is required.
    public var functionUrl: Swift.String?
    /// Use one of the following options:
    ///
    /// * BUFFERED – This is the default option. Lambda invokes your function using the Invoke API operation. Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
    ///
    /// * RESPONSE_STREAM – Your function streams payload results as they become available. Lambda invokes your function using the InvokeWithResponseStream API operation. The maximum response payload size is 20 MB, however, you can [request a quota increase](https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html).
    public var invokeMode: LambdaClientTypes.InvokeMode?
    /// When the function URL configuration was last updated, in [ISO-8601 format](https://www.w3.org/TR/NOTE-datetime) (YYYY-MM-DDThh:mm:ss.sTZD).
    /// This member is required.
    public var lastModifiedTime: Swift.String?

    public init(
        authType: LambdaClientTypes.FunctionUrlAuthType? = nil,
        cors: LambdaClientTypes.Cors? = nil,
        creationTime: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionUrl: Swift.String? = nil,
        invokeMode: LambdaClientTypes.InvokeMode? = nil,
        lastModifiedTime: Swift.String? = nil
    )
    {
        self.authType = authType
        self.cors = cors
        self.creationTime = creationTime
        self.functionArn = functionArn
        self.functionUrl = functionUrl
        self.invokeMode = invokeMode
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateFunctionUrlConfigOutputBody: Swift.Equatable {
    let functionUrl: Swift.String?
    let functionArn: Swift.String?
    let authType: LambdaClientTypes.FunctionUrlAuthType?
    let cors: LambdaClientTypes.Cors?
    let creationTime: Swift.String?
    let lastModifiedTime: Swift.String?
    let invokeMode: LambdaClientTypes.InvokeMode?
}

extension UpdateFunctionUrlConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType = "AuthType"
        case cors = "Cors"
        case creationTime = "CreationTime"
        case functionArn = "FunctionArn"
        case functionUrl = "FunctionUrl"
        case invokeMode = "InvokeMode"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionUrl)
        functionUrl = functionUrlDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionUrlAuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let corsDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Cors.self, forKey: .cors)
        cors = corsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let invokeModeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.InvokeMode.self, forKey: .invokeMode)
        invokeMode = invokeModeDecoded
    }
}

enum UpdateFunctionUrlConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LambdaClientTypes {
    public enum UpdateRuntimeOn: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case functionupdate
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRuntimeOn] {
            return [
                .auto,
                .functionupdate,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .functionupdate: return "FunctionUpdate"
            case .manual: return "Manual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateRuntimeOn(rawValue: rawValue) ?? UpdateRuntimeOn.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension LambdaClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
    public struct VpcConfig: Swift.Equatable {
        /// A list of VPC security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension LambdaClientTypes.VpcConfigResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension LambdaClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct VpcConfigResponse: Swift.Equatable {
        /// A list of VPC security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
