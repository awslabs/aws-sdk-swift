// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to a resource was denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddLFTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case lfTags = "LFTags"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let lfTags = lfTags {
            var lfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTags)
            for lftagpair0 in lfTags {
                try lfTagsContainer.encode(lftagpair0)
            }
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension AddLFTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/AddLFTagsToResource"
    }
}

public struct AddLFTagsToResourceInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The LF-tags to attach to the resource.
    /// This member is required.
    public var lfTags: [LakeFormationClientTypes.LFTagPair]?
    /// The database, table, or column resource to which to attach an LF-tag.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.lfTags = lfTags
        self.resource = resource
    }
}

struct AddLFTagsToResourceInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let resource: LakeFormationClientTypes.Resource?
    let lfTags: [LakeFormationClientTypes.LFTagPair]?
}

extension AddLFTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case lfTags = "LFTags"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let lfTagsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTags)
        var lfTagsDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsContainer = lfTagsContainer {
            lfTagsDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsContainer {
                if let structure0 = structure0 {
                    lfTagsDecoded0?.append(structure0)
                }
            }
        }
        lfTags = lfTagsDecoded0
    }
}

extension AddLFTagsToResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddLFTagsToResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct AddLFTagsToResourceOutput: Swift.Equatable {
    /// A list of failures to tag the resource.
    public var failures: [LakeFormationClientTypes.LFTagError]?

    public init(
        failures: [LakeFormationClientTypes.LFTagError]? = nil
    )
    {
        self.failures = failures
    }
}

struct AddLFTagsToResourceOutputBody: Swift.Equatable {
    let failures: [LakeFormationClientTypes.LFTagError]?
}

extension AddLFTagsToResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures = "Failures"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagError?].self, forKey: .failures)
        var failuresDecoded0:[LakeFormationClientTypes.LFTagError]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LakeFormationClientTypes.LFTagError]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum AddLFTagsToResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.AddObjectInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case partitionValues = "PartitionValues"
        case size = "Size"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for partitionvaluestring0 in partitionValues {
                try partitionValuesContainer.encode(partitionvaluestring0)
            }
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[Swift.String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [Swift.String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A new object to add to the governed table.
    public struct AddObjectInput: Swift.Equatable {
        /// The Amazon S3 ETag of the object. Returned by GetTableObjects for validation and used to identify changes to the underlying data.
        /// This member is required.
        public var eTag: Swift.String?
        /// A list of partition values for the object. A value must be specified for each partition key associated with the table. The supported data types are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.
        public var partitionValues: [Swift.String]?
        /// The size of the Amazon S3 object in bytes.
        /// This member is required.
        public var size: Swift.Int
        /// The Amazon S3 location of the object.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            partitionValues: [Swift.String]? = nil,
            size: Swift.Int = 0,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.partitionValues = partitionValues
            self.size = size
            self.uri = uri
        }
    }

}

extension LakeFormationClientTypes.AllRowsWildcard: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension LakeFormationClientTypes {
    /// A structure that you pass to indicate you want all rows in a filter.
    public struct AllRowsWildcard: Swift.Equatable {

        public init() { }
    }

}

extension AlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource to be created or added already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssumeDecoratedRoleWithSAMLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds = "DurationSeconds"
        case principalArn = "PrincipalArn"
        case roleArn = "RoleArn"
        case samlAssertion = "SAMLAssertion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let principalArn = self.principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let samlAssertion = self.samlAssertion {
            try encodeContainer.encode(samlAssertion, forKey: .samlAssertion)
        }
    }
}

extension AssumeDecoratedRoleWithSAMLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/AssumeDecoratedRoleWithSAML"
    }
}

public struct AssumeDecoratedRoleWithSAMLInput: Swift.Equatable {
    /// The time period, between 900 and 43,200 seconds, for the timeout of the temporary credentials.
    public var durationSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the IdP.
    /// This member is required.
    public var principalArn: Swift.String?
    /// The role that represents an IAM principal whose scope down policy allows it to call credential vending APIs such as GetTemporaryTableCredentials. The caller must also have iam:PassRole permission on this role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A SAML assertion consisting of an assertion statement for the user who needs temporary credentials. This must match the SAML assertion that was issued to IAM. This must be Base64 encoded.
    /// This member is required.
    public var samlAssertion: Swift.String?

    public init(
        durationSeconds: Swift.Int? = nil,
        principalArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        samlAssertion: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.principalArn = principalArn
        self.roleArn = roleArn
        self.samlAssertion = samlAssertion
    }
}

struct AssumeDecoratedRoleWithSAMLInputBody: Swift.Equatable {
    let samlAssertion: Swift.String?
    let roleArn: Swift.String?
    let principalArn: Swift.String?
    let durationSeconds: Swift.Int?
}

extension AssumeDecoratedRoleWithSAMLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds = "DurationSeconds"
        case principalArn = "PrincipalArn"
        case roleArn = "RoleArn"
        case samlAssertion = "SAMLAssertion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlAssertionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlAssertion)
        samlAssertion = samlAssertionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension AssumeDecoratedRoleWithSAMLOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssumeDecoratedRoleWithSAMLOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyId = output.accessKeyId
            self.expiration = output.expiration
            self.secretAccessKey = output.secretAccessKey
            self.sessionToken = output.sessionToken
        } else {
            self.accessKeyId = nil
            self.expiration = nil
            self.secretAccessKey = nil
            self.sessionToken = nil
        }
    }
}

public struct AssumeDecoratedRoleWithSAMLOutput: Swift.Equatable {
    /// The access key ID for the temporary credentials. (The access key consists of an access key ID and a secret key).
    public var accessKeyId: Swift.String?
    /// The date and time when the temporary credentials expire.
    public var expiration: ClientRuntime.Date?
    /// The secret key for the temporary credentials. (The access key consists of an access key ID and a secret key).
    public var secretAccessKey: Swift.String?
    /// The session token for the temporary credentials.
    public var sessionToken: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

struct AssumeDecoratedRoleWithSAMLOutputBody: Swift.Equatable {
    let accessKeyId: Swift.String?
    let secretAccessKey: Swift.String?
    let sessionToken: Swift.String?
    let expiration: ClientRuntime.Date?
}

extension AssumeDecoratedRoleWithSAMLOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
    }
}

enum AssumeDecoratedRoleWithSAMLOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.AuditContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuditContext = "AdditionalAuditContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuditContext = self.additionalAuditContext {
            try encodeContainer.encode(additionalAuditContext, forKey: .additionalAuditContext)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalAuditContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalAuditContext)
        additionalAuditContext = additionalAuditContextDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure used to include auditing information on the privileged API.
    public struct AuditContext: Swift.Equatable {
        /// The filter engine can populate the 'AdditionalAuditContext' information with the request ID for you to track. This information will be displayed in CloudTrail log in your account.
        public var additionalAuditContext: Swift.String?

        public init(
            additionalAuditContext: Swift.String? = nil
        )
        {
            self.additionalAuditContext = additionalAuditContext
        }
    }

}

extension BatchGrantPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchpermissionsrequestentry0 in entries {
                try entriesContainer.encode(batchpermissionsrequestentry0)
            }
        }
    }
}

extension BatchGrantPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGrantPermissions"
    }
}

public struct BatchGrantPermissionsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of up to 20 entries for resource permissions to be granted by batch operation to the principal.
    /// This member is required.
    public var entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]?

    public init(
        catalogId: Swift.String? = nil,
        entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]? = nil
    )
    {
        self.catalogId = catalogId
        self.entries = entries
    }
}

struct BatchGrantPermissionsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]?
}

extension BatchGrantPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let entriesContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.BatchPermissionsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[LakeFormationClientTypes.BatchPermissionsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LakeFormationClientTypes.BatchPermissionsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchGrantPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGrantPermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct BatchGrantPermissionsOutput: Swift.Equatable {
    /// A list of failures to grant permissions to the resources.
    public var failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]?

    public init(
        failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]? = nil
    )
    {
        self.failures = failures
    }
}

struct BatchGrantPermissionsOutputBody: Swift.Equatable {
    let failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]?
}

extension BatchGrantPermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures = "Failures"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.BatchPermissionsFailureEntry?].self, forKey: .failures)
        var failuresDecoded0:[LakeFormationClientTypes.BatchPermissionsFailureEntry]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LakeFormationClientTypes.BatchPermissionsFailureEntry]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum BatchGrantPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.BatchPermissionsFailureEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case requestEntry = "RequestEntry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let requestEntry = self.requestEntry {
            try encodeContainer.encode(requestEntry, forKey: .requestEntry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestEntryDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.BatchPermissionsRequestEntry.self, forKey: .requestEntry)
        requestEntry = requestEntryDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension LakeFormationClientTypes {
    /// A list of failures when performing a batch grant or batch revoke operation.
    public struct BatchPermissionsFailureEntry: Swift.Equatable {
        /// An error message that applies to the failure of the entry.
        public var error: LakeFormationClientTypes.ErrorDetail?
        /// An identifier for an entry of the batch request.
        public var requestEntry: LakeFormationClientTypes.BatchPermissionsRequestEntry?

        public init(
            error: LakeFormationClientTypes.ErrorDetail? = nil,
            requestEntry: LakeFormationClientTypes.BatchPermissionsRequestEntry? = nil
        )
        {
            self.error = error
            self.requestEntry = requestEntry
        }
    }

}

extension LakeFormationClientTypes.BatchPermissionsRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permission0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permission0.rawValue)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsWithGrantOptionContainer {
                if let enum0 = enum0 {
                    permissionsWithGrantOptionDecoded0?.append(enum0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A permission to a resource granted by batch operation to the principal.
    public struct BatchPermissionsRequestEntry: Swift.Equatable {
        /// A unique identifier for the batch permissions request entry.
        /// This member is required.
        public var id: Swift.String?
        /// The permissions to be granted.
        public var permissions: [LakeFormationClientTypes.Permission]?
        /// Indicates if the option to pass permissions is granted.
        public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
        /// The principal to be granted a permission.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?
        /// The resource to which the principal is to be granted a permission.
        public var resource: LakeFormationClientTypes.Resource?

        public init(
            id: Swift.String? = nil,
            permissions: [LakeFormationClientTypes.Permission]? = nil,
            permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
            resource: LakeFormationClientTypes.Resource? = nil
        )
        {
            self.id = id
            self.permissions = permissions
            self.permissionsWithGrantOption = permissionsWithGrantOption
            self.principal = principal
            self.resource = resource
        }
    }

}

extension BatchRevokePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchpermissionsrequestentry0 in entries {
                try entriesContainer.encode(batchpermissionsrequestentry0)
            }
        }
    }
}

extension BatchRevokePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchRevokePermissions"
    }
}

public struct BatchRevokePermissionsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of up to 20 entries for resource permissions to be revoked by batch operation to the principal.
    /// This member is required.
    public var entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]?

    public init(
        catalogId: Swift.String? = nil,
        entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]? = nil
    )
    {
        self.catalogId = catalogId
        self.entries = entries
    }
}

struct BatchRevokePermissionsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]?
}

extension BatchRevokePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case entries = "Entries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let entriesContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.BatchPermissionsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[LakeFormationClientTypes.BatchPermissionsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LakeFormationClientTypes.BatchPermissionsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchRevokePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchRevokePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct BatchRevokePermissionsOutput: Swift.Equatable {
    /// A list of failures to revoke permissions to the resources.
    public var failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]?

    public init(
        failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]? = nil
    )
    {
        self.failures = failures
    }
}

struct BatchRevokePermissionsOutputBody: Swift.Equatable {
    let failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]?
}

extension BatchRevokePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures = "Failures"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.BatchPermissionsFailureEntry?].self, forKey: .failures)
        var failuresDecoded0:[LakeFormationClientTypes.BatchPermissionsFailureEntry]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LakeFormationClientTypes.BatchPermissionsFailureEntry]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum BatchRevokePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension CancelTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CancelTransaction"
    }
}

public struct CancelTransactionInput: Swift.Equatable {
    /// The transaction to cancel.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct CancelTransactionInputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension CancelTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension CancelTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelTransactionOutput: Swift.Equatable {

    public init() { }
}

enum CancelTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommitInProgressException": return try await TransactionCommitInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommittedException": return try await TransactionCommittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.CatalogResource: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension LakeFormationClientTypes {
    /// A structure for the catalog object.
    public struct CatalogResource: Swift.Equatable {

        public init() { }
    }

}

extension LakeFormationClientTypes.ColumnLFTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lfTags = "LFTags"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lfTags = lfTags {
            var lfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTags)
            for lftagpair0 in lfTags {
                try lfTagsContainer.encode(lftagpair0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lfTagsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTags)
        var lfTagsDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsContainer = lfTagsContainer {
            lfTagsDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsContainer {
                if let structure0 = structure0 {
                    lfTagsDecoded0?.append(structure0)
                }
            }
        }
        lfTags = lfTagsDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure containing the name of a column resource and the LF-tags attached to it.
    public struct ColumnLFTag: Swift.Equatable {
        /// The LF-tags attached to a column resource.
        public var lfTags: [LakeFormationClientTypes.LFTagPair]?
        /// The name of a column resource.
        public var name: Swift.String?

        public init(
            lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
            name: Swift.String? = nil
        )
        {
            self.lfTags = lfTags
            self.name = name
        }
    }

}

extension LakeFormationClientTypes.ColumnWildcard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludedColumnNames = "ExcludedColumnNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedColumnNames = excludedColumnNames {
            var excludedColumnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedColumnNames)
            for namestring0 in excludedColumnNames {
                try excludedColumnNamesContainer.encode(namestring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludedColumnNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedColumnNames)
        var excludedColumnNamesDecoded0:[Swift.String]? = nil
        if let excludedColumnNamesContainer = excludedColumnNamesContainer {
            excludedColumnNamesDecoded0 = [Swift.String]()
            for string0 in excludedColumnNamesContainer {
                if let string0 = string0 {
                    excludedColumnNamesDecoded0?.append(string0)
                }
            }
        }
        excludedColumnNames = excludedColumnNamesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A wildcard object, consisting of an optional list of excluded column names or indexes.
    public struct ColumnWildcard: Swift.Equatable {
        /// Excludes column names. Any column with this name will be excluded.
        public var excludedColumnNames: [Swift.String]?

        public init(
            excludedColumnNames: [Swift.String]? = nil
        )
        {
            self.excludedColumnNames = excludedColumnNames
        }
    }

}

extension CommitTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension CommitTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CommitTransaction"
    }
}

public struct CommitTransactionInput: Swift.Equatable {
    /// The transaction to commit.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct CommitTransactionInputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension CommitTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension CommitTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CommitTransactionOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

public struct CommitTransactionOutput: Swift.Equatable {
    /// The status of the transaction.
    public var transactionStatus: LakeFormationClientTypes.TransactionStatus?

    public init(
        transactionStatus: LakeFormationClientTypes.TransactionStatus? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct CommitTransactionOutputBody: Swift.Equatable {
    let transactionStatus: LakeFormationClientTypes.TransactionStatus?
}

extension CommitTransactionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus = "TransactionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TransactionStatus.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

enum CommitTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCanceledException": return try await TransactionCanceledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case between
        case contains
        case eq
        case ge
        case gt
        case `in`
        case le
        case lt
        case ne
        case notContains
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith,
                .between,
                .contains,
                .eq,
                .ge,
                .gt,
                .in,
                .le,
                .lt,
                .ne,
                .notContains,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .eq: return "EQ"
            case .ge: return "GE"
            case .gt: return "GT"
            case .in: return "IN"
            case .le: return "LE"
            case .lt: return "LT"
            case .ne: return "NE"
            case .notContains: return "NOT_CONTAINS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Two processes are trying to modify a resource simultaneously.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDataCellsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableData = "TableData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableData = self.tableData {
            try encodeContainer.encode(tableData, forKey: .tableData)
        }
    }
}

extension CreateDataCellsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateDataCellsFilter"
    }
}

public struct CreateDataCellsFilterInput: Swift.Equatable {
    /// A DataCellsFilter structure containing information about the data cells filter.
    /// This member is required.
    public var tableData: LakeFormationClientTypes.DataCellsFilter?

    public init(
        tableData: LakeFormationClientTypes.DataCellsFilter? = nil
    )
    {
        self.tableData = tableData
    }
}

struct CreateDataCellsFilterInputBody: Swift.Equatable {
    let tableData: LakeFormationClientTypes.DataCellsFilter?
}

extension CreateDataCellsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableData = "TableData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDataDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataCellsFilter.self, forKey: .tableData)
        tableData = tableDataDecoded
    }
}

extension CreateDataCellsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateDataCellsFilterOutput: Swift.Equatable {

    public init() { }
}

enum CreateDataCellsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNumberLimitExceededException": return try await ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLFTagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for lftagvalue0 in tagValues {
                try tagValuesContainer.encode(lftagvalue0)
            }
        }
    }
}

extension CreateLFTagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLFTag"
    }
}

public struct CreateLFTagInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag.
    /// This member is required.
    public var tagKey: Swift.String?
    /// A list of possible values an attribute can take.
    /// This member is required.
    public var tagValues: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

struct CreateLFTagInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let tagKey: Swift.String?
    let tagValues: [Swift.String]?
}

extension CreateLFTagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension CreateLFTagOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateLFTagOutput: Swift.Equatable {

    public init() { }
}

enum CreateLFTagOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNumberLimitExceededException": return try await ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLakeFormationIdentityCenterConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case externalFiltering = "ExternalFiltering"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let externalFiltering = self.externalFiltering {
            try encodeContainer.encode(externalFiltering, forKey: .externalFiltering)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension CreateLakeFormationIdentityCenterConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLakeFormationIdentityCenterConfiguration"
    }
}

public struct CreateLakeFormationIdentityCenterConfigurationInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, view definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of the account IDs of Amazon Web Services accounts of third-party applications that are allowed to to access data managed by Lake Formation.
    public var externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
    /// The ARN of the IAM Identity Center instance for which the operation will be executed. For more information about ARNs, see Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.externalFiltering = externalFiltering
        self.instanceArn = instanceArn
    }
}

struct CreateLakeFormationIdentityCenterConfigurationInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let instanceArn: Swift.String?
    let externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
}

extension CreateLakeFormationIdentityCenterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case externalFiltering = "ExternalFiltering"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let externalFilteringDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ExternalFilteringConfiguration.self, forKey: .externalFiltering)
        externalFiltering = externalFilteringDecoded
    }
}

extension CreateLakeFormationIdentityCenterConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLakeFormationIdentityCenterConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
        } else {
            self.applicationArn = nil
        }
    }
}

public struct CreateLakeFormationIdentityCenterConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the integrated application.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

struct CreateLakeFormationIdentityCenterConfigurationOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
}

extension CreateLakeFormationIdentityCenterConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

enum CreateLakeFormationIdentityCenterConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLakeFormationOptInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension CreateLakeFormationOptInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLakeFormationOptIn"
    }
}

public struct CreateLakeFormationOptInInput: Swift.Equatable {
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A structure for the resource.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.principal = principal
        self.resource = resource
    }
}

struct CreateLakeFormationOptInInputBody: Swift.Equatable {
    let principal: LakeFormationClientTypes.DataLakePrincipal?
    let resource: LakeFormationClientTypes.Resource?
}

extension CreateLakeFormationOptInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principal = "Principal"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension CreateLakeFormationOptInOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateLakeFormationOptInOutput: Swift.Equatable {

    public init() { }
}

enum CreateLakeFormationOptInOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.DataCellsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnNames = "ColumnNames"
        case columnWildcard = "ColumnWildcard"
        case databaseName = "DatabaseName"
        case name = "Name"
        case rowFilter = "RowFilter"
        case tableCatalogId = "TableCatalogId"
        case tableName = "TableName"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for namestring0 in columnNames {
                try columnNamesContainer.encode(namestring0)
            }
        }
        if let columnWildcard = self.columnWildcard {
            try encodeContainer.encode(columnWildcard, forKey: .columnWildcard)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowFilter = self.rowFilter {
            try encodeContainer.encode(rowFilter, forKey: .rowFilter)
        }
        if let tableCatalogId = self.tableCatalogId {
            try encodeContainer.encode(tableCatalogId, forKey: .tableCatalogId)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableCatalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableCatalogId)
        tableCatalogId = tableCatalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let rowFilterDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.RowFilter.self, forKey: .rowFilter)
        rowFilter = rowFilterDecoded
        let columnNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[Swift.String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [Swift.String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
        let columnWildcardDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ColumnWildcard.self, forKey: .columnWildcard)
        columnWildcard = columnWildcardDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure that describes certain columns on certain rows.
    public struct DataCellsFilter: Swift.Equatable {
        /// A list of column names and/or nested column attributes. When specifying nested attributes, use a qualified dot (.) delimited format such as "address"."zip". Nested attributes within this list may not exceed a depth of 5.
        public var columnNames: [Swift.String]?
        /// A wildcard with exclusions. You must specify either a ColumnNames list or the ColumnWildCard.
        public var columnWildcard: LakeFormationClientTypes.ColumnWildcard?
        /// A database in the Glue Data Catalog.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name given by the user to the data filter cell.
        /// This member is required.
        public var name: Swift.String?
        /// A PartiQL predicate.
        public var rowFilter: LakeFormationClientTypes.RowFilter?
        /// The ID of the catalog to which the table belongs.
        /// This member is required.
        public var tableCatalogId: Swift.String?
        /// A table in the database.
        /// This member is required.
        public var tableName: Swift.String?
        /// The ID of the data cells filter version.
        public var versionId: Swift.String?

        public init(
            columnNames: [Swift.String]? = nil,
            columnWildcard: LakeFormationClientTypes.ColumnWildcard? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            rowFilter: LakeFormationClientTypes.RowFilter? = nil,
            tableCatalogId: Swift.String? = nil,
            tableName: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.columnNames = columnNames
            self.columnWildcard = columnWildcard
            self.databaseName = databaseName
            self.name = name
            self.rowFilter = rowFilter
            self.tableCatalogId = tableCatalogId
            self.tableName = tableName
            self.versionId = versionId
        }
    }

}

extension LakeFormationClientTypes.DataCellsFilterResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableCatalogId = "TableCatalogId"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableCatalogId = self.tableCatalogId {
            try encodeContainer.encode(tableCatalogId, forKey: .tableCatalogId)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableCatalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableCatalogId)
        tableCatalogId = tableCatalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure for a data cells filter resource.
    public struct DataCellsFilterResource: Swift.Equatable {
        /// A database in the Glue Data Catalog.
        public var databaseName: Swift.String?
        /// The name of the data cells filter.
        public var name: Swift.String?
        /// The ID of the catalog to which the table belongs.
        public var tableCatalogId: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            tableCatalogId: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.name = name
            self.tableCatalogId = tableCatalogId
            self.tableName = tableName
        }
    }

}

extension LakeFormationClientTypes.DataLakePrincipal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLakePrincipalIdentifier = "DataLakePrincipalIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLakePrincipalIdentifier = self.dataLakePrincipalIdentifier {
            try encodeContainer.encode(dataLakePrincipalIdentifier, forKey: .dataLakePrincipalIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakePrincipalIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLakePrincipalIdentifier)
        dataLakePrincipalIdentifier = dataLakePrincipalIdentifierDecoded
    }
}

extension LakeFormationClientTypes {
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    public struct DataLakePrincipal: Swift.Equatable {
        /// An identifier for the Lake Formation principal.
        public var dataLakePrincipalIdentifier: Swift.String?

        public init(
            dataLakePrincipalIdentifier: Swift.String? = nil
        )
        {
            self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
        }
    }

}

extension LakeFormationClientTypes {
    public enum DataLakeResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case catalog
        case database
        case dataLocation
        case lfTag
        case lfTagPolicy
        case lfTagPolicyDatabase
        case lfTagPolicyTable
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLakeResourceType] {
            return [
                .catalog,
                .database,
                .dataLocation,
                .lfTag,
                .lfTagPolicy,
                .lfTagPolicyDatabase,
                .lfTagPolicyTable,
                .table,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .catalog: return "CATALOG"
            case .database: return "DATABASE"
            case .dataLocation: return "DATA_LOCATION"
            case .lfTag: return "LF_TAG"
            case .lfTagPolicy: return "LF_TAG_POLICY"
            case .lfTagPolicyDatabase: return "LF_TAG_POLICY_DATABASE"
            case .lfTagPolicyTable: return "LF_TAG_POLICY_TABLE"
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLakeResourceType(rawValue: rawValue) ?? DataLakeResourceType.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes.DataLakeSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalDataFiltering = "AllowExternalDataFiltering"
        case allowFullTableExternalDataAccess = "AllowFullTableExternalDataAccess"
        case authorizedSessionTagValueList = "AuthorizedSessionTagValueList"
        case createDatabaseDefaultPermissions = "CreateDatabaseDefaultPermissions"
        case createTableDefaultPermissions = "CreateTableDefaultPermissions"
        case dataLakeAdmins = "DataLakeAdmins"
        case externalDataFilteringAllowList = "ExternalDataFilteringAllowList"
        case parameters = "Parameters"
        case readOnlyAdmins = "ReadOnlyAdmins"
        case trustedResourceOwners = "TrustedResourceOwners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalDataFiltering = self.allowExternalDataFiltering {
            try encodeContainer.encode(allowExternalDataFiltering, forKey: .allowExternalDataFiltering)
        }
        if let allowFullTableExternalDataAccess = self.allowFullTableExternalDataAccess {
            try encodeContainer.encode(allowFullTableExternalDataAccess, forKey: .allowFullTableExternalDataAccess)
        }
        if let authorizedSessionTagValueList = authorizedSessionTagValueList {
            var authorizedSessionTagValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedSessionTagValueList)
            for namestring0 in authorizedSessionTagValueList {
                try authorizedSessionTagValueListContainer.encode(namestring0)
            }
        }
        if let createDatabaseDefaultPermissions = createDatabaseDefaultPermissions {
            var createDatabaseDefaultPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createDatabaseDefaultPermissions)
            for principalpermissions0 in createDatabaseDefaultPermissions {
                try createDatabaseDefaultPermissionsContainer.encode(principalpermissions0)
            }
        }
        if let createTableDefaultPermissions = createTableDefaultPermissions {
            var createTableDefaultPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createTableDefaultPermissions)
            for principalpermissions0 in createTableDefaultPermissions {
                try createTableDefaultPermissionsContainer.encode(principalpermissions0)
            }
        }
        if let dataLakeAdmins = dataLakeAdmins {
            var dataLakeAdminsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataLakeAdmins)
            for datalakeprincipal0 in dataLakeAdmins {
                try dataLakeAdminsContainer.encode(datalakeprincipal0)
            }
        }
        if let externalDataFilteringAllowList = externalDataFilteringAllowList {
            var externalDataFilteringAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalDataFilteringAllowList)
            for datalakeprincipal0 in externalDataFilteringAllowList {
                try externalDataFilteringAllowListContainer.encode(datalakeprincipal0)
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let readOnlyAdmins = readOnlyAdmins {
            var readOnlyAdminsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readOnlyAdmins)
            for datalakeprincipal0 in readOnlyAdmins {
                try readOnlyAdminsContainer.encode(datalakeprincipal0)
            }
        }
        if let trustedResourceOwners = trustedResourceOwners {
            var trustedResourceOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustedResourceOwners)
            for catalogidstring0 in trustedResourceOwners {
                try trustedResourceOwnersContainer.encode(catalogidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakeAdminsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.DataLakePrincipal?].self, forKey: .dataLakeAdmins)
        var dataLakeAdminsDecoded0:[LakeFormationClientTypes.DataLakePrincipal]? = nil
        if let dataLakeAdminsContainer = dataLakeAdminsContainer {
            dataLakeAdminsDecoded0 = [LakeFormationClientTypes.DataLakePrincipal]()
            for structure0 in dataLakeAdminsContainer {
                if let structure0 = structure0 {
                    dataLakeAdminsDecoded0?.append(structure0)
                }
            }
        }
        dataLakeAdmins = dataLakeAdminsDecoded0
        let readOnlyAdminsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.DataLakePrincipal?].self, forKey: .readOnlyAdmins)
        var readOnlyAdminsDecoded0:[LakeFormationClientTypes.DataLakePrincipal]? = nil
        if let readOnlyAdminsContainer = readOnlyAdminsContainer {
            readOnlyAdminsDecoded0 = [LakeFormationClientTypes.DataLakePrincipal]()
            for structure0 in readOnlyAdminsContainer {
                if let structure0 = structure0 {
                    readOnlyAdminsDecoded0?.append(structure0)
                }
            }
        }
        readOnlyAdmins = readOnlyAdminsDecoded0
        let createDatabaseDefaultPermissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PrincipalPermissions?].self, forKey: .createDatabaseDefaultPermissions)
        var createDatabaseDefaultPermissionsDecoded0:[LakeFormationClientTypes.PrincipalPermissions]? = nil
        if let createDatabaseDefaultPermissionsContainer = createDatabaseDefaultPermissionsContainer {
            createDatabaseDefaultPermissionsDecoded0 = [LakeFormationClientTypes.PrincipalPermissions]()
            for structure0 in createDatabaseDefaultPermissionsContainer {
                if let structure0 = structure0 {
                    createDatabaseDefaultPermissionsDecoded0?.append(structure0)
                }
            }
        }
        createDatabaseDefaultPermissions = createDatabaseDefaultPermissionsDecoded0
        let createTableDefaultPermissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PrincipalPermissions?].self, forKey: .createTableDefaultPermissions)
        var createTableDefaultPermissionsDecoded0:[LakeFormationClientTypes.PrincipalPermissions]? = nil
        if let createTableDefaultPermissionsContainer = createTableDefaultPermissionsContainer {
            createTableDefaultPermissionsDecoded0 = [LakeFormationClientTypes.PrincipalPermissions]()
            for structure0 in createTableDefaultPermissionsContainer {
                if let structure0 = structure0 {
                    createTableDefaultPermissionsDecoded0?.append(structure0)
                }
            }
        }
        createTableDefaultPermissions = createTableDefaultPermissionsDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let trustedResourceOwnersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustedResourceOwners)
        var trustedResourceOwnersDecoded0:[Swift.String]? = nil
        if let trustedResourceOwnersContainer = trustedResourceOwnersContainer {
            trustedResourceOwnersDecoded0 = [Swift.String]()
            for string0 in trustedResourceOwnersContainer {
                if let string0 = string0 {
                    trustedResourceOwnersDecoded0?.append(string0)
                }
            }
        }
        trustedResourceOwners = trustedResourceOwnersDecoded0
        let allowExternalDataFilteringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalDataFiltering)
        allowExternalDataFiltering = allowExternalDataFilteringDecoded
        let allowFullTableExternalDataAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowFullTableExternalDataAccess)
        allowFullTableExternalDataAccess = allowFullTableExternalDataAccessDecoded
        let externalDataFilteringAllowListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.DataLakePrincipal?].self, forKey: .externalDataFilteringAllowList)
        var externalDataFilteringAllowListDecoded0:[LakeFormationClientTypes.DataLakePrincipal]? = nil
        if let externalDataFilteringAllowListContainer = externalDataFilteringAllowListContainer {
            externalDataFilteringAllowListDecoded0 = [LakeFormationClientTypes.DataLakePrincipal]()
            for structure0 in externalDataFilteringAllowListContainer {
                if let structure0 = structure0 {
                    externalDataFilteringAllowListDecoded0?.append(structure0)
                }
            }
        }
        externalDataFilteringAllowList = externalDataFilteringAllowListDecoded0
        let authorizedSessionTagValueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedSessionTagValueList)
        var authorizedSessionTagValueListDecoded0:[Swift.String]? = nil
        if let authorizedSessionTagValueListContainer = authorizedSessionTagValueListContainer {
            authorizedSessionTagValueListDecoded0 = [Swift.String]()
            for string0 in authorizedSessionTagValueListContainer {
                if let string0 = string0 {
                    authorizedSessionTagValueListDecoded0?.append(string0)
                }
            }
        }
        authorizedSessionTagValueList = authorizedSessionTagValueListDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure representing a list of Lake Formation principals designated as data lake administrators and lists of principal permission entries for default create database and default create table permissions.
    public struct DataLakeSettings: Swift.Equatable {
        /// Whether to allow Amazon EMR clusters to access data managed by Lake Formation. If true, you allow Amazon EMR clusters to access data in Amazon S3 locations that are registered with Lake Formation. If false or null, no Amazon EMR clusters will be able to access data in Amazon S3 locations that are registered with Lake Formation. For more information, see [(Optional) Allow external data filtering](https://docs.aws.amazon.com/lake-formation/latest/dg/initial-LF-setup.html#external-data-filter).
        public var allowExternalDataFiltering: Swift.Bool?
        /// Whether to allow a third-party query engine to get data access credentials without session tags when a caller has full data access permissions.
        public var allowFullTableExternalDataAccess: Swift.Bool?
        /// Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation's administrative APIs.
        public var authorizedSessionTagValueList: [Swift.String]?
        /// Specifies whether access control on newly created database is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS. For more information, see [Changing the Default Security Settings for Your Data Lake](https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html).
        public var createDatabaseDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]?
        /// Specifies whether access control on newly created table is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS. For more information, see [Changing the Default Security Settings for Your Data Lake](https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html).
        public var createTableDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]?
        /// A list of Lake Formation principals. Supported principals are IAM users or IAM roles.
        public var dataLakeAdmins: [LakeFormationClientTypes.DataLakePrincipal]?
        /// A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.>
        public var externalDataFilteringAllowList: [LakeFormationClientTypes.DataLakePrincipal]?
        /// A key-value map that provides an additional configuration on your data lake. CROSS_ACCOUNT_VERSION is the key you can configure in the Parameters field. Accepted values for the CrossAccountVersion key are 1, 2, 3, and 4.
        public var parameters: [Swift.String:Swift.String]?
        /// A list of Lake Formation principals with only view access to the resources, without the ability to make changes. Supported principals are IAM users or IAM roles.
        public var readOnlyAdmins: [LakeFormationClientTypes.DataLakePrincipal]?
        /// A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log. You may want to specify this property when you are in a high-trust boundary, such as the same team or company.
        public var trustedResourceOwners: [Swift.String]?

        public init(
            allowExternalDataFiltering: Swift.Bool? = nil,
            allowFullTableExternalDataAccess: Swift.Bool? = nil,
            authorizedSessionTagValueList: [Swift.String]? = nil,
            createDatabaseDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]? = nil,
            createTableDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]? = nil,
            dataLakeAdmins: [LakeFormationClientTypes.DataLakePrincipal]? = nil,
            externalDataFilteringAllowList: [LakeFormationClientTypes.DataLakePrincipal]? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            readOnlyAdmins: [LakeFormationClientTypes.DataLakePrincipal]? = nil,
            trustedResourceOwners: [Swift.String]? = nil
        )
        {
            self.allowExternalDataFiltering = allowExternalDataFiltering
            self.allowFullTableExternalDataAccess = allowFullTableExternalDataAccess
            self.authorizedSessionTagValueList = authorizedSessionTagValueList
            self.createDatabaseDefaultPermissions = createDatabaseDefaultPermissions
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.dataLakeAdmins = dataLakeAdmins
            self.externalDataFilteringAllowList = externalDataFilteringAllowList
            self.parameters = parameters
            self.readOnlyAdmins = readOnlyAdmins
            self.trustedResourceOwners = trustedResourceOwners
        }
    }

}

extension LakeFormationClientTypes.DataLocationResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure for a data location object where permissions are granted or revoked.
    public struct DataLocationResource: Swift.Equatable {
        /// The identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the data location resource.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.resourceArn = resourceArn
        }
    }

}

extension LakeFormationClientTypes.DatabaseResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure for the database object.
    public struct DatabaseResource: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The name of the database resource. Unique to the Data Catalog.
        /// This member is required.
        public var name: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.name = name
        }
    }

}

extension DeleteDataCellsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableCatalogId = "TableCatalogId"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableCatalogId = self.tableCatalogId {
            try encodeContainer.encode(tableCatalogId, forKey: .tableCatalogId)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension DeleteDataCellsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteDataCellsFilter"
    }
}

public struct DeleteDataCellsFilterInput: Swift.Equatable {
    /// A database in the Glue Data Catalog.
    public var databaseName: Swift.String?
    /// The name given by the user to the data filter cell.
    public var name: Swift.String?
    /// The ID of the catalog to which the table belongs.
    public var tableCatalogId: Swift.String?
    /// A table in the database.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        name: Swift.String? = nil,
        tableCatalogId: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.name = name
        self.tableCatalogId = tableCatalogId
        self.tableName = tableName
    }
}

struct DeleteDataCellsFilterInputBody: Swift.Equatable {
    let tableCatalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let name: Swift.String?
}

extension DeleteDataCellsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableCatalogId = "TableCatalogId"
        case tableName = "TableName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableCatalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableCatalogId)
        tableCatalogId = tableCatalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteDataCellsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataCellsFilterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataCellsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLFTagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }
}

extension DeleteLFTagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLFTag"
    }
}

public struct DeleteLFTagInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag to delete.
    /// This member is required.
    public var tagKey: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
    }
}

struct DeleteLFTagInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let tagKey: Swift.String?
}

extension DeleteLFTagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
    }
}

extension DeleteLFTagOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLFTagOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLFTagOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLakeFormationIdentityCenterConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

extension DeleteLakeFormationIdentityCenterConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLakeFormationIdentityCenterConfiguration"
    }
}

public struct DeleteLakeFormationIdentityCenterConfigurationInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, view definition, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct DeleteLakeFormationIdentityCenterConfigurationInputBody: Swift.Equatable {
    let catalogId: Swift.String?
}

extension DeleteLakeFormationIdentityCenterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension DeleteLakeFormationIdentityCenterConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLakeFormationIdentityCenterConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLakeFormationIdentityCenterConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLakeFormationOptInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension DeleteLakeFormationOptInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLakeFormationOptIn"
    }
}

public struct DeleteLakeFormationOptInInput: Swift.Equatable {
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A structure for the resource.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.principal = principal
        self.resource = resource
    }
}

struct DeleteLakeFormationOptInInputBody: Swift.Equatable {
    let principal: LakeFormationClientTypes.DataLakePrincipal?
    let resource: LakeFormationClientTypes.Resource?
}

extension DeleteLakeFormationOptInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principal = "Principal"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension DeleteLakeFormationOptInOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLakeFormationOptInOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLakeFormationOptInOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.DeleteObjectInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case partitionValues = "PartitionValues"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for partitionvaluestring0 in partitionValues {
                try partitionValuesContainer.encode(partitionvaluestring0)
            }
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let partitionValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[Swift.String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [Swift.String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// An object to delete from the governed table.
    public struct DeleteObjectInput: Swift.Equatable {
        /// The Amazon S3 ETag of the object. Returned by GetTableObjects for validation and used to identify changes to the underlying data.
        public var eTag: Swift.String?
        /// A list of partition values for the object. A value must be specified for each partition key associated with the governed table.
        public var partitionValues: [Swift.String]?
        /// The Amazon S3 location of the object to delete.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            partitionValues: [Swift.String]? = nil,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.partitionValues = partitionValues
            self.uri = uri
        }
    }

}

extension DeleteObjectsOnCancelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case objects = "Objects"
        case tableName = "TableName"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let objects = objects {
            var objectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objects)
            for virtualobject0 in objects {
                try objectsContainer.encode(virtualobject0)
            }
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension DeleteObjectsOnCancelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteObjectsOnCancel"
    }
}

public struct DeleteObjectsOnCancelInput: Swift.Equatable {
    /// The Glue data catalog that contains the governed table. Defaults to the current account ID.
    public var catalogId: Swift.String?
    /// The database that contains the governed table.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of VirtualObject structures, which indicates the Amazon S3 objects to be deleted if the transaction cancels.
    /// This member is required.
    public var objects: [LakeFormationClientTypes.VirtualObject]?
    /// The name of the governed table.
    /// This member is required.
    public var tableName: Swift.String?
    /// ID of the transaction that the writes occur in.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        objects: [LakeFormationClientTypes.VirtualObject]? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.objects = objects
        self.tableName = tableName
        self.transactionId = transactionId
    }
}

struct DeleteObjectsOnCancelInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let transactionId: Swift.String?
    let objects: [LakeFormationClientTypes.VirtualObject]?
}

extension DeleteObjectsOnCancelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case objects = "Objects"
        case tableName = "TableName"
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let objectsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.VirtualObject?].self, forKey: .objects)
        var objectsDecoded0:[LakeFormationClientTypes.VirtualObject]? = nil
        if let objectsContainer = objectsContainer {
            objectsDecoded0 = [LakeFormationClientTypes.VirtualObject]()
            for structure0 in objectsContainer {
                if let structure0 = structure0 {
                    objectsDecoded0?.append(structure0)
                }
            }
        }
        objects = objectsDecoded0
    }
}

extension DeleteObjectsOnCancelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteObjectsOnCancelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteObjectsOnCancelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCanceledException": return try await TransactionCanceledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommittedException": return try await TransactionCommittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeregisterResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeregisterResource"
    }
}

public struct DeregisterResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to deregister.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeregisterResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeregisterResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeregisterResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterResourceOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLakeFormationIdentityCenterConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

extension DescribeLakeFormationIdentityCenterConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeLakeFormationIdentityCenterConfiguration"
    }
}

public struct DescribeLakeFormationIdentityCenterConfigurationInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct DescribeLakeFormationIdentityCenterConfigurationInputBody: Swift.Equatable {
    let catalogId: Swift.String?
}

extension DescribeLakeFormationIdentityCenterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension DescribeLakeFormationIdentityCenterConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLakeFormationIdentityCenterConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.catalogId = output.catalogId
            self.externalFiltering = output.externalFiltering
            self.instanceArn = output.instanceArn
        } else {
            self.applicationArn = nil
            self.catalogId = nil
            self.externalFiltering = nil
            self.instanceArn = nil
        }
    }
}

public struct DescribeLakeFormationIdentityCenterConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the integrated application.
    public var applicationArn: Swift.String?
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// Indicates if external filtering is enabled.
    public var externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
    /// The Amazon Resource Name (ARN) of the connection.
    public var instanceArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        catalogId: Swift.String? = nil,
        externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.catalogId = catalogId
        self.externalFiltering = externalFiltering
        self.instanceArn = instanceArn
    }
}

struct DescribeLakeFormationIdentityCenterConfigurationOutputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let instanceArn: Swift.String?
    let applicationArn: Swift.String?
    let externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
}

extension DescribeLakeFormationIdentityCenterConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case catalogId = "CatalogId"
        case externalFiltering = "ExternalFiltering"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let externalFilteringDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ExternalFilteringConfiguration.self, forKey: .externalFiltering)
        externalFiltering = externalFilteringDecoded
    }
}

enum DescribeLakeFormationIdentityCenterConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DescribeResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeResource"
    }
}

public struct DescribeResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DescribeResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceInfo = output.resourceInfo
        } else {
            self.resourceInfo = nil
        }
    }
}

public struct DescribeResourceOutput: Swift.Equatable {
    /// A structure containing information about an Lake Formation resource.
    public var resourceInfo: LakeFormationClientTypes.ResourceInfo?

    public init(
        resourceInfo: LakeFormationClientTypes.ResourceInfo? = nil
    )
    {
        self.resourceInfo = resourceInfo
    }
}

struct DescribeResourceOutputBody: Swift.Equatable {
    let resourceInfo: LakeFormationClientTypes.ResourceInfo?
}

extension DescribeResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceInfo = "ResourceInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInfoDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ResourceInfo.self, forKey: .resourceInfo)
        resourceInfo = resourceInfoDecoded
    }
}

enum DescribeResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension DescribeTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeTransaction"
    }
}

public struct DescribeTransactionInput: Swift.Equatable {
    /// The transaction for which to return status.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct DescribeTransactionInputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension DescribeTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension DescribeTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTransactionOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionDescription = output.transactionDescription
        } else {
            self.transactionDescription = nil
        }
    }
}

public struct DescribeTransactionOutput: Swift.Equatable {
    /// Returns a TransactionDescription object containing information about the transaction.
    public var transactionDescription: LakeFormationClientTypes.TransactionDescription?

    public init(
        transactionDescription: LakeFormationClientTypes.TransactionDescription? = nil
    )
    {
        self.transactionDescription = transactionDescription
    }
}

struct DescribeTransactionOutputBody: Swift.Equatable {
    let transactionDescription: LakeFormationClientTypes.TransactionDescription?
}

extension DescribeTransactionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionDescription = "TransactionDescription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionDescriptionDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TransactionDescription.self, forKey: .transactionDescription)
        transactionDescription = transactionDescriptionDecoded
    }
}

enum DescribeTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.DetailsMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShare = "ResourceShare"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShare = resourceShare {
            var resourceShareContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShare)
            for ramresourcesharearn0 in resourceShare {
                try resourceShareContainer.encode(ramresourcesharearn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShare)
        var resourceShareDecoded0:[Swift.String]? = nil
        if let resourceShareContainer = resourceShareContainer {
            resourceShareDecoded0 = [Swift.String]()
            for string0 in resourceShareContainer {
                if let string0 = string0 {
                    resourceShareDecoded0?.append(string0)
                }
            }
        }
        resourceShare = resourceShareDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure containing the additional details to be returned in the AdditionalDetails attribute of PrincipalResourcePermissions. If a catalog resource is shared through Resource Access Manager (RAM), then there will exist a corresponding RAM resource share ARN.
    public struct DetailsMap: Swift.Equatable {
        /// A resource share ARN for a catalog resource shared through RAM.
        public var resourceShare: [Swift.String]?

        public init(
            resourceShare: [Swift.String]? = nil
        )
        {
            self.resourceShare = resourceShare
        }
    }

}

extension LakeFormationClientTypes {
    public enum EnableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnableStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnableStatus(rawValue: rawValue) ?? EnableStatus.sdkUnknown(rawValue)
        }
    }
}

extension EntityNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified entity does not exist.
public struct EntityNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntityNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension LakeFormationClientTypes {
    /// Contains details about an error.
    public struct ErrorDetail: Swift.Equatable {
        /// The code associated with this error.
        public var errorCode: Swift.String?
        /// A message describing the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension LakeFormationClientTypes.ExecutionStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageExecutionTimeMillis = "AverageExecutionTimeMillis"
        case dataScannedBytes = "DataScannedBytes"
        case workUnitsExecutedCount = "WorkUnitsExecutedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if averageExecutionTimeMillis != 0 {
            try encodeContainer.encode(averageExecutionTimeMillis, forKey: .averageExecutionTimeMillis)
        }
        if dataScannedBytes != 0 {
            try encodeContainer.encode(dataScannedBytes, forKey: .dataScannedBytes)
        }
        if workUnitsExecutedCount != 0 {
            try encodeContainer.encode(workUnitsExecutedCount, forKey: .workUnitsExecutedCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageExecutionTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .averageExecutionTimeMillis) ?? 0
        averageExecutionTimeMillis = averageExecutionTimeMillisDecoded
        let dataScannedBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataScannedBytes) ?? 0
        dataScannedBytes = dataScannedBytesDecoded
        let workUnitsExecutedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workUnitsExecutedCount) ?? 0
        workUnitsExecutedCount = workUnitsExecutedCountDecoded
    }
}

extension LakeFormationClientTypes {
    /// Statistics related to the processing of a query statement.
    public struct ExecutionStatistics: Swift.Equatable {
        /// The average time the request took to be executed.
        public var averageExecutionTimeMillis: Swift.Int
        /// The amount of data that was scanned in bytes.
        public var dataScannedBytes: Swift.Int
        /// The number of work units executed.
        public var workUnitsExecutedCount: Swift.Int

        public init(
            averageExecutionTimeMillis: Swift.Int = 0,
            dataScannedBytes: Swift.Int = 0,
            workUnitsExecutedCount: Swift.Int = 0
        )
        {
            self.averageExecutionTimeMillis = averageExecutionTimeMillis
            self.dataScannedBytes = dataScannedBytes
            self.workUnitsExecutedCount = workUnitsExecutedCount
        }
    }

}

extension ExpiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error where the query request expired.
public struct ExpiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ExpiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExtendTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension ExtendTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ExtendTransaction"
    }
}

public struct ExtendTransactionInput: Swift.Equatable {
    /// The transaction to extend.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct ExtendTransactionInputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension ExtendTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ExtendTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ExtendTransactionOutput: Swift.Equatable {

    public init() { }
}

enum ExtendTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCanceledException": return try await TransactionCanceledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommitInProgressException": return try await TransactionCommitInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommittedException": return try await TransactionCommittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.ExternalFilteringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedTargets = "AuthorizedTargets"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedTargets = authorizedTargets {
            var authorizedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedTargets)
            for scopetarget0 in authorizedTargets {
                try authorizedTargetsContainer.encode(scopetarget0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.EnableStatus.self, forKey: .status)
        status = statusDecoded
        let authorizedTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedTargets)
        var authorizedTargetsDecoded0:[Swift.String]? = nil
        if let authorizedTargetsContainer = authorizedTargetsContainer {
            authorizedTargetsDecoded0 = [Swift.String]()
            for string0 in authorizedTargetsContainer {
                if let string0 = string0 {
                    authorizedTargetsDecoded0?.append(string0)
                }
            }
        }
        authorizedTargets = authorizedTargetsDecoded0
    }
}

extension LakeFormationClientTypes {
    /// Configuration for enabling external data filtering for third-party applications to access data managed by Lake Formation .
    public struct ExternalFilteringConfiguration: Swift.Equatable {
        /// List of third-party application ARNs integrated with Lake Formation.
        /// This member is required.
        public var authorizedTargets: [Swift.String]?
        /// Allows to enable or disable the third-party applications that are allowed to access data managed by Lake Formation.
        /// This member is required.
        public var status: LakeFormationClientTypes.EnableStatus?

        public init(
            authorizedTargets: [Swift.String]? = nil,
            status: LakeFormationClientTypes.EnableStatus? = nil
        )
        {
            self.authorizedTargets = authorizedTargets
            self.status = status
        }
    }

}

extension LakeFormationClientTypes {
    public enum FieldNameString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastModified
        case resourceArn
        case roleArn
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldNameString] {
            return [
                .lastModified,
                .resourceArn,
                .roleArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastModified: return "LAST_MODIFIED"
            case .resourceArn: return "RESOURCE_ARN"
            case .roleArn: return "ROLE_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldNameString(rawValue: rawValue) ?? FieldNameString.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes.FilterCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case field = "Field"
        case stringValueList = "StringValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let field = self.field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let stringValueList = stringValueList {
            var stringValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValueList)
            for stringvalue0 in stringValueList {
                try stringValueListContainer.encode(stringvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.FieldNameString.self, forKey: .field)
        field = fieldDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let stringValueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValueList)
        var stringValueListDecoded0:[Swift.String]? = nil
        if let stringValueListContainer = stringValueListContainer {
            stringValueListDecoded0 = [Swift.String]()
            for string0 in stringValueListContainer {
                if let string0 = string0 {
                    stringValueListDecoded0?.append(string0)
                }
            }
        }
        stringValueList = stringValueListDecoded0
    }
}

extension LakeFormationClientTypes {
    /// This structure describes the filtering of columns in a table based on a filter condition.
    public struct FilterCondition: Swift.Equatable {
        /// The comparison operator used in the filter condition.
        public var comparisonOperator: LakeFormationClientTypes.ComparisonOperator?
        /// The field to filter in the filter condition.
        public var field: LakeFormationClientTypes.FieldNameString?
        /// A string with values used in evaluating the filter condition.
        public var stringValueList: [Swift.String]?

        public init(
            comparisonOperator: LakeFormationClientTypes.ComparisonOperator? = nil,
            field: LakeFormationClientTypes.FieldNameString? = nil,
            stringValueList: [Swift.String]? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.field = field
            self.stringValueList = stringValueList
        }
    }

}

extension GetDataCellsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableCatalogId = "TableCatalogId"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableCatalogId = self.tableCatalogId {
            try encodeContainer.encode(tableCatalogId, forKey: .tableCatalogId)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetDataCellsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDataCellsFilter"
    }
}

public struct GetDataCellsFilterInput: Swift.Equatable {
    /// A database in the Glue Data Catalog.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name given by the user to the data filter cell.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the catalog to which the table belongs.
    /// This member is required.
    public var tableCatalogId: Swift.String?
    /// A table in the database.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        name: Swift.String? = nil,
        tableCatalogId: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.name = name
        self.tableCatalogId = tableCatalogId
        self.tableName = tableName
    }
}

struct GetDataCellsFilterInputBody: Swift.Equatable {
    let tableCatalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let name: Swift.String?
}

extension GetDataCellsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableCatalogId = "TableCatalogId"
        case tableName = "TableName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableCatalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableCatalogId)
        tableCatalogId = tableCatalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetDataCellsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataCellsFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataCellsFilter = output.dataCellsFilter
        } else {
            self.dataCellsFilter = nil
        }
    }
}

public struct GetDataCellsFilterOutput: Swift.Equatable {
    /// A structure that describes certain columns on certain rows.
    public var dataCellsFilter: LakeFormationClientTypes.DataCellsFilter?

    public init(
        dataCellsFilter: LakeFormationClientTypes.DataCellsFilter? = nil
    )
    {
        self.dataCellsFilter = dataCellsFilter
    }
}

struct GetDataCellsFilterOutputBody: Swift.Equatable {
    let dataCellsFilter: LakeFormationClientTypes.DataCellsFilter?
}

extension GetDataCellsFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCellsFilter = "DataCellsFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCellsFilterDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataCellsFilter.self, forKey: .dataCellsFilter)
        dataCellsFilter = dataCellsFilterDecoded
    }
}

enum GetDataCellsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataLakeSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
    }
}

extension GetDataLakeSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDataLakeSettings"
    }
}

public struct GetDataLakeSettingsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

struct GetDataLakeSettingsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
}

extension GetDataLakeSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
    }
}

extension GetDataLakeSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataLakeSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataLakeSettings = output.dataLakeSettings
        } else {
            self.dataLakeSettings = nil
        }
    }
}

public struct GetDataLakeSettingsOutput: Swift.Equatable {
    /// A structure representing a list of Lake Formation principals designated as data lake administrators.
    public var dataLakeSettings: LakeFormationClientTypes.DataLakeSettings?

    public init(
        dataLakeSettings: LakeFormationClientTypes.DataLakeSettings? = nil
    )
    {
        self.dataLakeSettings = dataLakeSettings
    }
}

struct GetDataLakeSettingsOutputBody: Swift.Equatable {
    let dataLakeSettings: LakeFormationClientTypes.DataLakeSettings?
}

extension GetDataLakeSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLakeSettings = "DataLakeSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakeSettingsDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakeSettings.self, forKey: .dataLakeSettings)
        dataLakeSettings = dataLakeSettingsDecoded
    }
}

enum GetDataLakeSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEffectivePermissionsForPathInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetEffectivePermissionsForPathInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetEffectivePermissionsForPath"
    }
}

public struct GetEffectivePermissionsForPathInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to get permissions.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct GetEffectivePermissionsForPathInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetEffectivePermissionsForPathInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEffectivePermissionsForPathOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEffectivePermissionsForPathOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct GetEffectivePermissionsForPathOutput: Swift.Equatable {
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// A list of the permissions for the specified table or database resource located at the path in Amazon S3.
    public var permissions: [LakeFormationClientTypes.PrincipalResourcePermissions]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [LakeFormationClientTypes.PrincipalResourcePermissions]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct GetEffectivePermissionsForPathOutputBody: Swift.Equatable {
    let permissions: [LakeFormationClientTypes.PrincipalResourcePermissions]?
    let nextToken: Swift.String?
}

extension GetEffectivePermissionsForPathOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PrincipalResourcePermissions?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.PrincipalResourcePermissions]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.PrincipalResourcePermissions]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetEffectivePermissionsForPathOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLFTagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }
}

extension GetLFTagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLFTag"
    }
}

public struct GetLFTagInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag.
    /// This member is required.
    public var tagKey: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
    }
}

struct GetLFTagInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let tagKey: Swift.String?
}

extension GetLFTagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
    }
}

extension GetLFTagOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLFTagOutputBody = try responseDecoder.decode(responseBody: data)
            self.catalogId = output.catalogId
            self.tagKey = output.tagKey
            self.tagValues = output.tagValues
        } else {
            self.catalogId = nil
            self.tagKey = nil
            self.tagValues = nil
        }
    }
}

public struct GetLFTagOutput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag.
    public var tagKey: Swift.String?
    /// A list of possible values an attribute can take.
    public var tagValues: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

struct GetLFTagOutputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let tagKey: Swift.String?
    let tagValues: [Swift.String]?
}

extension GetLFTagOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

enum GetLFTagOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension GetQueryStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetQueryState"
    }
}

public struct GetQueryStateInput: Swift.Equatable {
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct GetQueryStateInputBody: Swift.Equatable {
    let queryId: Swift.String?
}

extension GetQueryStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension GetQueryStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
            self.state = output.state
        } else {
            self.error = nil
            self.state = nil
        }
    }
}

/// A structure for the output.
public struct GetQueryStateOutput: Swift.Equatable {
    /// An error message when the operation fails.
    public var error: Swift.String?
    /// The state of a query previously submitted. The possible states are:
    ///
    /// * PENDING: the query is pending.
    ///
    /// * WORKUNITS_AVAILABLE: some work units are ready for retrieval and execution.
    ///
    /// * FINISHED: the query planning finished successfully, and all work units are ready for retrieval and execution.
    ///
    /// * ERROR: an error occurred with the query, such as an invalid query ID or a backend error.
    /// This member is required.
    public var state: LakeFormationClientTypes.QueryStateString?

    public init(
        error: Swift.String? = nil,
        state: LakeFormationClientTypes.QueryStateString? = nil
    )
    {
        self.error = error
        self.state = state
    }
}

struct GetQueryStateOutputBody: Swift.Equatable {
    let error: Swift.String?
    let state: LakeFormationClientTypes.QueryStateString?
}

extension GetQueryStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.QueryStateString.self, forKey: .state)
        state = stateDecoded
    }
}

enum GetQueryStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension GetQueryStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetQueryStatistics"
    }
}

public struct GetQueryStatisticsInput: Swift.Equatable {
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct GetQueryStatisticsInputBody: Swift.Equatable {
    let queryId: Swift.String?
}

extension GetQueryStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension GetQueryStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionStatistics = output.executionStatistics
            self.planningStatistics = output.planningStatistics
            self.querySubmissionTime = output.querySubmissionTime
        } else {
            self.executionStatistics = nil
            self.planningStatistics = nil
            self.querySubmissionTime = nil
        }
    }
}

public struct GetQueryStatisticsOutput: Swift.Equatable {
    /// An ExecutionStatistics structure containing execution statistics.
    public var executionStatistics: LakeFormationClientTypes.ExecutionStatistics?
    /// A PlanningStatistics structure containing query planning statistics.
    public var planningStatistics: LakeFormationClientTypes.PlanningStatistics?
    /// The time that the query was submitted.
    public var querySubmissionTime: ClientRuntime.Date?

    public init(
        executionStatistics: LakeFormationClientTypes.ExecutionStatistics? = nil,
        planningStatistics: LakeFormationClientTypes.PlanningStatistics? = nil,
        querySubmissionTime: ClientRuntime.Date? = nil
    )
    {
        self.executionStatistics = executionStatistics
        self.planningStatistics = planningStatistics
        self.querySubmissionTime = querySubmissionTime
    }
}

struct GetQueryStatisticsOutputBody: Swift.Equatable {
    let executionStatistics: LakeFormationClientTypes.ExecutionStatistics?
    let planningStatistics: LakeFormationClientTypes.PlanningStatistics?
    let querySubmissionTime: ClientRuntime.Date?
}

extension GetQueryStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionStatistics = "ExecutionStatistics"
        case planningStatistics = "PlanningStatistics"
        case querySubmissionTime = "QuerySubmissionTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionStatisticsDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ExecutionStatistics.self, forKey: .executionStatistics)
        executionStatistics = executionStatisticsDecoded
        let planningStatisticsDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.PlanningStatistics.self, forKey: .planningStatistics)
        planningStatistics = planningStatisticsDecoded
        let querySubmissionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .querySubmissionTime)
        querySubmissionTime = querySubmissionTimeDecoded
    }
}

enum GetQueryStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredException": return try await ExpiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StatisticsNotReadyYetException": return try await StatisticsNotReadyYetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceLFTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case resource = "Resource"
        case showAssignedLFTags = "ShowAssignedLFTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let showAssignedLFTags = self.showAssignedLFTags {
            try encodeContainer.encode(showAssignedLFTags, forKey: .showAssignedLFTags)
        }
    }
}

extension GetResourceLFTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetResourceLFTags"
    }
}

public struct GetResourceLFTagsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The database, table, or column resource for which you want to return LF-tags.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?
    /// Indicates whether to show the assigned LF-tags.
    public var showAssignedLFTags: Swift.Bool?

    public init(
        catalogId: Swift.String? = nil,
        resource: LakeFormationClientTypes.Resource? = nil,
        showAssignedLFTags: Swift.Bool? = nil
    )
    {
        self.catalogId = catalogId
        self.resource = resource
        self.showAssignedLFTags = showAssignedLFTags
    }
}

struct GetResourceLFTagsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let resource: LakeFormationClientTypes.Resource?
    let showAssignedLFTags: Swift.Bool?
}

extension GetResourceLFTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case resource = "Resource"
        case showAssignedLFTags = "ShowAssignedLFTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let showAssignedLFTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showAssignedLFTags)
        showAssignedLFTags = showAssignedLFTagsDecoded
    }
}

extension GetResourceLFTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceLFTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lfTagOnDatabase = output.lfTagOnDatabase
            self.lfTagsOnColumns = output.lfTagsOnColumns
            self.lfTagsOnTable = output.lfTagsOnTable
        } else {
            self.lfTagOnDatabase = nil
            self.lfTagsOnColumns = nil
            self.lfTagsOnTable = nil
        }
    }
}

public struct GetResourceLFTagsOutput: Swift.Equatable {
    /// A list of LF-tags applied to a database resource.
    public var lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]?
    /// A list of LF-tags applied to a column resource.
    public var lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]?
    /// A list of LF-tags applied to a table resource.
    public var lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]?

    public init(
        lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]? = nil,
        lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]? = nil,
        lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]? = nil
    )
    {
        self.lfTagOnDatabase = lfTagOnDatabase
        self.lfTagsOnColumns = lfTagsOnColumns
        self.lfTagsOnTable = lfTagsOnTable
    }
}

struct GetResourceLFTagsOutputBody: Swift.Equatable {
    let lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]?
    let lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]?
    let lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]?
}

extension GetResourceLFTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lfTagOnDatabase = "LFTagOnDatabase"
        case lfTagsOnColumns = "LFTagsOnColumns"
        case lfTagsOnTable = "LFTagsOnTable"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lfTagOnDatabaseContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTagOnDatabase)
        var lfTagOnDatabaseDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagOnDatabaseContainer = lfTagOnDatabaseContainer {
            lfTagOnDatabaseDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagOnDatabaseContainer {
                if let structure0 = structure0 {
                    lfTagOnDatabaseDecoded0?.append(structure0)
                }
            }
        }
        lfTagOnDatabase = lfTagOnDatabaseDecoded0
        let lfTagsOnTableContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTagsOnTable)
        var lfTagsOnTableDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsOnTableContainer = lfTagsOnTableContainer {
            lfTagsOnTableDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsOnTableContainer {
                if let structure0 = structure0 {
                    lfTagsOnTableDecoded0?.append(structure0)
                }
            }
        }
        lfTagsOnTable = lfTagsOnTableDecoded0
        let lfTagsOnColumnsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.ColumnLFTag?].self, forKey: .lfTagsOnColumns)
        var lfTagsOnColumnsDecoded0:[LakeFormationClientTypes.ColumnLFTag]? = nil
        if let lfTagsOnColumnsContainer = lfTagsOnColumnsContainer {
            lfTagsOnColumnsDecoded0 = [LakeFormationClientTypes.ColumnLFTag]()
            for structure0 in lfTagsOnColumnsContainer {
                if let structure0 = structure0 {
                    lfTagsOnColumnsDecoded0?.append(structure0)
                }
            }
        }
        lfTagsOnColumns = lfTagsOnColumnsDecoded0
    }
}

enum GetResourceLFTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GlueEncryptionException": return try await GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableObjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case partitionPredicate = "PartitionPredicate"
        case queryAsOfTime = "QueryAsOfTime"
        case tableName = "TableName"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let partitionPredicate = self.partitionPredicate {
            try encodeContainer.encode(partitionPredicate, forKey: .partitionPredicate)
        }
        if let queryAsOfTime = self.queryAsOfTime {
            try encodeContainer.encodeTimestamp(queryAsOfTime, format: .epochSeconds, forKey: .queryAsOfTime)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension GetTableObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetTableObjects"
    }
}

public struct GetTableObjectsInput: Swift.Equatable {
    /// The catalog containing the governed table. Defaults to the caller’s account.
    public var catalogId: Swift.String?
    /// The database containing the governed table.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Specifies how many values to return in a page.
    public var maxResults: Swift.Int?
    /// A continuation token if this is not the first call to retrieve these objects.
    public var nextToken: Swift.String?
    /// A predicate to filter the objects returned based on the partition keys defined in the governed table.
    ///
    /// * The comparison operators supported are: =, >, <, >=, <=
    ///
    /// * The logical operators supported are: AND
    ///
    /// * The data types supported are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.
    public var partitionPredicate: Swift.String?
    /// The time as of when to read the governed table contents. If not set, the most recent transaction commit time is used. Cannot be specified along with TransactionId.
    public var queryAsOfTime: ClientRuntime.Date?
    /// The governed table for which to retrieve objects.
    /// This member is required.
    public var tableName: Swift.String?
    /// The transaction ID at which to read the governed table contents. If this transaction has aborted, an error is returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with QueryAsOfTime.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partitionPredicate: Swift.String? = nil,
        queryAsOfTime: ClientRuntime.Date? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partitionPredicate = partitionPredicate
        self.queryAsOfTime = queryAsOfTime
        self.tableName = tableName
        self.transactionId = transactionId
    }
}

struct GetTableObjectsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let transactionId: Swift.String?
    let queryAsOfTime: ClientRuntime.Date?
    let partitionPredicate: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetTableObjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case partitionPredicate = "PartitionPredicate"
        case queryAsOfTime = "QueryAsOfTime"
        case tableName = "TableName"
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let queryAsOfTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .queryAsOfTime)
        queryAsOfTime = queryAsOfTimeDecoded
        let partitionPredicateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionPredicate)
        partitionPredicate = partitionPredicateDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTableObjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableObjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objects = output.objects
        } else {
            self.nextToken = nil
            self.objects = nil
        }
    }
}

public struct GetTableObjectsOutput: Swift.Equatable {
    /// A continuation token indicating whether additional data is available.
    public var nextToken: Swift.String?
    /// A list of objects organized by partition keys.
    public var objects: [LakeFormationClientTypes.PartitionObjects]?

    public init(
        nextToken: Swift.String? = nil,
        objects: [LakeFormationClientTypes.PartitionObjects]? = nil
    )
    {
        self.nextToken = nextToken
        self.objects = objects
    }
}

struct GetTableObjectsOutputBody: Swift.Equatable {
    let objects: [LakeFormationClientTypes.PartitionObjects]?
    let nextToken: Swift.String?
}

extension GetTableObjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objects = "Objects"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PartitionObjects?].self, forKey: .objects)
        var objectsDecoded0:[LakeFormationClientTypes.PartitionObjects]? = nil
        if let objectsContainer = objectsContainer {
            objectsDecoded0 = [LakeFormationClientTypes.PartitionObjects]()
            for structure0 in objectsContainer {
                if let structure0 = structure0 {
                    objectsDecoded0?.append(structure0)
                }
            }
        }
        objects = objectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetTableObjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCanceledException": return try await TransactionCanceledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommittedException": return try await TransactionCommittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemporaryGluePartitionCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditContext = "AuditContext"
        case durationSeconds = "DurationSeconds"
        case partition = "Partition"
        case permissions = "Permissions"
        case supportedPermissionTypes = "SupportedPermissionTypes"
        case tableArn = "TableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditContext = self.auditContext {
            try encodeContainer.encode(auditContext, forKey: .auditContext)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let supportedPermissionTypes = supportedPermissionTypes {
            var supportedPermissionTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPermissionTypes)
            for permissiontype0 in supportedPermissionTypes {
                try supportedPermissionTypesContainer.encode(permissiontype0.rawValue)
            }
        }
        if let tableArn = self.tableArn {
            try encodeContainer.encode(tableArn, forKey: .tableArn)
        }
    }
}

extension GetTemporaryGluePartitionCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetTemporaryGluePartitionCredentials"
    }
}

public struct GetTemporaryGluePartitionCredentialsInput: Swift.Equatable {
    /// A structure representing context to access a resource (column names, query ID, etc).
    public var auditContext: LakeFormationClientTypes.AuditContext?
    /// The time period, between 900 and 21,600 seconds, for the timeout of the temporary credentials.
    public var durationSeconds: Swift.Int?
    /// A list of partition values identifying a single partition.
    /// This member is required.
    public var partition: LakeFormationClientTypes.PartitionValueList?
    /// Filters the request based on the user having been granted a list of specified permissions on the requested resource(s).
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// A list of supported permission types for the partition. Valid values are COLUMN_PERMISSION and CELL_FILTER_PERMISSION.
    public var supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]?
    /// The ARN of the partitions' table.
    /// This member is required.
    public var tableArn: Swift.String?

    public init(
        auditContext: LakeFormationClientTypes.AuditContext? = nil,
        durationSeconds: Swift.Int? = nil,
        partition: LakeFormationClientTypes.PartitionValueList? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]? = nil,
        tableArn: Swift.String? = nil
    )
    {
        self.auditContext = auditContext
        self.durationSeconds = durationSeconds
        self.partition = partition
        self.permissions = permissions
        self.supportedPermissionTypes = supportedPermissionTypes
        self.tableArn = tableArn
    }
}

struct GetTemporaryGluePartitionCredentialsInputBody: Swift.Equatable {
    let tableArn: Swift.String?
    let partition: LakeFormationClientTypes.PartitionValueList?
    let permissions: [LakeFormationClientTypes.Permission]?
    let durationSeconds: Swift.Int?
    let auditContext: LakeFormationClientTypes.AuditContext?
    let supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]?
}

extension GetTemporaryGluePartitionCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditContext = "AuditContext"
        case durationSeconds = "DurationSeconds"
        case partition = "Partition"
        case permissions = "Permissions"
        case supportedPermissionTypes = "SupportedPermissionTypes"
        case tableArn = "TableArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableArn)
        tableArn = tableArnDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.PartitionValueList.self, forKey: .partition)
        partition = partitionDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let auditContextDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.AuditContext.self, forKey: .auditContext)
        auditContext = auditContextDecoded
        let supportedPermissionTypesContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PermissionType?].self, forKey: .supportedPermissionTypes)
        var supportedPermissionTypesDecoded0:[LakeFormationClientTypes.PermissionType]? = nil
        if let supportedPermissionTypesContainer = supportedPermissionTypesContainer {
            supportedPermissionTypesDecoded0 = [LakeFormationClientTypes.PermissionType]()
            for enum0 in supportedPermissionTypesContainer {
                if let enum0 = enum0 {
                    supportedPermissionTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedPermissionTypes = supportedPermissionTypesDecoded0
    }
}

extension GetTemporaryGluePartitionCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemporaryGluePartitionCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyId = output.accessKeyId
            self.expiration = output.expiration
            self.secretAccessKey = output.secretAccessKey
            self.sessionToken = output.sessionToken
        } else {
            self.accessKeyId = nil
            self.expiration = nil
            self.secretAccessKey = nil
            self.sessionToken = nil
        }
    }
}

public struct GetTemporaryGluePartitionCredentialsOutput: Swift.Equatable {
    /// The access key ID for the temporary credentials.
    public var accessKeyId: Swift.String?
    /// The date and time when the temporary credentials expire.
    public var expiration: ClientRuntime.Date?
    /// The secret key for the temporary credentials.
    public var secretAccessKey: Swift.String?
    /// The session token for the temporary credentials.
    public var sessionToken: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

struct GetTemporaryGluePartitionCredentialsOutputBody: Swift.Equatable {
    let accessKeyId: Swift.String?
    let secretAccessKey: Swift.String?
    let sessionToken: Swift.String?
    let expiration: ClientRuntime.Date?
}

extension GetTemporaryGluePartitionCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
    }
}

enum GetTemporaryGluePartitionCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PermissionTypeMismatchException": return try await PermissionTypeMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemporaryGlueTableCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditContext = "AuditContext"
        case durationSeconds = "DurationSeconds"
        case permissions = "Permissions"
        case supportedPermissionTypes = "SupportedPermissionTypes"
        case tableArn = "TableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditContext = self.auditContext {
            try encodeContainer.encode(auditContext, forKey: .auditContext)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let supportedPermissionTypes = supportedPermissionTypes {
            var supportedPermissionTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPermissionTypes)
            for permissiontype0 in supportedPermissionTypes {
                try supportedPermissionTypesContainer.encode(permissiontype0.rawValue)
            }
        }
        if let tableArn = self.tableArn {
            try encodeContainer.encode(tableArn, forKey: .tableArn)
        }
    }
}

extension GetTemporaryGlueTableCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetTemporaryGlueTableCredentials"
    }
}

public struct GetTemporaryGlueTableCredentialsInput: Swift.Equatable {
    /// A structure representing context to access a resource (column names, query ID, etc).
    public var auditContext: LakeFormationClientTypes.AuditContext?
    /// The time period, between 900 and 21,600 seconds, for the timeout of the temporary credentials.
    public var durationSeconds: Swift.Int?
    /// Filters the request based on the user having been granted a list of specified permissions on the requested resource(s).
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// A list of supported permission types for the table. Valid values are COLUMN_PERMISSION and CELL_FILTER_PERMISSION.
    public var supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]?
    /// The ARN identifying a table in the Data Catalog for the temporary credentials request.
    /// This member is required.
    public var tableArn: Swift.String?

    public init(
        auditContext: LakeFormationClientTypes.AuditContext? = nil,
        durationSeconds: Swift.Int? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]? = nil,
        tableArn: Swift.String? = nil
    )
    {
        self.auditContext = auditContext
        self.durationSeconds = durationSeconds
        self.permissions = permissions
        self.supportedPermissionTypes = supportedPermissionTypes
        self.tableArn = tableArn
    }
}

struct GetTemporaryGlueTableCredentialsInputBody: Swift.Equatable {
    let tableArn: Swift.String?
    let permissions: [LakeFormationClientTypes.Permission]?
    let durationSeconds: Swift.Int?
    let auditContext: LakeFormationClientTypes.AuditContext?
    let supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]?
}

extension GetTemporaryGlueTableCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditContext = "AuditContext"
        case durationSeconds = "DurationSeconds"
        case permissions = "Permissions"
        case supportedPermissionTypes = "SupportedPermissionTypes"
        case tableArn = "TableArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableArn)
        tableArn = tableArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let auditContextDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.AuditContext.self, forKey: .auditContext)
        auditContext = auditContextDecoded
        let supportedPermissionTypesContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PermissionType?].self, forKey: .supportedPermissionTypes)
        var supportedPermissionTypesDecoded0:[LakeFormationClientTypes.PermissionType]? = nil
        if let supportedPermissionTypesContainer = supportedPermissionTypesContainer {
            supportedPermissionTypesDecoded0 = [LakeFormationClientTypes.PermissionType]()
            for enum0 in supportedPermissionTypesContainer {
                if let enum0 = enum0 {
                    supportedPermissionTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedPermissionTypes = supportedPermissionTypesDecoded0
    }
}

extension GetTemporaryGlueTableCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemporaryGlueTableCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessKeyId = output.accessKeyId
            self.expiration = output.expiration
            self.secretAccessKey = output.secretAccessKey
            self.sessionToken = output.sessionToken
        } else {
            self.accessKeyId = nil
            self.expiration = nil
            self.secretAccessKey = nil
            self.sessionToken = nil
        }
    }
}

public struct GetTemporaryGlueTableCredentialsOutput: Swift.Equatable {
    /// The access key ID for the temporary credentials.
    public var accessKeyId: Swift.String?
    /// The date and time when the temporary credentials expire.
    public var expiration: ClientRuntime.Date?
    /// The secret key for the temporary credentials.
    public var secretAccessKey: Swift.String?
    /// The session token for the temporary credentials.
    public var sessionToken: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

struct GetTemporaryGlueTableCredentialsOutputBody: Swift.Equatable {
    let accessKeyId: Swift.String?
    let secretAccessKey: Swift.String?
    let sessionToken: Swift.String?
    let expiration: ClientRuntime.Date?
}

extension GetTemporaryGlueTableCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
    }
}

enum GetTemporaryGlueTableCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PermissionTypeMismatchException": return try await PermissionTypeMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkUnitResultsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkUnitResultsInput(queryId: \(Swift.String(describing: queryId)), workUnitId: \(Swift.String(describing: workUnitId)), workUnitToken: \"CONTENT_REDACTED\")"}
}

extension GetWorkUnitResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
        case workUnitId = "WorkUnitId"
        case workUnitToken = "WorkUnitToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let workUnitId = self.workUnitId {
            try encodeContainer.encode(workUnitId, forKey: .workUnitId)
        }
        if let workUnitToken = self.workUnitToken {
            try encodeContainer.encode(workUnitToken, forKey: .workUnitToken)
        }
    }
}

extension GetWorkUnitResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetWorkUnitResults"
    }
}

public struct GetWorkUnitResultsInput: Swift.Equatable {
    /// The ID of the plan query operation for which to get results.
    /// This member is required.
    public var queryId: Swift.String?
    /// The work unit ID for which to get results. Value generated by enumerating WorkUnitIdMin to WorkUnitIdMax (inclusive) from the WorkUnitRange in the output of GetWorkUnits.
    /// This member is required.
    public var workUnitId: Swift.Int?
    /// A work token used to query the execution service. Token output from GetWorkUnits.
    /// This member is required.
    public var workUnitToken: Swift.String?

    public init(
        queryId: Swift.String? = nil,
        workUnitId: Swift.Int? = nil,
        workUnitToken: Swift.String? = nil
    )
    {
        self.queryId = queryId
        self.workUnitId = workUnitId
        self.workUnitToken = workUnitToken
    }
}

struct GetWorkUnitResultsInputBody: Swift.Equatable {
    let queryId: Swift.String?
    let workUnitId: Swift.Int?
    let workUnitToken: Swift.String?
}

extension GetWorkUnitResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
        case workUnitId = "WorkUnitId"
        case workUnitToken = "WorkUnitToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let workUnitIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workUnitId)
        workUnitId = workUnitIdDecoded
        let workUnitTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workUnitToken)
        workUnitToken = workUnitTokenDecoded
    }
}

extension GetWorkUnitResultsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.resultStream = .data(data)
        case .stream(let stream):
            self.resultStream = .stream(stream)
        case .none:
            self.resultStream = nil
        }
    }
}

/// A structure for the output.
public struct GetWorkUnitResultsOutput: Swift.Equatable {
    /// Rows returned from the GetWorkUnitResults operation as a stream of Apache Arrow v1.0 messages.
    public var resultStream: ClientRuntime.ByteStream?

    public init(
        resultStream: ClientRuntime.ByteStream? = nil
    )
    {
        self.resultStream = resultStream
    }
}

struct GetWorkUnitResultsOutputBody: Swift.Equatable {
    let resultStream: ClientRuntime.ByteStream?
}

extension GetWorkUnitResultsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultStream = "ResultStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .resultStream)
        resultStream = resultStreamDecoded
    }
}

enum GetWorkUnitResultsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredException": return try await ExpiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkUnitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pageSize = "PageSize"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension GetWorkUnitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetWorkUnits"
    }
}

public struct GetWorkUnitsInput: Swift.Equatable {
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The size of each page to get in the Amazon Web Services service call. This does not affect the number of items returned in the command's output. Setting a smaller page size results in more calls to the Amazon Web Services service, retrieving fewer items in each call. This can help prevent the Amazon Web Services service calls from timing out.
    public var pageSize: Swift.Int?
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.queryId = queryId
    }
}

struct GetWorkUnitsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pageSize: Swift.Int?
    let queryId: Swift.String?
}

extension GetWorkUnitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pageSize = "PageSize"
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension GetWorkUnitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkUnitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryId = output.queryId
            self.workUnitRanges = output.workUnitRanges
        } else {
            self.nextToken = nil
            self.queryId = nil
            self.workUnitRanges = nil
        }
    }
}

/// A structure for the output.
public struct GetWorkUnitsOutput: Swift.Equatable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?
    /// A WorkUnitRangeList object that specifies the valid range of work unit IDs for querying the execution service.
    /// This member is required.
    public var workUnitRanges: [LakeFormationClientTypes.WorkUnitRange]?

    public init(
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil,
        workUnitRanges: [LakeFormationClientTypes.WorkUnitRange]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryId = queryId
        self.workUnitRanges = workUnitRanges
    }
}

struct GetWorkUnitsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let queryId: Swift.String?
    let workUnitRanges: [LakeFormationClientTypes.WorkUnitRange]?
}

extension GetWorkUnitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queryId = "QueryId"
        case workUnitRanges = "WorkUnitRanges"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let workUnitRangesContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.WorkUnitRange?].self, forKey: .workUnitRanges)
        var workUnitRangesDecoded0:[LakeFormationClientTypes.WorkUnitRange]? = nil
        if let workUnitRangesContainer = workUnitRangesContainer {
            workUnitRangesDecoded0 = [LakeFormationClientTypes.WorkUnitRange]()
            for structure0 in workUnitRangesContainer {
                if let structure0 = structure0 {
                    workUnitRangesDecoded0?.append(structure0)
                }
            }
        }
        workUnitRanges = workUnitRangesDecoded0
    }
}

enum GetWorkUnitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredException": return try await ExpiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "WorkUnitsNotReadyYetException": return try await WorkUnitsNotReadyYetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GlueEncryptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GlueEncryptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An encryption operation failed.
public struct GlueEncryptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GlueEncryptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GlueEncryptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GlueEncryptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrantPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permission0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permission0.rawValue)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension GrantPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GrantPermissions"
    }
}

public struct GrantPermissionsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The permissions granted to the principal on the resource. Lake Formation defines privileges to grant and revoke access to metadata in the Data Catalog and data organized in underlying data storage such as Amazon S3. Lake Formation requires that each principal be authorized to perform a specific task on Lake Formation resources.
    /// This member is required.
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// Indicates a list of the granted permissions that the principal may pass to other users. These permissions may only be a subset of the permissions granted in the Privileges.
    public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
    /// The principal to be granted the permissions on the resource. Supported principals are IAM users or IAM roles, and they are defined by their principal type and their ARN. Note that if you define a resource with a particular ARN, then later delete, and recreate a resource with that same ARN, the resource maintains the permissions already granted.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// The resource to which permissions are to be granted. Resources in Lake Formation are the Data Catalog, databases, and tables.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

struct GrantPermissionsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let principal: LakeFormationClientTypes.DataLakePrincipal?
    let resource: LakeFormationClientTypes.Resource?
    let permissions: [LakeFormationClientTypes.Permission]?
    let permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
}

extension GrantPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsWithGrantOptionContainer {
                if let enum0 = enum0 {
                    permissionsWithGrantOptionDecoded0?.append(enum0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
    }
}

extension GrantPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct GrantPermissionsOutput: Swift.Equatable {

    public init() { }
}

enum GrantPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service error occurred.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input provided was not valid.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes.LFTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for lftagvalue0 in tagValues {
                try tagValuesContainer.encode(lftagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure that allows an admin to grant user permissions on certain conditions. For example, granting a role access to all columns that do not have the LF-tag 'PII' in tables that have the LF-tag 'Prod'.
    public struct LFTag: Swift.Equatable {
        /// The key-name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of possible values an attribute can take. The maximum number of values that can be defined for a LF-Tag is 1000. A single API call supports 50 values. You can use multiple API calls to add more values.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension LakeFormationClientTypes.LFTagError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case lfTag = "LFTag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lfTag = self.lfTag {
            try encodeContainer.encode(lfTag, forKey: .lfTag)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lfTagDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.LFTagPair.self, forKey: .lfTag)
        lfTag = lfTagDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure containing an error related to a TagResource or UnTagResource operation.
    public struct LFTagError: Swift.Equatable {
        /// An error that occurred with the attachment or detachment of the LF-tag.
        public var error: LakeFormationClientTypes.ErrorDetail?
        /// The key-name of the LF-tag.
        public var lfTag: LakeFormationClientTypes.LFTagPair?

        public init(
            error: LakeFormationClientTypes.ErrorDetail? = nil,
            lfTag: LakeFormationClientTypes.LFTagPair? = nil
        )
        {
            self.error = error
            self.lfTag = lfTag
        }
    }

}

extension LakeFormationClientTypes.LFTagKeyResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for lftagvalue0 in tagValues {
                try tagValuesContainer.encode(lftagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure containing an LF-tag key and values for a resource.
    public struct LFTagKeyResource: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalogId: Swift.String?
        /// The key-name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of possible values an attribute can take.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            catalogId: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.catalogId = catalogId
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension LakeFormationClientTypes.LFTagPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for lftagvalue0 in tagValues {
                try tagValuesContainer.encode(lftagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure containing an LF-tag key-value pair.
    public struct LFTagPair: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalogId: Swift.String?
        /// The key-name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of possible values an attribute can take.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            catalogId: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.catalogId = catalogId
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension LakeFormationClientTypes.LFTagPolicyResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let expressionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[LakeFormationClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [LakeFormationClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure containing a list of LF-tag conditions that apply to a resource's LF-tag policy.
    public struct LFTagPolicyResource: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalogId: Swift.String?
        /// A list of LF-tag conditions that apply to the resource's LF-tag policy.
        /// This member is required.
        public var expression: [LakeFormationClientTypes.LFTag]?
        /// The resource type for which the LF-tag policy applies.
        /// This member is required.
        public var resourceType: LakeFormationClientTypes.ResourceType?

        public init(
            catalogId: Swift.String? = nil,
            expression: [LakeFormationClientTypes.LFTag]? = nil,
            resourceType: LakeFormationClientTypes.ResourceType? = nil
        )
        {
            self.catalogId = catalogId
            self.expression = expression
            self.resourceType = resourceType
        }
    }

}

extension LakeFormationClientTypes.LakeFormationOptInsInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModified = "LastModified"
        case lastUpdatedBy = "LastUpdatedBy"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
    }
}

extension LakeFormationClientTypes {
    /// A single principal-resource pair that has Lake Formation permissins enforced.
    public struct LakeFormationOptInsInfo: Swift.Equatable {
        /// The last modified date and time of the record.
        public var lastModified: ClientRuntime.Date?
        /// The user who updated the record.
        public var lastUpdatedBy: Swift.String?
        /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?
        /// A structure for the resource.
        public var resource: LakeFormationClientTypes.Resource?

        public init(
            lastModified: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
            resource: LakeFormationClientTypes.Resource? = nil
        )
        {
            self.lastModified = lastModified
            self.lastUpdatedBy = lastUpdatedBy
            self.principal = principal
            self.resource = resource
        }
    }

}

extension ListDataCellsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case table = "Table"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }
}

extension ListDataCellsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListDataCellsFilter"
    }
}

public struct ListDataCellsFilterInput: Swift.Equatable {
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// A table in the Glue Data Catalog.
    public var table: LakeFormationClientTypes.TableResource?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        table: LakeFormationClientTypes.TableResource? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.table = table
    }
}

struct ListDataCellsFilterInputBody: Swift.Equatable {
    let table: LakeFormationClientTypes.TableResource?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDataCellsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case table = "Table"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TableResource.self, forKey: .table)
        table = tableDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataCellsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataCellsFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataCellsFilters = output.dataCellsFilters
            self.nextToken = output.nextToken
        } else {
            self.dataCellsFilters = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataCellsFilterOutput: Swift.Equatable {
    /// A list of DataCellFilter structures.
    public var dataCellsFilters: [LakeFormationClientTypes.DataCellsFilter]?
    /// A continuation token, if not all requested data cell filters have been returned.
    public var nextToken: Swift.String?

    public init(
        dataCellsFilters: [LakeFormationClientTypes.DataCellsFilter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataCellsFilters = dataCellsFilters
        self.nextToken = nextToken
    }
}

struct ListDataCellsFilterOutputBody: Swift.Equatable {
    let dataCellsFilters: [LakeFormationClientTypes.DataCellsFilter]?
    let nextToken: Swift.String?
}

extension ListDataCellsFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCellsFilters = "DataCellsFilters"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCellsFiltersContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.DataCellsFilter?].self, forKey: .dataCellsFilters)
        var dataCellsFiltersDecoded0:[LakeFormationClientTypes.DataCellsFilter]? = nil
        if let dataCellsFiltersContainer = dataCellsFiltersContainer {
            dataCellsFiltersDecoded0 = [LakeFormationClientTypes.DataCellsFilter]()
            for structure0 in dataCellsFiltersContainer {
                if let structure0 = structure0 {
                    dataCellsFiltersDecoded0?.append(structure0)
                }
            }
        }
        dataCellsFilters = dataCellsFiltersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataCellsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLFTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareType = self.resourceShareType {
            try encodeContainer.encode(resourceShareType.rawValue, forKey: .resourceShareType)
        }
    }
}

extension ListLFTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLFTags"
    }
}

public struct ListLFTagsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// If resource share type is ALL, returns both in-account LF-tags and shared LF-tags that the requester has permission to view. If resource share type is FOREIGN, returns all share LF-tags that the requester can view. If no resource share type is passed, lists LF-tags in the given catalog ID that the requester has permission to view.
    public var resourceShareType: LakeFormationClientTypes.ResourceShareType?

    public init(
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareType: LakeFormationClientTypes.ResourceShareType? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
    }
}

struct ListLFTagsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let resourceShareType: LakeFormationClientTypes.ResourceShareType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLFTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceShareType = "ResourceShareType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceShareTypeDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ResourceShareType.self, forKey: .resourceShareType)
        resourceShareType = resourceShareTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLFTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLFTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lfTags = output.lfTags
            self.nextToken = output.nextToken
        } else {
            self.lfTags = nil
            self.nextToken = nil
        }
    }
}

public struct ListLFTagsOutput: Swift.Equatable {
    /// A list of LF-tags that the requested has permission to view.
    public var lfTags: [LakeFormationClientTypes.LFTagPair]?
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?

    public init(
        lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lfTags = lfTags
        self.nextToken = nextToken
    }
}

struct ListLFTagsOutputBody: Swift.Equatable {
    let lfTags: [LakeFormationClientTypes.LFTagPair]?
    let nextToken: Swift.String?
}

extension ListLFTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lfTags = "LFTags"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lfTagsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTags)
        var lfTagsDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsContainer = lfTagsContainer {
            lfTagsDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsContainer {
                if let structure0 = structure0 {
                    lfTagsDecoded0?.append(structure0)
                }
            }
        }
        lfTags = lfTagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLFTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLakeFormationOptInsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension ListLakeFormationOptInsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLakeFormationOptIns"
    }
}

public struct ListLakeFormationOptInsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A structure for the resource.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resource = resource
    }
}

struct ListLakeFormationOptInsInputBody: Swift.Equatable {
    let principal: LakeFormationClientTypes.DataLakePrincipal?
    let resource: LakeFormationClientTypes.Resource?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLakeFormationOptInsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principal = "Principal"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLakeFormationOptInsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLakeFormationOptInsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lakeFormationOptInsInfoList = output.lakeFormationOptInsInfoList
            self.nextToken = output.nextToken
        } else {
            self.lakeFormationOptInsInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListLakeFormationOptInsOutput: Swift.Equatable {
    /// A list of principal-resource pairs that have Lake Formation permissins enforced.
    public var lakeFormationOptInsInfoList: [LakeFormationClientTypes.LakeFormationOptInsInfo]?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?

    public init(
        lakeFormationOptInsInfoList: [LakeFormationClientTypes.LakeFormationOptInsInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lakeFormationOptInsInfoList = lakeFormationOptInsInfoList
        self.nextToken = nextToken
    }
}

struct ListLakeFormationOptInsOutputBody: Swift.Equatable {
    let lakeFormationOptInsInfoList: [LakeFormationClientTypes.LakeFormationOptInsInfo]?
    let nextToken: Swift.String?
}

extension ListLakeFormationOptInsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lakeFormationOptInsInfoList = "LakeFormationOptInsInfoList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lakeFormationOptInsInfoListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LakeFormationOptInsInfo?].self, forKey: .lakeFormationOptInsInfoList)
        var lakeFormationOptInsInfoListDecoded0:[LakeFormationClientTypes.LakeFormationOptInsInfo]? = nil
        if let lakeFormationOptInsInfoListContainer = lakeFormationOptInsInfoListContainer {
            lakeFormationOptInsInfoListDecoded0 = [LakeFormationClientTypes.LakeFormationOptInsInfo]()
            for structure0 in lakeFormationOptInsInfoListContainer {
                if let structure0 = structure0 {
                    lakeFormationOptInsInfoListDecoded0?.append(structure0)
                }
            }
        }
        lakeFormationOptInsInfoList = lakeFormationOptInsInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLakeFormationOptInsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case includeRelated = "IncludeRelated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principal = "Principal"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let includeRelated = self.includeRelated {
            try encodeContainer.encode(includeRelated, forKey: .includeRelated)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListPermissions"
    }
}

public struct ListPermissionsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// Indicates that related permissions should be included in the results.
    public var includeRelated: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// Specifies a principal to filter the permissions returned.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A resource where you will get a list of the principal permissions. This operation does not support getting privileges on a table with columns. Instead, call this operation on the table, and the operation returns the table and the table w columns.
    public var resource: LakeFormationClientTypes.Resource?
    /// Specifies a resource type to filter the permissions returned.
    public var resourceType: LakeFormationClientTypes.DataLakeResourceType?

    public init(
        catalogId: Swift.String? = nil,
        includeRelated: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil,
        resourceType: LakeFormationClientTypes.DataLakeResourceType? = nil
    )
    {
        self.catalogId = catalogId
        self.includeRelated = includeRelated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let principal: LakeFormationClientTypes.DataLakePrincipal?
    let resourceType: LakeFormationClientTypes.DataLakeResourceType?
    let resource: LakeFormationClientTypes.Resource?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let includeRelated: Swift.String?
}

extension ListPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case includeRelated = "IncludeRelated"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principal = "Principal"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakeResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let includeRelatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .includeRelated)
        includeRelated = includeRelatedDecoded
    }
}

extension ListPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principalResourcePermissions = output.principalResourcePermissions
        } else {
            self.nextToken = nil
            self.principalResourcePermissions = nil
        }
    }
}

public struct ListPermissionsOutput: Swift.Equatable {
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// A list of principals and their permissions on the resource for the specified principal and resource types.
    public var principalResourcePermissions: [LakeFormationClientTypes.PrincipalResourcePermissions]?

    public init(
        nextToken: Swift.String? = nil,
        principalResourcePermissions: [LakeFormationClientTypes.PrincipalResourcePermissions]? = nil
    )
    {
        self.nextToken = nextToken
        self.principalResourcePermissions = principalResourcePermissions
    }
}

struct ListPermissionsOutputBody: Swift.Equatable {
    let principalResourcePermissions: [LakeFormationClientTypes.PrincipalResourcePermissions]?
    let nextToken: Swift.String?
}

extension ListPermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case principalResourcePermissions = "PrincipalResourcePermissions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalResourcePermissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.PrincipalResourcePermissions?].self, forKey: .principalResourcePermissions)
        var principalResourcePermissionsDecoded0:[LakeFormationClientTypes.PrincipalResourcePermissions]? = nil
        if let principalResourcePermissionsContainer = principalResourcePermissionsContainer {
            principalResourcePermissionsDecoded0 = [LakeFormationClientTypes.PrincipalResourcePermissions]()
            for structure0 in principalResourcePermissionsContainer {
                if let structure0 = structure0 {
                    principalResourcePermissionsDecoded0?.append(structure0)
                }
            }
        }
        principalResourcePermissions = principalResourcePermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterConditionList = "FilterConditionList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterConditionList = filterConditionList {
            var filterConditionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterConditionList)
            for filtercondition0 in filterConditionList {
                try filterConditionListContainer.encode(filtercondition0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListResources"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// Any applicable row-level and/or column-level filtering conditions for the resources.
    public var filterConditionList: [LakeFormationClientTypes.FilterCondition]?
    /// The maximum number of resource results.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve these resources.
    public var nextToken: Swift.String?

    public init(
        filterConditionList: [LakeFormationClientTypes.FilterCondition]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterConditionList = filterConditionList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let filterConditionList: [LakeFormationClientTypes.FilterCondition]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterConditionList = "FilterConditionList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterConditionListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.FilterCondition?].self, forKey: .filterConditionList)
        var filterConditionListDecoded0:[LakeFormationClientTypes.FilterCondition]? = nil
        if let filterConditionListContainer = filterConditionListContainer {
            filterConditionListDecoded0 = [LakeFormationClientTypes.FilterCondition]()
            for structure0 in filterConditionListContainer {
                if let structure0 = structure0 {
                    filterConditionListDecoded0?.append(structure0)
                }
            }
        }
        filterConditionList = filterConditionListDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceInfoList = output.resourceInfoList
        } else {
            self.nextToken = nil
            self.resourceInfoList = nil
        }
    }
}

public struct ListResourcesOutput: Swift.Equatable {
    /// A continuation token, if this is not the first call to retrieve these resources.
    public var nextToken: Swift.String?
    /// A summary of the data lake resources.
    public var resourceInfoList: [LakeFormationClientTypes.ResourceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        resourceInfoList: [LakeFormationClientTypes.ResourceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInfoList = resourceInfoList
    }
}

struct ListResourcesOutputBody: Swift.Equatable {
    let resourceInfoList: [LakeFormationClientTypes.ResourceInfo]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceInfoList = "ResourceInfoList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInfoListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.ResourceInfo?].self, forKey: .resourceInfoList)
        var resourceInfoListDecoded0:[LakeFormationClientTypes.ResourceInfo]? = nil
        if let resourceInfoListContainer = resourceInfoListContainer {
            resourceInfoListDecoded0 = [LakeFormationClientTypes.ResourceInfo]()
            for structure0 in resourceInfoListContainer {
                if let structure0 = structure0 {
                    resourceInfoListDecoded0?.append(structure0)
                }
            }
        }
        resourceInfoList = resourceInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTableStorageOptimizersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case storageOptimizerType = "StorageOptimizerType"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let storageOptimizerType = self.storageOptimizerType {
            try encodeContainer.encode(storageOptimizerType.rawValue, forKey: .storageOptimizerType)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension ListTableStorageOptimizersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTableStorageOptimizers"
    }
}

public struct ListTableStorageOptimizersInput: Swift.Equatable {
    /// The Catalog ID of the table.
    public var catalogId: Swift.String?
    /// Name of the database where the table is present.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The number of storage optimizers to return on each call.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The specific type of storage optimizers to list. The supported value is compaction.
    public var storageOptimizerType: LakeFormationClientTypes.OptimizerType?
    /// Name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        storageOptimizerType: LakeFormationClientTypes.OptimizerType? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageOptimizerType = storageOptimizerType
        self.tableName = tableName
    }
}

struct ListTableStorageOptimizersInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let storageOptimizerType: LakeFormationClientTypes.OptimizerType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTableStorageOptimizersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case storageOptimizerType = "StorageOptimizerType"
        case tableName = "TableName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let storageOptimizerTypeDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.OptimizerType.self, forKey: .storageOptimizerType)
        storageOptimizerType = storageOptimizerTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTableStorageOptimizersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTableStorageOptimizersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageOptimizerList = output.storageOptimizerList
        } else {
            self.nextToken = nil
            self.storageOptimizerList = nil
        }
    }
}

public struct ListTableStorageOptimizersOutput: Swift.Equatable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// A list of the storage optimizers associated with a table.
    public var storageOptimizerList: [LakeFormationClientTypes.StorageOptimizer]?

    public init(
        nextToken: Swift.String? = nil,
        storageOptimizerList: [LakeFormationClientTypes.StorageOptimizer]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageOptimizerList = storageOptimizerList
    }
}

struct ListTableStorageOptimizersOutputBody: Swift.Equatable {
    let storageOptimizerList: [LakeFormationClientTypes.StorageOptimizer]?
    let nextToken: Swift.String?
}

extension ListTableStorageOptimizersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storageOptimizerList = "StorageOptimizerList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageOptimizerListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.StorageOptimizer?].self, forKey: .storageOptimizerList)
        var storageOptimizerListDecoded0:[LakeFormationClientTypes.StorageOptimizer]? = nil
        if let storageOptimizerListContainer = storageOptimizerListContainer {
            storageOptimizerListDecoded0 = [LakeFormationClientTypes.StorageOptimizer]()
            for structure0 in storageOptimizerListContainer {
                if let structure0 = structure0 {
                    storageOptimizerListDecoded0?.append(structure0)
                }
            }
        }
        storageOptimizerList = storageOptimizerListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTableStorageOptimizersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTransactionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let statusFilter = self.statusFilter {
            try encodeContainer.encode(statusFilter.rawValue, forKey: .statusFilter)
        }
    }
}

extension ListTransactionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTransactions"
    }
}

public struct ListTransactionsInput: Swift.Equatable {
    /// The catalog for which to list transactions. Defaults to the account ID of the caller.
    public var catalogId: Swift.String?
    /// The maximum number of transactions to return in a single call.
    public var maxResults: Swift.Int?
    /// A continuation token if this is not the first call to retrieve transactions.
    public var nextToken: Swift.String?
    /// A filter indicating the status of transactions to return. Options are ALL | COMPLETED | COMMITTED | ABORTED | ACTIVE. The default is ALL.
    public var statusFilter: LakeFormationClientTypes.TransactionStatusFilter?

    public init(
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        statusFilter: LakeFormationClientTypes.TransactionStatusFilter? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

struct ListTransactionsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let statusFilter: LakeFormationClientTypes.TransactionStatusFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTransactionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let statusFilterDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TransactionStatusFilter.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTransactionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTransactionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transactions = output.transactions
        } else {
            self.nextToken = nil
            self.transactions = nil
        }
    }
}

public struct ListTransactionsOutput: Swift.Equatable {
    /// A continuation token indicating whether additional data is available.
    public var nextToken: Swift.String?
    /// A list of transactions. The record for each transaction is a TransactionDescription object.
    public var transactions: [LakeFormationClientTypes.TransactionDescription]?

    public init(
        nextToken: Swift.String? = nil,
        transactions: [LakeFormationClientTypes.TransactionDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.transactions = transactions
    }
}

struct ListTransactionsOutputBody: Swift.Equatable {
    let transactions: [LakeFormationClientTypes.TransactionDescription]?
    let nextToken: Swift.String?
}

extension ListTransactionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case transactions = "Transactions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.TransactionDescription?].self, forKey: .transactions)
        var transactionsDecoded0:[LakeFormationClientTypes.TransactionDescription]? = nil
        if let transactionsContainer = transactionsContainer {
            transactionsDecoded0 = [LakeFormationClientTypes.TransactionDescription]()
            for structure0 in transactionsContainer {
                if let structure0 = structure0 {
                    transactionsDecoded0?.append(structure0)
                }
            }
        }
        transactions = transactionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTransactionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OperationTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation timed out.
public struct OperationTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes {
    public enum OptimizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compaction
        case garbageCollection
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizerType] {
            return [
                .compaction,
                .garbageCollection,
                .generic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compaction: return "COMPACTION"
            case .garbageCollection: return "GARBAGE_COLLECTION"
            case .generic: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptimizerType(rawValue: rawValue) ?? OptimizerType.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes.PartitionObjects: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objects = "Objects"
        case partitionValues = "PartitionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objects = objects {
            var objectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objects)
            for tableobject0 in objects {
                try objectsContainer.encode(tableobject0)
            }
        }
        if let partitionValues = partitionValues {
            var partitionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionValues)
            for partitionvaluestring0 in partitionValues {
                try partitionValuesContainer.encode(partitionvaluestring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionValues)
        var partitionValuesDecoded0:[Swift.String]? = nil
        if let partitionValuesContainer = partitionValuesContainer {
            partitionValuesDecoded0 = [Swift.String]()
            for string0 in partitionValuesContainer {
                if let string0 = string0 {
                    partitionValuesDecoded0?.append(string0)
                }
            }
        }
        partitionValues = partitionValuesDecoded0
        let objectsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.TableObject?].self, forKey: .objects)
        var objectsDecoded0:[LakeFormationClientTypes.TableObject]? = nil
        if let objectsContainer = objectsContainer {
            objectsDecoded0 = [LakeFormationClientTypes.TableObject]()
            for structure0 in objectsContainer {
                if let structure0 = structure0 {
                    objectsDecoded0?.append(structure0)
                }
            }
        }
        objects = objectsDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure containing a list of partition values and table objects.
    public struct PartitionObjects: Swift.Equatable {
        /// A list of table objects
        public var objects: [LakeFormationClientTypes.TableObject]?
        /// A list of partition values.
        public var partitionValues: [Swift.String]?

        public init(
            objects: [LakeFormationClientTypes.TableObject]? = nil,
            partitionValues: [Swift.String]? = nil
        )
        {
            self.objects = objects
            self.partitionValues = partitionValues
        }
    }

}

extension LakeFormationClientTypes.PartitionValueList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuestring0 in values {
                try valuesContainer.encode(valuestring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LakeFormationClientTypes {
    /// Contains a list of values defining partitions.
    public struct PartitionValueList: Swift.Equatable {
        /// The list of partition values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension LakeFormationClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case alter
        case associate
        case createDatabase
        case createLfTag
        case createTable
        case dataLocationAccess
        case delete
        case describe
        case drop
        case grantWithLfTagExpression
        case insert
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .all,
                .alter,
                .associate,
                .createDatabase,
                .createLfTag,
                .createTable,
                .dataLocationAccess,
                .delete,
                .describe,
                .drop,
                .grantWithLfTagExpression,
                .insert,
                .select,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .alter: return "ALTER"
            case .associate: return "ASSOCIATE"
            case .createDatabase: return "CREATE_DATABASE"
            case .createLfTag: return "CREATE_LF_TAG"
            case .createTable: return "CREATE_TABLE"
            case .dataLocationAccess: return "DATA_LOCATION_ACCESS"
            case .delete: return "DELETE"
            case .describe: return "DESCRIBE"
            case .drop: return "DROP"
            case .grantWithLfTagExpression: return "GRANT_WITH_LF_TAG_EXPRESSION"
            case .insert: return "INSERT"
            case .select: return "SELECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cellFilterPermission
        case columnPermission
        case nestedCellPermission
        case nestedPermission
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .cellFilterPermission,
                .columnPermission,
                .nestedCellPermission,
                .nestedPermission,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cellFilterPermission: return "CELL_FILTER_PERMISSION"
            case .columnPermission: return "COLUMN_PERMISSION"
            case .nestedCellPermission: return "NESTED_CELL_PERMISSION"
            case .nestedPermission: return "NESTED_PERMISSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension PermissionTypeMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PermissionTypeMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The engine does not support filtering data based on the enforced permissions. For example, if you call the GetTemporaryGlueTableCredentials operation with SupportedPermissionType equal to ColumnPermission, but cell-level permissions exist on the table, this exception is thrown.
public struct PermissionTypeMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PermissionTypeMismatchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PermissionTypeMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PermissionTypeMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes.PlanningStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedDataToScanBytes = "EstimatedDataToScanBytes"
        case planningTimeMillis = "PlanningTimeMillis"
        case queueTimeMillis = "QueueTimeMillis"
        case workUnitsGeneratedCount = "WorkUnitsGeneratedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimatedDataToScanBytes != 0 {
            try encodeContainer.encode(estimatedDataToScanBytes, forKey: .estimatedDataToScanBytes)
        }
        if planningTimeMillis != 0 {
            try encodeContainer.encode(planningTimeMillis, forKey: .planningTimeMillis)
        }
        if queueTimeMillis != 0 {
            try encodeContainer.encode(queueTimeMillis, forKey: .queueTimeMillis)
        }
        if workUnitsGeneratedCount != 0 {
            try encodeContainer.encode(workUnitsGeneratedCount, forKey: .workUnitsGeneratedCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedDataToScanBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedDataToScanBytes) ?? 0
        estimatedDataToScanBytes = estimatedDataToScanBytesDecoded
        let planningTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .planningTimeMillis) ?? 0
        planningTimeMillis = planningTimeMillisDecoded
        let queueTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queueTimeMillis) ?? 0
        queueTimeMillis = queueTimeMillisDecoded
        let workUnitsGeneratedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workUnitsGeneratedCount) ?? 0
        workUnitsGeneratedCount = workUnitsGeneratedCountDecoded
    }
}

extension LakeFormationClientTypes {
    /// Statistics related to the processing of a query statement.
    public struct PlanningStatistics: Swift.Equatable {
        /// An estimate of the data that was scanned in bytes.
        public var estimatedDataToScanBytes: Swift.Int
        /// The time that it took to process the request.
        public var planningTimeMillis: Swift.Int
        /// The time the request was in queue to be processed.
        public var queueTimeMillis: Swift.Int
        /// The number of work units generated.
        public var workUnitsGeneratedCount: Swift.Int

        public init(
            estimatedDataToScanBytes: Swift.Int = 0,
            planningTimeMillis: Swift.Int = 0,
            queueTimeMillis: Swift.Int = 0,
            workUnitsGeneratedCount: Swift.Int = 0
        )
        {
            self.estimatedDataToScanBytes = estimatedDataToScanBytes
            self.planningTimeMillis = planningTimeMillis
            self.queueTimeMillis = queueTimeMillis
            self.workUnitsGeneratedCount = workUnitsGeneratedCount
        }
    }

}

extension LakeFormationClientTypes.PrincipalPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case principal = "Principal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension LakeFormationClientTypes {
    /// Permissions granted to a principal.
    public struct PrincipalPermissions: Swift.Equatable {
        /// The permissions that are granted to the principal.
        public var permissions: [LakeFormationClientTypes.Permission]?
        /// The principal who is granted permissions.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?

        public init(
            permissions: [LakeFormationClientTypes.Permission]? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil
        )
        {
            self.permissions = permissions
            self.principal = principal
        }
    }

}

extension LakeFormationClientTypes.PrincipalResourcePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalDetails = "AdditionalDetails"
        case lastUpdated = "LastUpdated"
        case lastUpdatedBy = "LastUpdatedBy"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalDetails = self.additionalDetails {
            try encodeContainer.encode(additionalDetails, forKey: .additionalDetails)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permission0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permission0.rawValue)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsWithGrantOptionContainer {
                if let enum0 = enum0 {
                    permissionsWithGrantOptionDecoded0?.append(enum0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
        let additionalDetailsDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DetailsMap.self, forKey: .additionalDetails)
        additionalDetails = additionalDetailsDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
    }
}

extension LakeFormationClientTypes {
    /// The permissions granted or revoked on a resource.
    public struct PrincipalResourcePermissions: Swift.Equatable {
        /// This attribute can be used to return any additional details of PrincipalResourcePermissions. Currently returns only as a RAM resource share ARN.
        public var additionalDetails: LakeFormationClientTypes.DetailsMap?
        /// The date and time when the resource was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The user who updated the record.
        public var lastUpdatedBy: Swift.String?
        /// The permissions to be granted or revoked on the resource.
        public var permissions: [LakeFormationClientTypes.Permission]?
        /// Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).
        public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
        /// The Data Lake principal to be granted or revoked permissions.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?
        /// The resource where permissions are to be granted or revoked.
        public var resource: LakeFormationClientTypes.Resource?

        public init(
            additionalDetails: LakeFormationClientTypes.DetailsMap? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            permissions: [LakeFormationClientTypes.Permission]? = nil,
            permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
            resource: LakeFormationClientTypes.Resource? = nil
        )
        {
            self.additionalDetails = additionalDetails
            self.lastUpdated = lastUpdated
            self.lastUpdatedBy = lastUpdatedBy
            self.permissions = permissions
            self.permissionsWithGrantOption = permissionsWithGrantOption
            self.principal = principal
            self.resource = resource
        }
    }

}

extension PutDataLakeSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case dataLakeSettings = "DataLakeSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let dataLakeSettings = self.dataLakeSettings {
            try encodeContainer.encode(dataLakeSettings, forKey: .dataLakeSettings)
        }
    }
}

extension PutDataLakeSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutDataLakeSettings"
    }
}

public struct PutDataLakeSettingsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A structure representing a list of Lake Formation principals designated as data lake administrators.
    /// This member is required.
    public var dataLakeSettings: LakeFormationClientTypes.DataLakeSettings?

    public init(
        catalogId: Swift.String? = nil,
        dataLakeSettings: LakeFormationClientTypes.DataLakeSettings? = nil
    )
    {
        self.catalogId = catalogId
        self.dataLakeSettings = dataLakeSettings
    }
}

struct PutDataLakeSettingsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let dataLakeSettings: LakeFormationClientTypes.DataLakeSettings?
}

extension PutDataLakeSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case dataLakeSettings = "DataLakeSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let dataLakeSettingsDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakeSettings.self, forKey: .dataLakeSettings)
        dataLakeSettings = dataLakeSettingsDecoded
    }
}

extension PutDataLakeSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutDataLakeSettingsOutput: Swift.Equatable {

    public init() { }
}

enum PutDataLakeSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.QueryPlanningContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case queryAsOfTime = "QueryAsOfTime"
        case queryParameters = "QueryParameters"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let queryAsOfTime = self.queryAsOfTime {
            try encodeContainer.encodeTimestamp(queryAsOfTime, format: .epochSeconds, forKey: .queryAsOfTime)
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryParameters)
            for (dictKey0, queryParameterMap0) in queryParameters {
                try queryParametersContainer.encode(queryParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let queryAsOfTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .queryAsOfTime)
        queryAsOfTime = queryAsOfTimeDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryParameters)
        var queryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in queryParametersContainer {
                if let string0 = string0 {
                    queryParametersDecoded0?[key0] = string0
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure containing information about the query plan.
    public struct QueryPlanningContext: Swift.Equatable {
        /// The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.
        public var catalogId: Swift.String?
        /// The database containing the table.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
        public var queryAsOfTime: ClientRuntime.Date?
        /// A map consisting of key-value pairs.
        public var queryParameters: [Swift.String:Swift.String]?
        /// The transaction ID at which to read the table contents. If this transaction is not committed, the read will be treated as part of that transaction and will see its writes. If this transaction has aborted, an error will be returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with QueryAsOfTime.
        public var transactionId: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            queryAsOfTime: ClientRuntime.Date? = nil,
            queryParameters: [Swift.String:Swift.String]? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.queryAsOfTime = queryAsOfTime
            self.queryParameters = queryParameters
            self.transactionId = transactionId
        }
    }

}

extension LakeFormationClientTypes {
    public enum QueryStateString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case expired
        case finished
        case pending
        case workunitsAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStateString] {
            return [
                .error,
                .expired,
                .finished,
                .pending,
                .workunitsAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .expired: return "EXPIRED"
            case .finished: return "FINISHED"
            case .pending: return "PENDING"
            case .workunitsAvailable: return "WORKUNITS_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryStateString(rawValue: rawValue) ?? QueryStateString.sdkUnknown(rawValue)
        }
    }
}

extension RegisterResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hybridAccessEnabled = "HybridAccessEnabled"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case useServiceLinkedRole = "UseServiceLinkedRole"
        case withFederation = "WithFederation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hybridAccessEnabled = self.hybridAccessEnabled {
            try encodeContainer.encode(hybridAccessEnabled, forKey: .hybridAccessEnabled)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let useServiceLinkedRole = self.useServiceLinkedRole {
            try encodeContainer.encode(useServiceLinkedRole, forKey: .useServiceLinkedRole)
        }
        if let withFederation = self.withFederation {
            try encodeContainer.encode(withFederation, forKey: .withFederation)
        }
    }
}

extension RegisterResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RegisterResource"
    }
}

public struct RegisterResourceInput: Swift.Equatable {
    /// Specifies whether the data access of tables pointing to the location can be managed by both Lake Formation permissions as well as Amazon S3 bucket policies.
    public var hybridAccessEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the resource that you want to register.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The identifier for the role that registers the resource.
    public var roleArn: Swift.String?
    /// Designates an Identity and Access Management (IAM) service-linked role by registering this role with the Data Catalog. A service-linked role is a unique type of IAM role that is linked directly to Lake Formation. For more information, see [Using Service-Linked Roles for Lake Formation](https://docs.aws.amazon.com/lake-formation/latest/dg/service-linked-roles.html).
    public var useServiceLinkedRole: Swift.Bool?
    /// Whether or not the resource is a federated resource.
    public var withFederation: Swift.Bool?

    public init(
        hybridAccessEnabled: Swift.Bool? = nil,
        resourceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        useServiceLinkedRole: Swift.Bool? = nil,
        withFederation: Swift.Bool? = nil
    )
    {
        self.hybridAccessEnabled = hybridAccessEnabled
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.useServiceLinkedRole = useServiceLinkedRole
        self.withFederation = withFederation
    }
}

struct RegisterResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let useServiceLinkedRole: Swift.Bool?
    let roleArn: Swift.String?
    let withFederation: Swift.Bool?
    let hybridAccessEnabled: Swift.Bool?
}

extension RegisterResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hybridAccessEnabled = "HybridAccessEnabled"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case useServiceLinkedRole = "UseServiceLinkedRole"
        case withFederation = "WithFederation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let useServiceLinkedRoleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useServiceLinkedRole)
        useServiceLinkedRole = useServiceLinkedRoleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let withFederationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withFederation)
        withFederation = withFederationDecoded
        let hybridAccessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hybridAccessEnabled)
        hybridAccessEnabled = hybridAccessEnabledDecoded
    }
}

extension RegisterResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterResourceOutput: Swift.Equatable {

    public init() { }
}

enum RegisterResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNumberLimitExceededException": return try await ResourceNumberLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveLFTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case lfTags = "LFTags"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let lfTags = lfTags {
            var lfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTags)
            for lftagpair0 in lfTags {
                try lfTagsContainer.encode(lftagpair0)
            }
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension RemoveLFTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RemoveLFTagsFromResource"
    }
}

public struct RemoveLFTagsFromResourceInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The LF-tags to be removed from the resource.
    /// This member is required.
    public var lfTags: [LakeFormationClientTypes.LFTagPair]?
    /// The database, table, or column resource where you want to remove an LF-tag.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.lfTags = lfTags
        self.resource = resource
    }
}

struct RemoveLFTagsFromResourceInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let resource: LakeFormationClientTypes.Resource?
    let lfTags: [LakeFormationClientTypes.LFTagPair]?
}

extension RemoveLFTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case lfTags = "LFTags"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let lfTagsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTags)
        var lfTagsDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsContainer = lfTagsContainer {
            lfTagsDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsContainer {
                if let structure0 = structure0 {
                    lfTagsDecoded0?.append(structure0)
                }
            }
        }
        lfTags = lfTagsDecoded0
    }
}

extension RemoveLFTagsFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveLFTagsFromResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
        } else {
            self.failures = nil
        }
    }
}

public struct RemoveLFTagsFromResourceOutput: Swift.Equatable {
    /// A list of failures to untag a resource.
    public var failures: [LakeFormationClientTypes.LFTagError]?

    public init(
        failures: [LakeFormationClientTypes.LFTagError]? = nil
    )
    {
        self.failures = failures
    }
}

struct RemoveLFTagsFromResourceOutputBody: Swift.Equatable {
    let failures: [LakeFormationClientTypes.LFTagError]?
}

extension RemoveLFTagsFromResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures = "Failures"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagError?].self, forKey: .failures)
        var failuresDecoded0:[LakeFormationClientTypes.LFTagError]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LakeFormationClientTypes.LFTagError]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum RemoveLFTagsFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GlueEncryptionException": return try await GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case dataCellsFilter = "DataCellsFilter"
        case dataLocation = "DataLocation"
        case database = "Database"
        case lfTag = "LFTag"
        case lfTagPolicy = "LFTagPolicy"
        case table = "Table"
        case tableWithColumns = "TableWithColumns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let dataCellsFilter = self.dataCellsFilter {
            try encodeContainer.encode(dataCellsFilter, forKey: .dataCellsFilter)
        }
        if let dataLocation = self.dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let lfTag = self.lfTag {
            try encodeContainer.encode(lfTag, forKey: .lfTag)
        }
        if let lfTagPolicy = self.lfTagPolicy {
            try encodeContainer.encode(lfTagPolicy, forKey: .lfTagPolicy)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
        if let tableWithColumns = self.tableWithColumns {
            try encodeContainer.encode(tableWithColumns, forKey: .tableWithColumns)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.CatalogResource.self, forKey: .catalog)
        catalog = catalogDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DatabaseResource.self, forKey: .database)
        database = databaseDecoded
        let tableDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TableResource.self, forKey: .table)
        table = tableDecoded
        let tableWithColumnsDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TableWithColumnsResource.self, forKey: .tableWithColumns)
        tableWithColumns = tableWithColumnsDecoded
        let dataLocationDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLocationResource.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let dataCellsFilterDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataCellsFilterResource.self, forKey: .dataCellsFilter)
        dataCellsFilter = dataCellsFilterDecoded
        let lfTagDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.LFTagKeyResource.self, forKey: .lfTag)
        lfTag = lfTagDecoded
        let lfTagPolicyDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.LFTagPolicyResource.self, forKey: .lfTagPolicy)
        lfTagPolicy = lfTagPolicyDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure for the resource.
    public struct Resource: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalog: LakeFormationClientTypes.CatalogResource?
        /// A data cell filter.
        public var dataCellsFilter: LakeFormationClientTypes.DataCellsFilterResource?
        /// The location of an Amazon S3 path where permissions are granted or revoked.
        public var dataLocation: LakeFormationClientTypes.DataLocationResource?
        /// The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal.
        public var database: LakeFormationClientTypes.DatabaseResource?
        /// The LF-tag key and values attached to a resource.
        public var lfTag: LakeFormationClientTypes.LFTagKeyResource?
        /// A list of LF-tag conditions that define a resource's LF-tag policy.
        public var lfTagPolicy: LakeFormationClientTypes.LFTagPolicyResource?
        /// The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.
        public var table: LakeFormationClientTypes.TableResource?
        /// The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.
        public var tableWithColumns: LakeFormationClientTypes.TableWithColumnsResource?

        public init(
            catalog: LakeFormationClientTypes.CatalogResource? = nil,
            dataCellsFilter: LakeFormationClientTypes.DataCellsFilterResource? = nil,
            dataLocation: LakeFormationClientTypes.DataLocationResource? = nil,
            database: LakeFormationClientTypes.DatabaseResource? = nil,
            lfTag: LakeFormationClientTypes.LFTagKeyResource? = nil,
            lfTagPolicy: LakeFormationClientTypes.LFTagPolicyResource? = nil,
            table: LakeFormationClientTypes.TableResource? = nil,
            tableWithColumns: LakeFormationClientTypes.TableWithColumnsResource? = nil
        )
        {
            self.catalog = catalog
            self.dataCellsFilter = dataCellsFilter
            self.dataLocation = dataLocation
            self.database = database
            self.lfTag = lfTag
            self.lfTagPolicy = lfTagPolicy
            self.table = table
            self.tableWithColumns = tableWithColumns
        }
    }

}

extension LakeFormationClientTypes.ResourceInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hybridAccessEnabled = "HybridAccessEnabled"
        case lastModified = "LastModified"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case withFederation = "WithFederation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hybridAccessEnabled = self.hybridAccessEnabled {
            try encodeContainer.encode(hybridAccessEnabled, forKey: .hybridAccessEnabled)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let withFederation = self.withFederation {
            try encodeContainer.encode(withFederation, forKey: .withFederation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let withFederationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withFederation)
        withFederation = withFederationDecoded
        let hybridAccessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hybridAccessEnabled)
        hybridAccessEnabled = hybridAccessEnabledDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure containing information about an Lake Formation resource.
    public struct ResourceInfo: Swift.Equatable {
        /// Indicates whether the data access of tables pointing to the location can be managed by both Lake Formation permissions as well as Amazon S3 bucket policies.
        public var hybridAccessEnabled: Swift.Bool?
        /// The date and time the resource was last modified.
        public var lastModified: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// The IAM role that registered a resource.
        public var roleArn: Swift.String?
        /// Whether or not the resource is a federated resource.
        public var withFederation: Swift.Bool?

        public init(
            hybridAccessEnabled: Swift.Bool? = nil,
            lastModified: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            withFederation: Swift.Bool? = nil
        )
        {
            self.hybridAccessEnabled = hybridAccessEnabled
            self.lastModified = lastModified
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.withFederation = withFederation
        }
    }

}

extension ResourceNotReadyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error related to a resource which is not ready for a transaction.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotReadyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNumberLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNumberLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource numerical limit was exceeded.
public struct ResourceNumberLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNumberLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNumberLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNumberLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes {
    public enum ResourceShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case foreign
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareType] {
            return [
                .all,
                .foreign,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .foreign: return "FOREIGN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareType(rawValue: rawValue) ?? ResourceShareType.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case database
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .database,
                .table,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .database: return "DATABASE"
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension RevokePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permission0 in permissions {
                try permissionsContainer.encode(permission0.rawValue)
            }
        }
        if let permissionsWithGrantOption = permissionsWithGrantOption {
            var permissionsWithGrantOptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionsWithGrantOption)
            for permission0 in permissionsWithGrantOption {
                try permissionsWithGrantOptionContainer.encode(permission0.rawValue)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension RevokePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RevokePermissions"
    }
}

public struct RevokePermissionsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The permissions revoked to the principal on the resource. For information about permissions, see [Security and Access Control to Metadata and Data](https://docs.aws.amazon.com/lake-formation/latest/dg/security-data-access.html).
    /// This member is required.
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// Indicates a list of permissions for which to revoke the grant option allowing the principal to pass permissions to other principals.
    public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
    /// The principal to be revoked permissions on the resource.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// The resource to which permissions are to be revoked.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

struct RevokePermissionsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let principal: LakeFormationClientTypes.DataLakePrincipal?
    let resource: LakeFormationClientTypes.Resource?
    let permissions: [LakeFormationClientTypes.Permission]?
    let permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
}

extension RevokePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case permissions = "Permissions"
        case permissionsWithGrantOption = "PermissionsWithGrantOption"
        case principal = "Principal"
        case resource = "Resource"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataLakePrincipal.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let permissionsWithGrantOptionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.Permission?].self, forKey: .permissionsWithGrantOption)
        var permissionsWithGrantOptionDecoded0:[LakeFormationClientTypes.Permission]? = nil
        if let permissionsWithGrantOptionContainer = permissionsWithGrantOptionContainer {
            permissionsWithGrantOptionDecoded0 = [LakeFormationClientTypes.Permission]()
            for enum0 in permissionsWithGrantOptionContainer {
                if let enum0 = enum0 {
                    permissionsWithGrantOptionDecoded0?.append(enum0)
                }
            }
        }
        permissionsWithGrantOption = permissionsWithGrantOptionDecoded0
    }
}

extension RevokePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RevokePermissionsOutput: Swift.Equatable {

    public init() { }
}

enum RevokePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.RowFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allRowsWildcard = "AllRowsWildcard"
        case filterExpression = "FilterExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRowsWildcard = self.allRowsWildcard {
            try encodeContainer.encode(allRowsWildcard, forKey: .allRowsWildcard)
        }
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let allRowsWildcardDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.AllRowsWildcard.self, forKey: .allRowsWildcard)
        allRowsWildcard = allRowsWildcardDecoded
    }
}

extension LakeFormationClientTypes {
    /// A PartiQL predicate.
    public struct RowFilter: Swift.Equatable {
        /// A wildcard for all rows.
        public var allRowsWildcard: LakeFormationClientTypes.AllRowsWildcard?
        /// A filter expression.
        public var filterExpression: Swift.String?

        public init(
            allRowsWildcard: LakeFormationClientTypes.AllRowsWildcard? = nil,
            filterExpression: Swift.String? = nil
        )
        {
            self.allRowsWildcard = allRowsWildcard
            self.filterExpression = filterExpression
        }
    }

}

extension SearchDatabasesByLFTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDatabasesByLFTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SearchDatabasesByLFTags"
    }
}

public struct SearchDatabasesByLFTagsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of conditions (LFTag structures) to search for in database resources.
    /// This member is required.
    public var expression: [LakeFormationClientTypes.LFTag]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        expression: [LakeFormationClientTypes.LFTag]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDatabasesByLFTagsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let catalogId: Swift.String?
    let expression: [LakeFormationClientTypes.LFTag]?
}

extension SearchDatabasesByLFTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let expressionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[LakeFormationClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [LakeFormationClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension SearchDatabasesByLFTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchDatabasesByLFTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct SearchDatabasesByLFTagsOutput: Swift.Equatable {
    /// A list of databases that meet the LF-tag conditions.
    public var databaseList: [LakeFormationClientTypes.TaggedDatabase]?
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?

    public init(
        databaseList: [LakeFormationClientTypes.TaggedDatabase]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct SearchDatabasesByLFTagsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let databaseList: [LakeFormationClientTypes.TaggedDatabase]?
}

extension SearchDatabasesByLFTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let databaseListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.TaggedDatabase?].self, forKey: .databaseList)
        var databaseListDecoded0:[LakeFormationClientTypes.TaggedDatabase]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [LakeFormationClientTypes.TaggedDatabase]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
    }
}

enum SearchDatabasesByLFTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GlueEncryptionException": return try await GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchTablesByLFTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchTablesByLFTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SearchTablesByLFTags"
    }
}

public struct SearchTablesByLFTagsInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of conditions (LFTag structures) to search for in table resources.
    /// This member is required.
    public var expression: [LakeFormationClientTypes.LFTag]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        expression: [LakeFormationClientTypes.LFTag]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchTablesByLFTagsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let catalogId: Swift.String?
    let expression: [LakeFormationClientTypes.LFTag]?
}

extension SearchTablesByLFTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let expressionContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[LakeFormationClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [LakeFormationClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension SearchTablesByLFTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchTablesByLFTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableList = output.tableList
        } else {
            self.nextToken = nil
            self.tableList = nil
        }
    }
}

public struct SearchTablesByLFTagsOutput: Swift.Equatable {
    /// A continuation token, present if the current list segment is not the last. On the first run, if you include a not null (a value) token you can get empty pages.
    public var nextToken: Swift.String?
    /// A list of tables that meet the LF-tag conditions.
    public var tableList: [LakeFormationClientTypes.TaggedTable]?

    public init(
        nextToken: Swift.String? = nil,
        tableList: [LakeFormationClientTypes.TaggedTable]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

struct SearchTablesByLFTagsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tableList: [LakeFormationClientTypes.TaggedTable]?
}

extension SearchTablesByLFTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tableList = "TableList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tableListContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.TaggedTable?].self, forKey: .tableList)
        var tableListDecoded0:[LakeFormationClientTypes.TaggedTable]? = nil
        if let tableListContainer = tableListContainer {
            tableListDecoded0 = [LakeFormationClientTypes.TaggedTable]()
            for structure0 in tableListContainer {
                if let structure0 = structure0 {
                    tableListDecoded0?.append(structure0)
                }
            }
        }
        tableList = tableListDecoded0
    }
}

enum SearchTablesByLFTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GlueEncryptionException": return try await GlueEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartQueryPlanningInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartQueryPlanningInput(queryPlanningContext: \(Swift.String(describing: queryPlanningContext)), queryString: \"CONTENT_REDACTED\")"}
}

extension StartQueryPlanningInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryPlanningContext = "QueryPlanningContext"
        case queryString = "QueryString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryPlanningContext = self.queryPlanningContext {
            try encodeContainer.encode(queryPlanningContext, forKey: .queryPlanningContext)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }
}

extension StartQueryPlanningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartQueryPlanning"
    }
}

public struct StartQueryPlanningInput: Swift.Equatable {
    /// A structure containing information about the query plan.
    /// This member is required.
    public var queryPlanningContext: LakeFormationClientTypes.QueryPlanningContext?
    /// A PartiQL query statement used as an input to the planner service.
    /// This member is required.
    public var queryString: Swift.String?

    public init(
        queryPlanningContext: LakeFormationClientTypes.QueryPlanningContext? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.queryPlanningContext = queryPlanningContext
        self.queryString = queryString
    }
}

struct StartQueryPlanningInputBody: Swift.Equatable {
    let queryPlanningContext: LakeFormationClientTypes.QueryPlanningContext?
    let queryString: Swift.String?
}

extension StartQueryPlanningInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryPlanningContext = "QueryPlanningContext"
        case queryString = "QueryString"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryPlanningContextDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.QueryPlanningContext.self, forKey: .queryPlanningContext)
        queryPlanningContext = queryPlanningContextDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
    }
}

extension StartQueryPlanningOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartQueryPlanningOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryId = output.queryId
        } else {
            self.queryId = nil
        }
    }
}

/// A structure for the output.
public struct StartQueryPlanningOutput: Swift.Equatable {
    /// The ID of the plan query operation can be used to fetch the actual work unit descriptors that are produced as the result of the operation. The ID is also used to get the query state and as an input to the Execute operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct StartQueryPlanningOutputBody: Swift.Equatable {
    let queryId: Swift.String?
}

extension StartQueryPlanningOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

enum StartQueryPlanningOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionType = "TransactionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionType = self.transactionType {
            try encodeContainer.encode(transactionType.rawValue, forKey: .transactionType)
        }
    }
}

extension StartTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartTransaction"
    }
}

public struct StartTransactionInput: Swift.Equatable {
    /// Indicates whether this transaction should be read only or read and write. Writes made using a read-only transaction ID will be rejected. Read-only transactions do not need to be committed.
    public var transactionType: LakeFormationClientTypes.TransactionType?

    public init(
        transactionType: LakeFormationClientTypes.TransactionType? = nil
    )
    {
        self.transactionType = transactionType
    }
}

struct StartTransactionInputBody: Swift.Equatable {
    let transactionType: LakeFormationClientTypes.TransactionType?
}

extension StartTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionType = "TransactionType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionTypeDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TransactionType.self, forKey: .transactionType)
        transactionType = transactionTypeDecoded
    }
}

extension StartTransactionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTransactionOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

public struct StartTransactionOutput: Swift.Equatable {
    /// An opaque identifier for the transaction.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct StartTransactionOutputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension StartTransactionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

enum StartTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StatisticsNotReadyYetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StatisticsNotReadyYetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error related to statistics not being ready.
public struct StatisticsNotReadyYetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StatisticsNotReadyYetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StatisticsNotReadyYetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StatisticsNotReadyYetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes.StorageOptimizer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case errorMessage = "ErrorMessage"
        case lastRunDetails = "LastRunDetails"
        case storageOptimizerType = "StorageOptimizerType"
        case warnings = "Warnings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .config)
            for (dictKey0, storageOptimizerConfig0) in config {
                try configContainer.encode(storageOptimizerConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastRunDetails = self.lastRunDetails {
            try encodeContainer.encode(lastRunDetails, forKey: .lastRunDetails)
        }
        if let storageOptimizerType = self.storageOptimizerType {
            try encodeContainer.encode(storageOptimizerType.rawValue, forKey: .storageOptimizerType)
        }
        if let warnings = self.warnings {
            try encodeContainer.encode(warnings, forKey: .warnings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageOptimizerTypeDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.OptimizerType.self, forKey: .storageOptimizerType)
        storageOptimizerType = storageOptimizerTypeDecoded
        let configContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .config)
        var configDecoded0: [Swift.String:Swift.String]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [Swift.String:Swift.String]()
            for (key0, storageoptimizerconfigvalue0) in configContainer {
                if let storageoptimizerconfigvalue0 = storageoptimizerconfigvalue0 {
                    configDecoded0?[key0] = storageoptimizerconfigvalue0
                }
            }
        }
        config = configDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let warningsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warnings)
        warnings = warningsDecoded
        let lastRunDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRunDetails)
        lastRunDetails = lastRunDetailsDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure describing the configuration and details of a storage optimizer.
    public struct StorageOptimizer: Swift.Equatable {
        /// A map of the storage optimizer configuration. Currently contains only one key-value pair: is_enabled indicates true or false for acceleration.
        public var config: [Swift.String:Swift.String]?
        /// A message that contains information about any error (if present). When an acceleration result has an enabled status, the error message is empty. When an acceleration result has a disabled status, the message describes an error or simply indicates "disabled by the user".
        public var errorMessage: Swift.String?
        /// When an acceleration result has an enabled status, contains the details of the last job run.
        public var lastRunDetails: Swift.String?
        /// The specific type of storage optimizer. The supported value is compaction.
        public var storageOptimizerType: LakeFormationClientTypes.OptimizerType?
        /// A message that contains information about any warnings (if present).
        public var warnings: Swift.String?

        public init(
            config: [Swift.String:Swift.String]? = nil,
            errorMessage: Swift.String? = nil,
            lastRunDetails: Swift.String? = nil,
            storageOptimizerType: LakeFormationClientTypes.OptimizerType? = nil,
            warnings: Swift.String? = nil
        )
        {
            self.config = config
            self.errorMessage = errorMessage
            self.lastRunDetails = lastRunDetails
            self.storageOptimizerType = storageOptimizerType
            self.warnings = warnings
        }
    }

}

extension LakeFormationClientTypes.TableObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case size = "Size"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
    }
}

extension LakeFormationClientTypes {
    /// Specifies the details of a governed table.
    public struct TableObject: Swift.Equatable {
        /// The Amazon S3 ETag of the object. Returned by GetTableObjects for validation and used to identify changes to the underlying data.
        public var eTag: Swift.String?
        /// The size of the Amazon S3 object in bytes.
        public var size: Swift.Int
        /// The Amazon S3 location of the object.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            size: Swift.Int = 0,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.size = size
            self.uri = uri
        }
    }

}

extension LakeFormationClientTypes.TableResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case name = "Name"
        case tableWildcard = "TableWildcard"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableWildcard = self.tableWildcard {
            try encodeContainer.encode(tableWildcard, forKey: .tableWildcard)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tableWildcardDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TableWildcard.self, forKey: .tableWildcard)
        tableWildcard = tableWildcardDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure for the table object. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.
    public struct TableResource: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the table.
        public var name: Swift.String?
        /// A wildcard object representing every table under a database. At least one of TableResource$Name or TableResource$TableWildcard is required.
        public var tableWildcard: LakeFormationClientTypes.TableWildcard?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            tableWildcard: LakeFormationClientTypes.TableWildcard? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
            self.tableWildcard = tableWildcard
        }
    }

}

extension LakeFormationClientTypes.TableWildcard: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension LakeFormationClientTypes {
    /// A wildcard object representing every table under a database.
    public struct TableWildcard: Swift.Equatable {

        public init() { }
    }

}

extension LakeFormationClientTypes.TableWithColumnsResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case columnNames = "ColumnNames"
        case columnWildcard = "ColumnWildcard"
        case databaseName = "DatabaseName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for namestring0 in columnNames {
                try columnNamesContainer.encode(namestring0)
            }
        }
        if let columnWildcard = self.columnWildcard {
            try encodeContainer.encode(columnWildcard, forKey: .columnWildcard)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let columnNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[Swift.String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [Swift.String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
        let columnWildcardDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ColumnWildcard.self, forKey: .columnWildcard)
        columnWildcard = columnWildcardDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure for a table with columns object. This object is only used when granting a SELECT permission. This object must take a value for at least one of ColumnsNames, ColumnsIndexes, or ColumnsWildcard.
    public struct TableWithColumnsResource: Swift.Equatable {
        /// The identifier for the Data Catalog. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The list of column names for the table. At least one of ColumnNames or ColumnWildcard is required.
        public var columnNames: [Swift.String]?
        /// A wildcard specified by a ColumnWildcard object. At least one of ColumnNames or ColumnWildcard is required.
        public var columnWildcard: LakeFormationClientTypes.ColumnWildcard?
        /// The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.
        /// This member is required.
        public var name: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            columnNames: [Swift.String]? = nil,
            columnWildcard: LakeFormationClientTypes.ColumnWildcard? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.columnNames = columnNames
            self.columnWildcard = columnWildcard
            self.databaseName = databaseName
            self.name = name
        }
    }

}

extension LakeFormationClientTypes.TaggedDatabase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case lfTags = "LFTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let lfTags = lfTags {
            var lfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTags)
            for lftagpair0 in lfTags {
                try lfTagsContainer.encode(lftagpair0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DatabaseResource.self, forKey: .database)
        database = databaseDecoded
        let lfTagsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTags)
        var lfTagsDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsContainer = lfTagsContainer {
            lfTagsDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsContainer {
                if let structure0 = structure0 {
                    lfTagsDecoded0?.append(structure0)
                }
            }
        }
        lfTags = lfTagsDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure describing a database resource with LF-tags.
    public struct TaggedDatabase: Swift.Equatable {
        /// A database that has LF-tags attached to it.
        public var database: LakeFormationClientTypes.DatabaseResource?
        /// A list of LF-tags attached to the database.
        public var lfTags: [LakeFormationClientTypes.LFTagPair]?

        public init(
            database: LakeFormationClientTypes.DatabaseResource? = nil,
            lfTags: [LakeFormationClientTypes.LFTagPair]? = nil
        )
        {
            self.database = database
            self.lfTags = lfTags
        }
    }

}

extension LakeFormationClientTypes.TaggedTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lfTagOnDatabase = "LFTagOnDatabase"
        case lfTagsOnColumns = "LFTagsOnColumns"
        case lfTagsOnTable = "LFTagsOnTable"
        case table = "Table"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lfTagOnDatabase = lfTagOnDatabase {
            var lfTagOnDatabaseContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTagOnDatabase)
            for lftagpair0 in lfTagOnDatabase {
                try lfTagOnDatabaseContainer.encode(lftagpair0)
            }
        }
        if let lfTagsOnColumns = lfTagsOnColumns {
            var lfTagsOnColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTagsOnColumns)
            for columnlftag0 in lfTagsOnColumns {
                try lfTagsOnColumnsContainer.encode(columnlftag0)
            }
        }
        if let lfTagsOnTable = lfTagsOnTable {
            var lfTagsOnTableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lfTagsOnTable)
            for lftagpair0 in lfTagsOnTable {
                try lfTagsOnTableContainer.encode(lftagpair0)
            }
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TableResource.self, forKey: .table)
        table = tableDecoded
        let lfTagOnDatabaseContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTagOnDatabase)
        var lfTagOnDatabaseDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagOnDatabaseContainer = lfTagOnDatabaseContainer {
            lfTagOnDatabaseDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagOnDatabaseContainer {
                if let structure0 = structure0 {
                    lfTagOnDatabaseDecoded0?.append(structure0)
                }
            }
        }
        lfTagOnDatabase = lfTagOnDatabaseDecoded0
        let lfTagsOnTableContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.LFTagPair?].self, forKey: .lfTagsOnTable)
        var lfTagsOnTableDecoded0:[LakeFormationClientTypes.LFTagPair]? = nil
        if let lfTagsOnTableContainer = lfTagsOnTableContainer {
            lfTagsOnTableDecoded0 = [LakeFormationClientTypes.LFTagPair]()
            for structure0 in lfTagsOnTableContainer {
                if let structure0 = structure0 {
                    lfTagsOnTableDecoded0?.append(structure0)
                }
            }
        }
        lfTagsOnTable = lfTagsOnTableDecoded0
        let lfTagsOnColumnsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.ColumnLFTag?].self, forKey: .lfTagsOnColumns)
        var lfTagsOnColumnsDecoded0:[LakeFormationClientTypes.ColumnLFTag]? = nil
        if let lfTagsOnColumnsContainer = lfTagsOnColumnsContainer {
            lfTagsOnColumnsDecoded0 = [LakeFormationClientTypes.ColumnLFTag]()
            for structure0 in lfTagsOnColumnsContainer {
                if let structure0 = structure0 {
                    lfTagsOnColumnsDecoded0?.append(structure0)
                }
            }
        }
        lfTagsOnColumns = lfTagsOnColumnsDecoded0
    }
}

extension LakeFormationClientTypes {
    /// A structure describing a table resource with LF-tags.
    public struct TaggedTable: Swift.Equatable {
        /// A list of LF-tags attached to the database where the table resides.
        public var lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]?
        /// A list of LF-tags attached to columns in the table.
        public var lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]?
        /// A list of LF-tags attached to the table.
        public var lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]?
        /// A table that has LF-tags attached to it.
        public var table: LakeFormationClientTypes.TableResource?

        public init(
            lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]? = nil,
            lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]? = nil,
            lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]? = nil,
            table: LakeFormationClientTypes.TableResource? = nil
        )
        {
            self.lfTagOnDatabase = lfTagOnDatabase
            self.lfTagsOnColumns = lfTagsOnColumns
            self.lfTagsOnTable = lfTagsOnTable
            self.table = table
        }
    }

}

extension ThrottledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error where the query request was throttled.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransactionCanceledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransactionCanceledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error related to a transaction that was cancelled.
public struct TransactionCanceledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionCanceledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TransactionCanceledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransactionCanceledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransactionCommitInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransactionCommitInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error related to a transaction commit that was in progress.
public struct TransactionCommitInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionCommitInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TransactionCommitInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransactionCommitInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransactionCommittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransactionCommittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error where the specified transaction has already been committed and cannot be used for UpdateTableObjects.
public struct TransactionCommittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionCommittedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TransactionCommittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransactionCommittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes.TransactionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionEndTime = "TransactionEndTime"
        case transactionId = "TransactionId"
        case transactionStartTime = "TransactionStartTime"
        case transactionStatus = "TransactionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionEndTime = self.transactionEndTime {
            try encodeContainer.encodeTimestamp(transactionEndTime, format: .epochSeconds, forKey: .transactionEndTime)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let transactionStartTime = self.transactionStartTime {
            try encodeContainer.encodeTimestamp(transactionStartTime, format: .epochSeconds, forKey: .transactionStartTime)
        }
        if let transactionStatus = self.transactionStatus {
            try encodeContainer.encode(transactionStatus.rawValue, forKey: .transactionStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let transactionStatusDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.TransactionStatus.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
        let transactionStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .transactionStartTime)
        transactionStartTime = transactionStartTimeDecoded
        let transactionEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .transactionEndTime)
        transactionEndTime = transactionEndTimeDecoded
    }
}

extension LakeFormationClientTypes {
    /// A structure that contains information about a transaction.
    public struct TransactionDescription: Swift.Equatable {
        /// The time when the transaction committed or aborted, if it is not currently active.
        public var transactionEndTime: ClientRuntime.Date?
        /// The ID of the transaction.
        public var transactionId: Swift.String?
        /// The time when the transaction started.
        public var transactionStartTime: ClientRuntime.Date?
        /// A status of ACTIVE, COMMITTED, or ABORTED.
        public var transactionStatus: LakeFormationClientTypes.TransactionStatus?

        public init(
            transactionEndTime: ClientRuntime.Date? = nil,
            transactionId: Swift.String? = nil,
            transactionStartTime: ClientRuntime.Date? = nil,
            transactionStatus: LakeFormationClientTypes.TransactionStatus? = nil
        )
        {
            self.transactionEndTime = transactionEndTime
            self.transactionId = transactionId
            self.transactionStartTime = transactionStartTime
            self.transactionStatus = transactionStatus
        }
    }

}

extension LakeFormationClientTypes {
    public enum TransactionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case active
        case committed
        case commitInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TransactionStatus] {
            return [
                .aborted,
                .active,
                .committed,
                .commitInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .active: return "ACTIVE"
            case .committed: return "COMMITTED"
            case .commitInProgress: return "COMMIT_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransactionStatus(rawValue: rawValue) ?? TransactionStatus.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes {
    public enum TransactionStatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case active
        case all
        case committed
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [TransactionStatusFilter] {
            return [
                .aborted,
                .active,
                .all,
                .committed,
                .completed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .active: return "ACTIVE"
            case .all: return "ALL"
            case .committed: return "COMMITTED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransactionStatusFilter(rawValue: rawValue) ?? TransactionStatusFilter.sdkUnknown(rawValue)
        }
    }
}

extension LakeFormationClientTypes {
    public enum TransactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case readAndWrite
        case readOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [TransactionType] {
            return [
                .readAndWrite,
                .readOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .readAndWrite: return "READ_AND_WRITE"
            case .readOnly: return "READ_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransactionType(rawValue: rawValue) ?? TransactionType.sdkUnknown(rawValue)
        }
    }
}

extension UpdateDataCellsFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableData = "TableData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableData = self.tableData {
            try encodeContainer.encode(tableData, forKey: .tableData)
        }
    }
}

extension UpdateDataCellsFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateDataCellsFilter"
    }
}

public struct UpdateDataCellsFilterInput: Swift.Equatable {
    /// A DataCellsFilter structure containing information about the data cells filter.
    /// This member is required.
    public var tableData: LakeFormationClientTypes.DataCellsFilter?

    public init(
        tableData: LakeFormationClientTypes.DataCellsFilter? = nil
    )
    {
        self.tableData = tableData
    }
}

struct UpdateDataCellsFilterInputBody: Swift.Equatable {
    let tableData: LakeFormationClientTypes.DataCellsFilter?
}

extension UpdateDataCellsFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableData = "TableData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDataDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DataCellsFilter.self, forKey: .tableData)
        tableData = tableDataDecoded
    }
}

extension UpdateDataCellsFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDataCellsFilterOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDataCellsFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLFTagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValuesToAdd = "TagValuesToAdd"
        case tagValuesToDelete = "TagValuesToDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValuesToAdd = tagValuesToAdd {
            var tagValuesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValuesToAdd)
            for lftagvalue0 in tagValuesToAdd {
                try tagValuesToAddContainer.encode(lftagvalue0)
            }
        }
        if let tagValuesToDelete = tagValuesToDelete {
            var tagValuesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValuesToDelete)
            for lftagvalue0 in tagValuesToDelete {
                try tagValuesToDeleteContainer.encode(lftagvalue0)
            }
        }
    }
}

extension UpdateLFTagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLFTag"
    }
}

public struct UpdateLFTagInput: Swift.Equatable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag for which to add or delete values.
    /// This member is required.
    public var tagKey: Swift.String?
    /// A list of LF-tag values to add from the LF-tag.
    public var tagValuesToAdd: [Swift.String]?
    /// A list of LF-tag values to delete from the LF-tag.
    public var tagValuesToDelete: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil,
        tagValuesToAdd: [Swift.String]? = nil,
        tagValuesToDelete: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValuesToAdd = tagValuesToAdd
        self.tagValuesToDelete = tagValuesToDelete
    }
}

struct UpdateLFTagInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let tagKey: Swift.String?
    let tagValuesToDelete: [Swift.String]?
    let tagValuesToAdd: [Swift.String]?
}

extension UpdateLFTagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case tagKey = "TagKey"
        case tagValuesToAdd = "TagValuesToAdd"
        case tagValuesToDelete = "TagValuesToDelete"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValuesToDelete)
        var tagValuesToDeleteDecoded0:[Swift.String]? = nil
        if let tagValuesToDeleteContainer = tagValuesToDeleteContainer {
            tagValuesToDeleteDecoded0 = [Swift.String]()
            for string0 in tagValuesToDeleteContainer {
                if let string0 = string0 {
                    tagValuesToDeleteDecoded0?.append(string0)
                }
            }
        }
        tagValuesToDelete = tagValuesToDeleteDecoded0
        let tagValuesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValuesToAdd)
        var tagValuesToAddDecoded0:[Swift.String]? = nil
        if let tagValuesToAddContainer = tagValuesToAddContainer {
            tagValuesToAddDecoded0 = [Swift.String]()
            for string0 in tagValuesToAddContainer {
                if let string0 = string0 {
                    tagValuesToAddDecoded0?.append(string0)
                }
            }
        }
        tagValuesToAdd = tagValuesToAddDecoded0
    }
}

extension UpdateLFTagOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLFTagOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLFTagOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLakeFormationIdentityCenterConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStatus = "ApplicationStatus"
        case catalogId = "CatalogId"
        case externalFiltering = "ExternalFiltering"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let externalFiltering = self.externalFiltering {
            try encodeContainer.encode(externalFiltering, forKey: .externalFiltering)
        }
    }
}

extension UpdateLakeFormationIdentityCenterConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLakeFormationIdentityCenterConfiguration"
    }
}

public struct UpdateLakeFormationIdentityCenterConfigurationInput: Swift.Equatable {
    /// Allows to enable or disable the IAM Identity Center connection.
    public var applicationStatus: LakeFormationClientTypes.ApplicationStatus?
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, view definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of the account IDs of Amazon Web Services accounts of third-party applications that are allowed to access data managed by Lake Formation.
    public var externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?

    public init(
        applicationStatus: LakeFormationClientTypes.ApplicationStatus? = nil,
        catalogId: Swift.String? = nil,
        externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.catalogId = catalogId
        self.externalFiltering = externalFiltering
    }
}

struct UpdateLakeFormationIdentityCenterConfigurationInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let applicationStatus: LakeFormationClientTypes.ApplicationStatus?
    let externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
}

extension UpdateLakeFormationIdentityCenterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStatus = "ApplicationStatus"
        case catalogId = "CatalogId"
        case externalFiltering = "ExternalFiltering"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let externalFilteringDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.ExternalFilteringConfiguration.self, forKey: .externalFiltering)
        externalFiltering = externalFilteringDecoded
    }
}

extension UpdateLakeFormationIdentityCenterConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLakeFormationIdentityCenterConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLakeFormationIdentityCenterConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hybridAccessEnabled = "HybridAccessEnabled"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case withFederation = "WithFederation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hybridAccessEnabled = self.hybridAccessEnabled {
            try encodeContainer.encode(hybridAccessEnabled, forKey: .hybridAccessEnabled)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let withFederation = self.withFederation {
            try encodeContainer.encode(withFederation, forKey: .withFederation)
        }
    }
}

extension UpdateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateResource"
    }
}

public struct UpdateResourceInput: Swift.Equatable {
    /// Specifies whether the data access of tables pointing to the location can be managed by both Lake Formation permissions as well as Amazon S3 bucket policies.
    public var hybridAccessEnabled: Swift.Bool?
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new role to use for the given resource registered in Lake Formation.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Whether or not the resource is a federated resource.
    public var withFederation: Swift.Bool?

    public init(
        hybridAccessEnabled: Swift.Bool? = nil,
        resourceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        withFederation: Swift.Bool? = nil
    )
    {
        self.hybridAccessEnabled = hybridAccessEnabled
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.withFederation = withFederation
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let resourceArn: Swift.String?
    let withFederation: Swift.Bool?
    let hybridAccessEnabled: Swift.Bool?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hybridAccessEnabled = "HybridAccessEnabled"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case withFederation = "WithFederation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let withFederationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withFederation)
        withFederation = withFederationDecoded
        let hybridAccessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hybridAccessEnabled)
        hybridAccessEnabled = hybridAccessEnabledDecoded
    }
}

extension UpdateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTableObjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case transactionId = "TransactionId"
        case writeOperations = "WriteOperations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let writeOperations = writeOperations {
            var writeOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .writeOperations)
            for writeoperation0 in writeOperations {
                try writeOperationsContainer.encode(writeoperation0)
            }
        }
    }
}

extension UpdateTableObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateTableObjects"
    }
}

public struct UpdateTableObjectsInput: Swift.Equatable {
    /// The catalog containing the governed table to update. Defaults to the caller’s account ID.
    public var catalogId: Swift.String?
    /// The database containing the governed table to update.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The governed table to update.
    /// This member is required.
    public var tableName: Swift.String?
    /// The transaction at which to do the write.
    public var transactionId: Swift.String?
    /// A list of WriteOperation objects that define an object to add to or delete from the manifest for a governed table.
    /// This member is required.
    public var writeOperations: [LakeFormationClientTypes.WriteOperation]?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil,
        writeOperations: [LakeFormationClientTypes.WriteOperation]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.transactionId = transactionId
        self.writeOperations = writeOperations
    }
}

struct UpdateTableObjectsInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let transactionId: Swift.String?
    let writeOperations: [LakeFormationClientTypes.WriteOperation]?
}

extension UpdateTableObjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case transactionId = "TransactionId"
        case writeOperations = "WriteOperations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let writeOperationsContainer = try containerValues.decodeIfPresent([LakeFormationClientTypes.WriteOperation?].self, forKey: .writeOperations)
        var writeOperationsDecoded0:[LakeFormationClientTypes.WriteOperation]? = nil
        if let writeOperationsContainer = writeOperationsContainer {
            writeOperationsDecoded0 = [LakeFormationClientTypes.WriteOperation]()
            for structure0 in writeOperationsContainer {
                if let structure0 = structure0 {
                    writeOperationsDecoded0?.append(structure0)
                }
            }
        }
        writeOperations = writeOperationsDecoded0
    }
}

extension UpdateTableObjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTableObjectsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTableObjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationTimeoutException": return try await OperationTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotReadyException": return try await ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCanceledException": return try await TransactionCanceledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommitInProgressException": return try await TransactionCommitInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionCommittedException": return try await TransactionCommittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTableStorageOptimizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case storageOptimizerConfig = "StorageOptimizerConfig"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let storageOptimizerConfig = storageOptimizerConfig {
            var storageOptimizerConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .storageOptimizerConfig)
            for (dictKey0, storageOptimizerConfigMap0) in storageOptimizerConfig {
                var storageOptimizerConfigMap0Container = storageOptimizerConfigContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, storageOptimizerConfig1) in storageOptimizerConfigMap0 {
                    try storageOptimizerConfigMap0Container.encode(storageOptimizerConfig1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension UpdateTableStorageOptimizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateTableStorageOptimizer"
    }
}

public struct UpdateTableStorageOptimizerInput: Swift.Equatable {
    /// The Catalog ID of the table.
    public var catalogId: Swift.String?
    /// Name of the database where the table is present.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Name of the table for which to enable the storage optimizer.
    /// This member is required.
    public var storageOptimizerConfig: [Swift.String:[Swift.String:Swift.String]]?
    /// Name of the table for which to enable the storage optimizer.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        storageOptimizerConfig: [Swift.String:[Swift.String:Swift.String]]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.storageOptimizerConfig = storageOptimizerConfig
        self.tableName = tableName
    }
}

struct UpdateTableStorageOptimizerInputBody: Swift.Equatable {
    let catalogId: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let storageOptimizerConfig: [Swift.String:[Swift.String:Swift.String]]?
}

extension UpdateTableStorageOptimizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case storageOptimizerConfig = "StorageOptimizerConfig"
        case tableName = "TableName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let storageOptimizerConfigContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .storageOptimizerConfig)
        var storageOptimizerConfigDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let storageOptimizerConfigContainer = storageOptimizerConfigContainer {
            storageOptimizerConfigDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, storageoptimizerconfig0) in storageOptimizerConfigContainer {
                var storageoptimizerconfig0Decoded0: [Swift.String: Swift.String]? = nil
                if let storageoptimizerconfig0 = storageoptimizerconfig0 {
                    storageoptimizerconfig0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, storageoptimizerconfigvalue1) in storageoptimizerconfig0 {
                        if let storageoptimizerconfigvalue1 = storageoptimizerconfigvalue1 {
                            storageoptimizerconfig0Decoded0?[key1] = storageoptimizerconfigvalue1
                        }
                    }
                }
                storageOptimizerConfigDecoded0?[key0] = storageoptimizerconfig0Decoded0
            }
        }
        storageOptimizerConfig = storageOptimizerConfigDecoded0
    }
}

extension UpdateTableStorageOptimizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTableStorageOptimizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

public struct UpdateTableStorageOptimizerOutput: Swift.Equatable {
    /// A response indicating the success of failure of the operation.
    public var result: Swift.String?

    public init(
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct UpdateTableStorageOptimizerOutputBody: Swift.Equatable {
    let result: Swift.String?
}

extension UpdateTableStorageOptimizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

enum UpdateTableStorageOptimizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityNotFoundException": return try await EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LakeFormationClientTypes.VirtualObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
    }
}

extension LakeFormationClientTypes {
    /// An object that defines an Amazon S3 object to be deleted if a transaction cancels, provided that VirtualPut was called before writing the object.
    public struct VirtualObject: Swift.Equatable {
        /// The ETag of the Amazon S3 object.
        public var eTag: Swift.String?
        /// The path to the Amazon S3 object. Must start with s3://
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.uri = uri
        }
    }

}

extension LakeFormationClientTypes.WorkUnitRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workUnitIdMax = "WorkUnitIdMax"
        case workUnitIdMin = "WorkUnitIdMin"
        case workUnitToken = "WorkUnitToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if workUnitIdMax != 0 {
            try encodeContainer.encode(workUnitIdMax, forKey: .workUnitIdMax)
        }
        if workUnitIdMin != 0 {
            try encodeContainer.encode(workUnitIdMin, forKey: .workUnitIdMin)
        }
        if let workUnitToken = self.workUnitToken {
            try encodeContainer.encode(workUnitToken, forKey: .workUnitToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workUnitIdMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workUnitIdMax) ?? 0
        workUnitIdMax = workUnitIdMaxDecoded
        let workUnitIdMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workUnitIdMin) ?? 0
        workUnitIdMin = workUnitIdMinDecoded
        let workUnitTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workUnitToken)
        workUnitToken = workUnitTokenDecoded
    }
}

extension LakeFormationClientTypes {
    /// Defines the valid range of work unit IDs for querying the execution service.
    public struct WorkUnitRange: Swift.Equatable {
        /// Defines the maximum work unit ID in the range. The maximum value is inclusive.
        /// This member is required.
        public var workUnitIdMax: Swift.Int
        /// Defines the minimum work unit ID in the range.
        /// This member is required.
        public var workUnitIdMin: Swift.Int
        /// A work token used to query the execution service.
        /// This member is required.
        public var workUnitToken: Swift.String?

        public init(
            workUnitIdMax: Swift.Int = 0,
            workUnitIdMin: Swift.Int = 0,
            workUnitToken: Swift.String? = nil
        )
        {
            self.workUnitIdMax = workUnitIdMax
            self.workUnitIdMin = workUnitIdMin
            self.workUnitToken = workUnitToken
        }
    }

}

extension WorkUnitsNotReadyYetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: WorkUnitsNotReadyYetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains details about an error related to work units not being ready.
public struct WorkUnitsNotReadyYetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "WorkUnitsNotReadyYetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct WorkUnitsNotReadyYetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension WorkUnitsNotReadyYetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LakeFormationClientTypes.WriteOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addObject = "AddObject"
        case deleteObject = "DeleteObject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addObject = self.addObject {
            try encodeContainer.encode(addObject, forKey: .addObject)
        }
        if let deleteObject = self.deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addObjectDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.AddObjectInput.self, forKey: .addObject)
        addObject = addObjectDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(LakeFormationClientTypes.DeleteObjectInput.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
    }
}

extension LakeFormationClientTypes {
    /// Defines an object to add to or delete from a governed table.
    public struct WriteOperation: Swift.Equatable {
        /// A new object to add to the governed table.
        public var addObject: LakeFormationClientTypes.AddObjectInput?
        /// An object to delete from the governed table.
        public var deleteObject: LakeFormationClientTypes.DeleteObjectInput?

        public init(
            addObject: LakeFormationClientTypes.AddObjectInput? = nil,
            deleteObject: LakeFormationClientTypes.DeleteObjectInput? = nil
        )
        {
            self.addObject = addObject
            self.deleteObject = deleteObject
        }
    }

}
