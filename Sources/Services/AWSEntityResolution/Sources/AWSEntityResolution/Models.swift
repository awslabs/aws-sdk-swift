//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import func ClientRuntime.quoteHeaderValue
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists, Schema already exists, Workflow is currently running, etc.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception occurs when there is an internal failure in the Entity Resolution service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by Entity Resolution.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension EntityResolutionClientTypes {

    public enum StatementEffect: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementEffect] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "Allow"
            case .deny: return "Deny"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AddPolicyStatementInput: Swift.Sendable {
    /// The action that the principal can use on the resource. For example, entityresolution:GetIdMappingJob, entityresolution:GetMatchingJob.
    /// This member is required.
    public var action: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
    /// This member is required.
    public var arn: Swift.String?
    /// A set of condition keys that you can use in key policies.
    public var condition: Swift.String?
    /// Determines whether the permissions specified in the policy are to be allowed (Allow) or denied (Deny). If you set the value of the effect parameter to Deny for the AddPolicyStatement operation, you must also set the value of the effect parameter in the policy to Deny for the PutPolicy operation.
    /// This member is required.
    public var effect: EntityResolutionClientTypes.StatementEffect?
    /// The Amazon Web Services service or Amazon Web Services account that can access the resource defined as ARN.
    /// This member is required.
    public var principal: [Swift.String]?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: [Swift.String]? = nil,
        arn: Swift.String? = nil,
        condition: Swift.String? = nil,
        effect: EntityResolutionClientTypes.StatementEffect? = nil,
        principal: [Swift.String]? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.condition = condition
        self.effect = effect
        self.principal = principal
        self.statementId = statementId
    }
}

public struct AddPolicyStatementOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

extension EntityResolutionClientTypes {

    public enum AttributeMatchingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchDeleteUniqueIdInput: Swift.Sendable {
    /// The input source for the batch delete unique ID operation.
    public var inputSource: Swift.String?
    /// The unique IDs to delete.
    /// This member is required.
    public var uniqueIds: [Swift.String]?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        inputSource: Swift.String? = nil,
        uniqueIds: [Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.inputSource = inputSource
        self.uniqueIds = uniqueIds
        self.workflowName = workflowName
    }
}

extension EntityResolutionClientTypes {

    /// The deleted unique ID.
    public struct DeletedUniqueId: Swift.Sendable {
        /// The unique ID of the deleted item.
        /// This member is required.
        public var uniqueId: Swift.String?

        public init(
            uniqueId: Swift.String? = nil
        )
        {
            self.uniqueId = uniqueId
        }
    }
}

extension EntityResolutionClientTypes {

    public enum DeleteUniqueIdErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case serviceError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteUniqueIdErrorType] {
            return [
                .serviceError,
                .validationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .serviceError: return "SERVICE_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// The Delete Unique Id error.
    public struct DeleteUniqueIdError: Swift.Sendable {
        /// The error type for the batch delete unique ID operation.
        /// This member is required.
        public var errorType: EntityResolutionClientTypes.DeleteUniqueIdErrorType?
        /// The unique ID that could not be deleted.
        /// This member is required.
        public var uniqueId: Swift.String?

        public init(
            errorType: EntityResolutionClientTypes.DeleteUniqueIdErrorType? = nil,
            uniqueId: Swift.String? = nil
        )
        {
            self.errorType = errorType
            self.uniqueId = uniqueId
        }
    }
}

extension EntityResolutionClientTypes {

    public enum DeleteUniqueIdStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteUniqueIdStatus] {
            return [
                .accepted,
                .completed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchDeleteUniqueIdOutput: Swift.Sendable {
    /// The unique IDs that were deleted.
    /// This member is required.
    public var deleted: [EntityResolutionClientTypes.DeletedUniqueId]?
    /// The unique IDs that were disconnected.
    /// This member is required.
    public var disconnectedUniqueIds: [Swift.String]?
    /// The errors from deleting multiple unique IDs.
    /// This member is required.
    public var errors: [EntityResolutionClientTypes.DeleteUniqueIdError]?
    /// The status of the batch delete unique ID operation.
    /// This member is required.
    public var status: EntityResolutionClientTypes.DeleteUniqueIdStatus?

    public init(
        deleted: [EntityResolutionClientTypes.DeletedUniqueId]? = nil,
        disconnectedUniqueIds: [Swift.String]? = nil,
        errors: [EntityResolutionClientTypes.DeleteUniqueIdError]? = nil,
        status: EntityResolutionClientTypes.DeleteUniqueIdStatus? = nil
    )
    {
        self.deleted = deleted
        self.disconnectedUniqueIds = disconnectedUniqueIds
        self.errors = errors
        self.status = status
    }
}

/// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits. The error message describes the limit exceeded.
public struct ExceedsLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the quota that has been breached.
        public internal(set) var quotaName: Swift.String? = nil
        /// The current quota value for the customers.
        public internal(set) var quotaValue: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExceedsLimitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaName: Swift.String? = nil,
        quotaValue: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaName = quotaName
        self.properties.quotaValue = quotaValue
    }
}

extension EntityResolutionClientTypes {

    public enum IdMappingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case provider
        case ruleBased
        case sdkUnknown(Swift.String)

        public static var allCases: [IdMappingType] {
            return [
                .provider,
                .ruleBased
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .provider: return "PROVIDER"
            case .ruleBased: return "RULE_BASED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
    public struct IntermediateSourceConfiguration: Swift.Sendable {
        /// The Amazon S3 location (bucket and prefix). For example: s3://provider_bucket/DOC-EXAMPLE-BUCKET
        /// This member is required.
        public var intermediateS3Path: Swift.String?

        public init(
            intermediateS3Path: Swift.String? = nil
        )
        {
            self.intermediateS3Path = intermediateS3Path
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing the providerServiceARN, intermediateSourceConfiguration, and providerConfiguration.
    public struct ProviderProperties: Swift.Sendable {
        /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        public var intermediateSourceConfiguration: EntityResolutionClientTypes.IntermediateSourceConfiguration?
        /// The required configuration fields to use with the provider service.
        public var providerConfiguration: Smithy.Document?
        /// The ARN of the provider service.
        /// This member is required.
        public var providerServiceArn: Swift.String?

        public init(
            intermediateSourceConfiguration: EntityResolutionClientTypes.IntermediateSourceConfiguration? = nil,
            providerConfiguration: Smithy.Document? = nil,
            providerServiceArn: Swift.String? = nil
        )
        {
            self.intermediateSourceConfiguration = intermediateSourceConfiguration
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }
    }
}

extension EntityResolutionClientTypes {

    public enum RecordMatchingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case manySourceToOneTarget
        case oneSourceToOneTarget
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordMatchingModel] {
            return [
                .manySourceToOneTarget,
                .oneSourceToOneTarget
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .manySourceToOneTarget: return "MANY_SOURCE_TO_ONE_TARGET"
            case .oneSourceToOneTarget: return "ONE_SOURCE_TO_ONE_TARGET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    public enum IdMappingWorkflowRuleDefinitionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [IdMappingWorkflowRuleDefinitionType] {
            return [
                .source,
                .target
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .source: return "SOURCE"
            case .target: return "TARGET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing RuleName, and MatchingKeys.
    public struct Rule: Swift.Sendable {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in the SchemaMapping. Two records are considered to match according to this rule if all of the MatchingKeys match.
        /// This member is required.
        public var matchingKeys: [Swift.String]?
        /// A name for the matching rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            matchingKeys: [Swift.String]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object that defines the list of matching rules to run in an ID mapping workflow.
    public struct IdMappingRuleBasedProperties: Swift.Sendable {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the attributeMatchingModel. If you choose MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A matches the value of the BusinessEmail field of Profile B, the two profiles are matched on the Email attribute type. If you choose ONE_TO_ONE, the system can only match attributes if the sub-types are an exact match. For example, for the Email attribute type, the system will only consider it a match if the value of the Email field of Profile A matches the value of the Email field of Profile B.
        /// This member is required.
        public var attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel?
        /// The type of matching record that is allowed to be used in an ID mapping workflow. If the value is set to ONE_SOURCE_TO_ONE_TARGET, only one record in the source can be matched to the same record in the target. If the value is set to MANY_SOURCE_TO_ONE_TARGET, multiple records in the source can be matched to one record in the target.
        /// This member is required.
        public var recordMatchingModel: EntityResolutionClientTypes.RecordMatchingModel?
        /// The set of rules you can use in an ID mapping workflow. The limitations specified for the source or target to define the match rules must be compatible.
        /// This member is required.
        public var ruleDefinitionType: EntityResolutionClientTypes.IdMappingWorkflowRuleDefinitionType?
        /// The rules that can be used for ID mapping.
        public var rules: [EntityResolutionClientTypes.Rule]?

        public init(
            attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel? = nil,
            recordMatchingModel: EntityResolutionClientTypes.RecordMatchingModel? = nil,
            ruleDefinitionType: EntityResolutionClientTypes.IdMappingWorkflowRuleDefinitionType? = nil,
            rules: [EntityResolutionClientTypes.Rule]? = nil
        )
        {
            self.attributeMatchingModel = attributeMatchingModel
            self.recordMatchingModel = recordMatchingModel
            self.ruleDefinitionType = ruleDefinitionType
            self.rules = rules
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object which defines the ID mapping technique and any additional configurations.
    public struct IdMappingTechniques: Swift.Sendable {
        /// The type of ID mapping.
        /// This member is required.
        public var idMappingType: EntityResolutionClientTypes.IdMappingType?
        /// An object which defines any additional configurations required by the provider service.
        public var providerProperties: EntityResolutionClientTypes.ProviderProperties?
        /// An object which defines any additional configurations required by rule-based matching.
        public var ruleBasedProperties: EntityResolutionClientTypes.IdMappingRuleBasedProperties?

        public init(
            idMappingType: EntityResolutionClientTypes.IdMappingType? = nil,
            providerProperties: EntityResolutionClientTypes.ProviderProperties? = nil,
            ruleBasedProperties: EntityResolutionClientTypes.IdMappingRuleBasedProperties? = nil
        )
        {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
            self.ruleBasedProperties = ruleBasedProperties
        }
    }
}

extension EntityResolutionClientTypes {

    public enum IdNamespaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [IdNamespaceType] {
            return [
                .source,
                .target
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .source: return "SOURCE"
            case .target: return "TARGET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing InputSourceARN, SchemaName, and Type.
    public struct IdMappingWorkflowInputSource: Swift.Sendable {
        /// An Glue table Amazon Resource Name (ARN) or a matching workflow ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        public var schemaName: Swift.String?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId which all sourceIds will resolve to.
        public var type: EntityResolutionClientTypes.IdNamespaceType?

        public init(
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            type: EntityResolutionClientTypes.IdNamespaceType? = nil
        )
        {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
            self.type = type
        }
    }
}

extension EntityResolutionClientTypes {

    /// The output source for the ID mapping workflow.
    public struct IdMappingWorkflowOutputSource: Swift.Sendable {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
        }
    }
}

public struct CreateIdMappingWorkflowInput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the ID mapping technique and any additional configurations.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the workflow. There can't be multiple IdMappingWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

public struct CreateIdMappingWorkflowOutput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the ID mapping technique and any additional configurations.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IDMappingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = "",
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

extension EntityResolutionClientTypes {

    /// An object containing ProviderConfiguration and ProviderServiceArn.
    public struct NamespaceProviderProperties: Swift.Sendable {
        /// An object which defines any additional configurations required by the provider service.
        public var providerConfiguration: Smithy.Document?
        /// The Amazon Resource Name (ARN) of the provider service.
        /// This member is required.
        public var providerServiceArn: Swift.String?

        public init(
            providerConfiguration: Smithy.Document? = nil,
            providerServiceArn: Swift.String? = nil
        )
        {
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }
    }
}

extension EntityResolutionClientTypes {

    /// The rule-based properties of an ID namespace. These properties define how the ID namespace can be used in an ID mapping workflow.
    public struct NamespaceRuleBasedProperties: Swift.Sendable {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the attributeMatchingModel. If you choose MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A matches the value of BusinessEmail field of Profile B, the two profiles are matched on the Email attribute type. If you choose ONE_TO_ONE, the system can only match attributes if the sub-types are an exact match. For example, for the Email attribute type, the system will only consider it a match if the value of the Email field of Profile A matches the value of the Email field of Profile B.
        public var attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel?
        /// The type of matching record that is allowed to be used in an ID mapping workflow. If the value is set to ONE_SOURCE_TO_ONE_TARGET, only one record in the source is matched to one record in the target. If the value is set to MANY_SOURCE_TO_ONE_TARGET, all matching records in the source are matched to one record in the target.
        public var recordMatchingModels: [EntityResolutionClientTypes.RecordMatchingModel]?
        /// The sets of rules you can use in an ID mapping workflow. The limitations specified for the source and target must be compatible.
        public var ruleDefinitionTypes: [EntityResolutionClientTypes.IdMappingWorkflowRuleDefinitionType]?
        /// The rules for the ID namespace.
        public var rules: [EntityResolutionClientTypes.Rule]?

        public init(
            attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel? = nil,
            recordMatchingModels: [EntityResolutionClientTypes.RecordMatchingModel]? = nil,
            ruleDefinitionTypes: [EntityResolutionClientTypes.IdMappingWorkflowRuleDefinitionType]? = nil,
            rules: [EntityResolutionClientTypes.Rule]? = nil
        )
        {
            self.attributeMatchingModel = attributeMatchingModel
            self.recordMatchingModels = recordMatchingModels
            self.ruleDefinitionTypes = ruleDefinitionTypes
            self.rules = rules
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing IdMappingType, ProviderProperties, and RuleBasedProperties.
    public struct IdNamespaceIdMappingWorkflowProperties: Swift.Sendable {
        /// The type of ID mapping.
        /// This member is required.
        public var idMappingType: EntityResolutionClientTypes.IdMappingType?
        /// An object which defines any additional configurations required by the provider service.
        public var providerProperties: EntityResolutionClientTypes.NamespaceProviderProperties?
        /// An object which defines any additional configurations required by rule-based matching.
        public var ruleBasedProperties: EntityResolutionClientTypes.NamespaceRuleBasedProperties?

        public init(
            idMappingType: EntityResolutionClientTypes.IdMappingType? = nil,
            providerProperties: EntityResolutionClientTypes.NamespaceProviderProperties? = nil,
            ruleBasedProperties: EntityResolutionClientTypes.NamespaceRuleBasedProperties? = nil
        )
        {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
            self.ruleBasedProperties = ruleBasedProperties
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing InputSourceARN and SchemaName.
    public struct IdNamespaceInputSource: Swift.Sendable {
        /// An Glue table Amazon Resource Name (ARN) or a matching workflow ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?

        public init(
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }
}

public struct CreateIdNamespaceInput: Swift.Sendable {
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of the workflow run.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?

    public init(
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil
    )
    {
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
    }
}

public struct CreateIdNamespaceOutput: Swift.Sendable {
    /// The timestamp of when the ID namespace was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The Amazon Resource Name (ARN) of the ID namespace.
    /// This member is required.
    public var idNamespaceArn: Swift.String?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in inputSourceConfig on your behalf as part of the workflow run.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?
    /// The timestamp of when the ID namespace was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceArn: Swift.String? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceArn = idNamespaceArn
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension EntityResolutionClientTypes {

    public enum IncrementalRunType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case immediate
        case sdkUnknown(Swift.String)

        public static var allCases: [IncrementalRunType] {
            return [
                .immediate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public struct IncrementalRunConfig: Swift.Sendable {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public var incrementalRunType: EntityResolutionClientTypes.IncrementalRunType?

        public init(
            incrementalRunType: EntityResolutionClientTypes.IncrementalRunType? = nil
        )
        {
            self.incrementalRunType = incrementalRunType
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing InputSourceARN, SchemaName, and ApplyNormalization.
    public struct InputSource: Swift.Sendable {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// An Glue table Amazon Resource Name (ARN) for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        /// This member is required.
        public var schemaName: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }
}

extension EntityResolutionClientTypes {

    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputAttribute: Swift.Sendable {
        /// Enables the ability to hash the column values in the output.
        public var hashed: Swift.Bool?
        /// A name of a column to be written to the output. This must be an InputField name in the schema mapping.
        /// This member is required.
        public var name: Swift.String?

        public init(
            hashed: Swift.Bool? = nil,
            name: Swift.String? = nil
        )
        {
            self.hashed = hashed
            self.name = name
        }
    }
}

extension EntityResolutionClientTypes {

    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputSource: Swift.Sendable {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        /// This member is required.
        public var output: [EntityResolutionClientTypes.OutputAttribute]?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            kmsArn: Swift.String? = nil,
            output: [EntityResolutionClientTypes.OutputAttribute]? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }
    }
}

extension EntityResolutionClientTypes {

    public enum ResolutionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mlMatching
        case provider
        case ruleMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionType] {
            return [
                .mlMatching,
                .provider,
                .ruleMatching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mlMatching: return "ML_MATCHING"
            case .provider: return "PROVIDER"
            case .ruleMatching: return "RULE_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    public enum MatchPurpose: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case identifierGeneration
        case indexing
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchPurpose] {
            return [
                .identifierGeneration,
                .indexing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .identifierGeneration: return "IDENTIFIER_GENERATION"
            case .indexing: return "INDEXING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object which defines the list of matching rules to run in a matching workflow. RuleBasedProperties contain a Rules field, which is a list of rule objects.
    public struct RuleBasedProperties: Swift.Sendable {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the attributeMatchingModel. If you choose MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email attribute type. If you choose ONE_TO_ONE, the system can only match attributes if the sub-types are an exact match. For example, for the Email attribute type, the system will only consider it a match if the value of the Email field of Profile A matches the value of the Email field of Profile B.
        /// This member is required.
        public var attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel?
        /// An indicator of whether to generate IDs and index the data or not. If you choose IDENTIFIER_GENERATION, the process generates IDs and indexes the data. If you choose INDEXING, the process indexes the data without generating IDs.
        public var matchPurpose: EntityResolutionClientTypes.MatchPurpose?
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        /// This member is required.
        public var rules: [EntityResolutionClientTypes.Rule]?

        public init(
            attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel? = nil,
            matchPurpose: EntityResolutionClientTypes.MatchPurpose? = nil,
            rules: [EntityResolutionClientTypes.Rule]? = nil
        )
        {
            self.attributeMatchingModel = attributeMatchingModel
            self.matchPurpose = matchPurpose
            self.rules = rules
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object which defines the resolutionType and the ruleBasedProperties.
    public struct ResolutionTechniques: Swift.Sendable {
        /// The properties of the provider service.
        public var providerProperties: EntityResolutionClientTypes.ProviderProperties?
        /// The type of matching. There are three types of matching: RULE_MATCHING, ML_MATCHING, and PROVIDER.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
        public var ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties?

        public init(
            providerProperties: EntityResolutionClientTypes.ProviderProperties? = nil,
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties? = nil
        )
        {
            self.providerProperties = providerProperties
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }
    }
}

public struct CreateMatchingWorkflowInput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the workflow. There can't be multiple MatchingWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

public struct CreateMatchingWorkflowOutput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

extension EntityResolutionClientTypes {

    public enum SchemaAttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case addressCity
        case addressCountry
        case addressPostalcode
        case addressState
        case addressStreet1
        case addressStreet2
        case addressStreet3
        case date
        case emailAddress
        case name
        case nameFirst
        case nameLast
        case nameMiddle
        case phone
        case phoneCountrycode
        case phoneNumber
        case providerId
        case string
        case uniqueId
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaAttributeType] {
            return [
                .address,
                .addressCity,
                .addressCountry,
                .addressPostalcode,
                .addressState,
                .addressStreet1,
                .addressStreet2,
                .addressStreet3,
                .date,
                .emailAddress,
                .name,
                .nameFirst,
                .nameLast,
                .nameMiddle,
                .phone,
                .phoneCountrycode,
                .phoneNumber,
                .providerId,
                .string,
                .uniqueId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .addressCity: return "ADDRESS_CITY"
            case .addressCountry: return "ADDRESS_COUNTRY"
            case .addressPostalcode: return "ADDRESS_POSTALCODE"
            case .addressState: return "ADDRESS_STATE"
            case .addressStreet1: return "ADDRESS_STREET1"
            case .addressStreet2: return "ADDRESS_STREET2"
            case .addressStreet3: return "ADDRESS_STREET3"
            case .date: return "DATE"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .nameFirst: return "NAME_FIRST"
            case .nameLast: return "NAME_LAST"
            case .nameMiddle: return "NAME_MIDDLE"
            case .phone: return "PHONE"
            case .phoneCountrycode: return "PHONE_COUNTRYCODE"
            case .phoneNumber: return "PHONE_NUMBER"
            case .providerId: return "PROVIDER_ID"
            case .string: return "STRING"
            case .uniqueId: return "UNIQUE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing FieldName, Type, GroupName, MatchKey, Hashing, and SubType.
    public struct SchemaInputAttribute: Swift.Sendable {
        /// A string containing the field name.
        /// This member is required.
        public var fieldName: Swift.String?
        /// A string that instructs Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common groupName will prompt Entity Resolution to concatenate them into a single value.
        public var groupName: Swift.String?
        /// Indicates if the column values are hashed in the schema input. If the value is set to TRUE, the column values are hashed. If the value is set to FALSE, the column values are cleartext.
        public var hashed: Swift.Bool?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning a matchKey called address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no matchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public var matchKey: Swift.String?
        /// The subtype of the attribute, selected from a list of values.
        public var subType: Swift.String?
        /// The type of the attribute, selected from a list of values.
        /// This member is required.
        public var type: EntityResolutionClientTypes.SchemaAttributeType?

        public init(
            fieldName: Swift.String? = nil,
            groupName: Swift.String? = nil,
            hashed: Swift.Bool? = nil,
            matchKey: Swift.String? = nil,
            subType: Swift.String? = nil,
            type: EntityResolutionClientTypes.SchemaAttributeType? = nil
        )
        {
            self.fieldName = fieldName
            self.groupName = groupName
            self.hashed = hashed
            self.matchKey = matchKey
            self.subType = subType
            self.type = type
        }
    }
}

public struct CreateSchemaMappingInput: Swift.Sendable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There can't be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
        self.tags = tags
    }
}

public struct CreateSchemaMappingOutput: Swift.Sendable {
    /// A description of the schema.
    /// This member is required.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

public struct DeleteIdMappingWorkflowInput: Swift.Sendable {
    /// The name of the workflow to be deleted.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

public struct DeleteIdMappingWorkflowOutput: Swift.Sendable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteIdNamespaceInput: Swift.Sendable {
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?

    public init(
        idNamespaceName: Swift.String? = nil
    )
    {
        self.idNamespaceName = idNamespaceName
    }
}

public struct DeleteIdNamespaceOutput: Swift.Sendable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeleteMatchingWorkflowInput: Swift.Sendable {
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

public struct DeleteMatchingWorkflowOutput: Swift.Sendable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct DeletePolicyStatementInput: Swift.Sendable {
    /// The ARN of the resource for which the policy need to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.statementId = statementId
    }
}

public struct DeletePolicyStatementOutput: Swift.Sendable {
    /// The ARN of the resource for which the policy need to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the deleted policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

public struct DeleteSchemaMappingInput: Swift.Sendable {
    /// The name of the schema to delete.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

public struct DeleteSchemaMappingOutput: Swift.Sendable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

public struct GetIdMappingJobInput: Swift.Sendable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

extension EntityResolutionClientTypes {

    /// An object containing an error message, if there was an error.
    public struct ErrorDetails: Swift.Sendable {
        /// The error message from the job, if there is one.
        public var errorMessage: Swift.String?

        public init(
            errorMessage: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing InputRecords, RecordsNotProcessed, TotalRecordsProcessed, TotalMappedRecords, TotalMappedSourceRecords, and TotalMappedTargetRecords.
    public struct IdMappingJobMetrics: Swift.Sendable {
        /// The total number of records that were input for processing.
        public var inputRecords: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records that were mapped.
        public var totalMappedRecords: Swift.Int?
        /// The total number of mapped source records.
        public var totalMappedSourceRecords: Swift.Int?
        /// The total number of distinct mapped target records.
        public var totalMappedTargetRecords: Swift.Int?
        /// The total number of records that were processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalMappedRecords: Swift.Int? = nil,
            totalMappedSourceRecords: Swift.Int? = nil,
            totalMappedTargetRecords: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.recordsNotProcessed = recordsNotProcessed
            self.totalMappedRecords = totalMappedRecords
            self.totalMappedSourceRecords = totalMappedSourceRecords
            self.totalMappedTargetRecords = totalMappedTargetRecords
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing KMSArn, OutputS3Path, and RoleARN.
    public struct IdMappingJobOutputSource: Swift.Sendable {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf as part of workflow execution.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
            self.roleArn = roleArn
        }
    }
}

extension EntityResolutionClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .failed,
                .queued,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIdMappingJobOutput: Swift.Sendable {
    /// The time at which the job has finished.
    public var endTime: Foundation.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.IdMappingJobMetrics?
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: Foundation.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.IdMappingJobMetrics? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil,
        startTime: Foundation.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.outputSourceConfig = outputSourceConfig
        self.startTime = startTime
        self.status = status
    }
}

public struct GetIdMappingWorkflowInput: Swift.Sendable {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

public struct GetIdMappingWorkflowOutput: Swift.Sendable {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the ID mapping technique and any additional configurations.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow .
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = "",
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

public struct GetIdNamespaceInput: Swift.Sendable {
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?

    public init(
        idNamespaceName: Swift.String? = nil
    )
    {
        self.idNamespaceName = idNamespaceName
    }
}

public struct GetIdNamespaceOutput: Swift.Sendable {
    /// The timestamp of when the ID namespace was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The Amazon Resource Name (ARN) of the ID namespace.
    /// This member is required.
    public var idNamespaceArn: Swift.String?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?
    /// The timestamp of when the ID namespace was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceArn: Swift.String? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceArn = idNamespaceArn
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct GetMatchIdInput: Swift.Sendable {
    /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
    public var applyNormalization: Swift.Bool?
    /// The record to fetch the Match ID for.
    /// This member is required.
    public var record: [Swift.String: Swift.String]?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        applyNormalization: Swift.Bool? = nil,
        record: [Swift.String: Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.applyNormalization = applyNormalization
        self.record = record
        self.workflowName = workflowName
    }
}

extension GetMatchIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMatchIdInput(applyNormalization: \(Swift.String(describing: applyNormalization)), workflowName: \(Swift.String(describing: workflowName)), record: \"CONTENT_REDACTED\")"}
}

public struct GetMatchIdOutput: Swift.Sendable {
    /// The unique identifiers for this group of match records.
    public var matchId: Swift.String?
    /// The rule the record matched on.
    public var matchRule: Swift.String?

    public init(
        matchId: Swift.String? = nil,
        matchRule: Swift.String? = nil
    )
    {
        self.matchId = matchId
        self.matchRule = matchRule
    }
}

public struct GetMatchingJobInput: Swift.Sendable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

extension EntityResolutionClientTypes {

    /// An object containing InputRecords, TotalRecordsProcessed, MatchIDs, and RecordsNotProcessed.
    public struct JobMetrics: Swift.Sendable {
        /// The total number of input records.
        public var inputRecords: Swift.Int?
        /// The total number of matchIDs generated.
        public var matchIDs: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            matchIDs: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }
}

extension EntityResolutionClientTypes {

    /// An object containing KMSArn, OutputS3Path, and RoleArn.
    public struct JobOutputSource: Swift.Sendable {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf as part of workflow execution.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
            self.roleArn = roleArn
        }
    }
}

public struct GetMatchingJobOutput: Swift.Sendable {
    /// The time at which the job has finished.
    public var endTime: Foundation.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.JobMetrics?
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.JobOutputSource]?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: Foundation.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.JobMetrics? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.JobOutputSource]? = nil,
        startTime: Foundation.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.outputSourceConfig = outputSourceConfig
        self.startTime = startTime
        self.status = status
    }
}

public struct GetMatchingWorkflowInput: Swift.Sendable {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

public struct GetMatchingWorkflowOutput: Swift.Sendable {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

public struct GetPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which the policy need to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetPolicyOutput: Swift.Sendable {
    /// The Entity Resolution resource ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

public struct GetProviderServiceInput: Swift.Sendable {
    /// The name of the provider. This name is typically the company name.
    /// This member is required.
    public var providerName: Swift.String?
    /// The ARN (Amazon Resource Name) of the product that the provider service provides.
    /// This member is required.
    public var providerServiceName: Swift.String?

    public init(
        providerName: Swift.String? = nil,
        providerServiceName: Swift.String? = nil
    )
    {
        self.providerName = providerName
        self.providerServiceName = providerServiceName
    }
}

extension EntityResolutionClientTypes {

    /// The provider schema attribute.
    public struct ProviderSchemaAttribute: Swift.Sendable {
        /// The field name.
        /// This member is required.
        public var fieldName: Swift.String?
        /// The hashing attribute of the provider schema.
        public var hashing: Swift.Bool?
        /// The sub type of the provider schema attribute.
        public var subType: Swift.String?
        /// The type of the provider schema attribute.
        /// This member is required.
        public var type: EntityResolutionClientTypes.SchemaAttributeType?

        public init(
            fieldName: Swift.String? = nil,
            hashing: Swift.Bool? = nil,
            subType: Swift.String? = nil,
            type: EntityResolutionClientTypes.SchemaAttributeType? = nil
        )
        {
            self.fieldName = fieldName
            self.hashing = hashing
            self.subType = subType
            self.type = type
        }
    }
}

extension EntityResolutionClientTypes {

    /// The input schema supported by provider service.
    public struct ProviderComponentSchema: Swift.Sendable {
        /// The provider schema attributes.
        public var providerSchemaAttributes: [EntityResolutionClientTypes.ProviderSchemaAttribute]?
        /// Input schema for the provider service.
        public var schemas: [[Swift.String]]?

        public init(
            providerSchemaAttributes: [EntityResolutionClientTypes.ProviderSchemaAttribute]? = nil,
            schemas: [[Swift.String]]? = nil
        )
        {
            self.providerSchemaAttributes = providerSchemaAttributes
            self.schemas = schemas
        }
    }
}

extension EntityResolutionClientTypes {

    /// The identifiers of the provider service, from Data Exchange.
    public struct ProviderMarketplaceConfiguration: Swift.Sendable {
        /// The asset ID on Data Exchange.
        /// This member is required.
        public var assetId: Swift.String?
        /// The dataset ID on Data Exchange.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The listing ID on Data Exchange.
        /// This member is required.
        public var listingId: Swift.String?
        /// The revision ID on Data Exchange.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            listingId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.listingId = listingId
            self.revisionId = revisionId
        }
    }
}

extension EntityResolutionClientTypes {

    /// The required configuration fields to use with the provider service.
    public enum ProviderEndpointConfiguration: Swift.Sendable {
        /// The identifiers of the provider service, from Data Exchange.
        case marketplaceconfiguration(EntityResolutionClientTypes.ProviderMarketplaceConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension EntityResolutionClientTypes {

    /// The provider configuration required for different ID namespace types.
    public struct ProviderIdNameSpaceConfiguration: Swift.Sendable {
        /// The description of the ID namespace.
        public var description: Swift.String?
        /// Configurations required for the source ID namespace.
        public var providerSourceConfigurationDefinition: Smithy.Document?
        /// Configurations required for the target ID namespace.
        public var providerTargetConfigurationDefinition: Smithy.Document?

        public init(
            description: Swift.String? = nil,
            providerSourceConfigurationDefinition: Smithy.Document? = nil,
            providerTargetConfigurationDefinition: Smithy.Document? = nil
        )
        {
            self.description = description
            self.providerSourceConfigurationDefinition = providerSourceConfigurationDefinition
            self.providerTargetConfigurationDefinition = providerTargetConfigurationDefinition
        }
    }
}

extension EntityResolutionClientTypes {

    /// The required configuration fields to give intermediate access to a provider service.
    public struct ProviderIntermediateDataAccessConfiguration: Swift.Sendable {
        /// The Amazon Web Services account that provider can use to read or write data into the customer's intermediate S3 bucket.
        public var awsAccountIds: [Swift.String]?
        /// The S3 bucket actions that the provider requires permission for.
        public var requiredBucketActions: [Swift.String]?

        public init(
            awsAccountIds: [Swift.String]? = nil,
            requiredBucketActions: [Swift.String]? = nil
        )
        {
            self.awsAccountIds = awsAccountIds
            self.requiredBucketActions = requiredBucketActions
        }
    }
}

extension EntityResolutionClientTypes {

    public enum ServiceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assignment
        case idMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .assignment,
                .idMapping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assignment: return "ASSIGNMENT"
            case .idMapping: return "ID_MAPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetProviderServiceOutput: Swift.Sendable {
    /// Specifies whether output data from the provider is anonymized. A value of TRUE means the output will be anonymized and you can't relate the data that comes back from the provider to the identifying input. A value of FALSE means the output won't be anonymized and you can relate the data that comes back from the provider to your source data.
    /// This member is required.
    public var anonymizedOutput: Swift.Bool?
    /// Input schema for the provider service.
    public var providerComponentSchema: EntityResolutionClientTypes.ProviderComponentSchema?
    /// The definition of the provider configuration.
    public var providerConfigurationDefinition: Smithy.Document?
    /// The required configuration fields to use with the provider service.
    /// This member is required.
    public var providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration?
    /// The definition of the provider entity output.
    /// This member is required.
    public var providerEntityOutputDefinition: Smithy.Document?
    /// The provider configuration required for different ID namespace types.
    public var providerIdNameSpaceConfiguration: EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration?
    /// The Amazon Web Services accounts and the S3 permissions that are required by some providers to create an S3 bucket for intermediate data storage.
    public var providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration?
    /// Provider service job configurations.
    public var providerJobConfiguration: Smithy.Document?
    /// The name of the provider. This name is typically the company name.
    /// This member is required.
    public var providerName: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the provider service.
    /// This member is required.
    public var providerServiceArn: Swift.String?
    /// The display name of the provider service.
    /// This member is required.
    public var providerServiceDisplayName: Swift.String?
    /// The name of the product that the provider service provides.
    /// This member is required.
    public var providerServiceName: Swift.String?
    /// The type of provider service.
    /// This member is required.
    public var providerServiceType: EntityResolutionClientTypes.ServiceType?

    public init(
        anonymizedOutput: Swift.Bool? = nil,
        providerComponentSchema: EntityResolutionClientTypes.ProviderComponentSchema? = nil,
        providerConfigurationDefinition: Smithy.Document? = nil,
        providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration? = nil,
        providerEntityOutputDefinition: Smithy.Document? = nil,
        providerIdNameSpaceConfiguration: EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration? = nil,
        providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration? = nil,
        providerJobConfiguration: Smithy.Document? = nil,
        providerName: Swift.String? = nil,
        providerServiceArn: Swift.String? = nil,
        providerServiceDisplayName: Swift.String? = nil,
        providerServiceName: Swift.String? = nil,
        providerServiceType: EntityResolutionClientTypes.ServiceType? = nil
    )
    {
        self.anonymizedOutput = anonymizedOutput
        self.providerComponentSchema = providerComponentSchema
        self.providerConfigurationDefinition = providerConfigurationDefinition
        self.providerEndpointConfiguration = providerEndpointConfiguration
        self.providerEntityOutputDefinition = providerEntityOutputDefinition
        self.providerIdNameSpaceConfiguration = providerIdNameSpaceConfiguration
        self.providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfiguration
        self.providerJobConfiguration = providerJobConfiguration
        self.providerName = providerName
        self.providerServiceArn = providerServiceArn
        self.providerServiceDisplayName = providerServiceDisplayName
        self.providerServiceName = providerServiceName
        self.providerServiceType = providerServiceType
    }
}

public struct GetSchemaMappingInput: Swift.Sendable {
    /// The name of the schema to be retrieved.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

public struct GetSchemaMappingOutput: Swift.Sendable {
    /// The timestamp of when the SchemaMapping was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// A description of the schema.
    public var description: Swift.String?
    /// Specifies whether the schema mapping has been applied to a workflow.
    /// This member is required.
    public var hasWorkflows: Swift.Bool?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp of when the SchemaMapping was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        hasWorkflows: Swift.Bool? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.hasWorkflows = hasWorkflows
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

public struct ListIdMappingJobsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

extension EntityResolutionClientTypes {

    /// An object containing the JobId, Status, StartTime, and EndTime of a job.
    public struct JobSummary: Swift.Sendable {
        /// The time at which the job has finished.
        public var endTime: Foundation.Date?
        /// The ID of the job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The time at which the job was started.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The current status of the job.
        /// This member is required.
        public var status: EntityResolutionClientTypes.JobStatus?

        public init(
            endTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: EntityResolutionClientTypes.JobStatus? = nil
        )
        {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }
    }
}

public struct ListIdMappingJobsOutput: Swift.Sendable {
    /// A list of JobSummary objects.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListIdMappingWorkflowsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension EntityResolutionClientTypes {

    /// A list of IdMappingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public struct IdMappingWorkflowSummary: Swift.Sendable {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }
}

public struct ListIdMappingWorkflowsOutput: Swift.Sendable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of IdMappingWorkflowSummary objects.
    public var workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

public struct ListIdNamespacesInput: Swift.Sendable {
    /// The maximum number of IdNamespace objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension EntityResolutionClientTypes {

    /// The settings for the ID namespace for the ID mapping workflow job.
    public struct IdNamespaceIdMappingWorkflowMetadata: Swift.Sendable {
        /// The type of ID mapping.
        /// This member is required.
        public var idMappingType: EntityResolutionClientTypes.IdMappingType?

        public init(
            idMappingType: EntityResolutionClientTypes.IdMappingType? = nil
        )
        {
            self.idMappingType = idMappingType
        }
    }
}

extension EntityResolutionClientTypes {

    /// A summary of ID namespaces.
    public struct IdNamespaceSummary: Swift.Sendable {
        /// The timestamp of when the ID namespace was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the ID namespace.
        public var description: Swift.String?
        /// An object which defines any additional configurations required by the ID mapping workflow.
        public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowMetadata]?
        /// The Amazon Resource Name (ARN) of the ID namespace.
        /// This member is required.
        public var idNamespaceArn: Swift.String?
        /// The name of the ID namespace.
        /// This member is required.
        public var idNamespaceName: Swift.String?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId which all sourceIds will resolve to.
        /// This member is required.
        public var type: EntityResolutionClientTypes.IdNamespaceType?
        /// The timestamp of when the ID namespace was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowMetadata]? = nil,
            idNamespaceArn: Swift.String? = nil,
            idNamespaceName: Swift.String? = nil,
            type: EntityResolutionClientTypes.IdNamespaceType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.idMappingWorkflowProperties = idMappingWorkflowProperties
            self.idNamespaceArn = idNamespaceArn
            self.idNamespaceName = idNamespaceName
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListIdNamespacesOutput: Swift.Sendable {
    /// A list of IdNamespaceSummaries objects.
    public var idNamespaceSummaries: [EntityResolutionClientTypes.IdNamespaceSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        idNamespaceSummaries: [EntityResolutionClientTypes.IdNamespaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.idNamespaceSummaries = idNamespaceSummaries
        self.nextToken = nextToken
    }
}

public struct ListMatchingJobsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

public struct ListMatchingJobsOutput: Swift.Sendable {
    /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListMatchingWorkflowsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension EntityResolutionClientTypes {

    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, UpdatedAt.
    public struct MatchingWorkflowSummary: Swift.Sendable {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The method that has been specified for data matching, either using matching provided by Entity Resolution or through a provider service.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            updatedAt: Foundation.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.resolutionType = resolutionType
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }
}

public struct ListMatchingWorkflowsOutput: Swift.Sendable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public var workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

public struct ListProviderServicesInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the provider. This name is typically the company name.
    public var providerName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.providerName = providerName
    }
}

extension EntityResolutionClientTypes {

    /// A list of ProviderService objects, each of which contain the fields providerName, providerServiceArn, providerServiceName, and providerServiceType.
    public struct ProviderServiceSummary: Swift.Sendable {
        /// The name of the provider. This name is typically the company name.
        /// This member is required.
        public var providerName: Swift.String?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the providerService.
        /// This member is required.
        public var providerServiceArn: Swift.String?
        /// The display name of the provider service.
        /// This member is required.
        public var providerServiceDisplayName: Swift.String?
        /// The name of the product that the provider service provides.
        /// This member is required.
        public var providerServiceName: Swift.String?
        /// The type of provider service.
        /// This member is required.
        public var providerServiceType: EntityResolutionClientTypes.ServiceType?

        public init(
            providerName: Swift.String? = nil,
            providerServiceArn: Swift.String? = nil,
            providerServiceDisplayName: Swift.String? = nil,
            providerServiceName: Swift.String? = nil,
            providerServiceType: EntityResolutionClientTypes.ServiceType? = nil
        )
        {
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }
    }
}

public struct ListProviderServicesOutput: Swift.Sendable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of ProviderServices objects.
    public var providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.providerServiceSummaries = providerServiceSummaries
    }
}

public struct ListSchemaMappingsInput: Swift.Sendable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension EntityResolutionClientTypes {

    /// An object containing SchemaName, SchemaArn, CreatedAt, andUpdatedAt.
    public struct SchemaMappingSummary: Swift.Sendable {
        /// The timestamp of when the SchemaMapping was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Specifies whether the schema mapping has been applied to a workflow.
        /// This member is required.
        public var hasWorkflows: Swift.Bool?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The timestamp of when the SchemaMapping was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            hasWorkflows: Swift.Bool? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.hasWorkflows = hasWorkflows
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }
    }
}

public struct ListSchemaMappingsOutput: Swift.Sendable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of SchemaMappingSummary objects, each of which contain the fields SchemaName, SchemaArn, CreatedAt, UpdatedAt.
    public var schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaList = schemaList
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which the policy needs to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy. If you set the value of the effect parameter in the policy to Deny for the PutPolicy operation, you must also set the value of the effect parameter to Deny for the AddPolicyStatement operation.
    /// This member is required.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

public struct PutPolicyOutput: Swift.Sendable {
    /// The Entity Resolution resource ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

public struct StartIdMappingJobInput: Swift.Sendable {
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
    /// The name of the ID mapping job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.outputSourceConfig = outputSourceConfig
        self.workflowName = workflowName
    }
}

public struct StartIdMappingJobOutput: Swift.Sendable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?

    public init(
        jobId: Swift.String? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil
    )
    {
        self.jobId = jobId
        self.outputSourceConfig = outputSourceConfig
    }
}

public struct StartMatchingJobInput: Swift.Sendable {
    /// The name of the matching job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

public struct StartMatchingJobOutput: Swift.Sendable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource for which you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateIdMappingWorkflowInput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the ID mapping technique and any additional configurations.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

public struct UpdateIdMappingWorkflowOutput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the ID mapping technique and any additional configurations.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = "",
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

public struct UpdateIdNamespaceInput: Swift.Sendable {
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    public var roleArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
    }
}

public struct UpdateIdNamespaceOutput: Swift.Sendable {
    /// The timestamp of when the ID namespace was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The Amazon Resource Name (ARN) of the ID namespace.
    /// This member is required.
    public var idNamespaceArn: Swift.String?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    public var roleArn: Swift.String?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?
    /// The timestamp of when the ID namespace was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceArn: Swift.String? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceArn = idNamespaceArn
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct UpdateMatchingWorkflowInput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

public struct UpdateMatchingWorkflowOutput: Swift.Sendable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

public struct UpdateSchemaMappingInput: Swift.Sendable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There can't be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
    }
}

public struct UpdateSchemaMappingOutput: Swift.Sendable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

extension AddPolicyStatementInput {

    static func urlPathProvider(_ value: AddPolicyStatementInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())/\(statementId.urlPercentEncoding())"
    }
}

extension BatchDeleteUniqueIdInput {

    static func urlPathProvider(_ value: BatchDeleteUniqueIdInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/uniqueids"
    }
}

extension BatchDeleteUniqueIdInput {

    static func headerProvider(_ value: BatchDeleteUniqueIdInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let inputSource = value.inputSource {
            items.add(SmithyHTTPAPI.Header(name: "inputSource", value: Swift.String(inputSource)))
        }
        if let uniqueIds = value.uniqueIds {
            if uniqueIds.isEmpty {
                items.add(name: "uniqueIds", value: "")
            }
            uniqueIds.forEach { headerValue in
                items.add(SmithyHTTPAPI.Header(name: "uniqueIds", value: ClientRuntime.quoteHeaderValue(Swift.String(headerValue))))
            }
        }
        return items
    }
}

extension CreateIdMappingWorkflowInput {

    static func urlPathProvider(_ value: CreateIdMappingWorkflowInput) -> Swift.String? {
        return "/idmappingworkflows"
    }
}

extension CreateIdNamespaceInput {

    static func urlPathProvider(_ value: CreateIdNamespaceInput) -> Swift.String? {
        return "/idnamespaces"
    }
}

extension CreateMatchingWorkflowInput {

    static func urlPathProvider(_ value: CreateMatchingWorkflowInput) -> Swift.String? {
        return "/matchingworkflows"
    }
}

extension CreateSchemaMappingInput {

    static func urlPathProvider(_ value: CreateSchemaMappingInput) -> Swift.String? {
        return "/schemas"
    }
}

extension DeleteIdMappingWorkflowInput {

    static func urlPathProvider(_ value: DeleteIdMappingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

extension DeleteIdNamespaceInput {

    static func urlPathProvider(_ value: DeleteIdNamespaceInput) -> Swift.String? {
        guard let idNamespaceName = value.idNamespaceName else {
            return nil
        }
        return "/idnamespaces/\(idNamespaceName.urlPercentEncoding())"
    }
}

extension DeleteMatchingWorkflowInput {

    static func urlPathProvider(_ value: DeleteMatchingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

extension DeletePolicyStatementInput {

    static func urlPathProvider(_ value: DeletePolicyStatementInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())/\(statementId.urlPercentEncoding())"
    }
}

extension DeleteSchemaMappingInput {

    static func urlPathProvider(_ value: DeleteSchemaMappingInput) -> Swift.String? {
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

extension GetIdMappingJobInput {

    static func urlPathProvider(_ value: GetIdMappingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetIdMappingWorkflowInput {

    static func urlPathProvider(_ value: GetIdMappingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

extension GetIdNamespaceInput {

    static func urlPathProvider(_ value: GetIdNamespaceInput) -> Swift.String? {
        guard let idNamespaceName = value.idNamespaceName else {
            return nil
        }
        return "/idnamespaces/\(idNamespaceName.urlPercentEncoding())"
    }
}

extension GetMatchIdInput {

    static func urlPathProvider(_ value: GetMatchIdInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/matches"
    }
}

extension GetMatchingJobInput {

    static func urlPathProvider(_ value: GetMatchingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetMatchingWorkflowInput {

    static func urlPathProvider(_ value: GetMatchingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())"
    }
}

extension GetProviderServiceInput {

    static func urlPathProvider(_ value: GetProviderServiceInput) -> Swift.String? {
        guard let providerName = value.providerName else {
            return nil
        }
        guard let providerServiceName = value.providerServiceName else {
            return nil
        }
        return "/providerservices/\(providerName.urlPercentEncoding())/\(providerServiceName.urlPercentEncoding())"
    }
}

extension GetSchemaMappingInput {

    static func urlPathProvider(_ value: GetSchemaMappingInput) -> Swift.String? {
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

extension ListIdMappingJobsInput {

    static func urlPathProvider(_ value: ListIdMappingJobsInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

extension ListIdMappingJobsInput {

    static func queryItemProvider(_ value: ListIdMappingJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdMappingWorkflowsInput {

    static func urlPathProvider(_ value: ListIdMappingWorkflowsInput) -> Swift.String? {
        return "/idmappingworkflows"
    }
}

extension ListIdMappingWorkflowsInput {

    static func queryItemProvider(_ value: ListIdMappingWorkflowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdNamespacesInput {

    static func urlPathProvider(_ value: ListIdNamespacesInput) -> Swift.String? {
        return "/idnamespaces"
    }
}

extension ListIdNamespacesInput {

    static func queryItemProvider(_ value: ListIdNamespacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMatchingJobsInput {

    static func urlPathProvider(_ value: ListMatchingJobsInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

extension ListMatchingJobsInput {

    static func queryItemProvider(_ value: ListMatchingJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMatchingWorkflowsInput {

    static func urlPathProvider(_ value: ListMatchingWorkflowsInput) -> Swift.String? {
        return "/matchingworkflows"
    }
}

extension ListMatchingWorkflowsInput {

    static func queryItemProvider(_ value: ListMatchingWorkflowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProviderServicesInput {

    static func urlPathProvider(_ value: ListProviderServicesInput) -> Swift.String? {
        return "/providerservices"
    }
}

extension ListProviderServicesInput {

    static func queryItemProvider(_ value: ListProviderServicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let providerName = value.providerName {
            let providerNameQueryItem = Smithy.URIQueryItem(name: "providerName".urlPercentEncoding(), value: Swift.String(providerName).urlPercentEncoding())
            items.append(providerNameQueryItem)
        }
        return items
    }
}

extension ListSchemaMappingsInput {

    static func urlPathProvider(_ value: ListSchemaMappingsInput) -> Swift.String? {
        return "/schemas"
    }
}

extension ListSchemaMappingsInput {

    static func queryItemProvider(_ value: ListSchemaMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutPolicyInput {

    static func urlPathProvider(_ value: PutPolicyInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())"
    }
}

extension StartIdMappingJobInput {

    static func urlPathProvider(_ value: StartIdMappingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

extension StartMatchingJobInput {

    static func urlPathProvider(_ value: StartMatchingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateIdMappingWorkflowInput {

    static func urlPathProvider(_ value: UpdateIdMappingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

extension UpdateIdNamespaceInput {

    static func urlPathProvider(_ value: UpdateIdNamespaceInput) -> Swift.String? {
        guard let idNamespaceName = value.idNamespaceName else {
            return nil
        }
        return "/idnamespaces/\(idNamespaceName.urlPercentEncoding())"
    }
}

extension UpdateMatchingWorkflowInput {

    static func urlPathProvider(_ value: UpdateMatchingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

extension UpdateSchemaMappingInput {

    static func urlPathProvider(_ value: UpdateSchemaMappingInput) -> Swift.String? {
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

extension AddPolicyStatementInput {

    static func write(value: AddPolicyStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].writeList(value.action, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["condition"].write(value.condition)
        try writer["effect"].write(value.effect)
        try writer["principal"].writeList(value.principal, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIdMappingWorkflowInput {

    static func write(value: CreateIdMappingWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["idMappingTechniques"].write(value.idMappingTechniques, with: EntityResolutionClientTypes.IdMappingTechniques.write(value:to:))
        try writer["inputSourceConfig"].writeList(value.inputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdMappingWorkflowInputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputSourceConfig"].writeList(value.outputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdMappingWorkflowOutputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workflowName"].write(value.workflowName)
    }
}

extension CreateIdNamespaceInput {

    static func write(value: CreateIdNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["idMappingWorkflowProperties"].writeList(value.idMappingWorkflowProperties, memberWritingClosure: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["idNamespaceName"].write(value.idNamespaceName)
        try writer["inputSourceConfig"].writeList(value.inputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdNamespaceInputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateMatchingWorkflowInput {

    static func write(value: CreateMatchingWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["incrementalRunConfig"].write(value.incrementalRunConfig, with: EntityResolutionClientTypes.IncrementalRunConfig.write(value:to:))
        try writer["inputSourceConfig"].writeList(value.inputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.InputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputSourceConfig"].writeList(value.outputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.OutputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resolutionTechniques"].write(value.resolutionTechniques, with: EntityResolutionClientTypes.ResolutionTechniques.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workflowName"].write(value.workflowName)
    }
}

extension CreateSchemaMappingInput {

    static func write(value: CreateSchemaMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["mappedInputFields"].writeList(value.mappedInputFields, memberWritingClosure: EntityResolutionClientTypes.SchemaInputAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["schemaName"].write(value.schemaName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetMatchIdInput {

    static func write(value: GetMatchIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applyNormalization"].write(value.applyNormalization)
        try writer["record"].writeMap(value.record, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutPolicyInput {

    static func write(value: PutPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
        try writer["token"].write(value.token)
    }
}

extension StartIdMappingJobInput {

    static func write(value: StartIdMappingJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputSourceConfig"].writeList(value.outputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdMappingJobOutputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateIdMappingWorkflowInput {

    static func write(value: UpdateIdMappingWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["idMappingTechniques"].write(value.idMappingTechniques, with: EntityResolutionClientTypes.IdMappingTechniques.write(value:to:))
        try writer["inputSourceConfig"].writeList(value.inputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdMappingWorkflowInputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputSourceConfig"].writeList(value.outputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdMappingWorkflowOutputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateIdNamespaceInput {

    static func write(value: UpdateIdNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["idMappingWorkflowProperties"].writeList(value.idMappingWorkflowProperties, memberWritingClosure: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inputSourceConfig"].writeList(value.inputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.IdNamespaceInputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateMatchingWorkflowInput {

    static func write(value: UpdateMatchingWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["incrementalRunConfig"].write(value.incrementalRunConfig, with: EntityResolutionClientTypes.IncrementalRunConfig.write(value:to:))
        try writer["inputSourceConfig"].writeList(value.inputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.InputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputSourceConfig"].writeList(value.outputSourceConfig, memberWritingClosure: EntityResolutionClientTypes.OutputSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resolutionTechniques"].write(value.resolutionTechniques, with: EntityResolutionClientTypes.ResolutionTechniques.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateSchemaMappingInput {

    static func write(value: UpdateSchemaMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["mappedInputFields"].writeList(value.mappedInputFields, memberWritingClosure: EntityResolutionClientTypes.SchemaInputAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddPolicyStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddPolicyStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddPolicyStatementOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.policy = try reader["policy"].readIfPresent()
        value.token = try reader["token"].readIfPresent() ?? ""
        return value
    }
}

extension BatchDeleteUniqueIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteUniqueIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteUniqueIdOutput()
        value.deleted = try reader["deleted"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.DeletedUniqueId.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.disconnectedUniqueIds = try reader["disconnectedUniqueIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.DeleteUniqueIdError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateIdMappingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdMappingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdMappingWorkflowOutput()
        value.description = try reader["description"].readIfPresent()
        value.idMappingTechniques = try reader["idMappingTechniques"].readIfPresent(with: EntityResolutionClientTypes.IdMappingTechniques.read(from:))
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowInputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowOutputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        return value
    }
}

extension CreateIdNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdNamespaceOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.idMappingWorkflowProperties = try reader["idMappingWorkflowProperties"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.idNamespaceArn = try reader["idNamespaceArn"].readIfPresent() ?? ""
        value.idNamespaceName = try reader["idNamespaceName"].readIfPresent() ?? ""
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceInputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateMatchingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMatchingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMatchingWorkflowOutput()
        value.description = try reader["description"].readIfPresent()
        value.incrementalRunConfig = try reader["incrementalRunConfig"].readIfPresent(with: EntityResolutionClientTypes.IncrementalRunConfig.read(from:))
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.InputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.OutputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resolutionTechniques = try reader["resolutionTechniques"].readIfPresent(with: EntityResolutionClientTypes.ResolutionTechniques.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        return value
    }
}

extension CreateSchemaMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSchemaMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSchemaMappingOutput()
        value.description = try reader["description"].readIfPresent() ?? ""
        value.mappedInputFields = try reader["mappedInputFields"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.SchemaInputAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.schemaArn = try reader["schemaArn"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteIdMappingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdMappingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIdMappingWorkflowOutput()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteIdNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIdNamespaceOutput()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteMatchingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMatchingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMatchingWorkflowOutput()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeletePolicyStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePolicyStatementOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.policy = try reader["policy"].readIfPresent()
        value.token = try reader["token"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteSchemaMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSchemaMappingOutput()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension GetIdMappingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdMappingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdMappingJobOutput()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorDetails = try reader["errorDetails"].readIfPresent(with: EntityResolutionClientTypes.ErrorDetails.read(from:))
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.metrics = try reader["metrics"].readIfPresent(with: EntityResolutionClientTypes.IdMappingJobMetrics.read(from:))
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingJobOutputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetIdMappingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdMappingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdMappingWorkflowOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.idMappingTechniques = try reader["idMappingTechniques"].readIfPresent(with: EntityResolutionClientTypes.IdMappingTechniques.read(from:))
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowInputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowOutputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        return value
    }
}

extension GetIdNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdNamespaceOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.idMappingWorkflowProperties = try reader["idMappingWorkflowProperties"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.idNamespaceArn = try reader["idNamespaceArn"].readIfPresent() ?? ""
        value.idNamespaceName = try reader["idNamespaceName"].readIfPresent() ?? ""
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceInputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetMatchIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMatchIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMatchIdOutput()
        value.matchId = try reader["matchId"].readIfPresent()
        value.matchRule = try reader["matchRule"].readIfPresent()
        return value
    }
}

extension GetMatchingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMatchingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMatchingJobOutput()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorDetails = try reader["errorDetails"].readIfPresent(with: EntityResolutionClientTypes.ErrorDetails.read(from:))
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.metrics = try reader["metrics"].readIfPresent(with: EntityResolutionClientTypes.JobMetrics.read(from:))
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.JobOutputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetMatchingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMatchingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMatchingWorkflowOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.incrementalRunConfig = try reader["incrementalRunConfig"].readIfPresent(with: EntityResolutionClientTypes.IncrementalRunConfig.read(from:))
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.InputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.OutputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resolutionTechniques = try reader["resolutionTechniques"].readIfPresent(with: EntityResolutionClientTypes.ResolutionTechniques.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.policy = try reader["policy"].readIfPresent()
        value.token = try reader["token"].readIfPresent() ?? ""
        return value
    }
}

extension GetProviderServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProviderServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProviderServiceOutput()
        value.anonymizedOutput = try reader["anonymizedOutput"].readIfPresent() ?? false
        value.providerComponentSchema = try reader["providerComponentSchema"].readIfPresent(with: EntityResolutionClientTypes.ProviderComponentSchema.read(from:))
        value.providerConfigurationDefinition = try reader["providerConfigurationDefinition"].readIfPresent()
        value.providerEndpointConfiguration = try reader["providerEndpointConfiguration"].readIfPresent(with: EntityResolutionClientTypes.ProviderEndpointConfiguration.read(from:))
        value.providerEntityOutputDefinition = try reader["providerEntityOutputDefinition"].readIfPresent() ?? [:]
        value.providerIdNameSpaceConfiguration = try reader["providerIdNameSpaceConfiguration"].readIfPresent(with: EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration.read(from:))
        value.providerIntermediateDataAccessConfiguration = try reader["providerIntermediateDataAccessConfiguration"].readIfPresent(with: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration.read(from:))
        value.providerJobConfiguration = try reader["providerJobConfiguration"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent() ?? ""
        value.providerServiceArn = try reader["providerServiceArn"].readIfPresent() ?? ""
        value.providerServiceDisplayName = try reader["providerServiceDisplayName"].readIfPresent() ?? ""
        value.providerServiceName = try reader["providerServiceName"].readIfPresent() ?? ""
        value.providerServiceType = try reader["providerServiceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetSchemaMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaMappingOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.hasWorkflows = try reader["hasWorkflows"].readIfPresent() ?? false
        value.mappedInputFields = try reader["mappedInputFields"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.SchemaInputAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.schemaArn = try reader["schemaArn"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ListIdMappingJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdMappingJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdMappingJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIdMappingWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdMappingWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdMappingWorkflowsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workflowSummaries = try reader["workflowSummaries"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListIdNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdNamespacesOutput()
        value.idNamespaceSummaries = try reader["idNamespaceSummaries"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMatchingJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMatchingJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMatchingJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMatchingWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMatchingWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMatchingWorkflowsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workflowSummaries = try reader["workflowSummaries"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.MatchingWorkflowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProviderServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProviderServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProviderServicesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.providerServiceSummaries = try reader["providerServiceSummaries"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.ProviderServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSchemaMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemaMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemaMappingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.schemaList = try reader["schemaList"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.SchemaMappingSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PutPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutPolicyOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.policy = try reader["policy"].readIfPresent()
        value.token = try reader["token"].readIfPresent() ?? ""
        return value
    }
}

extension StartIdMappingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartIdMappingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartIdMappingJobOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingJobOutputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartMatchingJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMatchingJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMatchingJobOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateIdMappingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdMappingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdMappingWorkflowOutput()
        value.description = try reader["description"].readIfPresent()
        value.idMappingTechniques = try reader["idMappingTechniques"].readIfPresent(with: EntityResolutionClientTypes.IdMappingTechniques.read(from:))
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowInputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdMappingWorkflowOutputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateIdNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdNamespaceOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.idMappingWorkflowProperties = try reader["idMappingWorkflowProperties"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.idNamespaceArn = try reader["idNamespaceArn"].readIfPresent() ?? ""
        value.idNamespaceName = try reader["idNamespaceName"].readIfPresent() ?? ""
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceInputSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateMatchingWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMatchingWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMatchingWorkflowOutput()
        value.description = try reader["description"].readIfPresent()
        value.incrementalRunConfig = try reader["incrementalRunConfig"].readIfPresent(with: EntityResolutionClientTypes.IncrementalRunConfig.read(from:))
        value.inputSourceConfig = try reader["inputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.InputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputSourceConfig = try reader["outputSourceConfig"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.OutputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resolutionTechniques = try reader["resolutionTechniques"].readIfPresent(with: EntityResolutionClientTypes.ResolutionTechniques.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateSchemaMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSchemaMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSchemaMappingOutput()
        value.description = try reader["description"].readIfPresent()
        value.mappedInputFields = try reader["mappedInputFields"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.SchemaInputAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.schemaArn = try reader["schemaArn"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent() ?? ""
        return value
    }
}

enum AddPolicyStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteUniqueIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdMappingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExceedsLimitException": return try ExceedsLimitException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExceedsLimitException": return try ExceedsLimitException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMatchingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExceedsLimitException": return try ExceedsLimitException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSchemaMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExceedsLimitException": return try ExceedsLimitException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdMappingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMatchingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdMappingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdMappingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMatchIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMatchingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMatchingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProviderServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdMappingJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdMappingWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMatchingJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMatchingWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProviderServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemaMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartIdMappingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExceedsLimitException": return try ExceedsLimitException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMatchingJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExceedsLimitException": return try ExceedsLimitException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdMappingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMatchingWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSchemaMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExceedsLimitException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ExceedsLimitException {
        let reader = baseError.errorBodyReader
        var value = ExceedsLimitException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaName = try reader["quotaName"].readIfPresent()
        value.properties.quotaValue = try reader["quotaValue"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityResolutionClientTypes.DeleteUniqueIdError {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.DeleteUniqueIdError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.DeleteUniqueIdError()
        value.uniqueId = try reader["uniqueId"].readIfPresent() ?? ""
        value.errorType = try reader["errorType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension EntityResolutionClientTypes.DeletedUniqueId {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.DeletedUniqueId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.DeletedUniqueId()
        value.uniqueId = try reader["uniqueId"].readIfPresent() ?? ""
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingWorkflowInputSource {

    static func write(value: EntityResolutionClientTypes.IdMappingWorkflowInputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputSourceARN"].write(value.inputSourceARN)
        try writer["schemaName"].write(value.schemaName)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingWorkflowInputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingWorkflowInputSource()
        value.inputSourceARN = try reader["inputSourceARN"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingWorkflowOutputSource {

    static func write(value: EntityResolutionClientTypes.IdMappingWorkflowOutputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSArn"].write(value.kmsArn)
        try writer["outputS3Path"].write(value.outputS3Path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingWorkflowOutputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingWorkflowOutputSource()
        value.outputS3Path = try reader["outputS3Path"].readIfPresent() ?? ""
        value.kmsArn = try reader["KMSArn"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingTechniques {

    static func write(value: EntityResolutionClientTypes.IdMappingTechniques?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["idMappingType"].write(value.idMappingType)
        try writer["providerProperties"].write(value.providerProperties, with: EntityResolutionClientTypes.ProviderProperties.write(value:to:))
        try writer["ruleBasedProperties"].write(value.ruleBasedProperties, with: EntityResolutionClientTypes.IdMappingRuleBasedProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingTechniques {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingTechniques()
        value.idMappingType = try reader["idMappingType"].readIfPresent() ?? .sdkUnknown("")
        value.ruleBasedProperties = try reader["ruleBasedProperties"].readIfPresent(with: EntityResolutionClientTypes.IdMappingRuleBasedProperties.read(from:))
        value.providerProperties = try reader["providerProperties"].readIfPresent(with: EntityResolutionClientTypes.ProviderProperties.read(from:))
        return value
    }
}

extension EntityResolutionClientTypes.ProviderProperties {

    static func write(value: EntityResolutionClientTypes.ProviderProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["intermediateSourceConfiguration"].write(value.intermediateSourceConfiguration, with: EntityResolutionClientTypes.IntermediateSourceConfiguration.write(value:to:))
        try writer["providerConfiguration"].write(value.providerConfiguration)
        try writer["providerServiceArn"].write(value.providerServiceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderProperties()
        value.providerServiceArn = try reader["providerServiceArn"].readIfPresent() ?? ""
        value.providerConfiguration = try reader["providerConfiguration"].readIfPresent()
        value.intermediateSourceConfiguration = try reader["intermediateSourceConfiguration"].readIfPresent(with: EntityResolutionClientTypes.IntermediateSourceConfiguration.read(from:))
        return value
    }
}

extension EntityResolutionClientTypes.IntermediateSourceConfiguration {

    static func write(value: EntityResolutionClientTypes.IntermediateSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["intermediateS3Path"].write(value.intermediateS3Path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IntermediateSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IntermediateSourceConfiguration()
        value.intermediateS3Path = try reader["intermediateS3Path"].readIfPresent() ?? ""
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingRuleBasedProperties {

    static func write(value: EntityResolutionClientTypes.IdMappingRuleBasedProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeMatchingModel"].write(value.attributeMatchingModel)
        try writer["recordMatchingModel"].write(value.recordMatchingModel)
        try writer["ruleDefinitionType"].write(value.ruleDefinitionType)
        try writer["rules"].writeList(value.rules, memberWritingClosure: EntityResolutionClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingRuleBasedProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingRuleBasedProperties()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleDefinitionType = try reader["ruleDefinitionType"].readIfPresent() ?? .sdkUnknown("")
        value.attributeMatchingModel = try reader["attributeMatchingModel"].readIfPresent() ?? .sdkUnknown("")
        value.recordMatchingModel = try reader["recordMatchingModel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension EntityResolutionClientTypes.Rule {

    static func write(value: EntityResolutionClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchingKeys"].writeList(value.matchingKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleName"].write(value.ruleName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.Rule()
        value.ruleName = try reader["ruleName"].readIfPresent() ?? ""
        value.matchingKeys = try reader["matchingKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension EntityResolutionClientTypes.IdNamespaceInputSource {

    static func write(value: EntityResolutionClientTypes.IdNamespaceInputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputSourceARN"].write(value.inputSourceARN)
        try writer["schemaName"].write(value.schemaName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdNamespaceInputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdNamespaceInputSource()
        value.inputSourceARN = try reader["inputSourceARN"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties {

    static func write(value: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["idMappingType"].write(value.idMappingType)
        try writer["providerProperties"].write(value.providerProperties, with: EntityResolutionClientTypes.NamespaceProviderProperties.write(value:to:))
        try writer["ruleBasedProperties"].write(value.ruleBasedProperties, with: EntityResolutionClientTypes.NamespaceRuleBasedProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties()
        value.idMappingType = try reader["idMappingType"].readIfPresent() ?? .sdkUnknown("")
        value.ruleBasedProperties = try reader["ruleBasedProperties"].readIfPresent(with: EntityResolutionClientTypes.NamespaceRuleBasedProperties.read(from:))
        value.providerProperties = try reader["providerProperties"].readIfPresent(with: EntityResolutionClientTypes.NamespaceProviderProperties.read(from:))
        return value
    }
}

extension EntityResolutionClientTypes.NamespaceProviderProperties {

    static func write(value: EntityResolutionClientTypes.NamespaceProviderProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["providerConfiguration"].write(value.providerConfiguration)
        try writer["providerServiceArn"].write(value.providerServiceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.NamespaceProviderProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.NamespaceProviderProperties()
        value.providerServiceArn = try reader["providerServiceArn"].readIfPresent() ?? ""
        value.providerConfiguration = try reader["providerConfiguration"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.NamespaceRuleBasedProperties {

    static func write(value: EntityResolutionClientTypes.NamespaceRuleBasedProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeMatchingModel"].write(value.attributeMatchingModel)
        try writer["recordMatchingModels"].writeList(value.recordMatchingModels, memberWritingClosure: SmithyReadWrite.WritingClosureBox<EntityResolutionClientTypes.RecordMatchingModel>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleDefinitionTypes"].writeList(value.ruleDefinitionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<EntityResolutionClientTypes.IdMappingWorkflowRuleDefinitionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rules"].writeList(value.rules, memberWritingClosure: EntityResolutionClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.NamespaceRuleBasedProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.NamespaceRuleBasedProperties()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleDefinitionTypes = try reader["ruleDefinitionTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<EntityResolutionClientTypes.IdMappingWorkflowRuleDefinitionType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributeMatchingModel = try reader["attributeMatchingModel"].readIfPresent()
        value.recordMatchingModels = try reader["recordMatchingModels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<EntityResolutionClientTypes.RecordMatchingModel>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EntityResolutionClientTypes.InputSource {

    static func write(value: EntityResolutionClientTypes.InputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applyNormalization"].write(value.applyNormalization)
        try writer["inputSourceARN"].write(value.inputSourceARN)
        try writer["schemaName"].write(value.schemaName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.InputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.InputSource()
        value.inputSourceARN = try reader["inputSourceARN"].readIfPresent() ?? ""
        value.schemaName = try reader["schemaName"].readIfPresent() ?? ""
        value.applyNormalization = try reader["applyNormalization"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.OutputSource {

    static func write(value: EntityResolutionClientTypes.OutputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSArn"].write(value.kmsArn)
        try writer["applyNormalization"].write(value.applyNormalization)
        try writer["output"].writeList(value.output, memberWritingClosure: EntityResolutionClientTypes.OutputAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputS3Path"].write(value.outputS3Path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.OutputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.OutputSource()
        value.outputS3Path = try reader["outputS3Path"].readIfPresent() ?? ""
        value.kmsArn = try reader["KMSArn"].readIfPresent()
        value.output = try reader["output"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.OutputAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.applyNormalization = try reader["applyNormalization"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.OutputAttribute {

    static func write(value: EntityResolutionClientTypes.OutputAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hashed"].write(value.hashed)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.OutputAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.OutputAttribute()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.hashed = try reader["hashed"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.ResolutionTechniques {

    static func write(value: EntityResolutionClientTypes.ResolutionTechniques?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["providerProperties"].write(value.providerProperties, with: EntityResolutionClientTypes.ProviderProperties.write(value:to:))
        try writer["resolutionType"].write(value.resolutionType)
        try writer["ruleBasedProperties"].write(value.ruleBasedProperties, with: EntityResolutionClientTypes.RuleBasedProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ResolutionTechniques {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ResolutionTechniques()
        value.resolutionType = try reader["resolutionType"].readIfPresent() ?? .sdkUnknown("")
        value.ruleBasedProperties = try reader["ruleBasedProperties"].readIfPresent(with: EntityResolutionClientTypes.RuleBasedProperties.read(from:))
        value.providerProperties = try reader["providerProperties"].readIfPresent(with: EntityResolutionClientTypes.ProviderProperties.read(from:))
        return value
    }
}

extension EntityResolutionClientTypes.RuleBasedProperties {

    static func write(value: EntityResolutionClientTypes.RuleBasedProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeMatchingModel"].write(value.attributeMatchingModel)
        try writer["matchPurpose"].write(value.matchPurpose)
        try writer["rules"].writeList(value.rules, memberWritingClosure: EntityResolutionClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.RuleBasedProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.RuleBasedProperties()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.attributeMatchingModel = try reader["attributeMatchingModel"].readIfPresent() ?? .sdkUnknown("")
        value.matchPurpose = try reader["matchPurpose"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.IncrementalRunConfig {

    static func write(value: EntityResolutionClientTypes.IncrementalRunConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["incrementalRunType"].write(value.incrementalRunType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IncrementalRunConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IncrementalRunConfig()
        value.incrementalRunType = try reader["incrementalRunType"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.SchemaInputAttribute {

    static func write(value: EntityResolutionClientTypes.SchemaInputAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldName"].write(value.fieldName)
        try writer["groupName"].write(value.groupName)
        try writer["hashed"].write(value.hashed)
        try writer["matchKey"].write(value.matchKey)
        try writer["subType"].write(value.subType)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.SchemaInputAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.SchemaInputAttribute()
        value.fieldName = try reader["fieldName"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.groupName = try reader["groupName"].readIfPresent()
        value.matchKey = try reader["matchKey"].readIfPresent()
        value.subType = try reader["subType"].readIfPresent()
        value.hashed = try reader["hashed"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingJobMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingJobMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingJobMetrics()
        value.inputRecords = try reader["inputRecords"].readIfPresent()
        value.totalRecordsProcessed = try reader["totalRecordsProcessed"].readIfPresent()
        value.recordsNotProcessed = try reader["recordsNotProcessed"].readIfPresent()
        value.totalMappedRecords = try reader["totalMappedRecords"].readIfPresent()
        value.totalMappedSourceRecords = try reader["totalMappedSourceRecords"].readIfPresent()
        value.totalMappedTargetRecords = try reader["totalMappedTargetRecords"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ErrorDetails()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingJobOutputSource {

    static func write(value: EntityResolutionClientTypes.IdMappingJobOutputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSArn"].write(value.kmsArn)
        try writer["outputS3Path"].write(value.outputS3Path)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingJobOutputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingJobOutputSource()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.outputS3Path = try reader["outputS3Path"].readIfPresent() ?? ""
        value.kmsArn = try reader["KMSArn"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.JobMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.JobMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.JobMetrics()
        value.inputRecords = try reader["inputRecords"].readIfPresent()
        value.totalRecordsProcessed = try reader["totalRecordsProcessed"].readIfPresent()
        value.recordsNotProcessed = try reader["recordsNotProcessed"].readIfPresent()
        value.matchIDs = try reader["matchIDs"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.JobOutputSource {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.JobOutputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.JobOutputSource()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.outputS3Path = try reader["outputS3Path"].readIfPresent() ?? ""
        value.kmsArn = try reader["KMSArn"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration()
        value.description = try reader["description"].readIfPresent()
        value.providerTargetConfigurationDefinition = try reader["providerTargetConfigurationDefinition"].readIfPresent()
        value.providerSourceConfigurationDefinition = try reader["providerSourceConfigurationDefinition"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.ProviderEndpointConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderEndpointConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "marketplaceConfiguration":
                return .marketplaceconfiguration(try reader["marketplaceConfiguration"].read(with: EntityResolutionClientTypes.ProviderMarketplaceConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension EntityResolutionClientTypes.ProviderMarketplaceConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderMarketplaceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderMarketplaceConfiguration()
        value.dataSetId = try reader["dataSetId"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent() ?? ""
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.listingId = try reader["listingId"].readIfPresent() ?? ""
        return value
    }
}

extension EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration()
        value.awsAccountIds = try reader["awsAccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.requiredBucketActions = try reader["requiredBucketActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EntityResolutionClientTypes.ProviderComponentSchema {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderComponentSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderComponentSchema()
        value.schemas = try reader["schemas"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.providerSchemaAttributes = try reader["providerSchemaAttributes"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.ProviderSchemaAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EntityResolutionClientTypes.ProviderSchemaAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderSchemaAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderSchemaAttribute()
        value.fieldName = try reader["fieldName"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.subType = try reader["subType"].readIfPresent()
        value.hashing = try reader["hashing"].readIfPresent()
        return value
    }
}

extension EntityResolutionClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.JobSummary()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension EntityResolutionClientTypes.IdMappingWorkflowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdMappingWorkflowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdMappingWorkflowSummary()
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension EntityResolutionClientTypes.IdNamespaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdNamespaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdNamespaceSummary()
        value.idNamespaceName = try reader["idNamespaceName"].readIfPresent() ?? ""
        value.idNamespaceArn = try reader["idNamespaceArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.idMappingWorkflowProperties = try reader["idMappingWorkflowProperties"].readListIfPresent(memberReadingClosure: EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowMetadata()
        value.idMappingType = try reader["idMappingType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension EntityResolutionClientTypes.MatchingWorkflowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.MatchingWorkflowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.MatchingWorkflowSummary()
        value.workflowName = try reader["workflowName"].readIfPresent() ?? ""
        value.workflowArn = try reader["workflowArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resolutionType = try reader["resolutionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension EntityResolutionClientTypes.ProviderServiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.ProviderServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.ProviderServiceSummary()
        value.providerServiceArn = try reader["providerServiceArn"].readIfPresent() ?? ""
        value.providerName = try reader["providerName"].readIfPresent() ?? ""
        value.providerServiceDisplayName = try reader["providerServiceDisplayName"].readIfPresent() ?? ""
        value.providerServiceName = try reader["providerServiceName"].readIfPresent() ?? ""
        value.providerServiceType = try reader["providerServiceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension EntityResolutionClientTypes.SchemaMappingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EntityResolutionClientTypes.SchemaMappingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EntityResolutionClientTypes.SchemaMappingSummary()
        value.schemaName = try reader["schemaName"].readIfPresent() ?? ""
        value.schemaArn = try reader["schemaArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.hasWorkflows = try reader["hasWorkflows"].readIfPresent() ?? false
        return value
    }
}

public enum EntityResolutionClientTypes {}
