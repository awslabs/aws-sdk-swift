// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action. HTTP Status Code: 403
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes {
    public enum AttributeMatchingModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeMatchingModel(rawValue: rawValue) ?? AttributeMatchingModel.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists, Schema already exists, Workflow is currently running, etc. HTTP Status Code: 400
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateMatchingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let incrementalRunConfig = self.incrementalRunConfig {
            try encodeContainer.encode(incrementalRunConfig, forKey: .incrementalRunConfig)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for inputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(inputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for outputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(outputsource0)
            }
        }
        if let resolutionTechniques = self.resolutionTechniques {
            try encodeContainer.encode(resolutionTechniques, forKey: .resolutionTechniques)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }
}

extension CreateMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/matchingworkflows"
    }
}

public struct CreateMatchingWorkflowInput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workflow. There cannot be multiple DataIntegrationWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

struct CreateMatchingWorkflowInputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMatchingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct CreateMatchingWorkflowOutput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct CreateMatchingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension CreateMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum CreateMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSchemaMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mappedInputFields = mappedInputFields {
            var mappedInputFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mappedInputFields)
            for schemainputattribute0 in mappedInputFields {
                try mappedInputFieldsContainer.encode(schemainputattribute0)
            }
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schemas"
    }
}

public struct CreateSchemaMappingInput: Swift.Equatable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There cannot be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
        self.tags = tags
    }
}

struct CreateSchemaMappingInputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSchemaMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
        } else {
            self.description = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
        }
    }
}

public struct CreateSchemaMappingOutput: Swift.Equatable {
    /// A description of the schema.
    /// This member is required.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

struct CreateSchemaMappingOutputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension CreateSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaArn
        case schemaName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

enum CreateSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct DeleteMatchingWorkflowInput: Swift.Equatable {
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct DeleteMatchingWorkflowInputBody: Swift.Equatable {
}

extension DeleteMatchingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteMatchingWorkflowOutput: Swift.Equatable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteMatchingWorkflowOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let schemaName = schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaMappingInput: Swift.Equatable {
    /// The name of the schema to delete.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

struct DeleteSchemaMappingInputBody: Swift.Equatable {
}

extension DeleteSchemaMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteSchemaMappingOutput: Swift.Equatable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteSchemaMappingOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing an error message, if there was an error.
    public struct ErrorDetails: Swift.Equatable {
        /// The error message from the job, if there is one.
        public var errorMessage: Swift.String?

        public init(
            errorMessage: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
        }
    }

}

extension ExceedsLimitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExceedsLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaName = output.quotaName
            self.properties.quotaValue = output.quotaValue
        } else {
            self.properties.message = nil
            self.properties.quotaName = nil
            self.properties.quotaValue = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits. The error message describes the limit exceeded. HTTP Status Code: 402
public struct ExceedsLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the quota that has been breached.
        public internal(set) var quotaName: Swift.String? = nil
        /// The current quota value for the customers.
        public internal(set) var quotaValue: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExceedsLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaName: Swift.String? = nil,
        quotaValue: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaName = quotaName
        self.properties.quotaValue = quotaValue
    }
}

struct ExceedsLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaName: Swift.String?
    let quotaValue: Swift.Int?
}

extension ExceedsLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaName
        case quotaValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let quotaValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quotaValue)
        quotaValue = quotaValueDecoded
    }
}

extension GetMatchIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMatchIdInput(workflowName: \(Swift.String(describing: workflowName)), record: \"CONTENT_REDACTED\")"}
}

extension GetMatchIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .record)
            for (dictKey0, recordAttributeMap0) in record {
                try recordContainer.encode(recordAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetMatchIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/matches"
    }
}

public struct GetMatchIdInput: Swift.Equatable {
    /// The record to fetch the Match ID for.
    /// This member is required.
    public var record: [Swift.String:Swift.String]?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        record: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.record = record
        self.workflowName = workflowName
    }
}

struct GetMatchIdInputBody: Swift.Equatable {
    let record: [Swift.String:Swift.String]?
}

extension GetMatchIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .record)
        var recordDecoded0: [Swift.String:Swift.String]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in recordContainer {
                if let string0 = string0 {
                    recordDecoded0?[key0] = string0
                }
            }
        }
        record = recordDecoded0
    }
}

extension GetMatchIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchId = output.matchId
        } else {
            self.matchId = nil
        }
    }
}

public struct GetMatchIdOutput: Swift.Equatable {
    /// The unique identifiers for this group of match records.
    public var matchId: Swift.String?

    public init(
        matchId: Swift.String? = nil
    )
    {
        self.matchId = matchId
    }
}

struct GetMatchIdOutputBody: Swift.Equatable {
    let matchId: Swift.String?
}

extension GetMatchIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchId)
        matchId = matchIdDecoded
    }
}

enum GetMatchIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetMatchingJobInput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

struct GetMatchingJobInputBody: Swift.Equatable {
}

extension GetMatchingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorDetails = output.errorDetails
            self.jobId = output.jobId
            self.metrics = output.metrics
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.endTime = nil
            self.errorDetails = nil
            self.jobId = nil
            self.metrics = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct GetMatchingJobOutput: Swift.Equatable {
    /// The time at which the job has finished.
    public var endTime: ClientRuntime.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.JobMetrics?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: ClientRuntime.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.JobMetrics? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.startTime = startTime
        self.status = status
    }
}

struct GetMatchingJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: EntityResolutionClientTypes.JobStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metrics: EntityResolutionClientTypes.JobMetrics?
    let errorDetails: EntityResolutionClientTypes.ErrorDetails?
}

extension GetMatchingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorDetails
        case jobId
        case metrics
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

enum GetMatchingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct GetMatchingWorkflowInput: Swift.Equatable {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct GetMatchingWorkflowInputBody: Swift.Equatable {
}

extension GetMatchingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.updatedAt = output.updatedAt
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.createdAt = nil
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.tags = nil
            self.updatedAt = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct GetMatchingWorkflowOutput: Swift.Equatable {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct GetMatchingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case updatedAt
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let schemaName = schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct GetSchemaMappingInput: Swift.Equatable {
    /// The name of the schema to be retrieved.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

struct GetSchemaMappingInputBody: Swift.Equatable {
}

extension GetSchemaMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetSchemaMappingOutput: Swift.Equatable {
    /// The timestamp of when the SchemaMapping was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the SchemaMapping was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetSchemaMappingOutputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case mappedInputFields
        case schemaArn
        case schemaName
        case tags
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.IncrementalRunConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incrementalRunType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incrementalRunType = self.incrementalRunType {
            try encodeContainer.encode(incrementalRunType.rawValue, forKey: .incrementalRunType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incrementalRunTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunType.self, forKey: .incrementalRunType)
        incrementalRunType = incrementalRunTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public struct IncrementalRunConfig: Swift.Equatable {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public var incrementalRunType: EntityResolutionClientTypes.IncrementalRunType?

        public init(
            incrementalRunType: EntityResolutionClientTypes.IncrementalRunType? = nil
        )
        {
            self.incrementalRunType = incrementalRunType
        }
    }

}

extension EntityResolutionClientTypes {
    public enum IncrementalRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case sdkUnknown(Swift.String)

        public static var allCases: [IncrementalRunType] {
            return [
                .immediate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IncrementalRunType(rawValue: rawValue) ?? IncrementalRunType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.InputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyNormalization
        case inputSourceARN
        case schemaName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let inputSourceARN = self.inputSourceARN {
            try encodeContainer.encode(inputSourceARN, forKey: .inputSourceARN)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSourceARN)
        inputSourceARN = inputSourceARNDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputSourceARN, SchemaName, and ApplyNormalization.
    public struct InputSource: Swift.Equatable {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// An Glue table ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        /// This member is required.
        public var schemaName: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when there is an internal failure in the Entity Resolution service. HTTP Status Code: 500
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes.JobMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputRecords
        case matchIDs
        case recordsNotProcessed
        case totalRecordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputRecords = self.inputRecords {
            try encodeContainer.encode(inputRecords, forKey: .inputRecords)
        }
        if let matchIDs = self.matchIDs {
            try encodeContainer.encode(matchIDs, forKey: .matchIDs)
        }
        if let recordsNotProcessed = self.recordsNotProcessed {
            try encodeContainer.encode(recordsNotProcessed, forKey: .recordsNotProcessed)
        }
        if let totalRecordsProcessed = self.totalRecordsProcessed {
            try encodeContainer.encode(totalRecordsProcessed, forKey: .totalRecordsProcessed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRecords)
        inputRecords = inputRecordsDecoded
        let totalRecordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsProcessed)
        totalRecordsProcessed = totalRecordsProcessedDecoded
        let recordsNotProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsNotProcessed)
        recordsNotProcessed = recordsNotProcessedDecoded
        let matchIDsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .matchIDs)
        matchIDs = matchIDsDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputRecords, TotalRecordsProcessed, MatchIDs, and RecordsNotProcessed.
    public struct JobMetrics: Swift.Equatable {
        /// The total number of input records.
        public var inputRecords: Swift.Int?
        /// The total number of matchIDs generated.
        public var matchIDs: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            matchIDs: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }

}

extension EntityResolutionClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case jobId
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing the JobId, Status, StartTime, and EndTime of a job.
    public struct JobSummary: Swift.Equatable {
        /// The time at which the job has finished.
        public var endTime: ClientRuntime.Date?
        /// The ID of the job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The time at which the job was started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The current status of the job.
        /// This member is required.
        public var status: EntityResolutionClientTypes.JobStatus?

        public init(
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: EntityResolutionClientTypes.JobStatus? = nil
        )
        {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }
    }

}

extension ListMatchingJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMatchingJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct ListMatchingJobsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListSchemaMappings API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

struct ListMatchingJobsInputBody: Swift.Equatable {
}

extension ListMatchingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMatchingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMatchingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMatchingJobsOutput: Swift.Equatable {
    /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous ListSchemaMappings API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMatchingJobsOutputBody: Swift.Equatable {
    let jobs: [EntityResolutionClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListMatchingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[EntityResolutionClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [EntityResolutionClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMatchingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMatchingWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMatchingWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/matchingworkflows"
    }
}

public struct ListMatchingWorkflowsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListSchemaMappings API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMatchingWorkflowsInputBody: Swift.Equatable {
}

extension ListMatchingWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMatchingWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMatchingWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowSummaries = output.workflowSummaries
        } else {
            self.nextToken = nil
            self.workflowSummaries = nil
        }
    }
}

public struct ListMatchingWorkflowsOutput: Swift.Equatable {
    /// The pagination token from the previous ListSchemaMappings API call.
    public var nextToken: Swift.String?
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public var workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

struct ListMatchingWorkflowsOutputBody: Swift.Equatable {
    let workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?
    let nextToken: Swift.String?
}

extension ListMatchingWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.MatchingWorkflowSummary?].self, forKey: .workflowSummaries)
        var workflowSummariesDecoded0:[EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
        if let workflowSummariesContainer = workflowSummariesContainer {
            workflowSummariesDecoded0 = [EntityResolutionClientTypes.MatchingWorkflowSummary]()
            for structure0 in workflowSummariesContainer {
                if let structure0 = structure0 {
                    workflowSummariesDecoded0?.append(structure0)
                }
            }
        }
        workflowSummaries = workflowSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMatchingWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemaMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSchemaMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schemas"
    }
}

public struct ListSchemaMappingsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous ListSchemaMappings API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemaMappingsInputBody: Swift.Equatable {
}

extension ListSchemaMappingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemaMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemaMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaList = output.schemaList
        } else {
            self.nextToken = nil
            self.schemaList = nil
        }
    }
}

public struct ListSchemaMappingsOutput: Swift.Equatable {
    /// The pagination token from the previous ListDomains API call.
    public var nextToken: Swift.String?
    /// A list of SchemaMappingSummary objects, each of which contain the fields SchemaName, SchemaArn, CreatedAt, UpdatedAt.
    public var schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaList = schemaList
    }
}

struct ListSchemaMappingsOutputBody: Swift.Equatable {
    let schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?
    let nextToken: Swift.String?
}

extension ListSchemaMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemaList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaListContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaMappingSummary?].self, forKey: .schemaList)
        var schemaListDecoded0:[EntityResolutionClientTypes.SchemaMappingSummary]? = nil
        if let schemaListContainer = schemaListContainer {
            schemaListDecoded0 = [EntityResolutionClientTypes.SchemaMappingSummary]()
            for structure0 in schemaListContainer {
                if let structure0 = structure0 {
                    schemaListDecoded0?.append(structure0)
                }
            }
        }
        schemaList = schemaListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemaMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.MatchingWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case updatedAt
        case workflowArn
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workflowArn = self.workflowArn {
            try encodeContainer.encode(workflowArn, forKey: .workflowArn)
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, UpdatedAt.
    public struct MatchingWorkflowSummary: Swift.Equatable {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }

}

extension EntityResolutionClientTypes.OutputAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashed
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashed = self.hashed {
            try encodeContainer.encode(hashed, forKey: .hashed)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hashedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hashed)
        hashed = hashedDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputAttribute: Swift.Equatable {
        /// Enables the ability to hash the column values in the output.
        public var hashed: Swift.Bool?
        /// A name of a column to be written to the output. This must be an InputField name in the schema mapping.
        /// This member is required.
        public var name: Swift.String?

        public init(
            hashed: Swift.Bool? = nil,
            name: Swift.String? = nil
        )
        {
            self.hashed = hashed
            self.name = name
        }
    }

}

extension EntityResolutionClientTypes.OutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case applyNormalization
        case output
        case outputS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let output = output {
            var outputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .output)
            for outputattribute0 in output {
                try outputContainer.encode(outputattribute0)
            }
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let outputContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputAttribute?].self, forKey: .output)
        var outputDecoded0:[EntityResolutionClientTypes.OutputAttribute]? = nil
        if let outputContainer = outputContainer {
            outputDecoded0 = [EntityResolutionClientTypes.OutputAttribute]()
            for structure0 in outputContainer {
                if let structure0 = structure0 {
                    outputDecoded0?.append(structure0)
                }
            }
        }
        output = outputDecoded0
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputSource: Swift.Equatable {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        /// This member is required.
        public var output: [EntityResolutionClientTypes.OutputAttribute]?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            kmsArn: Swift.String? = nil,
            output: [EntityResolutionClientTypes.OutputAttribute]? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }
    }

}

extension EntityResolutionClientTypes.ResolutionTechniques: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolutionType
        case ruleBasedProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolutionType = self.resolutionType {
            try encodeContainer.encode(resolutionType.rawValue, forKey: .resolutionType)
        }
        if let ruleBasedProperties = self.ruleBasedProperties {
            try encodeContainer.encode(ruleBasedProperties, forKey: .ruleBasedProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionType.self, forKey: .resolutionType)
        resolutionType = resolutionTypeDecoded
        let ruleBasedPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.RuleBasedProperties.self, forKey: .ruleBasedProperties)
        ruleBasedProperties = ruleBasedPropertiesDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the resolutionType and the ruleBasedProperties.
    public struct ResolutionTechniques: Swift.Equatable {
        /// The type of matching. There are two types of matching: RULE_MATCHING and ML_MATCHING.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
        public var ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties?

        public init(
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties? = nil
        )
        {
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }
    }

}

extension EntityResolutionClientTypes {
    public enum ResolutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mlMatching
        case ruleMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionType] {
            return [
                .mlMatching,
                .ruleMatching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mlMatching: return "ML_MATCHING"
            case .ruleMatching: return "RULE_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionType(rawValue: rawValue) ?? ResolutionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found. HTTP Status Code: 404
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchingKeys
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchingKeys = matchingKeys {
            var matchingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingKeys)
            for attributename0 in matchingKeys {
                try matchingKeysContainer.encode(attributename0)
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let matchingKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchingKeys)
        var matchingKeysDecoded0:[Swift.String]? = nil
        if let matchingKeysContainer = matchingKeysContainer {
            matchingKeysDecoded0 = [Swift.String]()
            for string0 in matchingKeysContainer {
                if let string0 = string0 {
                    matchingKeysDecoded0?.append(string0)
                }
            }
        }
        matchingKeys = matchingKeysDecoded0
    }
}

extension EntityResolutionClientTypes {
    /// An object containing RuleName, and MatchingKeys.
    public struct Rule: Swift.Equatable {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in the SchemaMapping. Two records are considered to match according to this rule if all of the MatchingKeys match.
        /// This member is required.
        public var matchingKeys: [Swift.String]?
        /// A name for the matching rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            matchingKeys: [Swift.String]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }
    }

}

extension EntityResolutionClientTypes.RuleBasedProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeMatchingModel
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeMatchingModel = self.attributeMatchingModel {
            try encodeContainer.encode(attributeMatchingModel.rawValue, forKey: .attributeMatchingModel)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[EntityResolutionClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [EntityResolutionClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let attributeMatchingModelDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.AttributeMatchingModel.self, forKey: .attributeMatchingModel)
        attributeMatchingModel = attributeMatchingModelDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
    public struct RuleBasedProperties: Swift.Equatable {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE ,the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
        /// This member is required.
        public var attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel?
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        /// This member is required.
        public var rules: [EntityResolutionClientTypes.Rule]?

        public init(
            attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel? = nil,
            rules: [EntityResolutionClientTypes.Rule]? = nil
        )
        {
            self.attributeMatchingModel = attributeMatchingModel
            self.rules = rules
        }
    }

}

extension EntityResolutionClientTypes {
    public enum SchemaAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case addressCity
        case addressCountry
        case addressPostalcode
        case addressState
        case addressStreet1
        case addressStreet2
        case addressStreet3
        case date
        case emailAddress
        case name
        case nameFirst
        case nameLast
        case nameMiddle
        case phone
        case phoneCountrycode
        case phoneNumber
        case string
        case uniqueId
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaAttributeType] {
            return [
                .address,
                .addressCity,
                .addressCountry,
                .addressPostalcode,
                .addressState,
                .addressStreet1,
                .addressStreet2,
                .addressStreet3,
                .date,
                .emailAddress,
                .name,
                .nameFirst,
                .nameLast,
                .nameMiddle,
                .phone,
                .phoneCountrycode,
                .phoneNumber,
                .string,
                .uniqueId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .addressCity: return "ADDRESS_CITY"
            case .addressCountry: return "ADDRESS_COUNTRY"
            case .addressPostalcode: return "ADDRESS_POSTALCODE"
            case .addressState: return "ADDRESS_STATE"
            case .addressStreet1: return "ADDRESS_STREET1"
            case .addressStreet2: return "ADDRESS_STREET2"
            case .addressStreet3: return "ADDRESS_STREET3"
            case .date: return "DATE"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .nameFirst: return "NAME_FIRST"
            case .nameLast: return "NAME_LAST"
            case .nameMiddle: return "NAME_MIDDLE"
            case .phone: return "PHONE"
            case .phoneCountrycode: return "PHONE_COUNTRYCODE"
            case .phoneNumber: return "PHONE_NUMBER"
            case .string: return "STRING"
            case .uniqueId: return "UNIQUE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaAttributeType(rawValue: rawValue) ?? SchemaAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.SchemaInputAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case groupName
        case matchKey
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let matchKey = self.matchKey {
            try encodeContainer.encode(matchKey, forKey: .matchKey)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.SchemaAttributeType.self, forKey: .type)
        type = typeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let matchKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchKey)
        matchKey = matchKeyDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing FieldField, Type, GroupName, and MatchKey.
    public struct SchemaInputAttribute: Swift.Equatable {
        /// A string containing the field name.
        /// This member is required.
        public var fieldName: Swift.String?
        /// Instruct Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common GroupName will prompt Entity Resolution to concatenate them into a single value.
        public var groupName: Swift.String?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, let's consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning the MatchKey Address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no MatchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public var matchKey: Swift.String?
        /// The type of the attribute, selected from a list of values.
        /// This member is required.
        public var type: EntityResolutionClientTypes.SchemaAttributeType?

        public init(
            fieldName: Swift.String? = nil,
            groupName: Swift.String? = nil,
            matchKey: Swift.String? = nil,
            type: EntityResolutionClientTypes.SchemaAttributeType? = nil
        )
        {
            self.fieldName = fieldName
            self.groupName = groupName
            self.matchKey = matchKey
            self.type = type
        }
    }

}

extension EntityResolutionClientTypes.SchemaMappingSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case schemaArn
        case schemaName
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing SchemaName, SchemaArn, CreatedAt, andUpdatedAt.
    public struct SchemaMappingSummary: Swift.Equatable {
        /// The timestamp of when the SchemaMapping was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The timestamp of when the SchemaMapping was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }
    }

}

extension StartMatchingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct StartMatchingJobInput: Swift.Equatable {
    /// The name of the matching job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct StartMatchingJobInputBody: Swift.Equatable {
}

extension StartMatchingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartMatchingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMatchingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMatchingJobOutput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMatchingJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartMatchingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartMatchingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling. HTTP Status Code: 429
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMatchingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let incrementalRunConfig = self.incrementalRunConfig {
            try encodeContainer.encode(incrementalRunConfig, forKey: .incrementalRunConfig)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for inputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(inputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for outputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(outputsource0)
            }
        }
        if let resolutionTechniques = self.resolutionTechniques {
            try encodeContainer.encode(resolutionTechniques, forKey: .resolutionTechniques)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct UpdateMatchingWorkflowInput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateMatchingWorkflowInputBody: Swift.Equatable {
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension UpdateMatchingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.workflowName = nil
        }
    }
}

public struct UpdateMatchingWorkflowOutput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateMatchingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension UpdateMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum UpdateMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by Entity Resolution. HTTP Status Code: 400
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
