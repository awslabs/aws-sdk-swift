// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action. HTTP Status Code: 403
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes {
    public enum AttributeMatchingModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeMatchingModel(rawValue: rawValue) ?? AttributeMatchingModel.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists, Schema already exists, Workflow is currently running, etc. HTTP Status Code: 400
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateIdMappingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case tags
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idMappingTechniques = self.idMappingTechniques {
            try encodeContainer.encode(idMappingTechniques, forKey: .idMappingTechniques)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for idmappingworkflowinputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(idmappingworkflowinputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for idmappingworkflowoutputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(idmappingworkflowoutputsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }
}

extension CreateIdMappingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/idmappingworkflows"
    }
}

public struct CreateIdMappingWorkflowInput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workflow. There can't be multiple IdMappingWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

struct CreateIdMappingWorkflowInputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIdMappingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case tags
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.idMappingTechniques = output.idMappingTechniques
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.idMappingTechniques = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct CreateIdMappingWorkflowOutput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IDMappingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct CreateIdMappingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
}

extension CreateIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum CreateIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMatchingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let incrementalRunConfig = self.incrementalRunConfig {
            try encodeContainer.encode(incrementalRunConfig, forKey: .incrementalRunConfig)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for inputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(inputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for outputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(outputsource0)
            }
        }
        if let resolutionTechniques = self.resolutionTechniques {
            try encodeContainer.encode(resolutionTechniques, forKey: .resolutionTechniques)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }
}

extension CreateMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/matchingworkflows"
    }
}

public struct CreateMatchingWorkflowInput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workflow. There can't be multiple MatchingWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

struct CreateMatchingWorkflowInputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMatchingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct CreateMatchingWorkflowOutput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct CreateMatchingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension CreateMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum CreateMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSchemaMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mappedInputFields = mappedInputFields {
            var mappedInputFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mappedInputFields)
            for schemainputattribute0 in mappedInputFields {
                try mappedInputFieldsContainer.encode(schemainputattribute0)
            }
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schemas"
    }
}

public struct CreateSchemaMappingInput: Swift.Equatable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There can't be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
        self.tags = tags
    }
}

struct CreateSchemaMappingInputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSchemaMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
        } else {
            self.description = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
        }
    }
}

public struct CreateSchemaMappingOutput: Swift.Equatable {
    /// A description of the schema.
    /// This member is required.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

struct CreateSchemaMappingOutputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension CreateSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaArn
        case schemaName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

enum CreateSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIdMappingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct DeleteIdMappingWorkflowInput: Swift.Equatable {
    /// The name of the workflow to be deleted.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct DeleteIdMappingWorkflowInputBody: Swift.Equatable {
}

extension DeleteIdMappingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteIdMappingWorkflowOutput: Swift.Equatable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteIdMappingWorkflowOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct DeleteMatchingWorkflowInput: Swift.Equatable {
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct DeleteMatchingWorkflowInputBody: Swift.Equatable {
}

extension DeleteMatchingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteMatchingWorkflowOutput: Swift.Equatable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteMatchingWorkflowOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let schemaName = schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaMappingInput: Swift.Equatable {
    /// The name of the schema to delete.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

struct DeleteSchemaMappingInputBody: Swift.Equatable {
}

extension DeleteSchemaMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteSchemaMappingOutput: Swift.Equatable {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteSchemaMappingOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing an error message, if there was an error.
    public struct ErrorDetails: Swift.Equatable {
        /// The error message from the job, if there is one.
        public var errorMessage: Swift.String?

        public init(
            errorMessage: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
        }
    }

}

extension ExceedsLimitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExceedsLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaName = output.quotaName
            self.properties.quotaValue = output.quotaValue
        } else {
            self.properties.message = nil
            self.properties.quotaName = nil
            self.properties.quotaValue = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits. The error message describes the limit exceeded. HTTP Status Code: 402
public struct ExceedsLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the quota that has been breached.
        public internal(set) var quotaName: Swift.String? = nil
        /// The current quota value for the customers.
        public internal(set) var quotaValue: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExceedsLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaName: Swift.String? = nil,
        quotaValue: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaName = quotaName
        self.properties.quotaValue = quotaValue
    }
}

struct ExceedsLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaName: Swift.String?
    let quotaValue: Swift.Int?
}

extension ExceedsLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaName
        case quotaValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let quotaValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quotaValue)
        quotaValue = quotaValueDecoded
    }
}

extension GetIdMappingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetIdMappingJobInput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

struct GetIdMappingJobInputBody: Swift.Equatable {
}

extension GetIdMappingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdMappingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdMappingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorDetails = output.errorDetails
            self.jobId = output.jobId
            self.metrics = output.metrics
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.endTime = nil
            self.errorDetails = nil
            self.jobId = nil
            self.metrics = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct GetIdMappingJobOutput: Swift.Equatable {
    /// The time at which the job has finished.
    public var endTime: ClientRuntime.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.IdMappingJobMetrics?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: ClientRuntime.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.IdMappingJobMetrics? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.startTime = startTime
        self.status = status
    }
}

struct GetIdMappingJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: EntityResolutionClientTypes.JobStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metrics: EntityResolutionClientTypes.IdMappingJobMetrics?
    let errorDetails: EntityResolutionClientTypes.ErrorDetails?
}

extension GetIdMappingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorDetails
        case jobId
        case metrics
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingJobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

enum GetIdMappingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdMappingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct GetIdMappingWorkflowInput: Swift.Equatable {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct GetIdMappingWorkflowInputBody: Swift.Equatable {
}

extension GetIdMappingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.idMappingTechniques = output.idMappingTechniques
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.updatedAt = output.updatedAt
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.createdAt = nil
            self.description = nil
            self.idMappingTechniques = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.roleArn = nil
            self.tags = nil
            self.updatedAt = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct GetIdMappingWorkflowOutput: Swift.Equatable {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow .
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct GetIdMappingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case tags
        case updatedAt
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMatchIdInput(workflowName: \(Swift.String(describing: workflowName)), record: \"CONTENT_REDACTED\")"}
}

extension GetMatchIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .record)
            for (dictKey0, recordAttributeMap0) in record {
                try recordContainer.encode(recordAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetMatchIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/matches"
    }
}

public struct GetMatchIdInput: Swift.Equatable {
    /// The record to fetch the Match ID for.
    /// This member is required.
    public var record: [Swift.String:Swift.String]?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        record: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.record = record
        self.workflowName = workflowName
    }
}

struct GetMatchIdInputBody: Swift.Equatable {
    let record: [Swift.String:Swift.String]?
}

extension GetMatchIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .record)
        var recordDecoded0: [Swift.String:Swift.String]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in recordContainer {
                if let string0 = string0 {
                    recordDecoded0?[key0] = string0
                }
            }
        }
        record = recordDecoded0
    }
}

extension GetMatchIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchId = output.matchId
        } else {
            self.matchId = nil
        }
    }
}

public struct GetMatchIdOutput: Swift.Equatable {
    /// The unique identifiers for this group of match records.
    public var matchId: Swift.String?

    public init(
        matchId: Swift.String? = nil
    )
    {
        self.matchId = matchId
    }
}

struct GetMatchIdOutputBody: Swift.Equatable {
    let matchId: Swift.String?
}

extension GetMatchIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchId)
        matchId = matchIdDecoded
    }
}

enum GetMatchIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetMatchingJobInput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

struct GetMatchingJobInputBody: Swift.Equatable {
}

extension GetMatchingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorDetails = output.errorDetails
            self.jobId = output.jobId
            self.metrics = output.metrics
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.endTime = nil
            self.errorDetails = nil
            self.jobId = nil
            self.metrics = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct GetMatchingJobOutput: Swift.Equatable {
    /// The time at which the job has finished.
    public var endTime: ClientRuntime.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.JobMetrics?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: ClientRuntime.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.JobMetrics? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.startTime = startTime
        self.status = status
    }
}

struct GetMatchingJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: EntityResolutionClientTypes.JobStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metrics: EntityResolutionClientTypes.JobMetrics?
    let errorDetails: EntityResolutionClientTypes.ErrorDetails?
}

extension GetMatchingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorDetails
        case jobId
        case metrics
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

enum GetMatchingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct GetMatchingWorkflowInput: Swift.Equatable {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct GetMatchingWorkflowInputBody: Swift.Equatable {
}

extension GetMatchingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.updatedAt = output.updatedAt
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.createdAt = nil
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.tags = nil
            self.updatedAt = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct GetMatchingWorkflowOutput: Swift.Equatable {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct GetMatchingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case updatedAt
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProviderServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let providerName = providerName else {
            return nil
        }
        guard let providerServiceName = providerServiceName else {
            return nil
        }
        return "/providerservices/\(providerName.urlPercentEncoding())/\(providerServiceName.urlPercentEncoding())"
    }
}

public struct GetProviderServiceInput: Swift.Equatable {
    /// The name of the provider. This name is typically the company name.
    /// This member is required.
    public var providerName: Swift.String?
    /// The ARN (Amazon Resource Name) of the product that the provider service provides.
    /// This member is required.
    public var providerServiceName: Swift.String?

    public init(
        providerName: Swift.String? = nil,
        providerServiceName: Swift.String? = nil
    )
    {
        self.providerName = providerName
        self.providerServiceName = providerServiceName
    }
}

struct GetProviderServiceInputBody: Swift.Equatable {
}

extension GetProviderServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProviderServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProviderServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.anonymizedOutput = output.anonymizedOutput
            self.providerConfigurationDefinition = output.providerConfigurationDefinition
            self.providerEndpointConfiguration = output.providerEndpointConfiguration
            self.providerEntityOutputDefinition = output.providerEntityOutputDefinition
            self.providerIntermediateDataAccessConfiguration = output.providerIntermediateDataAccessConfiguration
            self.providerName = output.providerName
            self.providerServiceArn = output.providerServiceArn
            self.providerServiceDisplayName = output.providerServiceDisplayName
            self.providerServiceName = output.providerServiceName
            self.providerServiceType = output.providerServiceType
        } else {
            self.anonymizedOutput = nil
            self.providerConfigurationDefinition = nil
            self.providerEndpointConfiguration = nil
            self.providerEntityOutputDefinition = nil
            self.providerIntermediateDataAccessConfiguration = nil
            self.providerName = nil
            self.providerServiceArn = nil
            self.providerServiceDisplayName = nil
            self.providerServiceName = nil
            self.providerServiceType = nil
        }
    }
}

public struct GetProviderServiceOutput: Swift.Equatable {
    /// Specifies whether output data from the provider is anonymized. A value of TRUE means the output will be anonymized and you can't relate the data that comes back from the provider to the identifying input. A value of FALSE means the output won't be anonymized and you can relate the data that comes back from the provider to your source data.
    /// This member is required.
    public var anonymizedOutput: Swift.Bool?
    /// The definition of the provider configuration.
    public var providerConfigurationDefinition: ClientRuntime.Document?
    /// The required configuration fields to use with the provider service.
    /// This member is required.
    public var providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration?
    /// The definition of the provider entity output.
    /// This member is required.
    public var providerEntityOutputDefinition: ClientRuntime.Document?
    /// The Amazon Web Services accounts and the S3 permissions that are required by some providers to create an S3 bucket for intermediate data storage.
    public var providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration?
    /// The name of the provider. This name is typically the company name.
    /// This member is required.
    public var providerName: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the provider service.
    /// This member is required.
    public var providerServiceArn: Swift.String?
    /// The display name of the provider service.
    /// This member is required.
    public var providerServiceDisplayName: Swift.String?
    /// The name of the product that the provider service provides.
    /// This member is required.
    public var providerServiceName: Swift.String?
    /// The type of provider service.
    /// This member is required.
    public var providerServiceType: EntityResolutionClientTypes.ServiceType?

    public init(
        anonymizedOutput: Swift.Bool? = nil,
        providerConfigurationDefinition: ClientRuntime.Document? = nil,
        providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration? = nil,
        providerEntityOutputDefinition: ClientRuntime.Document? = nil,
        providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration? = nil,
        providerName: Swift.String? = nil,
        providerServiceArn: Swift.String? = nil,
        providerServiceDisplayName: Swift.String? = nil,
        providerServiceName: Swift.String? = nil,
        providerServiceType: EntityResolutionClientTypes.ServiceType? = nil
    )
    {
        self.anonymizedOutput = anonymizedOutput
        self.providerConfigurationDefinition = providerConfigurationDefinition
        self.providerEndpointConfiguration = providerEndpointConfiguration
        self.providerEntityOutputDefinition = providerEntityOutputDefinition
        self.providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfiguration
        self.providerName = providerName
        self.providerServiceArn = providerServiceArn
        self.providerServiceDisplayName = providerServiceDisplayName
        self.providerServiceName = providerServiceName
        self.providerServiceType = providerServiceType
    }
}

struct GetProviderServiceOutputBody: Swift.Equatable {
    let providerName: Swift.String?
    let providerServiceName: Swift.String?
    let providerServiceDisplayName: Swift.String?
    let providerServiceType: EntityResolutionClientTypes.ServiceType?
    let providerServiceArn: Swift.String?
    let providerConfigurationDefinition: ClientRuntime.Document?
    let providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration?
    let anonymizedOutput: Swift.Bool?
    let providerEntityOutputDefinition: ClientRuntime.Document?
    let providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration?
}

extension GetProviderServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anonymizedOutput
        case providerConfigurationDefinition
        case providerEndpointConfiguration
        case providerEntityOutputDefinition
        case providerIntermediateDataAccessConfiguration
        case providerName
        case providerServiceArn
        case providerServiceDisplayName
        case providerServiceName
        case providerServiceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceName)
        providerServiceName = providerServiceNameDecoded
        let providerServiceDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceDisplayName)
        providerServiceDisplayName = providerServiceDisplayNameDecoded
        let providerServiceTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ServiceType.self, forKey: .providerServiceType)
        providerServiceType = providerServiceTypeDecoded
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerConfigurationDefinitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerConfigurationDefinition)
        providerConfigurationDefinition = providerConfigurationDefinitionDecoded
        let providerEndpointConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderEndpointConfiguration.self, forKey: .providerEndpointConfiguration)
        providerEndpointConfiguration = providerEndpointConfigurationDecoded
        let anonymizedOutputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .anonymizedOutput)
        anonymizedOutput = anonymizedOutputDecoded
        let providerEntityOutputDefinitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerEntityOutputDefinition)
        providerEntityOutputDefinition = providerEntityOutputDefinitionDecoded
        let providerIntermediateDataAccessConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration.self, forKey: .providerIntermediateDataAccessConfiguration)
        providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfigurationDecoded
    }
}

enum GetProviderServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let schemaName = schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct GetSchemaMappingInput: Swift.Equatable {
    /// The name of the schema to be retrieved.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

struct GetSchemaMappingInputBody: Swift.Equatable {
}

extension GetSchemaMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.hasWorkflows = output.hasWorkflows
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.hasWorkflows = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetSchemaMappingOutput: Swift.Equatable {
    /// The timestamp of when the SchemaMapping was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the schema.
    public var description: Swift.String?
    /// Specifies whether the schema mapping has been applied to a workflow.
    /// This member is required.
    public var hasWorkflows: Swift.Bool?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the SchemaMapping was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hasWorkflows: Swift.Bool? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.hasWorkflows = hasWorkflows
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetSchemaMappingOutputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let hasWorkflows: Swift.Bool?
}

extension GetSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case hasWorkflows
        case mappedInputFields
        case schemaArn
        case schemaName
        case tags
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let hasWorkflowsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasWorkflows)
        hasWorkflows = hasWorkflowsDecoded
    }
}

enum GetSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.IdMappingJobMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputRecords
        case recordsNotProcessed
        case totalRecordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputRecords = self.inputRecords {
            try encodeContainer.encode(inputRecords, forKey: .inputRecords)
        }
        if let recordsNotProcessed = self.recordsNotProcessed {
            try encodeContainer.encode(recordsNotProcessed, forKey: .recordsNotProcessed)
        }
        if let totalRecordsProcessed = self.totalRecordsProcessed {
            try encodeContainer.encode(totalRecordsProcessed, forKey: .totalRecordsProcessed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRecords)
        inputRecords = inputRecordsDecoded
        let totalRecordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsProcessed)
        totalRecordsProcessed = totalRecordsProcessedDecoded
        let recordsNotProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsNotProcessed)
        recordsNotProcessed = recordsNotProcessedDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputRecords, TotalRecordsProcessed, MatchIDs, and RecordsNotProcessed.
    public struct IdMappingJobMetrics: Swift.Equatable {
        /// The total number of input records.
        public var inputRecords: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }

}

extension EntityResolutionClientTypes.IdMappingTechniques: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idMappingType
        case providerProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idMappingType = self.idMappingType {
            try encodeContainer.encode(idMappingType.rawValue, forKey: .idMappingType)
        }
        if let providerProperties = self.providerProperties {
            try encodeContainer.encode(providerProperties, forKey: .providerProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idMappingTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingType.self, forKey: .idMappingType)
        idMappingType = idMappingTypeDecoded
        let providerPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderProperties.self, forKey: .providerProperties)
        providerProperties = providerPropertiesDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the ID mapping techniques and provider configurations.
    public struct IdMappingTechniques: Swift.Equatable {
        /// The type of ID mapping.
        /// This member is required.
        public var idMappingType: EntityResolutionClientTypes.IdMappingType?
        /// An object which defines any additional configurations required by the provider service.
        /// This member is required.
        public var providerProperties: EntityResolutionClientTypes.ProviderProperties?

        public init(
            idMappingType: EntityResolutionClientTypes.IdMappingType? = nil,
            providerProperties: EntityResolutionClientTypes.ProviderProperties? = nil
        )
        {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
        }
    }

}

extension EntityResolutionClientTypes {
    public enum IdMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provider
        case sdkUnknown(Swift.String)

        public static var allCases: [IdMappingType] {
            return [
                .provider,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provider: return "PROVIDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdMappingType(rawValue: rawValue) ?? IdMappingType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.IdMappingWorkflowInputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSourceARN
        case schemaName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputSourceARN = self.inputSourceARN {
            try encodeContainer.encode(inputSourceARN, forKey: .inputSourceARN)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSourceARN)
        inputSourceARN = inputSourceARNDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputSourceARN and SchemaName.
    public struct IdMappingWorkflowInputSource: Swift.Equatable {
        /// An Gluetable ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        /// This member is required.
        public var schemaName: Swift.String?

        public init(
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }

}

extension EntityResolutionClientTypes.IdMappingWorkflowOutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case outputS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The output source for the ID mapping workflow.
    public struct IdMappingWorkflowOutputSource: Swift.Equatable {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
        }
    }

}

extension EntityResolutionClientTypes.IdMappingWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case updatedAt
        case workflowArn
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workflowArn = self.workflowArn {
            try encodeContainer.encode(workflowArn, forKey: .workflowArn)
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of IdMappingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public struct IdMappingWorkflowSummary: Swift.Equatable {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }

}

extension EntityResolutionClientTypes.IncrementalRunConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incrementalRunType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incrementalRunType = self.incrementalRunType {
            try encodeContainer.encode(incrementalRunType.rawValue, forKey: .incrementalRunType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incrementalRunTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunType.self, forKey: .incrementalRunType)
        incrementalRunType = incrementalRunTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public struct IncrementalRunConfig: Swift.Equatable {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public var incrementalRunType: EntityResolutionClientTypes.IncrementalRunType?

        public init(
            incrementalRunType: EntityResolutionClientTypes.IncrementalRunType? = nil
        )
        {
            self.incrementalRunType = incrementalRunType
        }
    }

}

extension EntityResolutionClientTypes {
    public enum IncrementalRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case sdkUnknown(Swift.String)

        public static var allCases: [IncrementalRunType] {
            return [
                .immediate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IncrementalRunType(rawValue: rawValue) ?? IncrementalRunType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.InputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyNormalization
        case inputSourceARN
        case schemaName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let inputSourceARN = self.inputSourceARN {
            try encodeContainer.encode(inputSourceARN, forKey: .inputSourceARN)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSourceARN)
        inputSourceARN = inputSourceARNDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputSourceARN, SchemaName, and ApplyNormalization.
    public struct InputSource: Swift.Equatable {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// An Glue table ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        /// This member is required.
        public var schemaName: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }

}

extension EntityResolutionClientTypes.IntermediateSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intermediateS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intermediateS3Path = self.intermediateS3Path {
            try encodeContainer.encode(intermediateS3Path, forKey: .intermediateS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intermediateS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateS3Path)
        intermediateS3Path = intermediateS3PathDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
    public struct IntermediateSourceConfiguration: Swift.Equatable {
        /// The Amazon S3 location (bucket and prefix). For example: s3://provider_bucket/DOC-EXAMPLE-BUCKET
        /// This member is required.
        public var intermediateS3Path: Swift.String?

        public init(
            intermediateS3Path: Swift.String? = nil
        )
        {
            self.intermediateS3Path = intermediateS3Path
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when there is an internal failure in the Entity Resolution service. HTTP Status Code: 500
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes.JobMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputRecords
        case matchIDs
        case recordsNotProcessed
        case totalRecordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputRecords = self.inputRecords {
            try encodeContainer.encode(inputRecords, forKey: .inputRecords)
        }
        if let matchIDs = self.matchIDs {
            try encodeContainer.encode(matchIDs, forKey: .matchIDs)
        }
        if let recordsNotProcessed = self.recordsNotProcessed {
            try encodeContainer.encode(recordsNotProcessed, forKey: .recordsNotProcessed)
        }
        if let totalRecordsProcessed = self.totalRecordsProcessed {
            try encodeContainer.encode(totalRecordsProcessed, forKey: .totalRecordsProcessed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRecords)
        inputRecords = inputRecordsDecoded
        let totalRecordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsProcessed)
        totalRecordsProcessed = totalRecordsProcessedDecoded
        let recordsNotProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsNotProcessed)
        recordsNotProcessed = recordsNotProcessedDecoded
        let matchIDsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .matchIDs)
        matchIDs = matchIDsDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputRecords, TotalRecordsProcessed, MatchIDs, and RecordsNotProcessed.
    public struct JobMetrics: Swift.Equatable {
        /// The total number of input records.
        public var inputRecords: Swift.Int?
        /// The total number of matchIDs generated.
        public var matchIDs: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            matchIDs: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }

}

extension EntityResolutionClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case jobId
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing the JobId, Status, StartTime, and EndTime of a job.
    public struct JobSummary: Swift.Equatable {
        /// The time at which the job has finished.
        public var endTime: ClientRuntime.Date?
        /// The ID of the job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The time at which the job was started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The current status of the job.
        /// This member is required.
        public var status: EntityResolutionClientTypes.JobStatus?

        public init(
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: EntityResolutionClientTypes.JobStatus? = nil
        )
        {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }
    }

}

extension ListIdMappingJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdMappingJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct ListIdMappingJobsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

struct ListIdMappingJobsInputBody: Swift.Equatable {
}

extension ListIdMappingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdMappingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdMappingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdMappingJobsOutput: Swift.Equatable {
    /// A list of JobSummary objects.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListIdMappingJobsOutputBody: Swift.Equatable {
    let jobs: [EntityResolutionClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListIdMappingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[EntityResolutionClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [EntityResolutionClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdMappingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdMappingWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdMappingWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/idmappingworkflows"
    }
}

public struct ListIdMappingWorkflowsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdMappingWorkflowsInputBody: Swift.Equatable {
}

extension ListIdMappingWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdMappingWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdMappingWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowSummaries = output.workflowSummaries
        } else {
            self.nextToken = nil
            self.workflowSummaries = nil
        }
    }
}

public struct ListIdMappingWorkflowsOutput: Swift.Equatable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of IdMappingWorkflowSummary objects.
    public var workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

struct ListIdMappingWorkflowsOutputBody: Swift.Equatable {
    let workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]?
    let nextToken: Swift.String?
}

extension ListIdMappingWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowSummary?].self, forKey: .workflowSummaries)
        var workflowSummariesDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowSummary]? = nil
        if let workflowSummariesContainer = workflowSummariesContainer {
            workflowSummariesDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowSummary]()
            for structure0 in workflowSummariesContainer {
                if let structure0 = structure0 {
                    workflowSummariesDecoded0?.append(structure0)
                }
            }
        }
        workflowSummaries = workflowSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdMappingWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMatchingJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMatchingJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct ListMatchingJobsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

struct ListMatchingJobsInputBody: Swift.Equatable {
}

extension ListMatchingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMatchingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMatchingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMatchingJobsOutput: Swift.Equatable {
    /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMatchingJobsOutputBody: Swift.Equatable {
    let jobs: [EntityResolutionClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListMatchingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[EntityResolutionClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [EntityResolutionClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMatchingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMatchingWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMatchingWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/matchingworkflows"
    }
}

public struct ListMatchingWorkflowsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMatchingWorkflowsInputBody: Swift.Equatable {
}

extension ListMatchingWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMatchingWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMatchingWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowSummaries = output.workflowSummaries
        } else {
            self.nextToken = nil
            self.workflowSummaries = nil
        }
    }
}

public struct ListMatchingWorkflowsOutput: Swift.Equatable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public var workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

struct ListMatchingWorkflowsOutputBody: Swift.Equatable {
    let workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?
    let nextToken: Swift.String?
}

extension ListMatchingWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.MatchingWorkflowSummary?].self, forKey: .workflowSummaries)
        var workflowSummariesDecoded0:[EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
        if let workflowSummariesContainer = workflowSummariesContainer {
            workflowSummariesDecoded0 = [EntityResolutionClientTypes.MatchingWorkflowSummary]()
            for structure0 in workflowSummariesContainer {
                if let structure0 = structure0 {
                    workflowSummariesDecoded0?.append(structure0)
                }
            }
        }
        workflowSummaries = workflowSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMatchingWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProviderServicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let providerName = providerName {
                let providerNameQueryItem = ClientRuntime.URLQueryItem(name: "providerName".urlPercentEncoding(), value: Swift.String(providerName).urlPercentEncoding())
                items.append(providerNameQueryItem)
            }
            return items
        }
    }
}

extension ListProviderServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/providerservices"
    }
}

public struct ListProviderServicesInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the provider. This name is typically the company name.
    public var providerName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.providerName = providerName
    }
}

struct ListProviderServicesInputBody: Swift.Equatable {
}

extension ListProviderServicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProviderServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProviderServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.providerServiceSummaries = output.providerServiceSummaries
        } else {
            self.nextToken = nil
            self.providerServiceSummaries = nil
        }
    }
}

public struct ListProviderServicesOutput: Swift.Equatable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of ProviderServices objects.
    public var providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.providerServiceSummaries = providerServiceSummaries
    }
}

struct ListProviderServicesOutputBody: Swift.Equatable {
    let providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]?
    let nextToken: Swift.String?
}

extension ListProviderServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case providerServiceSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.ProviderServiceSummary?].self, forKey: .providerServiceSummaries)
        var providerServiceSummariesDecoded0:[EntityResolutionClientTypes.ProviderServiceSummary]? = nil
        if let providerServiceSummariesContainer = providerServiceSummariesContainer {
            providerServiceSummariesDecoded0 = [EntityResolutionClientTypes.ProviderServiceSummary]()
            for structure0 in providerServiceSummariesContainer {
                if let structure0 = structure0 {
                    providerServiceSummariesDecoded0?.append(structure0)
                }
            }
        }
        providerServiceSummaries = providerServiceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProviderServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemaMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSchemaMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schemas"
    }
}

public struct ListSchemaMappingsInput: Swift.Equatable {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemaMappingsInputBody: Swift.Equatable {
}

extension ListSchemaMappingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemaMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemaMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaList = output.schemaList
        } else {
            self.nextToken = nil
            self.schemaList = nil
        }
    }
}

public struct ListSchemaMappingsOutput: Swift.Equatable {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of SchemaMappingSummary objects, each of which contain the fields SchemaName, SchemaArn, CreatedAt, UpdatedAt.
    public var schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaList = schemaList
    }
}

struct ListSchemaMappingsOutputBody: Swift.Equatable {
    let schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?
    let nextToken: Swift.String?
}

extension ListSchemaMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemaList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaListContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaMappingSummary?].self, forKey: .schemaList)
        var schemaListDecoded0:[EntityResolutionClientTypes.SchemaMappingSummary]? = nil
        if let schemaListContainer = schemaListContainer {
            schemaListDecoded0 = [EntityResolutionClientTypes.SchemaMappingSummary]()
            for structure0 in schemaListContainer {
                if let structure0 = structure0 {
                    schemaListDecoded0?.append(structure0)
                }
            }
        }
        schemaList = schemaListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemaMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.MatchingWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case resolutionType
        case updatedAt
        case workflowArn
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let resolutionType = self.resolutionType {
            try encodeContainer.encode(resolutionType.rawValue, forKey: .resolutionType)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workflowArn = self.workflowArn {
            try encodeContainer.encode(workflowArn, forKey: .workflowArn)
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let resolutionTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionType.self, forKey: .resolutionType)
        resolutionType = resolutionTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, UpdatedAt.
    public struct MatchingWorkflowSummary: Swift.Equatable {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The method that has been specified for data matching, either using matching provided by Entity Resolution or through a provider service.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.resolutionType = resolutionType
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }

}

extension EntityResolutionClientTypes.OutputAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashed
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashed = self.hashed {
            try encodeContainer.encode(hashed, forKey: .hashed)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hashedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hashed)
        hashed = hashedDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputAttribute: Swift.Equatable {
        /// Enables the ability to hash the column values in the output.
        public var hashed: Swift.Bool?
        /// A name of a column to be written to the output. This must be an InputField name in the schema mapping.
        /// This member is required.
        public var name: Swift.String?

        public init(
            hashed: Swift.Bool? = nil,
            name: Swift.String? = nil
        )
        {
            self.hashed = hashed
            self.name = name
        }
    }

}

extension EntityResolutionClientTypes.OutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case applyNormalization
        case output
        case outputS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let output = output {
            var outputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .output)
            for outputattribute0 in output {
                try outputContainer.encode(outputattribute0)
            }
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let outputContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputAttribute?].self, forKey: .output)
        var outputDecoded0:[EntityResolutionClientTypes.OutputAttribute]? = nil
        if let outputContainer = outputContainer {
            outputDecoded0 = [EntityResolutionClientTypes.OutputAttribute]()
            for structure0 in outputContainer {
                if let structure0 = structure0 {
                    outputDecoded0?.append(structure0)
                }
            }
        }
        output = outputDecoded0
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputSource: Swift.Equatable {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        /// This member is required.
        public var output: [EntityResolutionClientTypes.OutputAttribute]?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            kmsArn: Swift.String? = nil,
            output: [EntityResolutionClientTypes.OutputAttribute]? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }
    }

}

extension EntityResolutionClientTypes.ProviderEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marketplaceconfiguration = "marketplaceConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .marketplaceconfiguration(marketplaceconfiguration):
                try container.encode(marketplaceconfiguration, forKey: .marketplaceconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let marketplaceconfigurationDecoded = try values.decodeIfPresent(EntityResolutionClientTypes.ProviderMarketplaceConfiguration.self, forKey: .marketplaceconfiguration)
        if let marketplaceconfiguration = marketplaceconfigurationDecoded {
            self = .marketplaceconfiguration(marketplaceconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EntityResolutionClientTypes {
    /// The required configuration fields to use with the provider service.
    public enum ProviderEndpointConfiguration: Swift.Equatable {
        /// The identifiers of the provider service, from Data Exchange.
        case marketplaceconfiguration(EntityResolutionClientTypes.ProviderMarketplaceConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountIds
        case requiredBucketActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountIds = awsAccountIds {
            var awsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountIds)
            for awsaccountid0 in awsAccountIds {
                try awsAccountIdsContainer.encode(awsaccountid0)
            }
        }
        if let requiredBucketActions = requiredBucketActions {
            var requiredBucketActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredBucketActions)
            for string0 in requiredBucketActions {
                try requiredBucketActionsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsAccountIds)
        var awsAccountIdsDecoded0:[Swift.String]? = nil
        if let awsAccountIdsContainer = awsAccountIdsContainer {
            awsAccountIdsDecoded0 = [Swift.String]()
            for string0 in awsAccountIdsContainer {
                if let string0 = string0 {
                    awsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        awsAccountIds = awsAccountIdsDecoded0
        let requiredBucketActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredBucketActions)
        var requiredBucketActionsDecoded0:[Swift.String]? = nil
        if let requiredBucketActionsContainer = requiredBucketActionsContainer {
            requiredBucketActionsDecoded0 = [Swift.String]()
            for string0 in requiredBucketActionsContainer {
                if let string0 = string0 {
                    requiredBucketActionsDecoded0?.append(string0)
                }
            }
        }
        requiredBucketActions = requiredBucketActionsDecoded0
    }
}

extension EntityResolutionClientTypes {
    /// The required configuration fields to give intermediate access to a provider service.
    public struct ProviderIntermediateDataAccessConfiguration: Swift.Equatable {
        /// The Amazon Web Services account that provider can use to read or write data into the customer's intermediate S3 bucket.
        public var awsAccountIds: [Swift.String]?
        /// The S3 bucket actions that the provider requires permission for.
        public var requiredBucketActions: [Swift.String]?

        public init(
            awsAccountIds: [Swift.String]? = nil,
            requiredBucketActions: [Swift.String]? = nil
        )
        {
            self.awsAccountIds = awsAccountIds
            self.requiredBucketActions = requiredBucketActions
        }
    }

}

extension EntityResolutionClientTypes.ProviderMarketplaceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case dataSetId
        case listingId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let listingId = self.listingId {
            try encodeContainer.encode(listingId, forKey: .listingId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let listingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingId)
        listingId = listingIdDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The identifiers of the provider service, from Data Exchange.
    public struct ProviderMarketplaceConfiguration: Swift.Equatable {
        /// The asset ID on Data Exchange.
        /// This member is required.
        public var assetId: Swift.String?
        /// The dataset ID on Data Exchange.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The listing ID on Data Exchange.
        /// This member is required.
        public var listingId: Swift.String?
        /// The revision ID on Data Exchange.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            listingId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.listingId = listingId
            self.revisionId = revisionId
        }
    }

}

extension EntityResolutionClientTypes.ProviderProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intermediateSourceConfiguration
        case providerConfiguration
        case providerServiceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intermediateSourceConfiguration = self.intermediateSourceConfiguration {
            try encodeContainer.encode(intermediateSourceConfiguration, forKey: .intermediateSourceConfiguration)
        }
        if let providerConfiguration = self.providerConfiguration {
            try encodeContainer.encode(providerConfiguration, forKey: .providerConfiguration)
        }
        if let providerServiceArn = self.providerServiceArn {
            try encodeContainer.encode(providerServiceArn, forKey: .providerServiceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerConfigurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerConfiguration)
        providerConfiguration = providerConfigurationDecoded
        let intermediateSourceConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IntermediateSourceConfiguration.self, forKey: .intermediateSourceConfiguration)
        intermediateSourceConfiguration = intermediateSourceConfigurationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing the providerServiceARN, intermediateSourceConfiguration, and providerConfiguration.
    public struct ProviderProperties: Swift.Equatable {
        /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        public var intermediateSourceConfiguration: EntityResolutionClientTypes.IntermediateSourceConfiguration?
        /// The required configuration fields to use with the provider service.
        public var providerConfiguration: ClientRuntime.Document?
        /// The ARN of the provider service.
        /// This member is required.
        public var providerServiceArn: Swift.String?

        public init(
            intermediateSourceConfiguration: EntityResolutionClientTypes.IntermediateSourceConfiguration? = nil,
            providerConfiguration: ClientRuntime.Document? = nil,
            providerServiceArn: Swift.String? = nil
        )
        {
            self.intermediateSourceConfiguration = intermediateSourceConfiguration
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }
    }

}

extension EntityResolutionClientTypes.ProviderServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providerName
        case providerServiceArn
        case providerServiceDisplayName
        case providerServiceName
        case providerServiceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let providerServiceArn = self.providerServiceArn {
            try encodeContainer.encode(providerServiceArn, forKey: .providerServiceArn)
        }
        if let providerServiceDisplayName = self.providerServiceDisplayName {
            try encodeContainer.encode(providerServiceDisplayName, forKey: .providerServiceDisplayName)
        }
        if let providerServiceName = self.providerServiceName {
            try encodeContainer.encode(providerServiceName, forKey: .providerServiceName)
        }
        if let providerServiceType = self.providerServiceType {
            try encodeContainer.encode(providerServiceType.rawValue, forKey: .providerServiceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerServiceDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceDisplayName)
        providerServiceDisplayName = providerServiceDisplayNameDecoded
        let providerServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceName)
        providerServiceName = providerServiceNameDecoded
        let providerServiceTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ServiceType.self, forKey: .providerServiceType)
        providerServiceType = providerServiceTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of ProviderService objects, each of which contain the fields providerName, providerServiceArn, providerServiceName, and providerServiceType.
    public struct ProviderServiceSummary: Swift.Equatable {
        /// The name of the provider. This name is typically the company name.
        /// This member is required.
        public var providerName: Swift.String?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the providerService.
        /// This member is required.
        public var providerServiceArn: Swift.String?
        /// The display name of the provider service.
        /// This member is required.
        public var providerServiceDisplayName: Swift.String?
        /// The name of the product that the provider service provides.
        /// This member is required.
        public var providerServiceName: Swift.String?
        /// The type of provider service.
        /// This member is required.
        public var providerServiceType: EntityResolutionClientTypes.ServiceType?

        public init(
            providerName: Swift.String? = nil,
            providerServiceArn: Swift.String? = nil,
            providerServiceDisplayName: Swift.String? = nil,
            providerServiceName: Swift.String? = nil,
            providerServiceType: EntityResolutionClientTypes.ServiceType? = nil
        )
        {
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }
    }

}

extension EntityResolutionClientTypes.ResolutionTechniques: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providerProperties
        case resolutionType
        case ruleBasedProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerProperties = self.providerProperties {
            try encodeContainer.encode(providerProperties, forKey: .providerProperties)
        }
        if let resolutionType = self.resolutionType {
            try encodeContainer.encode(resolutionType.rawValue, forKey: .resolutionType)
        }
        if let ruleBasedProperties = self.ruleBasedProperties {
            try encodeContainer.encode(ruleBasedProperties, forKey: .ruleBasedProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionType.self, forKey: .resolutionType)
        resolutionType = resolutionTypeDecoded
        let ruleBasedPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.RuleBasedProperties.self, forKey: .ruleBasedProperties)
        ruleBasedProperties = ruleBasedPropertiesDecoded
        let providerPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderProperties.self, forKey: .providerProperties)
        providerProperties = providerPropertiesDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the resolutionType and the ruleBasedProperties.
    public struct ResolutionTechniques: Swift.Equatable {
        /// The properties of the provider service.
        public var providerProperties: EntityResolutionClientTypes.ProviderProperties?
        /// The type of matching. There are two types of matching: RULE_MATCHING and ML_MATCHING.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
        public var ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties?

        public init(
            providerProperties: EntityResolutionClientTypes.ProviderProperties? = nil,
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties? = nil
        )
        {
            self.providerProperties = providerProperties
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }
    }

}

extension EntityResolutionClientTypes {
    public enum ResolutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mlMatching
        case provider
        case ruleMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionType] {
            return [
                .mlMatching,
                .provider,
                .ruleMatching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mlMatching: return "ML_MATCHING"
            case .provider: return "PROVIDER"
            case .ruleMatching: return "RULE_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionType(rawValue: rawValue) ?? ResolutionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found. HTTP Status Code: 404
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchingKeys
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchingKeys = matchingKeys {
            var matchingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingKeys)
            for attributename0 in matchingKeys {
                try matchingKeysContainer.encode(attributename0)
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let matchingKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchingKeys)
        var matchingKeysDecoded0:[Swift.String]? = nil
        if let matchingKeysContainer = matchingKeysContainer {
            matchingKeysDecoded0 = [Swift.String]()
            for string0 in matchingKeysContainer {
                if let string0 = string0 {
                    matchingKeysDecoded0?.append(string0)
                }
            }
        }
        matchingKeys = matchingKeysDecoded0
    }
}

extension EntityResolutionClientTypes {
    /// An object containing RuleName, and MatchingKeys.
    public struct Rule: Swift.Equatable {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in the SchemaMapping. Two records are considered to match according to this rule if all of the MatchingKeys match.
        /// This member is required.
        public var matchingKeys: [Swift.String]?
        /// A name for the matching rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            matchingKeys: [Swift.String]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }
    }

}

extension EntityResolutionClientTypes.RuleBasedProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeMatchingModel
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeMatchingModel = self.attributeMatchingModel {
            try encodeContainer.encode(attributeMatchingModel.rawValue, forKey: .attributeMatchingModel)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[EntityResolutionClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [EntityResolutionClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let attributeMatchingModelDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.AttributeMatchingModel.self, forKey: .attributeMatchingModel)
        attributeMatchingModel = attributeMatchingModelDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
    public struct RuleBasedProperties: Swift.Equatable {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE ,the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
        /// This member is required.
        public var attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel?
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        /// This member is required.
        public var rules: [EntityResolutionClientTypes.Rule]?

        public init(
            attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel? = nil,
            rules: [EntityResolutionClientTypes.Rule]? = nil
        )
        {
            self.attributeMatchingModel = attributeMatchingModel
            self.rules = rules
        }
    }

}

extension EntityResolutionClientTypes {
    public enum SchemaAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case addressCity
        case addressCountry
        case addressPostalcode
        case addressState
        case addressStreet1
        case addressStreet2
        case addressStreet3
        case date
        case emailAddress
        case name
        case nameFirst
        case nameLast
        case nameMiddle
        case phone
        case phoneCountrycode
        case phoneNumber
        case providerId
        case string
        case uniqueId
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaAttributeType] {
            return [
                .address,
                .addressCity,
                .addressCountry,
                .addressPostalcode,
                .addressState,
                .addressStreet1,
                .addressStreet2,
                .addressStreet3,
                .date,
                .emailAddress,
                .name,
                .nameFirst,
                .nameLast,
                .nameMiddle,
                .phone,
                .phoneCountrycode,
                .phoneNumber,
                .providerId,
                .string,
                .uniqueId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .addressCity: return "ADDRESS_CITY"
            case .addressCountry: return "ADDRESS_COUNTRY"
            case .addressPostalcode: return "ADDRESS_POSTALCODE"
            case .addressState: return "ADDRESS_STATE"
            case .addressStreet1: return "ADDRESS_STREET1"
            case .addressStreet2: return "ADDRESS_STREET2"
            case .addressStreet3: return "ADDRESS_STREET3"
            case .date: return "DATE"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .nameFirst: return "NAME_FIRST"
            case .nameLast: return "NAME_LAST"
            case .nameMiddle: return "NAME_MIDDLE"
            case .phone: return "PHONE"
            case .phoneCountrycode: return "PHONE_COUNTRYCODE"
            case .phoneNumber: return "PHONE_NUMBER"
            case .providerId: return "PROVIDER_ID"
            case .string: return "STRING"
            case .uniqueId: return "UNIQUE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaAttributeType(rawValue: rawValue) ?? SchemaAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.SchemaInputAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case groupName
        case matchKey
        case subType
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let matchKey = self.matchKey {
            try encodeContainer.encode(matchKey, forKey: .matchKey)
        }
        if let subType = self.subType {
            try encodeContainer.encode(subType, forKey: .subType)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.SchemaAttributeType.self, forKey: .type)
        type = typeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let matchKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchKey)
        matchKey = matchKeyDecoded
        let subTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subType)
        subType = subTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing FieldName, Type, GroupName, and MatchKey.
    public struct SchemaInputAttribute: Swift.Equatable {
        /// A string containing the field name.
        /// This member is required.
        public var fieldName: Swift.String?
        /// Instruct Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common GroupName will prompt Entity Resolution to concatenate them into a single value.
        public var groupName: Swift.String?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, let's consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning the MatchKey Address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no MatchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public var matchKey: Swift.String?
        /// The subtype of the attribute, selected from a list of values.
        public var subType: Swift.String?
        /// The type of the attribute, selected from a list of values.
        /// This member is required.
        public var type: EntityResolutionClientTypes.SchemaAttributeType?

        public init(
            fieldName: Swift.String? = nil,
            groupName: Swift.String? = nil,
            matchKey: Swift.String? = nil,
            subType: Swift.String? = nil,
            type: EntityResolutionClientTypes.SchemaAttributeType? = nil
        )
        {
            self.fieldName = fieldName
            self.groupName = groupName
            self.matchKey = matchKey
            self.subType = subType
            self.type = type
        }
    }

}

extension EntityResolutionClientTypes.SchemaMappingSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case hasWorkflows
        case schemaArn
        case schemaName
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let hasWorkflows = self.hasWorkflows {
            try encodeContainer.encode(hasWorkflows, forKey: .hasWorkflows)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let hasWorkflowsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasWorkflows)
        hasWorkflows = hasWorkflowsDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing SchemaName, SchemaArn, CreatedAt, andUpdatedAt.
    public struct SchemaMappingSummary: Swift.Equatable {
        /// The timestamp of when the SchemaMapping was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Specifies whether the schema mapping has been applied to a workflow.
        /// This member is required.
        public var hasWorkflows: Swift.Bool?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The timestamp of when the SchemaMapping was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            hasWorkflows: Swift.Bool? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.hasWorkflows = hasWorkflows
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }
    }

}

extension EntityResolutionClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assignment
        case idMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .assignment,
                .idMapping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assignment: return "ASSIGNMENT"
            case .idMapping: return "ID_MAPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension StartIdMappingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct StartIdMappingJobInput: Swift.Equatable {
    /// The name of the ID mapping job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct StartIdMappingJobInputBody: Swift.Equatable {
}

extension StartIdMappingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartIdMappingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartIdMappingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartIdMappingJobOutput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartIdMappingJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartIdMappingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartIdMappingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMatchingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct StartMatchingJobInput: Swift.Equatable {
    /// The name of the matching job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct StartMatchingJobInputBody: Swift.Equatable {
}

extension StartMatchingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartMatchingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMatchingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMatchingJobOutput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMatchingJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartMatchingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartMatchingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling. HTTP Status Code: 429
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdMappingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idMappingTechniques = self.idMappingTechniques {
            try encodeContainer.encode(idMappingTechniques, forKey: .idMappingTechniques)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for idmappingworkflowinputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(idmappingworkflowinputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for idmappingworkflowoutputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(idmappingworkflowoutputsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateIdMappingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct UpdateIdMappingWorkflowInput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateIdMappingWorkflowInputBody: Swift.Equatable {
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
}

extension UpdateIdMappingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.idMappingTechniques = output.idMappingTechniques
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.idMappingTechniques = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct UpdateIdMappingWorkflowOutput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow role. Entity Resolution assumes this role to access resources on your behalf.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct UpdateIdMappingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
}

extension UpdateIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum UpdateIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMatchingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let incrementalRunConfig = self.incrementalRunConfig {
            try encodeContainer.encode(incrementalRunConfig, forKey: .incrementalRunConfig)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for inputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(inputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for outputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(outputsource0)
            }
        }
        if let resolutionTechniques = self.resolutionTechniques {
            try encodeContainer.encode(resolutionTechniques, forKey: .resolutionTechniques)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateMatchingWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workflowName = workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct UpdateMatchingWorkflowInput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateMatchingWorkflowInputBody: Swift.Equatable {
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension UpdateMatchingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.workflowName = nil
        }
    }
}

public struct UpdateMatchingWorkflowOutput: Swift.Equatable {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateMatchingWorkflowOutputBody: Swift.Equatable {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension UpdateMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum UpdateMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSchemaMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mappedInputFields = mappedInputFields {
            var mappedInputFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mappedInputFields)
            for schemainputattribute0 in mappedInputFields {
                try mappedInputFieldsContainer.encode(schemainputattribute0)
            }
        }
    }
}

extension UpdateSchemaMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let schemaName = schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct UpdateSchemaMappingInput: Swift.Equatable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There can't be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
    }
}

struct UpdateSchemaMappingInputBody: Swift.Equatable {
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension UpdateSchemaMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

extension UpdateSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
        } else {
            self.description = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
        }
    }
}

public struct UpdateSchemaMappingOutput: Swift.Equatable {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

struct UpdateSchemaMappingOutputBody: Swift.Equatable {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension UpdateSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaArn
        case schemaName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

enum UpdateSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by Entity Resolution. HTTP Status Code: 400
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
