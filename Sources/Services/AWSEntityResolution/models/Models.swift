// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action. HTTP Status Code: 403
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddPolicyStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case condition
        case effect
        case principal
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for statementaction0 in action {
                try actionContainer.encode(statementaction0)
            }
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let effect = self.effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principal)
            for statementprincipal0 in principal {
                try principalContainer.encode(statementprincipal0)
            }
        }
    }
}

extension AddPolicyStatementInput {

    static func urlPathProvider(_ value: AddPolicyStatementInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())/\(statementId.urlPercentEncoding())"
    }
}

public struct AddPolicyStatementInput {
    /// The action that the principal can use on the resource. For example, entityresolution:GetIdMappingJob, entityresolution:GetMatchingJob.
    /// This member is required.
    public var action: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
    /// This member is required.
    public var arn: Swift.String?
    /// A set of condition keys that you can use in key policies.
    public var condition: Swift.String?
    /// Determines whether the permissions specified in the policy are to be allowed (Allow) or denied (Deny).
    /// This member is required.
    public var effect: EntityResolutionClientTypes.StatementEffect?
    /// The Amazon Web Services service or Amazon Web Services account that can access the resource defined as ARN.
    /// This member is required.
    public var principal: [Swift.String]?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: [Swift.String]? = nil,
        arn: Swift.String? = nil,
        condition: Swift.String? = nil,
        effect: EntityResolutionClientTypes.StatementEffect? = nil,
        principal: [Swift.String]? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.condition = condition
        self.effect = effect
        self.principal = principal
        self.statementId = statementId
    }
}

struct AddPolicyStatementInputBody {
    let effect: EntityResolutionClientTypes.StatementEffect?
    let action: [Swift.String]?
    let principal: [Swift.String]?
    let condition: Swift.String?
}

extension AddPolicyStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case condition
        case effect
        case principal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.StatementEffect.self, forKey: .effect)
        effect = effectDecoded
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let principalContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principal)
        var principalDecoded0:[Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String]()
            for string0 in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?.append(string0)
                }
            }
        }
        principal = principalDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension AddPolicyStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddPolicyStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.policy = output.policy
            self.token = output.token
        } else {
            self.arn = nil
            self.policy = nil
            self.token = nil
        }
    }
}

public struct AddPolicyStatementOutput {
    /// The Amazon Resource Name (ARN) of the resource that will be accessed by the principal.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

struct AddPolicyStatementOutputBody {
    let arn: Swift.String?
    let token: Swift.String?
    let policy: Swift.String?
}

extension AddPolicyStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case policy
        case token
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum AddPolicyStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes {
    public enum AttributeMatchingModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manyToMany
        case oneToOne
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeMatchingModel] {
            return [
                .manyToMany,
                .oneToOne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manyToMany: return "MANY_TO_MANY"
            case .oneToOne: return "ONE_TO_ONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeMatchingModel(rawValue: rawValue) ?? AttributeMatchingModel.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. Example: Workflow already exists, Schema already exists, Workflow is currently running, etc. HTTP Status Code: 400
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateIdMappingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case tags
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idMappingTechniques = self.idMappingTechniques {
            try encodeContainer.encode(idMappingTechniques, forKey: .idMappingTechniques)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for idmappingworkflowinputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(idmappingworkflowinputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for idmappingworkflowoutputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(idmappingworkflowoutputsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }
}

extension CreateIdMappingWorkflowInput {

    static func urlPathProvider(_ value: CreateIdMappingWorkflowInput) -> Swift.String? {
        return "/idmappingworkflows"
    }
}

public struct CreateIdMappingWorkflowInput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workflow. There can't be multiple IdMappingWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

struct CreateIdMappingWorkflowInputBody {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIdMappingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case tags
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.idMappingTechniques = output.idMappingTechniques
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.idMappingTechniques = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct CreateIdMappingWorkflowOutput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of IdMappingWorkflowOutputSource objects, each of which contains fields OutputS3Path and Output.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IDMappingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct CreateIdMappingWorkflowOutputBody {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
}

extension CreateIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum CreateIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIdNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingWorkflowProperties
        case idNamespaceName
        case inputSourceConfig
        case roleArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idMappingWorkflowProperties = idMappingWorkflowProperties {
            var idMappingWorkflowPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idMappingWorkflowProperties)
            for idnamespaceidmappingworkflowproperties0 in idMappingWorkflowProperties {
                try idMappingWorkflowPropertiesContainer.encode(idnamespaceidmappingworkflowproperties0)
            }
        }
        if let idNamespaceName = self.idNamespaceName {
            try encodeContainer.encode(idNamespaceName, forKey: .idNamespaceName)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for idnamespaceinputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(idnamespaceinputsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateIdNamespaceInput {

    static func urlPathProvider(_ value: CreateIdNamespaceInput) -> Swift.String? {
        return "/idnamespaces"
    }
}

public struct CreateIdNamespaceInput {
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of the workflow run.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?

    public init(
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil
    )
    {
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
    }
}

struct CreateIdNamespaceInputBody {
    let idNamespaceName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    let idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    let type: EntityResolutionClientTypes.IdNamespaceType?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIdNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingWorkflowProperties
        case idNamespaceName
        case inputSourceConfig
        case roleArn
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceName)
        idNamespaceName = idNamespaceNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdNamespaceInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdNamespaceInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let idMappingWorkflowPropertiesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties?].self, forKey: .idMappingWorkflowProperties)
        var idMappingWorkflowPropertiesDecoded0:[EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil
        if let idMappingWorkflowPropertiesContainer = idMappingWorkflowPropertiesContainer {
            idMappingWorkflowPropertiesDecoded0 = [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]()
            for structure0 in idMappingWorkflowPropertiesContainer {
                if let structure0 = structure0 {
                    idMappingWorkflowPropertiesDecoded0?.append(structure0)
                }
            }
        }
        idMappingWorkflowProperties = idMappingWorkflowPropertiesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdNamespaceType.self, forKey: .type)
        type = typeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIdNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.idMappingWorkflowProperties = output.idMappingWorkflowProperties
            self.idNamespaceArn = output.idNamespaceArn
            self.idNamespaceName = output.idNamespaceName
            self.inputSourceConfig = output.inputSourceConfig
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.idMappingWorkflowProperties = nil
            self.idNamespaceArn = nil
            self.idNamespaceName = nil
            self.inputSourceConfig = nil
            self.roleArn = nil
            self.tags = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateIdNamespaceOutput {
    /// The timestamp of when the ID namespace was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The Amazon Resource Name (ARN) of the ID namespace.
    /// This member is required.
    public var idNamespaceArn: Swift.String?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in inputSourceConfig on your behalf as part of the workflow run.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?
    /// The timestamp of when the ID namespace was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceArn: Swift.String? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceArn = idNamespaceArn
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct CreateIdNamespaceOutputBody {
    let idNamespaceName: Swift.String?
    let idNamespaceArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    let idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    let type: EntityResolutionClientTypes.IdNamespaceType?
    let roleArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIdNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case idMappingWorkflowProperties
        case idNamespaceArn
        case idNamespaceName
        case inputSourceConfig
        case roleArn
        case tags
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceName)
        idNamespaceName = idNamespaceNameDecoded
        let idNamespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceArn)
        idNamespaceArn = idNamespaceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdNamespaceInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdNamespaceInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let idMappingWorkflowPropertiesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties?].self, forKey: .idMappingWorkflowProperties)
        var idMappingWorkflowPropertiesDecoded0:[EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil
        if let idMappingWorkflowPropertiesContainer = idMappingWorkflowPropertiesContainer {
            idMappingWorkflowPropertiesDecoded0 = [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]()
            for structure0 in idMappingWorkflowPropertiesContainer {
                if let structure0 = structure0 {
                    idMappingWorkflowPropertiesDecoded0?.append(structure0)
                }
            }
        }
        idMappingWorkflowProperties = idMappingWorkflowPropertiesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdNamespaceType.self, forKey: .type)
        type = typeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateIdNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMatchingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let incrementalRunConfig = self.incrementalRunConfig {
            try encodeContainer.encode(incrementalRunConfig, forKey: .incrementalRunConfig)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for inputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(inputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for outputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(outputsource0)
            }
        }
        if let resolutionTechniques = self.resolutionTechniques {
            try encodeContainer.encode(resolutionTechniques, forKey: .resolutionTechniques)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }
}

extension CreateMatchingWorkflowInput {

    static func urlPathProvider(_ value: CreateMatchingWorkflowInput) -> Swift.String? {
        return "/matchingworkflows"
    }
}

public struct CreateMatchingWorkflowInput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workflow. There can't be multiple MatchingWorkflows with the same name.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.workflowName = workflowName
    }
}

struct CreateMatchingWorkflowInputBody {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMatchingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct CreateMatchingWorkflowOutput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct CreateMatchingWorkflowOutputBody {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension CreateMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum CreateMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSchemaMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mappedInputFields = mappedInputFields {
            var mappedInputFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mappedInputFields)
            for schemainputattribute0 in mappedInputFields {
                try mappedInputFieldsContainer.encode(schemainputattribute0)
            }
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSchemaMappingInput {

    static func urlPathProvider(_ value: CreateSchemaMappingInput) -> Swift.String? {
        return "/schemas"
    }
}

public struct CreateSchemaMappingInput {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There can't be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
        self.tags = tags
    }
}

struct CreateSchemaMappingInputBody {
    let schemaName: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSchemaMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
        } else {
            self.description = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
        }
    }
}

public struct CreateSchemaMappingOutput {
    /// A description of the schema.
    /// This member is required.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

struct CreateSchemaMappingOutputBody {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension CreateSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaArn
        case schemaName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

enum CreateSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIdMappingWorkflowInput {

    static func urlPathProvider(_ value: DeleteIdMappingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct DeleteIdMappingWorkflowInput {
    /// The name of the workflow to be deleted.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct DeleteIdMappingWorkflowInputBody {
}

extension DeleteIdMappingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteIdMappingWorkflowOutput {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteIdMappingWorkflowOutputBody {
    let message: Swift.String?
}

extension DeleteIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIdNamespaceInput {

    static func urlPathProvider(_ value: DeleteIdNamespaceInput) -> Swift.String? {
        guard let idNamespaceName = value.idNamespaceName else {
            return nil
        }
        return "/idnamespaces/\(idNamespaceName.urlPercentEncoding())"
    }
}

public struct DeleteIdNamespaceInput {
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?

    public init(
        idNamespaceName: Swift.String? = nil
    )
    {
        self.idNamespaceName = idNamespaceName
    }
}

struct DeleteIdNamespaceInputBody {
}

extension DeleteIdNamespaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteIdNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteIdNamespaceOutput {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteIdNamespaceOutputBody {
    let message: Swift.String?
}

extension DeleteIdNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteIdNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMatchingWorkflowInput {

    static func urlPathProvider(_ value: DeleteMatchingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct DeleteMatchingWorkflowInput {
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct DeleteMatchingWorkflowInputBody {
}

extension DeleteMatchingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteMatchingWorkflowOutput {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteMatchingWorkflowOutputBody {
    let message: Swift.String?
}

extension DeleteMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePolicyStatementInput {

    static func urlPathProvider(_ value: DeletePolicyStatementInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())/\(statementId.urlPercentEncoding())"
    }
}

public struct DeletePolicyStatementInput {
    /// The ARN of the resource for which the policy need to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.statementId = statementId
    }
}

struct DeletePolicyStatementInputBody {
}

extension DeletePolicyStatementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePolicyStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePolicyStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.policy = output.policy
            self.token = output.token
        } else {
            self.arn = nil
            self.policy = nil
            self.token = nil
        }
    }
}

public struct DeletePolicyStatementOutput {
    /// The ARN of the resource for which the policy need to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the deleted policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

struct DeletePolicyStatementOutputBody {
    let arn: Swift.String?
    let token: Swift.String?
    let policy: Swift.String?
}

extension DeletePolicyStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case policy
        case token
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum DeletePolicyStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaMappingInput {

    static func urlPathProvider(_ value: DeleteSchemaMappingInput) -> Swift.String? {
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct DeleteSchemaMappingInput {
    /// The name of the schema to delete.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

struct DeleteSchemaMappingInputBody {
}

extension DeleteSchemaMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct DeleteSchemaMappingOutput {
    /// A successful operation message.
    /// This member is required.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeleteSchemaMappingOutputBody {
    let message: Swift.String?
}

extension DeleteSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DeleteSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum EntityResolutionClientTypes {}

extension EntityResolutionClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing an error message, if there was an error.
    public struct ErrorDetails {
        /// The error message from the job, if there is one.
        public var errorMessage: Swift.String?

        public init(
            errorMessage: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
        }
    }

}

extension ExceedsLimitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExceedsLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaName = output.quotaName
            self.properties.quotaValue = output.quotaValue
        } else {
            self.properties.message = nil
            self.properties.quotaName = nil
            self.properties.quotaValue = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Entity Resolution account limits. The error message describes the limit exceeded. HTTP Status Code: 402
public struct ExceedsLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the quota that has been breached.
        public internal(set) var quotaName: Swift.String? = nil
        /// The current quota value for the customers.
        public internal(set) var quotaValue: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExceedsLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaName: Swift.String? = nil,
        quotaValue: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaName = quotaName
        self.properties.quotaValue = quotaValue
    }
}

struct ExceedsLimitExceptionBody {
    let message: Swift.String?
    let quotaName: Swift.String?
    let quotaValue: Swift.Int?
}

extension ExceedsLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaName
        case quotaValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let quotaValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quotaValue)
        quotaValue = quotaValueDecoded
    }
}

extension GetIdMappingJobInput {

    static func urlPathProvider(_ value: GetIdMappingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetIdMappingJobInput {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

struct GetIdMappingJobInputBody {
}

extension GetIdMappingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdMappingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdMappingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorDetails = output.errorDetails
            self.jobId = output.jobId
            self.metrics = output.metrics
            self.outputSourceConfig = output.outputSourceConfig
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.endTime = nil
            self.errorDetails = nil
            self.jobId = nil
            self.metrics = nil
            self.outputSourceConfig = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct GetIdMappingJobOutput {
    /// The time at which the job has finished.
    public var endTime: ClientRuntime.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.IdMappingJobMetrics?
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: ClientRuntime.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.IdMappingJobMetrics? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.outputSourceConfig = outputSourceConfig
        self.startTime = startTime
        self.status = status
    }
}

struct GetIdMappingJobOutputBody {
    let jobId: Swift.String?
    let status: EntityResolutionClientTypes.JobStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metrics: EntityResolutionClientTypes.IdMappingJobMetrics?
    let errorDetails: EntityResolutionClientTypes.ErrorDetails?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
}

extension GetIdMappingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorDetails
        case jobId
        case metrics
        case outputSourceConfig
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingJobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingJobOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingJobOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
    }
}

enum GetIdMappingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdMappingWorkflowInput {

    static func urlPathProvider(_ value: GetIdMappingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct GetIdMappingWorkflowInput {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct GetIdMappingWorkflowInputBody {
}

extension GetIdMappingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.idMappingTechniques = output.idMappingTechniques
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.updatedAt = output.updatedAt
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.createdAt = nil
            self.description = nil
            self.idMappingTechniques = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.roleArn = nil
            self.tags = nil
            self.updatedAt = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct GetIdMappingWorkflowOutput {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow .
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct GetIdMappingWorkflowOutputBody {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case tags
        case updatedAt
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdNamespaceInput {

    static func urlPathProvider(_ value: GetIdNamespaceInput) -> Swift.String? {
        guard let idNamespaceName = value.idNamespaceName else {
            return nil
        }
        return "/idnamespaces/\(idNamespaceName.urlPercentEncoding())"
    }
}

public struct GetIdNamespaceInput {
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?

    public init(
        idNamespaceName: Swift.String? = nil
    )
    {
        self.idNamespaceName = idNamespaceName
    }
}

struct GetIdNamespaceInputBody {
}

extension GetIdNamespaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.idMappingWorkflowProperties = output.idMappingWorkflowProperties
            self.idNamespaceArn = output.idNamespaceArn
            self.idNamespaceName = output.idNamespaceName
            self.inputSourceConfig = output.inputSourceConfig
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.idMappingWorkflowProperties = nil
            self.idNamespaceArn = nil
            self.idNamespaceName = nil
            self.inputSourceConfig = nil
            self.roleArn = nil
            self.tags = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetIdNamespaceOutput {
    /// The timestamp of when the ID namespace was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The Amazon Resource Name (ARN) of the ID namespace.
    /// This member is required.
    public var idNamespaceArn: Swift.String?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?
    /// The timestamp of when the ID namespace was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceArn: Swift.String? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceArn = idNamespaceArn
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetIdNamespaceOutputBody {
    let idNamespaceName: Swift.String?
    let idNamespaceArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    let idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    let type: EntityResolutionClientTypes.IdNamespaceType?
    let roleArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetIdNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case idMappingWorkflowProperties
        case idNamespaceArn
        case idNamespaceName
        case inputSourceConfig
        case roleArn
        case tags
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceName)
        idNamespaceName = idNamespaceNameDecoded
        let idNamespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceArn)
        idNamespaceArn = idNamespaceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdNamespaceInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdNamespaceInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let idMappingWorkflowPropertiesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties?].self, forKey: .idMappingWorkflowProperties)
        var idMappingWorkflowPropertiesDecoded0:[EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil
        if let idMappingWorkflowPropertiesContainer = idMappingWorkflowPropertiesContainer {
            idMappingWorkflowPropertiesDecoded0 = [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]()
            for structure0 in idMappingWorkflowPropertiesContainer {
                if let structure0 = structure0 {
                    idMappingWorkflowPropertiesDecoded0?.append(structure0)
                }
            }
        }
        idMappingWorkflowProperties = idMappingWorkflowPropertiesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdNamespaceType.self, forKey: .type)
        type = typeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetIdNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMatchIdInput(applyNormalization: \(Swift.String(describing: applyNormalization)), workflowName: \(Swift.String(describing: workflowName)), record: \"CONTENT_REDACTED\")"}
}

extension GetMatchIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyNormalization
        case record
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let record = record {
            var recordContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .record)
            for (dictKey0, recordAttributeMap0) in record {
                try recordContainer.encode(recordAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetMatchIdInput {

    static func urlPathProvider(_ value: GetMatchIdInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/matches"
    }
}

public struct GetMatchIdInput {
    /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
    public var applyNormalization: Swift.Bool?
    /// The record to fetch the Match ID for.
    /// This member is required.
    public var record: [Swift.String:Swift.String]?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        applyNormalization: Swift.Bool? = nil,
        record: [Swift.String:Swift.String]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.applyNormalization = applyNormalization
        self.record = record
        self.workflowName = workflowName
    }
}

struct GetMatchIdInputBody {
    let record: [Swift.String:Swift.String]?
    let applyNormalization: Swift.Bool?
}

extension GetMatchIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyNormalization
        case record
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .record)
        var recordDecoded0: [Swift.String:Swift.String]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in recordContainer {
                if let string0 = string0 {
                    recordDecoded0?[key0] = string0
                }
            }
        }
        record = recordDecoded0
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension GetMatchIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.matchId = output.matchId
            self.matchRule = output.matchRule
        } else {
            self.matchId = nil
            self.matchRule = nil
        }
    }
}

public struct GetMatchIdOutput {
    /// The unique identifiers for this group of match records.
    public var matchId: Swift.String?
    /// The rule the record matched on.
    public var matchRule: Swift.String?

    public init(
        matchId: Swift.String? = nil,
        matchRule: Swift.String? = nil
    )
    {
        self.matchId = matchId
        self.matchRule = matchRule
    }
}

struct GetMatchIdOutputBody {
    let matchId: Swift.String?
    let matchRule: Swift.String?
}

extension GetMatchIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchId
        case matchRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchId)
        matchId = matchIdDecoded
        let matchRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchRule)
        matchRule = matchRuleDecoded
    }
}

enum GetMatchIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchingJobInput {

    static func urlPathProvider(_ value: GetMatchingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetMatchingJobInput {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.workflowName = workflowName
    }
}

struct GetMatchingJobInputBody {
}

extension GetMatchingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorDetails = output.errorDetails
            self.jobId = output.jobId
            self.metrics = output.metrics
            self.outputSourceConfig = output.outputSourceConfig
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.endTime = nil
            self.errorDetails = nil
            self.jobId = nil
            self.metrics = nil
            self.outputSourceConfig = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct GetMatchingJobOutput {
    /// The time at which the job has finished.
    public var endTime: ClientRuntime.Date?
    /// An object containing an error message, if there was an error.
    public var errorDetails: EntityResolutionClientTypes.ErrorDetails?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Metrics associated with the execution, specifically total records processed, unique IDs generated, and records the execution skipped.
    public var metrics: EntityResolutionClientTypes.JobMetrics?
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.JobOutputSource]?
    /// The time at which the job was started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The current status of the job.
    /// This member is required.
    public var status: EntityResolutionClientTypes.JobStatus?

    public init(
        endTime: ClientRuntime.Date? = nil,
        errorDetails: EntityResolutionClientTypes.ErrorDetails? = nil,
        jobId: Swift.String? = nil,
        metrics: EntityResolutionClientTypes.JobMetrics? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.JobOutputSource]? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EntityResolutionClientTypes.JobStatus? = nil
    )
    {
        self.endTime = endTime
        self.errorDetails = errorDetails
        self.jobId = jobId
        self.metrics = metrics
        self.outputSourceConfig = outputSourceConfig
        self.startTime = startTime
        self.status = status
    }
}

struct GetMatchingJobOutputBody {
    let jobId: Swift.String?
    let status: EntityResolutionClientTypes.JobStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metrics: EntityResolutionClientTypes.JobMetrics?
    let errorDetails: EntityResolutionClientTypes.ErrorDetails?
    let outputSourceConfig: [EntityResolutionClientTypes.JobOutputSource]?
}

extension GetMatchingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorDetails
        case jobId
        case metrics
        case outputSourceConfig
        case startTime
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.JobOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.JobOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.JobOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
    }
}

enum GetMatchingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMatchingWorkflowInput {

    static func urlPathProvider(_ value: GetMatchingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct GetMatchingWorkflowInput {
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct GetMatchingWorkflowInputBody {
}

extension GetMatchingWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.updatedAt = output.updatedAt
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.createdAt = nil
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.tags = nil
            self.updatedAt = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct GetMatchingWorkflowOutput {
    /// The timestamp of when the workflow was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the workflow was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct GetMatchingWorkflowOutputBody {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case tags
        case updatedAt
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())"
    }
}

public struct GetPolicyInput {
    /// The Amazon Resource Name (ARN) of the resource for which the policy need to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetPolicyInputBody {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.policy = output.policy
            self.token = output.token
        } else {
            self.arn = nil
            self.policy = nil
            self.token = nil
        }
    }
}

public struct GetPolicyOutput {
    /// The Entity Resolution resource ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

struct GetPolicyOutputBody {
    let arn: Swift.String?
    let token: Swift.String?
    let policy: Swift.String?
}

extension GetPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case policy
        case token
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProviderServiceInput {

    static func urlPathProvider(_ value: GetProviderServiceInput) -> Swift.String? {
        guard let providerName = value.providerName else {
            return nil
        }
        guard let providerServiceName = value.providerServiceName else {
            return nil
        }
        return "/providerservices/\(providerName.urlPercentEncoding())/\(providerServiceName.urlPercentEncoding())"
    }
}

public struct GetProviderServiceInput {
    /// The name of the provider. This name is typically the company name.
    /// This member is required.
    public var providerName: Swift.String?
    /// The ARN (Amazon Resource Name) of the product that the provider service provides.
    /// This member is required.
    public var providerServiceName: Swift.String?

    public init(
        providerName: Swift.String? = nil,
        providerServiceName: Swift.String? = nil
    )
    {
        self.providerName = providerName
        self.providerServiceName = providerServiceName
    }
}

struct GetProviderServiceInputBody {
}

extension GetProviderServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProviderServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProviderServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.anonymizedOutput = output.anonymizedOutput
            self.providerComponentSchema = output.providerComponentSchema
            self.providerConfigurationDefinition = output.providerConfigurationDefinition
            self.providerEndpointConfiguration = output.providerEndpointConfiguration
            self.providerEntityOutputDefinition = output.providerEntityOutputDefinition
            self.providerIdNameSpaceConfiguration = output.providerIdNameSpaceConfiguration
            self.providerIntermediateDataAccessConfiguration = output.providerIntermediateDataAccessConfiguration
            self.providerJobConfiguration = output.providerJobConfiguration
            self.providerName = output.providerName
            self.providerServiceArn = output.providerServiceArn
            self.providerServiceDisplayName = output.providerServiceDisplayName
            self.providerServiceName = output.providerServiceName
            self.providerServiceType = output.providerServiceType
        } else {
            self.anonymizedOutput = nil
            self.providerComponentSchema = nil
            self.providerConfigurationDefinition = nil
            self.providerEndpointConfiguration = nil
            self.providerEntityOutputDefinition = nil
            self.providerIdNameSpaceConfiguration = nil
            self.providerIntermediateDataAccessConfiguration = nil
            self.providerJobConfiguration = nil
            self.providerName = nil
            self.providerServiceArn = nil
            self.providerServiceDisplayName = nil
            self.providerServiceName = nil
            self.providerServiceType = nil
        }
    }
}

public struct GetProviderServiceOutput {
    /// Specifies whether output data from the provider is anonymized. A value of TRUE means the output will be anonymized and you can't relate the data that comes back from the provider to the identifying input. A value of FALSE means the output won't be anonymized and you can relate the data that comes back from the provider to your source data.
    /// This member is required.
    public var anonymizedOutput: Swift.Bool?
    /// Input schema for the provider service.
    public var providerComponentSchema: EntityResolutionClientTypes.ProviderComponentSchema?
    /// The definition of the provider configuration.
    public var providerConfigurationDefinition: ClientRuntime.Document?
    /// The required configuration fields to use with the provider service.
    /// This member is required.
    public var providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration?
    /// The definition of the provider entity output.
    /// This member is required.
    public var providerEntityOutputDefinition: ClientRuntime.Document?
    /// The provider configuration required for different ID namespace types.
    public var providerIdNameSpaceConfiguration: EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration?
    /// The Amazon Web Services accounts and the S3 permissions that are required by some providers to create an S3 bucket for intermediate data storage.
    public var providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration?
    /// Provider service job configurations.
    public var providerJobConfiguration: ClientRuntime.Document?
    /// The name of the provider. This name is typically the company name.
    /// This member is required.
    public var providerName: Swift.String?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the provider service.
    /// This member is required.
    public var providerServiceArn: Swift.String?
    /// The display name of the provider service.
    /// This member is required.
    public var providerServiceDisplayName: Swift.String?
    /// The name of the product that the provider service provides.
    /// This member is required.
    public var providerServiceName: Swift.String?
    /// The type of provider service.
    /// This member is required.
    public var providerServiceType: EntityResolutionClientTypes.ServiceType?

    public init(
        anonymizedOutput: Swift.Bool? = nil,
        providerComponentSchema: EntityResolutionClientTypes.ProviderComponentSchema? = nil,
        providerConfigurationDefinition: ClientRuntime.Document? = nil,
        providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration? = nil,
        providerEntityOutputDefinition: ClientRuntime.Document? = nil,
        providerIdNameSpaceConfiguration: EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration? = nil,
        providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration? = nil,
        providerJobConfiguration: ClientRuntime.Document? = nil,
        providerName: Swift.String? = nil,
        providerServiceArn: Swift.String? = nil,
        providerServiceDisplayName: Swift.String? = nil,
        providerServiceName: Swift.String? = nil,
        providerServiceType: EntityResolutionClientTypes.ServiceType? = nil
    )
    {
        self.anonymizedOutput = anonymizedOutput
        self.providerComponentSchema = providerComponentSchema
        self.providerConfigurationDefinition = providerConfigurationDefinition
        self.providerEndpointConfiguration = providerEndpointConfiguration
        self.providerEntityOutputDefinition = providerEntityOutputDefinition
        self.providerIdNameSpaceConfiguration = providerIdNameSpaceConfiguration
        self.providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfiguration
        self.providerJobConfiguration = providerJobConfiguration
        self.providerName = providerName
        self.providerServiceArn = providerServiceArn
        self.providerServiceDisplayName = providerServiceDisplayName
        self.providerServiceName = providerServiceName
        self.providerServiceType = providerServiceType
    }
}

struct GetProviderServiceOutputBody {
    let providerName: Swift.String?
    let providerServiceName: Swift.String?
    let providerServiceDisplayName: Swift.String?
    let providerServiceType: EntityResolutionClientTypes.ServiceType?
    let providerServiceArn: Swift.String?
    let providerConfigurationDefinition: ClientRuntime.Document?
    let providerIdNameSpaceConfiguration: EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration?
    let providerJobConfiguration: ClientRuntime.Document?
    let providerEndpointConfiguration: EntityResolutionClientTypes.ProviderEndpointConfiguration?
    let anonymizedOutput: Swift.Bool?
    let providerEntityOutputDefinition: ClientRuntime.Document?
    let providerIntermediateDataAccessConfiguration: EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration?
    let providerComponentSchema: EntityResolutionClientTypes.ProviderComponentSchema?
}

extension GetProviderServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anonymizedOutput
        case providerComponentSchema
        case providerConfigurationDefinition
        case providerEndpointConfiguration
        case providerEntityOutputDefinition
        case providerIdNameSpaceConfiguration
        case providerIntermediateDataAccessConfiguration
        case providerJobConfiguration
        case providerName
        case providerServiceArn
        case providerServiceDisplayName
        case providerServiceName
        case providerServiceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceName)
        providerServiceName = providerServiceNameDecoded
        let providerServiceDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceDisplayName)
        providerServiceDisplayName = providerServiceDisplayNameDecoded
        let providerServiceTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ServiceType.self, forKey: .providerServiceType)
        providerServiceType = providerServiceTypeDecoded
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerConfigurationDefinitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerConfigurationDefinition)
        providerConfigurationDefinition = providerConfigurationDefinitionDecoded
        let providerIdNameSpaceConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration.self, forKey: .providerIdNameSpaceConfiguration)
        providerIdNameSpaceConfiguration = providerIdNameSpaceConfigurationDecoded
        let providerJobConfigurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerJobConfiguration)
        providerJobConfiguration = providerJobConfigurationDecoded
        let providerEndpointConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderEndpointConfiguration.self, forKey: .providerEndpointConfiguration)
        providerEndpointConfiguration = providerEndpointConfigurationDecoded
        let anonymizedOutputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .anonymizedOutput)
        anonymizedOutput = anonymizedOutputDecoded
        let providerEntityOutputDefinitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerEntityOutputDefinition)
        providerEntityOutputDefinition = providerEntityOutputDefinitionDecoded
        let providerIntermediateDataAccessConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration.self, forKey: .providerIntermediateDataAccessConfiguration)
        providerIntermediateDataAccessConfiguration = providerIntermediateDataAccessConfigurationDecoded
        let providerComponentSchemaDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderComponentSchema.self, forKey: .providerComponentSchema)
        providerComponentSchema = providerComponentSchemaDecoded
    }
}

enum GetProviderServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaMappingInput {

    static func urlPathProvider(_ value: GetSchemaMappingInput) -> Swift.String? {
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct GetSchemaMappingInput {
    /// The name of the schema to be retrieved.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        schemaName: Swift.String? = nil
    )
    {
        self.schemaName = schemaName
    }
}

struct GetSchemaMappingInputBody {
}

extension GetSchemaMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.hasWorkflows = output.hasWorkflows
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.hasWorkflows = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetSchemaMappingOutput {
    /// The timestamp of when the SchemaMapping was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A description of the schema.
    public var description: Swift.String?
    /// Specifies whether the schema mapping has been applied to a workflow.
    /// This member is required.
    public var hasWorkflows: Swift.Bool?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information Venice uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp of when the SchemaMapping was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        hasWorkflows: Swift.Bool? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.hasWorkflows = hasWorkflows
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetSchemaMappingOutputBody {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let hasWorkflows: Swift.Bool?
}

extension GetSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case hasWorkflows
        case mappedInputFields
        case schemaArn
        case schemaName
        case tags
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let hasWorkflowsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasWorkflows)
        hasWorkflows = hasWorkflowsDecoded
    }
}

enum GetSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.IdMappingJobMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputRecords
        case recordsNotProcessed
        case totalRecordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputRecords = self.inputRecords {
            try encodeContainer.encode(inputRecords, forKey: .inputRecords)
        }
        if let recordsNotProcessed = self.recordsNotProcessed {
            try encodeContainer.encode(recordsNotProcessed, forKey: .recordsNotProcessed)
        }
        if let totalRecordsProcessed = self.totalRecordsProcessed {
            try encodeContainer.encode(totalRecordsProcessed, forKey: .totalRecordsProcessed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRecords)
        inputRecords = inputRecordsDecoded
        let totalRecordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsProcessed)
        totalRecordsProcessed = totalRecordsProcessedDecoded
        let recordsNotProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsNotProcessed)
        recordsNotProcessed = recordsNotProcessedDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputRecords, TotalRecordsProcessed, MatchIDs, and RecordsNotProcessed.
    public struct IdMappingJobMetrics {
        /// The total number of input records.
        public var inputRecords: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }

}

extension EntityResolutionClientTypes.IdMappingJobOutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case outputS3Path
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing KMSArn, OutputS3Path, and RoleARN.
    public struct IdMappingJobOutputSource {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf as part of workflow execution.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
            self.roleArn = roleArn
        }
    }

}

extension EntityResolutionClientTypes.IdMappingTechniques: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idMappingType
        case providerProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idMappingType = self.idMappingType {
            try encodeContainer.encode(idMappingType.rawValue, forKey: .idMappingType)
        }
        if let providerProperties = self.providerProperties {
            try encodeContainer.encode(providerProperties, forKey: .providerProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idMappingTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingType.self, forKey: .idMappingType)
        idMappingType = idMappingTypeDecoded
        let providerPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderProperties.self, forKey: .providerProperties)
        providerProperties = providerPropertiesDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the ID mapping techniques and provider configurations.
    public struct IdMappingTechniques {
        /// The type of ID mapping.
        /// This member is required.
        public var idMappingType: EntityResolutionClientTypes.IdMappingType?
        /// An object which defines any additional configurations required by the provider service.
        public var providerProperties: EntityResolutionClientTypes.ProviderProperties?

        public init(
            idMappingType: EntityResolutionClientTypes.IdMappingType? = nil,
            providerProperties: EntityResolutionClientTypes.ProviderProperties? = nil
        )
        {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
        }
    }

}

extension EntityResolutionClientTypes {
    public enum IdMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provider
        case sdkUnknown(Swift.String)

        public static var allCases: [IdMappingType] {
            return [
                .provider,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provider: return "PROVIDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdMappingType(rawValue: rawValue) ?? IdMappingType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.IdMappingWorkflowInputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSourceARN
        case schemaName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputSourceARN = self.inputSourceARN {
            try encodeContainer.encode(inputSourceARN, forKey: .inputSourceARN)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSourceARN)
        inputSourceARN = inputSourceARNDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdNamespaceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputSourceARN, SchemaName, and Type.
    public struct IdMappingWorkflowInputSource {
        /// An Glue table ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        public var schemaName: Swift.String?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        public var type: EntityResolutionClientTypes.IdNamespaceType?

        public init(
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            type: EntityResolutionClientTypes.IdNamespaceType? = nil
        )
        {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
            self.type = type
        }
    }

}

extension EntityResolutionClientTypes.IdMappingWorkflowOutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case outputS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The output source for the ID mapping workflow.
    public struct IdMappingWorkflowOutputSource {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
        }
    }

}

extension EntityResolutionClientTypes.IdMappingWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case updatedAt
        case workflowArn
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workflowArn = self.workflowArn {
            try encodeContainer.encode(workflowArn, forKey: .workflowArn)
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of IdMappingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public struct IdMappingWorkflowSummary {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the IdMappingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }

}

extension EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idMappingType
        case providerProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idMappingType = self.idMappingType {
            try encodeContainer.encode(idMappingType.rawValue, forKey: .idMappingType)
        }
        if let providerProperties = self.providerProperties {
            try encodeContainer.encode(providerProperties, forKey: .providerProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idMappingTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingType.self, forKey: .idMappingType)
        idMappingType = idMappingTypeDecoded
        let providerPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.NamespaceProviderProperties.self, forKey: .providerProperties)
        providerProperties = providerPropertiesDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing IdMappingType and ProviderProperties.
    public struct IdNamespaceIdMappingWorkflowProperties {
        /// The type of ID mapping.
        /// This member is required.
        public var idMappingType: EntityResolutionClientTypes.IdMappingType?
        /// An object which defines any additional configurations required by the provider service.
        public var providerProperties: EntityResolutionClientTypes.NamespaceProviderProperties?

        public init(
            idMappingType: EntityResolutionClientTypes.IdMappingType? = nil,
            providerProperties: EntityResolutionClientTypes.NamespaceProviderProperties? = nil
        )
        {
            self.idMappingType = idMappingType
            self.providerProperties = providerProperties
        }
    }

}

extension EntityResolutionClientTypes.IdNamespaceInputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSourceARN
        case schemaName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputSourceARN = self.inputSourceARN {
            try encodeContainer.encode(inputSourceARN, forKey: .inputSourceARN)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSourceARN)
        inputSourceARN = inputSourceARNDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputSourceARN and SchemaName.
    public struct IdNamespaceInputSource {
        /// An Glue table ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema.
        public var schemaName: Swift.String?

        public init(
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }

}

extension EntityResolutionClientTypes.IdNamespaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case idNamespaceArn
        case idNamespaceName
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idNamespaceArn = self.idNamespaceArn {
            try encodeContainer.encode(idNamespaceArn, forKey: .idNamespaceArn)
        }
        if let idNamespaceName = self.idNamespaceName {
            try encodeContainer.encode(idNamespaceName, forKey: .idNamespaceName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceName)
        idNamespaceName = idNamespaceNameDecoded
        let idNamespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceArn)
        idNamespaceArn = idNamespaceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdNamespaceType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A summary of ID namespaces.
    public struct IdNamespaceSummary {
        /// The timestamp of when the ID namespace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the ID namespace.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the ID namespace.
        /// This member is required.
        public var idNamespaceArn: Swift.String?
        /// The name of the ID namespace.
        /// This member is required.
        public var idNamespaceName: Swift.String?
        /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
        /// This member is required.
        public var type: EntityResolutionClientTypes.IdNamespaceType?
        /// The timestamp of when the ID namespace was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            idNamespaceArn: Swift.String? = nil,
            idNamespaceName: Swift.String? = nil,
            type: EntityResolutionClientTypes.IdNamespaceType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.idNamespaceArn = idNamespaceArn
            self.idNamespaceName = idNamespaceName
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension EntityResolutionClientTypes {
    public enum IdNamespaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [IdNamespaceType] {
            return [
                .source,
                .target,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .source: return "SOURCE"
            case .target: return "TARGET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdNamespaceType(rawValue: rawValue) ?? IdNamespaceType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.IncrementalRunConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incrementalRunType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incrementalRunType = self.incrementalRunType {
            try encodeContainer.encode(incrementalRunType.rawValue, forKey: .incrementalRunType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incrementalRunTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunType.self, forKey: .incrementalRunType)
        incrementalRunType = incrementalRunTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public struct IncrementalRunConfig {
        /// The type of incremental run. It takes only one value: IMMEDIATE.
        public var incrementalRunType: EntityResolutionClientTypes.IncrementalRunType?

        public init(
            incrementalRunType: EntityResolutionClientTypes.IncrementalRunType? = nil
        )
        {
            self.incrementalRunType = incrementalRunType
        }
    }

}

extension EntityResolutionClientTypes {
    public enum IncrementalRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case sdkUnknown(Swift.String)

        public static var allCases: [IncrementalRunType] {
            return [
                .immediate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IncrementalRunType(rawValue: rawValue) ?? IncrementalRunType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.InputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyNormalization
        case inputSourceARN
        case schemaName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let inputSourceARN = self.inputSourceARN {
            try encodeContainer.encode(inputSourceARN, forKey: .inputSourceARN)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSourceARN)
        inputSourceARN = inputSourceARNDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputSourceARN, SchemaName, and ApplyNormalization.
    public struct InputSource {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// An Glue table ARN for the input source table.
        /// This member is required.
        public var inputSourceARN: Swift.String?
        /// The name of the schema to be retrieved.
        /// This member is required.
        public var schemaName: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            inputSourceARN: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.inputSourceARN = inputSourceARN
            self.schemaName = schemaName
        }
    }

}

extension EntityResolutionClientTypes.IntermediateSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intermediateS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intermediateS3Path = self.intermediateS3Path {
            try encodeContainer.encode(intermediateS3Path, forKey: .intermediateS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intermediateS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateS3Path)
        intermediateS3Path = intermediateS3PathDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
    public struct IntermediateSourceConfiguration {
        /// The Amazon S3 location (bucket and prefix). For example: s3://provider_bucket/DOC-EXAMPLE-BUCKET
        /// This member is required.
        public var intermediateS3Path: Swift.String?

        public init(
            intermediateS3Path: Swift.String? = nil
        )
        {
            self.intermediateS3Path = intermediateS3Path
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when there is an internal failure in the Entity Resolution service. HTTP Status Code: 500
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes.JobMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputRecords
        case matchIDs
        case recordsNotProcessed
        case totalRecordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputRecords = self.inputRecords {
            try encodeContainer.encode(inputRecords, forKey: .inputRecords)
        }
        if let matchIDs = self.matchIDs {
            try encodeContainer.encode(matchIDs, forKey: .matchIDs)
        }
        if let recordsNotProcessed = self.recordsNotProcessed {
            try encodeContainer.encode(recordsNotProcessed, forKey: .recordsNotProcessed)
        }
        if let totalRecordsProcessed = self.totalRecordsProcessed {
            try encodeContainer.encode(totalRecordsProcessed, forKey: .totalRecordsProcessed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRecords)
        inputRecords = inputRecordsDecoded
        let totalRecordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsProcessed)
        totalRecordsProcessed = totalRecordsProcessedDecoded
        let recordsNotProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsNotProcessed)
        recordsNotProcessed = recordsNotProcessedDecoded
        let matchIDsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .matchIDs)
        matchIDs = matchIDsDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing InputRecords, TotalRecordsProcessed, MatchIDs, and RecordsNotProcessed.
    public struct JobMetrics {
        /// The total number of input records.
        public var inputRecords: Swift.Int?
        /// The total number of matchIDs generated.
        public var matchIDs: Swift.Int?
        /// The total number of records that did not get processed.
        public var recordsNotProcessed: Swift.Int?
        /// The total number of records processed.
        public var totalRecordsProcessed: Swift.Int?

        public init(
            inputRecords: Swift.Int? = nil,
            matchIDs: Swift.Int? = nil,
            recordsNotProcessed: Swift.Int? = nil,
            totalRecordsProcessed: Swift.Int? = nil
        )
        {
            self.inputRecords = inputRecords
            self.matchIDs = matchIDs
            self.recordsNotProcessed = recordsNotProcessed
            self.totalRecordsProcessed = totalRecordsProcessed
        }
    }

}

extension EntityResolutionClientTypes.JobOutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case outputS3Path
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing KMSArn, OutputS3Path, and RoleArn.
    public struct JobOutputSource {
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf as part of workflow execution.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            kmsArn: Swift.String? = nil,
            outputS3Path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kmsArn = kmsArn
            self.outputS3Path = outputS3Path
            self.roleArn = roleArn
        }
    }

}

extension EntityResolutionClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case jobId
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing the JobId, Status, StartTime, and EndTime of a job.
    public struct JobSummary {
        /// The time at which the job has finished.
        public var endTime: ClientRuntime.Date?
        /// The ID of the job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The time at which the job was started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The current status of the job.
        /// This member is required.
        public var status: EntityResolutionClientTypes.JobStatus?

        public init(
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: EntityResolutionClientTypes.JobStatus? = nil
        )
        {
            self.endTime = endTime
            self.jobId = jobId
            self.startTime = startTime
            self.status = status
        }
    }

}

extension ListIdMappingJobsInput {

    static func queryItemProvider(_ value: ListIdMappingJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdMappingJobsInput {

    static func urlPathProvider(_ value: ListIdMappingJobsInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct ListIdMappingJobsInput {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

struct ListIdMappingJobsInputBody {
}

extension ListIdMappingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdMappingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdMappingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdMappingJobsOutput {
    /// A list of JobSummary objects.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListIdMappingJobsOutputBody {
    let jobs: [EntityResolutionClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListIdMappingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[EntityResolutionClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [EntityResolutionClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdMappingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdMappingWorkflowsInput {

    static func queryItemProvider(_ value: ListIdMappingWorkflowsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdMappingWorkflowsInput {

    static func urlPathProvider(_ value: ListIdMappingWorkflowsInput) -> Swift.String? {
        return "/idmappingworkflows"
    }
}

public struct ListIdMappingWorkflowsInput {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdMappingWorkflowsInputBody {
}

extension ListIdMappingWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdMappingWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdMappingWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowSummaries = output.workflowSummaries
        } else {
            self.nextToken = nil
            self.workflowSummaries = nil
        }
    }
}

public struct ListIdMappingWorkflowsOutput {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of IdMappingWorkflowSummary objects.
    public var workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

struct ListIdMappingWorkflowsOutputBody {
    let workflowSummaries: [EntityResolutionClientTypes.IdMappingWorkflowSummary]?
    let nextToken: Swift.String?
}

extension ListIdMappingWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowSummary?].self, forKey: .workflowSummaries)
        var workflowSummariesDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowSummary]? = nil
        if let workflowSummariesContainer = workflowSummariesContainer {
            workflowSummariesDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowSummary]()
            for structure0 in workflowSummariesContainer {
                if let structure0 = structure0 {
                    workflowSummariesDecoded0?.append(structure0)
                }
            }
        }
        workflowSummaries = workflowSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdMappingWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdNamespacesInput {

    static func queryItemProvider(_ value: ListIdNamespacesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdNamespacesInput {

    static func urlPathProvider(_ value: ListIdNamespacesInput) -> Swift.String? {
        return "/idnamespaces"
    }
}

public struct ListIdNamespacesInput {
    /// The maximum number of IdNamespace objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdNamespacesInputBody {
}

extension ListIdNamespacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdNamespacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdNamespacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.idNamespaceSummaries = output.idNamespaceSummaries
            self.nextToken = output.nextToken
        } else {
            self.idNamespaceSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdNamespacesOutput {
    /// A list of IdNamespaceSummaries objects.
    public var idNamespaceSummaries: [EntityResolutionClientTypes.IdNamespaceSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        idNamespaceSummaries: [EntityResolutionClientTypes.IdNamespaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.idNamespaceSummaries = idNamespaceSummaries
        self.nextToken = nextToken
    }
}

struct ListIdNamespacesOutputBody {
    let idNamespaceSummaries: [EntityResolutionClientTypes.IdNamespaceSummary]?
    let nextToken: Swift.String?
}

extension ListIdNamespacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idNamespaceSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idNamespaceSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceSummary?].self, forKey: .idNamespaceSummaries)
        var idNamespaceSummariesDecoded0:[EntityResolutionClientTypes.IdNamespaceSummary]? = nil
        if let idNamespaceSummariesContainer = idNamespaceSummariesContainer {
            idNamespaceSummariesDecoded0 = [EntityResolutionClientTypes.IdNamespaceSummary]()
            for structure0 in idNamespaceSummariesContainer {
                if let structure0 = structure0 {
                    idNamespaceSummariesDecoded0?.append(structure0)
                }
            }
        }
        idNamespaceSummaries = idNamespaceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdNamespacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMatchingJobsInput {

    static func queryItemProvider(_ value: ListMatchingJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMatchingJobsInput {

    static func urlPathProvider(_ value: ListMatchingJobsInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct ListMatchingJobsInput {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowName = workflowName
    }
}

struct ListMatchingJobsInputBody {
}

extension ListMatchingJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMatchingJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMatchingJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMatchingJobsOutput {
    /// A list of JobSummary objects, each of which contain the ID, status, start time, and end time of a job.
    public var jobs: [EntityResolutionClientTypes.JobSummary]?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        jobs: [EntityResolutionClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMatchingJobsOutputBody {
    let jobs: [EntityResolutionClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListMatchingJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[EntityResolutionClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [EntityResolutionClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMatchingJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMatchingWorkflowsInput {

    static func queryItemProvider(_ value: ListMatchingWorkflowsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMatchingWorkflowsInput {

    static func urlPathProvider(_ value: ListMatchingWorkflowsInput) -> Swift.String? {
        return "/matchingworkflows"
    }
}

public struct ListMatchingWorkflowsInput {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMatchingWorkflowsInputBody {
}

extension ListMatchingWorkflowsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMatchingWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMatchingWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflowSummaries = output.workflowSummaries
        } else {
            self.nextToken = nil
            self.workflowSummaries = nil
        }
    }
}

public struct ListMatchingWorkflowsOutput {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, and UpdatedAt.
    public var workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflowSummaries = workflowSummaries
    }
}

struct ListMatchingWorkflowsOutputBody {
    let workflowSummaries: [EntityResolutionClientTypes.MatchingWorkflowSummary]?
    let nextToken: Swift.String?
}

extension ListMatchingWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workflowSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.MatchingWorkflowSummary?].self, forKey: .workflowSummaries)
        var workflowSummariesDecoded0:[EntityResolutionClientTypes.MatchingWorkflowSummary]? = nil
        if let workflowSummariesContainer = workflowSummariesContainer {
            workflowSummariesDecoded0 = [EntityResolutionClientTypes.MatchingWorkflowSummary]()
            for structure0 in workflowSummariesContainer {
                if let structure0 = structure0 {
                    workflowSummariesDecoded0?.append(structure0)
                }
            }
        }
        workflowSummaries = workflowSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMatchingWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProviderServicesInput {

    static func queryItemProvider(_ value: ListProviderServicesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let providerName = value.providerName {
            let providerNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "providerName".urlPercentEncoding(), value: Swift.String(providerName).urlPercentEncoding())
            items.append(providerNameQueryItem)
        }
        return items
    }
}

extension ListProviderServicesInput {

    static func urlPathProvider(_ value: ListProviderServicesInput) -> Swift.String? {
        return "/providerservices"
    }
}

public struct ListProviderServicesInput {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// The name of the provider. This name is typically the company name.
    public var providerName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.providerName = providerName
    }
}

struct ListProviderServicesInputBody {
}

extension ListProviderServicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProviderServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProviderServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.providerServiceSummaries = output.providerServiceSummaries
        } else {
            self.nextToken = nil
            self.providerServiceSummaries = nil
        }
    }
}

public struct ListProviderServicesOutput {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of ProviderServices objects.
    public var providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.providerServiceSummaries = providerServiceSummaries
    }
}

struct ListProviderServicesOutputBody {
    let providerServiceSummaries: [EntityResolutionClientTypes.ProviderServiceSummary]?
    let nextToken: Swift.String?
}

extension ListProviderServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case providerServiceSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceSummariesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.ProviderServiceSummary?].self, forKey: .providerServiceSummaries)
        var providerServiceSummariesDecoded0:[EntityResolutionClientTypes.ProviderServiceSummary]? = nil
        if let providerServiceSummariesContainer = providerServiceSummariesContainer {
            providerServiceSummariesDecoded0 = [EntityResolutionClientTypes.ProviderServiceSummary]()
            for structure0 in providerServiceSummariesContainer {
                if let structure0 = structure0 {
                    providerServiceSummariesDecoded0?.append(structure0)
                }
            }
        }
        providerServiceSummaries = providerServiceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProviderServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemaMappingsInput {

    static func queryItemProvider(_ value: ListSchemaMappingsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSchemaMappingsInput {

    static func urlPathProvider(_ value: ListSchemaMappingsInput) -> Swift.String? {
        return "/schemas"
    }
}

public struct ListSchemaMappingsInput {
    /// The maximum number of objects returned per page.
    public var maxResults: Swift.Int?
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemaMappingsInputBody {
}

extension ListSchemaMappingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemaMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemaMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaList = output.schemaList
        } else {
            self.nextToken = nil
            self.schemaList = nil
        }
    }
}

public struct ListSchemaMappingsOutput {
    /// The pagination token from the previous API call.
    public var nextToken: Swift.String?
    /// A list of SchemaMappingSummary objects, each of which contain the fields SchemaName, SchemaArn, CreatedAt, UpdatedAt.
    public var schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaList = schemaList
    }
}

struct ListSchemaMappingsOutputBody {
    let schemaList: [EntityResolutionClientTypes.SchemaMappingSummary]?
    let nextToken: Swift.String?
}

extension ListSchemaMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemaList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaListContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaMappingSummary?].self, forKey: .schemaList)
        var schemaListDecoded0:[EntityResolutionClientTypes.SchemaMappingSummary]? = nil
        if let schemaListContainer = schemaListContainer {
            schemaListDecoded0 = [EntityResolutionClientTypes.SchemaMappingSummary]()
            for structure0 in schemaListContainer {
                if let structure0 = structure0 {
                    schemaListDecoded0?.append(structure0)
                }
            }
        }
        schemaList = schemaListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemaMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.MatchingWorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case resolutionType
        case updatedAt
        case workflowArn
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let resolutionType = self.resolutionType {
            try encodeContainer.encode(resolutionType.rawValue, forKey: .resolutionType)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workflowArn = self.workflowArn {
            try encodeContainer.encode(workflowArn, forKey: .workflowArn)
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let resolutionTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionType.self, forKey: .resolutionType)
        resolutionType = resolutionTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of MatchingWorkflowSummary objects, each of which contain the fields WorkflowName, WorkflowArn, CreatedAt, UpdatedAt.
    public struct MatchingWorkflowSummary {
        /// The timestamp of when the workflow was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The method that has been specified for data matching, either using matching provided by Entity Resolution or through a provider service.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// The timestamp of when the workflow was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the MatchingWorkflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workflowArn: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.resolutionType = resolutionType
            self.updatedAt = updatedAt
            self.workflowArn = workflowArn
            self.workflowName = workflowName
        }
    }

}

extension EntityResolutionClientTypes.NamespaceProviderProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providerConfiguration
        case providerServiceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerConfiguration = self.providerConfiguration {
            try encodeContainer.encode(providerConfiguration, forKey: .providerConfiguration)
        }
        if let providerServiceArn = self.providerServiceArn {
            try encodeContainer.encode(providerServiceArn, forKey: .providerServiceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerConfigurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerConfiguration)
        providerConfiguration = providerConfigurationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing ProviderConfiguration and ProviderServiceArn.
    public struct NamespaceProviderProperties {
        /// An object which defines any additional configurations required by the provider service.
        public var providerConfiguration: ClientRuntime.Document?
        /// The Amazon Resource Name (ARN) of the provider service.
        /// This member is required.
        public var providerServiceArn: Swift.String?

        public init(
            providerConfiguration: ClientRuntime.Document? = nil,
            providerServiceArn: Swift.String? = nil
        )
        {
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }
    }

}

extension EntityResolutionClientTypes.OutputAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashed
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashed = self.hashed {
            try encodeContainer.encode(hashed, forKey: .hashed)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hashedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hashed)
        hashed = hashedDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputAttribute {
        /// Enables the ability to hash the column values in the output.
        public var hashed: Swift.Bool?
        /// A name of a column to be written to the output. This must be an InputField name in the schema mapping.
        /// This member is required.
        public var name: Swift.String?

        public init(
            hashed: Swift.Bool? = nil,
            name: Swift.String? = nil
        )
        {
            self.hashed = hashed
            self.name = name
        }
    }

}

extension EntityResolutionClientTypes.OutputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsArn = "KMSArn"
        case applyNormalization
        case output
        case outputS3Path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let applyNormalization = self.applyNormalization {
            try encodeContainer.encode(applyNormalization, forKey: .applyNormalization)
        }
        if let output = output {
            var outputContainer = encodeContainer.nestedUnkeyedContainer(forKey: .output)
            for outputattribute0 in output {
                try outputContainer.encode(outputattribute0)
            }
        }
        if let outputS3Path = self.outputS3Path {
            try encodeContainer.encode(outputS3Path, forKey: .outputS3Path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Path)
        outputS3Path = outputS3PathDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let outputContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputAttribute?].self, forKey: .output)
        var outputDecoded0:[EntityResolutionClientTypes.OutputAttribute]? = nil
        if let outputContainer = outputContainer {
            outputDecoded0 = [EntityResolutionClientTypes.OutputAttribute]()
            for structure0 in outputContainer {
                if let structure0 = structure0 {
                    outputDecoded0?.append(structure0)
                }
            }
        }
        output = outputDecoded0
        let applyNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyNormalization)
        applyNormalization = applyNormalizationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
    public struct OutputSource {
        /// Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an AttributeType of PHONE_NUMBER, and the data in the input table is in a format of 1234567890, Entity Resolution will normalize this field in the output to (123)-456-7890.
        public var applyNormalization: Swift.Bool?
        /// Customer KMS ARN for encryption at rest. If not provided, system will use an Entity Resolution managed KMS key.
        public var kmsArn: Swift.String?
        /// A list of OutputAttribute objects, each of which have the fields Name and Hashed. Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        /// This member is required.
        public var output: [EntityResolutionClientTypes.OutputAttribute]?
        /// The S3 path to which Entity Resolution will write the output table.
        /// This member is required.
        public var outputS3Path: Swift.String?

        public init(
            applyNormalization: Swift.Bool? = nil,
            kmsArn: Swift.String? = nil,
            output: [EntityResolutionClientTypes.OutputAttribute]? = nil,
            outputS3Path: Swift.String? = nil
        )
        {
            self.applyNormalization = applyNormalization
            self.kmsArn = kmsArn
            self.output = output
            self.outputS3Path = outputS3Path
        }
    }

}

extension EntityResolutionClientTypes.ProviderComponentSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providerSchemaAttributes
        case schemas
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerSchemaAttributes = providerSchemaAttributes {
            var providerSchemaAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerSchemaAttributes)
            for providerschemaattribute0 in providerSchemaAttributes {
                try providerSchemaAttributesContainer.encode(providerschemaattribute0)
            }
        }
        if let schemas = schemas {
            var schemasContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemas)
            for schemalist0 in schemas {
                var schemalist0Container = schemasContainer.nestedUnkeyedContainer()
                for string1 in schemalist0 {
                    try schemalist0Container.encode(string1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .schemas)
        var schemasDecoded0:[[Swift.String]]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [[Swift.String]]()
            for list0 in schemasContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    schemasDecoded0?.append(list0Decoded0)
                }
            }
        }
        schemas = schemasDecoded0
        let providerSchemaAttributesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.ProviderSchemaAttribute?].self, forKey: .providerSchemaAttributes)
        var providerSchemaAttributesDecoded0:[EntityResolutionClientTypes.ProviderSchemaAttribute]? = nil
        if let providerSchemaAttributesContainer = providerSchemaAttributesContainer {
            providerSchemaAttributesDecoded0 = [EntityResolutionClientTypes.ProviderSchemaAttribute]()
            for structure0 in providerSchemaAttributesContainer {
                if let structure0 = structure0 {
                    providerSchemaAttributesDecoded0?.append(structure0)
                }
            }
        }
        providerSchemaAttributes = providerSchemaAttributesDecoded0
    }
}

extension EntityResolutionClientTypes {
    /// The input schema supported by provider service.
    public struct ProviderComponentSchema {
        /// The provider schema attributes.
        public var providerSchemaAttributes: [EntityResolutionClientTypes.ProviderSchemaAttribute]?
        /// Input schema for the provider service.
        public var schemas: [[Swift.String]]?

        public init(
            providerSchemaAttributes: [EntityResolutionClientTypes.ProviderSchemaAttribute]? = nil,
            schemas: [[Swift.String]]? = nil
        )
        {
            self.providerSchemaAttributes = providerSchemaAttributes
            self.schemas = schemas
        }
    }

}

extension EntityResolutionClientTypes.ProviderEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marketplaceconfiguration = "marketplaceConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .marketplaceconfiguration(marketplaceconfiguration):
                try container.encode(marketplaceconfiguration, forKey: .marketplaceconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let marketplaceconfigurationDecoded = try values.decodeIfPresent(EntityResolutionClientTypes.ProviderMarketplaceConfiguration.self, forKey: .marketplaceconfiguration)
        if let marketplaceconfiguration = marketplaceconfigurationDecoded {
            self = .marketplaceconfiguration(marketplaceconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EntityResolutionClientTypes {
    /// The required configuration fields to use with the provider service.
    public enum ProviderEndpointConfiguration {
        /// The identifiers of the provider service, from Data Exchange.
        case marketplaceconfiguration(EntityResolutionClientTypes.ProviderMarketplaceConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension EntityResolutionClientTypes.ProviderIdNameSpaceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case providerSourceConfigurationDefinition
        case providerTargetConfigurationDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let providerSourceConfigurationDefinition = self.providerSourceConfigurationDefinition {
            try encodeContainer.encode(providerSourceConfigurationDefinition, forKey: .providerSourceConfigurationDefinition)
        }
        if let providerTargetConfigurationDefinition = self.providerTargetConfigurationDefinition {
            try encodeContainer.encode(providerTargetConfigurationDefinition, forKey: .providerTargetConfigurationDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerTargetConfigurationDefinitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerTargetConfigurationDefinition)
        providerTargetConfigurationDefinition = providerTargetConfigurationDefinitionDecoded
        let providerSourceConfigurationDefinitionDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerSourceConfigurationDefinition)
        providerSourceConfigurationDefinition = providerSourceConfigurationDefinitionDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The provider configuration required for different ID namespace types.
    public struct ProviderIdNameSpaceConfiguration {
        /// The description of the ID namespace.
        public var description: Swift.String?
        /// Configurations required for the source ID namespace.
        public var providerSourceConfigurationDefinition: ClientRuntime.Document?
        /// Configurations required for the target ID namespace.
        public var providerTargetConfigurationDefinition: ClientRuntime.Document?

        public init(
            description: Swift.String? = nil,
            providerSourceConfigurationDefinition: ClientRuntime.Document? = nil,
            providerTargetConfigurationDefinition: ClientRuntime.Document? = nil
        )
        {
            self.description = description
            self.providerSourceConfigurationDefinition = providerSourceConfigurationDefinition
            self.providerTargetConfigurationDefinition = providerTargetConfigurationDefinition
        }
    }

}

extension EntityResolutionClientTypes.ProviderIntermediateDataAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountIds
        case requiredBucketActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountIds = awsAccountIds {
            var awsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountIds)
            for awsaccountid0 in awsAccountIds {
                try awsAccountIdsContainer.encode(awsaccountid0)
            }
        }
        if let requiredBucketActions = requiredBucketActions {
            var requiredBucketActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredBucketActions)
            for string0 in requiredBucketActions {
                try requiredBucketActionsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsAccountIds)
        var awsAccountIdsDecoded0:[Swift.String]? = nil
        if let awsAccountIdsContainer = awsAccountIdsContainer {
            awsAccountIdsDecoded0 = [Swift.String]()
            for string0 in awsAccountIdsContainer {
                if let string0 = string0 {
                    awsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        awsAccountIds = awsAccountIdsDecoded0
        let requiredBucketActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredBucketActions)
        var requiredBucketActionsDecoded0:[Swift.String]? = nil
        if let requiredBucketActionsContainer = requiredBucketActionsContainer {
            requiredBucketActionsDecoded0 = [Swift.String]()
            for string0 in requiredBucketActionsContainer {
                if let string0 = string0 {
                    requiredBucketActionsDecoded0?.append(string0)
                }
            }
        }
        requiredBucketActions = requiredBucketActionsDecoded0
    }
}

extension EntityResolutionClientTypes {
    /// The required configuration fields to give intermediate access to a provider service.
    public struct ProviderIntermediateDataAccessConfiguration {
        /// The Amazon Web Services account that provider can use to read or write data into the customer's intermediate S3 bucket.
        public var awsAccountIds: [Swift.String]?
        /// The S3 bucket actions that the provider requires permission for.
        public var requiredBucketActions: [Swift.String]?

        public init(
            awsAccountIds: [Swift.String]? = nil,
            requiredBucketActions: [Swift.String]? = nil
        )
        {
            self.awsAccountIds = awsAccountIds
            self.requiredBucketActions = requiredBucketActions
        }
    }

}

extension EntityResolutionClientTypes.ProviderMarketplaceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case dataSetId
        case listingId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let listingId = self.listingId {
            try encodeContainer.encode(listingId, forKey: .listingId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let listingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listingId)
        listingId = listingIdDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The identifiers of the provider service, from Data Exchange.
    public struct ProviderMarketplaceConfiguration {
        /// The asset ID on Data Exchange.
        /// This member is required.
        public var assetId: Swift.String?
        /// The dataset ID on Data Exchange.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The listing ID on Data Exchange.
        /// This member is required.
        public var listingId: Swift.String?
        /// The revision ID on Data Exchange.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            listingId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.listingId = listingId
            self.revisionId = revisionId
        }
    }

}

extension EntityResolutionClientTypes.ProviderProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intermediateSourceConfiguration
        case providerConfiguration
        case providerServiceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intermediateSourceConfiguration = self.intermediateSourceConfiguration {
            try encodeContainer.encode(intermediateSourceConfiguration, forKey: .intermediateSourceConfiguration)
        }
        if let providerConfiguration = self.providerConfiguration {
            try encodeContainer.encode(providerConfiguration, forKey: .providerConfiguration)
        }
        if let providerServiceArn = self.providerServiceArn {
            try encodeContainer.encode(providerServiceArn, forKey: .providerServiceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerConfigurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .providerConfiguration)
        providerConfiguration = providerConfigurationDecoded
        let intermediateSourceConfigurationDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IntermediateSourceConfiguration.self, forKey: .intermediateSourceConfiguration)
        intermediateSourceConfiguration = intermediateSourceConfigurationDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing the providerServiceARN, intermediateSourceConfiguration, and providerConfiguration.
    public struct ProviderProperties {
        /// The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        public var intermediateSourceConfiguration: EntityResolutionClientTypes.IntermediateSourceConfiguration?
        /// The required configuration fields to use with the provider service.
        public var providerConfiguration: ClientRuntime.Document?
        /// The ARN of the provider service.
        /// This member is required.
        public var providerServiceArn: Swift.String?

        public init(
            intermediateSourceConfiguration: EntityResolutionClientTypes.IntermediateSourceConfiguration? = nil,
            providerConfiguration: ClientRuntime.Document? = nil,
            providerServiceArn: Swift.String? = nil
        )
        {
            self.intermediateSourceConfiguration = intermediateSourceConfiguration
            self.providerConfiguration = providerConfiguration
            self.providerServiceArn = providerServiceArn
        }
    }

}

extension EntityResolutionClientTypes.ProviderSchemaAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case hashing
        case subType
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let hashing = self.hashing {
            try encodeContainer.encode(hashing, forKey: .hashing)
        }
        if let subType = self.subType {
            try encodeContainer.encode(subType, forKey: .subType)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.SchemaAttributeType.self, forKey: .type)
        type = typeDecoded
        let subTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subType)
        subType = subTypeDecoded
        let hashingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hashing)
        hashing = hashingDecoded
    }
}

extension EntityResolutionClientTypes {
    /// The provider schema attribute.
    public struct ProviderSchemaAttribute {
        /// The field name.
        /// This member is required.
        public var fieldName: Swift.String?
        /// The hashing attribute of the provider schema.
        public var hashing: Swift.Bool?
        /// The sub type of the provider schema attribute.
        public var subType: Swift.String?
        /// The type of the provider schema attribute.
        /// This member is required.
        public var type: EntityResolutionClientTypes.SchemaAttributeType?

        public init(
            fieldName: Swift.String? = nil,
            hashing: Swift.Bool? = nil,
            subType: Swift.String? = nil,
            type: EntityResolutionClientTypes.SchemaAttributeType? = nil
        )
        {
            self.fieldName = fieldName
            self.hashing = hashing
            self.subType = subType
            self.type = type
        }
    }

}

extension EntityResolutionClientTypes.ProviderServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providerName
        case providerServiceArn
        case providerServiceDisplayName
        case providerServiceName
        case providerServiceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let providerServiceArn = self.providerServiceArn {
            try encodeContainer.encode(providerServiceArn, forKey: .providerServiceArn)
        }
        if let providerServiceDisplayName = self.providerServiceDisplayName {
            try encodeContainer.encode(providerServiceDisplayName, forKey: .providerServiceDisplayName)
        }
        if let providerServiceName = self.providerServiceName {
            try encodeContainer.encode(providerServiceName, forKey: .providerServiceName)
        }
        if let providerServiceType = self.providerServiceType {
            try encodeContainer.encode(providerServiceType.rawValue, forKey: .providerServiceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerServiceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceArn)
        providerServiceArn = providerServiceArnDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerServiceDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceDisplayName)
        providerServiceDisplayName = providerServiceDisplayNameDecoded
        let providerServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerServiceName)
        providerServiceName = providerServiceNameDecoded
        let providerServiceTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ServiceType.self, forKey: .providerServiceType)
        providerServiceType = providerServiceTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// A list of ProviderService objects, each of which contain the fields providerName, providerServiceArn, providerServiceName, and providerServiceType.
    public struct ProviderServiceSummary {
        /// The name of the provider. This name is typically the company name.
        /// This member is required.
        public var providerName: Swift.String?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the providerService.
        /// This member is required.
        public var providerServiceArn: Swift.String?
        /// The display name of the provider service.
        /// This member is required.
        public var providerServiceDisplayName: Swift.String?
        /// The name of the product that the provider service provides.
        /// This member is required.
        public var providerServiceName: Swift.String?
        /// The type of provider service.
        /// This member is required.
        public var providerServiceType: EntityResolutionClientTypes.ServiceType?

        public init(
            providerName: Swift.String? = nil,
            providerServiceArn: Swift.String? = nil,
            providerServiceDisplayName: Swift.String? = nil,
            providerServiceName: Swift.String? = nil,
            providerServiceType: EntityResolutionClientTypes.ServiceType? = nil
        )
        {
            self.providerName = providerName
            self.providerServiceArn = providerServiceArn
            self.providerServiceDisplayName = providerServiceDisplayName
            self.providerServiceName = providerServiceName
            self.providerServiceType = providerServiceType
        }
    }

}

extension PutPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

extension PutPolicyInput {

    static func urlPathProvider(_ value: PutPolicyInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/policies/\(arn.urlPercentEncoding())"
    }
}

public struct PutPolicyInput {
    /// The Amazon Resource Name (ARN) of the resource for which the policy needs to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

struct PutPolicyInputBody {
    let token: Swift.String?
    let policy: Swift.String?
}

extension PutPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case token
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.policy = output.policy
            self.token = output.token
        } else {
            self.arn = nil
            self.policy = nil
            self.token = nil
        }
    }
}

public struct PutPolicyOutput {
    /// The Entity Resolution resource ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    /// This member is required.
    public var token: Swift.String?

    public init(
        arn: Swift.String? = nil,
        policy: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.arn = arn
        self.policy = policy
        self.token = token
    }
}

struct PutPolicyOutputBody {
    let arn: Swift.String?
    let token: Swift.String?
    let policy: Swift.String?
}

extension PutPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case policy
        case token
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum PutPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes.ResolutionTechniques: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case providerProperties
        case resolutionType
        case ruleBasedProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerProperties = self.providerProperties {
            try encodeContainer.encode(providerProperties, forKey: .providerProperties)
        }
        if let resolutionType = self.resolutionType {
            try encodeContainer.encode(resolutionType.rawValue, forKey: .resolutionType)
        }
        if let ruleBasedProperties = self.ruleBasedProperties {
            try encodeContainer.encode(ruleBasedProperties, forKey: .ruleBasedProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionTypeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionType.self, forKey: .resolutionType)
        resolutionType = resolutionTypeDecoded
        let ruleBasedPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.RuleBasedProperties.self, forKey: .ruleBasedProperties)
        ruleBasedProperties = ruleBasedPropertiesDecoded
        let providerPropertiesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ProviderProperties.self, forKey: .providerProperties)
        providerProperties = providerPropertiesDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the resolutionType and the ruleBasedProperties.
    public struct ResolutionTechniques {
        /// The properties of the provider service.
        public var providerProperties: EntityResolutionClientTypes.ProviderProperties?
        /// The type of matching. There are three types of matching: RULE_MATCHING, ML_MATCHING, and PROVIDER.
        /// This member is required.
        public var resolutionType: EntityResolutionClientTypes.ResolutionType?
        /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
        public var ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties?

        public init(
            providerProperties: EntityResolutionClientTypes.ProviderProperties? = nil,
            resolutionType: EntityResolutionClientTypes.ResolutionType? = nil,
            ruleBasedProperties: EntityResolutionClientTypes.RuleBasedProperties? = nil
        )
        {
            self.providerProperties = providerProperties
            self.resolutionType = resolutionType
            self.ruleBasedProperties = ruleBasedProperties
        }
    }

}

extension EntityResolutionClientTypes {
    public enum ResolutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mlMatching
        case provider
        case ruleMatching
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionType] {
            return [
                .mlMatching,
                .provider,
                .ruleMatching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mlMatching: return "ML_MATCHING"
            case .provider: return "PROVIDER"
            case .ruleMatching: return "RULE_MATCHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionType(rawValue: rawValue) ?? ResolutionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found. HTTP Status Code: 404
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityResolutionClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchingKeys
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchingKeys = matchingKeys {
            var matchingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingKeys)
            for attributename0 in matchingKeys {
                try matchingKeysContainer.encode(attributename0)
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let matchingKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchingKeys)
        var matchingKeysDecoded0:[Swift.String]? = nil
        if let matchingKeysContainer = matchingKeysContainer {
            matchingKeysDecoded0 = [Swift.String]()
            for string0 in matchingKeysContainer {
                if let string0 = string0 {
                    matchingKeysDecoded0?.append(string0)
                }
            }
        }
        matchingKeys = matchingKeysDecoded0
    }
}

extension EntityResolutionClientTypes {
    /// An object containing RuleName, and MatchingKeys.
    public struct Rule {
        /// A list of MatchingKeys. The MatchingKeys must have been defined in the SchemaMapping. Two records are considered to match according to this rule if all of the MatchingKeys match.
        /// This member is required.
        public var matchingKeys: [Swift.String]?
        /// A name for the matching rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            matchingKeys: [Swift.String]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.matchingKeys = matchingKeys
            self.ruleName = ruleName
        }
    }

}

extension EntityResolutionClientTypes.RuleBasedProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeMatchingModel
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeMatchingModel = self.attributeMatchingModel {
            try encodeContainer.encode(attributeMatchingModel.rawValue, forKey: .attributeMatchingModel)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[EntityResolutionClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [EntityResolutionClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let attributeMatchingModelDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.AttributeMatchingModel.self, forKey: .attributeMatchingModel)
        attributeMatchingModel = attributeMatchingModelDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object which defines the list of matching rules to run and has a field Rules, which is a list of rule objects.
    public struct RuleBasedProperties {
        /// The comparison type. You can either choose ONE_TO_ONE or MANY_TO_MANY as the AttributeMatchingModel. When choosing MANY_TO_MANY, the system can match attributes across the sub-types of an attribute type. For example, if the value of the Email field of Profile A and the value of BusinessEmail field of Profile B matches, the two profiles are matched on the Email type. When choosing ONE_TO_ONE ,the system can only match if the sub-types are exact matches. For example, only when the value of the Email field of Profile A and the value of the Email field of Profile B matches, the two profiles are matched on the Email type.
        /// This member is required.
        public var attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel?
        /// A list of Rule objects, each of which have fields RuleName and MatchingKeys.
        /// This member is required.
        public var rules: [EntityResolutionClientTypes.Rule]?

        public init(
            attributeMatchingModel: EntityResolutionClientTypes.AttributeMatchingModel? = nil,
            rules: [EntityResolutionClientTypes.Rule]? = nil
        )
        {
            self.attributeMatchingModel = attributeMatchingModel
            self.rules = rules
        }
    }

}

extension EntityResolutionClientTypes {
    public enum SchemaAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case addressCity
        case addressCountry
        case addressPostalcode
        case addressState
        case addressStreet1
        case addressStreet2
        case addressStreet3
        case date
        case emailAddress
        case name
        case nameFirst
        case nameLast
        case nameMiddle
        case phone
        case phoneCountrycode
        case phoneNumber
        case providerId
        case string
        case uniqueId
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaAttributeType] {
            return [
                .address,
                .addressCity,
                .addressCountry,
                .addressPostalcode,
                .addressState,
                .addressStreet1,
                .addressStreet2,
                .addressStreet3,
                .date,
                .emailAddress,
                .name,
                .nameFirst,
                .nameLast,
                .nameMiddle,
                .phone,
                .phoneCountrycode,
                .phoneNumber,
                .providerId,
                .string,
                .uniqueId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .addressCity: return "ADDRESS_CITY"
            case .addressCountry: return "ADDRESS_COUNTRY"
            case .addressPostalcode: return "ADDRESS_POSTALCODE"
            case .addressState: return "ADDRESS_STATE"
            case .addressStreet1: return "ADDRESS_STREET1"
            case .addressStreet2: return "ADDRESS_STREET2"
            case .addressStreet3: return "ADDRESS_STREET3"
            case .date: return "DATE"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .name: return "NAME"
            case .nameFirst: return "NAME_FIRST"
            case .nameLast: return "NAME_LAST"
            case .nameMiddle: return "NAME_MIDDLE"
            case .phone: return "PHONE"
            case .phoneCountrycode: return "PHONE_COUNTRYCODE"
            case .phoneNumber: return "PHONE_NUMBER"
            case .providerId: return "PROVIDER_ID"
            case .string: return "STRING"
            case .uniqueId: return "UNIQUE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaAttributeType(rawValue: rawValue) ?? SchemaAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension EntityResolutionClientTypes.SchemaInputAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case groupName
        case matchKey
        case subType
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let matchKey = self.matchKey {
            try encodeContainer.encode(matchKey, forKey: .matchKey)
        }
        if let subType = self.subType {
            try encodeContainer.encode(subType, forKey: .subType)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.SchemaAttributeType.self, forKey: .type)
        type = typeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let matchKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchKey)
        matchKey = matchKeyDecoded
        let subTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subType)
        subType = subTypeDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing FieldName, Type, GroupName, MatchKey, and SubType.
    public struct SchemaInputAttribute {
        /// A string containing the field name.
        /// This member is required.
        public var fieldName: Swift.String?
        /// A string that instructs Entity Resolution to combine several columns into a unified column with the identical attribute type. For example, when working with columns such as first_name, middle_name, and last_name, assigning them a common groupName will prompt Entity Resolution to concatenate them into a single value.
        public var groupName: Swift.String?
        /// A key that allows grouping of multiple input attributes into a unified matching group. For example, consider a scenario where the source table contains various addresses, such as business_address and shipping_address. By assigning a matchKey called address to both attributes, Entity Resolution will match records across these fields to create a consolidated matching group. If no matchKey is specified for a column, it won't be utilized for matching purposes but will still be included in the output table.
        public var matchKey: Swift.String?
        /// The subtype of the attribute, selected from a list of values.
        public var subType: Swift.String?
        /// The type of the attribute, selected from a list of values.
        /// This member is required.
        public var type: EntityResolutionClientTypes.SchemaAttributeType?

        public init(
            fieldName: Swift.String? = nil,
            groupName: Swift.String? = nil,
            matchKey: Swift.String? = nil,
            subType: Swift.String? = nil,
            type: EntityResolutionClientTypes.SchemaAttributeType? = nil
        )
        {
            self.fieldName = fieldName
            self.groupName = groupName
            self.matchKey = matchKey
            self.subType = subType
            self.type = type
        }
    }

}

extension EntityResolutionClientTypes.SchemaMappingSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case hasWorkflows
        case schemaArn
        case schemaName
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let hasWorkflows = self.hasWorkflows {
            try encodeContainer.encode(hasWorkflows, forKey: .hasWorkflows)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let hasWorkflowsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasWorkflows)
        hasWorkflows = hasWorkflowsDecoded
    }
}

extension EntityResolutionClientTypes {
    /// An object containing SchemaName, SchemaArn, CreatedAt, andUpdatedAt.
    public struct SchemaMappingSummary {
        /// The timestamp of when the SchemaMapping was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Specifies whether the schema mapping has been applied to a workflow.
        /// This member is required.
        public var hasWorkflows: Swift.Bool?
        /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The name of the schema.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The timestamp of when the SchemaMapping was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            hasWorkflows: Swift.Bool? = nil,
            schemaArn: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.hasWorkflows = hasWorkflows
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.updatedAt = updatedAt
        }
    }

}

extension EntityResolutionClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assignment
        case idMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .assignment,
                .idMapping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assignment: return "ASSIGNMENT"
            case .idMapping: return "ID_MAPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension StartIdMappingJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputSourceConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for idmappingjoboutputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(idmappingjoboutputsource0)
            }
        }
    }
}

extension StartIdMappingJobInput {

    static func urlPathProvider(_ value: StartIdMappingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct StartIdMappingJobInput {
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
    /// The name of the ID mapping job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.outputSourceConfig = outputSourceConfig
        self.workflowName = workflowName
    }
}

struct StartIdMappingJobInputBody {
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
}

extension StartIdMappingJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputSourceConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingJobOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingJobOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
    }
}

extension StartIdMappingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartIdMappingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.outputSourceConfig = output.outputSourceConfig
        } else {
            self.jobId = nil
            self.outputSourceConfig = nil
        }
    }
}

public struct StartIdMappingJobOutput {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// A list of OutputSource objects.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?

    public init(
        jobId: Swift.String? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil
    )
    {
        self.jobId = jobId
        self.outputSourceConfig = outputSourceConfig
    }
}

struct StartIdMappingJobOutputBody {
    let jobId: Swift.String?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingJobOutputSource]?
}

extension StartIdMappingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case outputSourceConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingJobOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingJobOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingJobOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
    }
}

enum StartIdMappingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMatchingJobInput {

    static func urlPathProvider(_ value: StartMatchingJobInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())/jobs"
    }
}

public struct StartMatchingJobInput {
    /// The name of the matching job to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        workflowName: Swift.String? = nil
    )
    {
        self.workflowName = workflowName
    }
}

struct StartMatchingJobInputBody {
}

extension StartMatchingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartMatchingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMatchingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMatchingJobOutput {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMatchingJobOutputBody {
    let jobId: Swift.String?
}

extension StartMatchingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartMatchingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExceedsLimitException": return try await ExceedsLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityResolutionClientTypes {
    public enum StatementEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "Allow"
            case .deny: return "Deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatementEffect(rawValue: rawValue) ?? StatementEffect.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// The ARN of the resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling. HTTP Status Code: 429
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource for which you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdMappingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idMappingTechniques = self.idMappingTechniques {
            try encodeContainer.encode(idMappingTechniques, forKey: .idMappingTechniques)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for idmappingworkflowinputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(idmappingworkflowinputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for idmappingworkflowoutputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(idmappingworkflowoutputsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateIdMappingWorkflowInput {

    static func urlPathProvider(_ value: UpdateIdMappingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/idmappingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct UpdateIdMappingWorkflowInput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateIdMappingWorkflowInputBody {
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
}

extension UpdateIdMappingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateIdMappingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdMappingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.idMappingTechniques = output.idMappingTechniques
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.roleArn = output.roleArn
            self.workflowArn = output.workflowArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.idMappingTechniques = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.roleArn = nil
            self.workflowArn = nil
            self.workflowName = nil
        }
    }
}

public struct UpdateIdMappingWorkflowOutput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines the idMappingType and the providerProperties.
    /// This member is required.
    public var idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path and KMSArn.
    public var outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow role. Entity Resolution assumes this role to access Amazon Web Services resources on your behalf.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil,
        roleArn: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTechniques = idMappingTechniques
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.roleArn = roleArn
        self.workflowArn = workflowArn
        self.workflowName = workflowName
    }
}

struct UpdateIdMappingWorkflowOutputBody {
    let workflowName: Swift.String?
    let workflowArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowInputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]?
    let idMappingTechniques: EntityResolutionClientTypes.IdMappingTechniques?
    let roleArn: Swift.String?
}

extension UpdateIdMappingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingTechniques
        case inputSourceConfig
        case outputSourceConfig
        case roleArn
        case workflowArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let workflowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowArn)
        workflowArn = workflowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdMappingWorkflowOutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.IdMappingWorkflowOutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdMappingWorkflowOutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let idMappingTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdMappingTechniques.self, forKey: .idMappingTechniques)
        idMappingTechniques = idMappingTechniquesDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum UpdateIdMappingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIdNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingWorkflowProperties
        case inputSourceConfig
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idMappingWorkflowProperties = idMappingWorkflowProperties {
            var idMappingWorkflowPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idMappingWorkflowProperties)
            for idnamespaceidmappingworkflowproperties0 in idMappingWorkflowProperties {
                try idMappingWorkflowPropertiesContainer.encode(idnamespaceidmappingworkflowproperties0)
            }
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for idnamespaceinputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(idnamespaceinputsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateIdNamespaceInput {

    static func urlPathProvider(_ value: UpdateIdNamespaceInput) -> Swift.String? {
        guard let idNamespaceName = value.idNamespaceName else {
            return nil
        }
        return "/idnamespaces/\(idNamespaceName.urlPercentEncoding())"
    }
}

public struct UpdateIdNamespaceInput {
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    public var roleArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
    }
}

struct UpdateIdNamespaceInputBody {
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    let idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    let roleArn: Swift.String?
}

extension UpdateIdNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case idMappingWorkflowProperties
        case inputSourceConfig
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdNamespaceInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdNamespaceInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let idMappingWorkflowPropertiesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties?].self, forKey: .idMappingWorkflowProperties)
        var idMappingWorkflowPropertiesDecoded0:[EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil
        if let idMappingWorkflowPropertiesContainer = idMappingWorkflowPropertiesContainer {
            idMappingWorkflowPropertiesDecoded0 = [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]()
            for structure0 in idMappingWorkflowPropertiesContainer {
                if let structure0 = structure0 {
                    idMappingWorkflowPropertiesDecoded0?.append(structure0)
                }
            }
        }
        idMappingWorkflowProperties = idMappingWorkflowPropertiesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateIdNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.description = output.description
            self.idMappingWorkflowProperties = output.idMappingWorkflowProperties
            self.idNamespaceArn = output.idNamespaceArn
            self.idNamespaceName = output.idNamespaceName
            self.inputSourceConfig = output.inputSourceConfig
            self.roleArn = output.roleArn
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.description = nil
            self.idMappingWorkflowProperties = nil
            self.idNamespaceArn = nil
            self.idNamespaceName = nil
            self.inputSourceConfig = nil
            self.roleArn = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateIdNamespaceOutput {
    /// The timestamp of when the ID namespace was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description of the ID namespace.
    public var description: Swift.String?
    /// Determines the properties of IdMappingWorkflow where this IdNamespace can be used as a Source or a Target.
    public var idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    /// The Amazon Resource Name (ARN) of the ID namespace.
    /// This member is required.
    public var idNamespaceArn: Swift.String?
    /// The name of the ID namespace.
    /// This member is required.
    public var idNamespaceName: Swift.String?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    public var inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to access the resources defined in this IdNamespace on your behalf as part of a workflow run.
    public var roleArn: Swift.String?
    /// The type of ID namespace. There are two types: SOURCE and TARGET. The SOURCE contains configurations for sourceId data that will be processed in an ID mapping workflow. The TARGET contains a configuration of targetId to which all sourceIds will resolve to.
    /// This member is required.
    public var type: EntityResolutionClientTypes.IdNamespaceType?
    /// The timestamp of when the ID namespace was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil,
        idNamespaceArn: Swift.String? = nil,
        idNamespaceName: Swift.String? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]? = nil,
        roleArn: Swift.String? = nil,
        type: EntityResolutionClientTypes.IdNamespaceType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.idMappingWorkflowProperties = idMappingWorkflowProperties
        self.idNamespaceArn = idNamespaceArn
        self.idNamespaceName = idNamespaceName
        self.inputSourceConfig = inputSourceConfig
        self.roleArn = roleArn
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct UpdateIdNamespaceOutputBody {
    let idNamespaceName: Swift.String?
    let idNamespaceArn: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.IdNamespaceInputSource]?
    let idMappingWorkflowProperties: [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]?
    let type: EntityResolutionClientTypes.IdNamespaceType?
    let roleArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateIdNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case idMappingWorkflowProperties
        case idNamespaceArn
        case idNamespaceName
        case inputSourceConfig
        case roleArn
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceName)
        idNamespaceName = idNamespaceNameDecoded
        let idNamespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idNamespaceArn)
        idNamespaceArn = idNamespaceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceInputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.IdNamespaceInputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.IdNamespaceInputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let idMappingWorkflowPropertiesContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties?].self, forKey: .idMappingWorkflowProperties)
        var idMappingWorkflowPropertiesDecoded0:[EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]? = nil
        if let idMappingWorkflowPropertiesContainer = idMappingWorkflowPropertiesContainer {
            idMappingWorkflowPropertiesDecoded0 = [EntityResolutionClientTypes.IdNamespaceIdMappingWorkflowProperties]()
            for structure0 in idMappingWorkflowPropertiesContainer {
                if let structure0 = structure0 {
                    idMappingWorkflowPropertiesDecoded0?.append(structure0)
                }
            }
        }
        idMappingWorkflowProperties = idMappingWorkflowPropertiesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IdNamespaceType.self, forKey: .type)
        type = typeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum UpdateIdNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMatchingWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let incrementalRunConfig = self.incrementalRunConfig {
            try encodeContainer.encode(incrementalRunConfig, forKey: .incrementalRunConfig)
        }
        if let inputSourceConfig = inputSourceConfig {
            var inputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputSourceConfig)
            for inputsource0 in inputSourceConfig {
                try inputSourceConfigContainer.encode(inputsource0)
            }
        }
        if let outputSourceConfig = outputSourceConfig {
            var outputSourceConfigContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputSourceConfig)
            for outputsource0 in outputSourceConfig {
                try outputSourceConfigContainer.encode(outputsource0)
            }
        }
        if let resolutionTechniques = self.resolutionTechniques {
            try encodeContainer.encode(resolutionTechniques, forKey: .resolutionTechniques)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateMatchingWorkflowInput {

    static func urlPathProvider(_ value: UpdateMatchingWorkflowInput) -> Swift.String? {
        guard let workflowName = value.workflowName else {
            return nil
        }
        return "/matchingworkflows/\(workflowName.urlPercentEncoding())"
    }
}

public struct UpdateMatchingWorkflowInput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties.
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow to be retrieved.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateMatchingWorkflowInputBody {
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension UpdateMatchingWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateMatchingWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMatchingWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.incrementalRunConfig = output.incrementalRunConfig
            self.inputSourceConfig = output.inputSourceConfig
            self.outputSourceConfig = output.outputSourceConfig
            self.resolutionTechniques = output.resolutionTechniques
            self.roleArn = output.roleArn
            self.workflowName = output.workflowName
        } else {
            self.description = nil
            self.incrementalRunConfig = nil
            self.inputSourceConfig = nil
            self.outputSourceConfig = nil
            self.resolutionTechniques = nil
            self.roleArn = nil
            self.workflowName = nil
        }
    }
}

public struct UpdateMatchingWorkflowOutput {
    /// A description of the workflow.
    public var description: Swift.String?
    /// An object which defines an incremental run type and has only incrementalRunType as a field.
    public var incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    /// A list of InputSource objects, which have the fields InputSourceARN and SchemaName.
    /// This member is required.
    public var inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    /// A list of OutputSource objects, each of which contains fields OutputS3Path, ApplyNormalization, and Output.
    /// This member is required.
    public var outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    /// An object which defines the resolutionType and the ruleBasedProperties
    /// This member is required.
    public var resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    /// The Amazon Resource Name (ARN) of the IAM role. Entity Resolution assumes this role to create resources on your behalf as part of workflow execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the workflow.
    /// This member is required.
    public var workflowName: Swift.String?

    public init(
        description: Swift.String? = nil,
        incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig? = nil,
        inputSourceConfig: [EntityResolutionClientTypes.InputSource]? = nil,
        outputSourceConfig: [EntityResolutionClientTypes.OutputSource]? = nil,
        resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques? = nil,
        roleArn: Swift.String? = nil,
        workflowName: Swift.String? = nil
    )
    {
        self.description = description
        self.incrementalRunConfig = incrementalRunConfig
        self.inputSourceConfig = inputSourceConfig
        self.outputSourceConfig = outputSourceConfig
        self.resolutionTechniques = resolutionTechniques
        self.roleArn = roleArn
        self.workflowName = workflowName
    }
}

struct UpdateMatchingWorkflowOutputBody {
    let workflowName: Swift.String?
    let description: Swift.String?
    let inputSourceConfig: [EntityResolutionClientTypes.InputSource]?
    let outputSourceConfig: [EntityResolutionClientTypes.OutputSource]?
    let resolutionTechniques: EntityResolutionClientTypes.ResolutionTechniques?
    let incrementalRunConfig: EntityResolutionClientTypes.IncrementalRunConfig?
    let roleArn: Swift.String?
}

extension UpdateMatchingWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case incrementalRunConfig
        case inputSourceConfig
        case outputSourceConfig
        case resolutionTechniques
        case roleArn
        case workflowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let inputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.InputSource?].self, forKey: .inputSourceConfig)
        var inputSourceConfigDecoded0:[EntityResolutionClientTypes.InputSource]? = nil
        if let inputSourceConfigContainer = inputSourceConfigContainer {
            inputSourceConfigDecoded0 = [EntityResolutionClientTypes.InputSource]()
            for structure0 in inputSourceConfigContainer {
                if let structure0 = structure0 {
                    inputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        inputSourceConfig = inputSourceConfigDecoded0
        let outputSourceConfigContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.OutputSource?].self, forKey: .outputSourceConfig)
        var outputSourceConfigDecoded0:[EntityResolutionClientTypes.OutputSource]? = nil
        if let outputSourceConfigContainer = outputSourceConfigContainer {
            outputSourceConfigDecoded0 = [EntityResolutionClientTypes.OutputSource]()
            for structure0 in outputSourceConfigContainer {
                if let structure0 = structure0 {
                    outputSourceConfigDecoded0?.append(structure0)
                }
            }
        }
        outputSourceConfig = outputSourceConfigDecoded0
        let resolutionTechniquesDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.ResolutionTechniques.self, forKey: .resolutionTechniques)
        resolutionTechniques = resolutionTechniquesDecoded
        let incrementalRunConfigDecoded = try containerValues.decodeIfPresent(EntityResolutionClientTypes.IncrementalRunConfig.self, forKey: .incrementalRunConfig)
        incrementalRunConfig = incrementalRunConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum UpdateMatchingWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSchemaMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mappedInputFields = mappedInputFields {
            var mappedInputFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mappedInputFields)
            for schemainputattribute0 in mappedInputFields {
                try mappedInputFieldsContainer.encode(schemainputattribute0)
            }
        }
    }
}

extension UpdateSchemaMappingInput {

    static func urlPathProvider(_ value: UpdateSchemaMappingInput) -> Swift.String? {
        guard let schemaName = value.schemaName else {
            return nil
        }
        return "/schemas/\(schemaName.urlPercentEncoding())"
    }
}

public struct UpdateSchemaMappingInput {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The name of the schema. There can't be multiple SchemaMappings with the same name.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaName = schemaName
    }
}

struct UpdateSchemaMappingInputBody {
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension UpdateSchemaMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

extension UpdateSchemaMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSchemaMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.mappedInputFields = output.mappedInputFields
            self.schemaArn = output.schemaArn
            self.schemaName = output.schemaName
        } else {
            self.description = nil
            self.mappedInputFields = nil
            self.schemaArn = nil
            self.schemaName = nil
        }
    }
}

public struct UpdateSchemaMappingOutput {
    /// A description of the schema.
    public var description: Swift.String?
    /// A list of MappedInputFields. Each MappedInputField corresponds to a column the source data table, and contains column name plus additional information that Entity Resolution uses for matching.
    /// This member is required.
    public var mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
    /// The ARN (Amazon Resource Name) that Entity Resolution generated for the SchemaMapping.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// The name of the schema.
    /// This member is required.
    public var schemaName: Swift.String?

    public init(
        description: Swift.String? = nil,
        mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]? = nil,
        schemaArn: Swift.String? = nil,
        schemaName: Swift.String? = nil
    )
    {
        self.description = description
        self.mappedInputFields = mappedInputFields
        self.schemaArn = schemaArn
        self.schemaName = schemaName
    }
}

struct UpdateSchemaMappingOutputBody {
    let schemaName: Swift.String?
    let schemaArn: Swift.String?
    let description: Swift.String?
    let mappedInputFields: [EntityResolutionClientTypes.SchemaInputAttribute]?
}

extension UpdateSchemaMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case mappedInputFields
        case schemaArn
        case schemaName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mappedInputFieldsContainer = try containerValues.decodeIfPresent([EntityResolutionClientTypes.SchemaInputAttribute?].self, forKey: .mappedInputFields)
        var mappedInputFieldsDecoded0:[EntityResolutionClientTypes.SchemaInputAttribute]? = nil
        if let mappedInputFieldsContainer = mappedInputFieldsContainer {
            mappedInputFieldsDecoded0 = [EntityResolutionClientTypes.SchemaInputAttribute]()
            for structure0 in mappedInputFieldsContainer {
                if let structure0 = structure0 {
                    mappedInputFieldsDecoded0?.append(structure0)
                }
            }
        }
        mappedInputFields = mappedInputFieldsDecoded0
    }
}

enum UpdateSchemaMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by Entity Resolution. HTTP Status Code: 400
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
