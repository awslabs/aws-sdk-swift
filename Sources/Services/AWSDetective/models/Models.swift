// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension AcceptInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation"
    }
}

public struct AcceptInvitationInput: Swift.Equatable {
    /// The ARN of the behavior graph that the member account is accepting the invitation for. The member account status in the behavior graph must be INVITED.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    let graphArn: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension AcceptInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.errorCodeReason = output.errorCodeReason
            self.message = output.message
            self.subErrorCode = output.subErrorCode
            self.subErrorCodeReason = output.subErrorCodeReason
        } else {
            self.errorCode = nil
            self.errorCodeReason = nil
            self.message = nil
            self.subErrorCode = nil
            self.subErrorCodeReason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request issuer does not have permission to access this resource or perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The SDK default error code associated with the access denied exception.
    public var errorCode: DetectiveClientTypes.ErrorCode?
    /// The SDK default explanation of why access was denied.
    public var errorCodeReason: Swift.String?
    public var message: Swift.String?
    /// The error code associated with the access denied exception.
    public var subErrorCode: DetectiveClientTypes.ErrorCode?
    /// An explanation of why access was denied.
    public var subErrorCodeReason: Swift.String?

    public init (
        errorCode: DetectiveClientTypes.ErrorCode? = nil,
        errorCodeReason: Swift.String? = nil,
        message: Swift.String? = nil,
        subErrorCode: DetectiveClientTypes.ErrorCode? = nil,
        subErrorCodeReason: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorCodeReason = errorCodeReason
        self.message = message
        self.subErrorCode = subErrorCode
        self.subErrorCodeReason = subErrorCodeReason
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: DetectiveClientTypes.ErrorCode?
    let errorCodeReason: Swift.String?
    let subErrorCode: DetectiveClientTypes.ErrorCode?
    let subErrorCodeReason: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorCodeReason = "ErrorCodeReason"
        case message = "Message"
        case subErrorCode = "SubErrorCode"
        case subErrorCodeReason = "SubErrorCodeReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorCodeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCodeReason)
        errorCodeReason = errorCodeReasonDecoded
        let subErrorCodeDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.ErrorCode.self, forKey: .subErrorCode)
        subErrorCode = subErrorCodeDecoded
        let subErrorCodeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subErrorCodeReason)
        subErrorCodeReason = subErrorCodeReasonDecoded
    }
}

extension DetectiveClientTypes.Account: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case emailAddress = "EmailAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension DetectiveClientTypes {
    /// An Amazon Web Services account that is the administrator account of or a member of a behavior graph.
    public struct Account: Swift.Equatable {
        /// The account identifier of the Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The Amazon Web Services account root user email address for the Amazon Web Services account.
        /// This member is required.
        public var emailAddress: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            emailAddress: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.emailAddress = emailAddress
        }
    }

}

extension DetectiveClientTypes.Administrator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case delegationTime = "DelegationTime"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let delegationTime = self.delegationTime {
            try encodeContainer.encodeTimestamp(delegationTime, format: .dateTime, forKey: .delegationTime)
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let delegationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .delegationTime)
        delegationTime = delegationTimeDecoded
    }
}

extension DetectiveClientTypes {
    /// Information about the Detective administrator account for an organization.
    public struct Administrator: Swift.Equatable {
        /// The Amazon Web Services account identifier of the Detective administrator account for the organization.
        public var accountId: Swift.String?
        /// The date and time when the Detective administrator account was enabled. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        public var delegationTime: ClientRuntime.Date?
        /// The ARN of the organization behavior graph.
        public var graphArn: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            delegationTime: ClientRuntime.Date? = nil,
            graphArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.delegationTime = delegationTime
            self.graphArn = graphArn
        }
    }

}

extension BatchGetGraphMemberDatasourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension BatchGetGraphMemberDatasourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/datasources/get"
    }
}

public struct BatchGetGraphMemberDatasourcesInput: Swift.Equatable {
    /// The list of Amazon Web Services accounts to get data source package information on.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct BatchGetGraphMemberDatasourcesInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let accountIds: [Swift.String]?
}

extension BatchGetGraphMemberDatasourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchGetGraphMemberDatasourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetGraphMemberDatasourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetGraphMemberDatasourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetGraphMemberDatasourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetGraphMemberDatasourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDatasources = output.memberDatasources
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDatasources = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct BatchGetGraphMemberDatasourcesOutputResponse: Swift.Equatable {
    /// Details on the status of data source packages for members of the behavior graph.
    public var memberDatasources: [DetectiveClientTypes.MembershipDatasources]?
    /// Accounts that data source package information could not be retrieved for.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        memberDatasources: [DetectiveClientTypes.MembershipDatasources]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.memberDatasources = memberDatasources
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct BatchGetGraphMemberDatasourcesOutputResponseBody: Swift.Equatable {
    let memberDatasources: [DetectiveClientTypes.MembershipDatasources]?
    let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension BatchGetGraphMemberDatasourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDatasources = "MemberDatasources"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDatasourcesContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MembershipDatasources?].self, forKey: .memberDatasources)
        var memberDatasourcesDecoded0:[DetectiveClientTypes.MembershipDatasources]? = nil
        if let memberDatasourcesContainer = memberDatasourcesContainer {
            memberDatasourcesDecoded0 = [DetectiveClientTypes.MembershipDatasources]()
            for structure0 in memberDatasourcesContainer {
                if let structure0 = structure0 {
                    memberDatasourcesDecoded0?.append(structure0)
                }
            }
        }
        memberDatasources = memberDatasourcesDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension BatchGetMembershipDatasourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArns = "GraphArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArns = graphArns {
            var graphArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .graphArns)
            for grapharn0 in graphArns {
                try graphArnsContainer.encode(grapharn0)
            }
        }
    }
}

extension BatchGetMembershipDatasourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/membership/datasources/get"
    }
}

public struct BatchGetMembershipDatasourcesInput: Swift.Equatable {
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArns: [Swift.String]?

    public init (
        graphArns: [Swift.String]? = nil
    )
    {
        self.graphArns = graphArns
    }
}

struct BatchGetMembershipDatasourcesInputBody: Swift.Equatable {
    let graphArns: [Swift.String]?
}

extension BatchGetMembershipDatasourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArns = "GraphArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .graphArns)
        var graphArnsDecoded0:[Swift.String]? = nil
        if let graphArnsContainer = graphArnsContainer {
            graphArnsDecoded0 = [Swift.String]()
            for string0 in graphArnsContainer {
                if let string0 = string0 {
                    graphArnsDecoded0?.append(string0)
                }
            }
        }
        graphArns = graphArnsDecoded0
    }
}

extension BatchGetMembershipDatasourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetMembershipDatasourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetMembershipDatasourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetMembershipDatasourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetMembershipDatasourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.membershipDatasources = output.membershipDatasources
            self.unprocessedGraphs = output.unprocessedGraphs
        } else {
            self.membershipDatasources = nil
            self.unprocessedGraphs = nil
        }
    }
}

public struct BatchGetMembershipDatasourcesOutputResponse: Swift.Equatable {
    /// Details on the data source package history for an member of the behavior graph.
    public var membershipDatasources: [DetectiveClientTypes.MembershipDatasources]?
    /// Graphs that data source package information could not be retrieved for.
    public var unprocessedGraphs: [DetectiveClientTypes.UnprocessedGraph]?

    public init (
        membershipDatasources: [DetectiveClientTypes.MembershipDatasources]? = nil,
        unprocessedGraphs: [DetectiveClientTypes.UnprocessedGraph]? = nil
    )
    {
        self.membershipDatasources = membershipDatasources
        self.unprocessedGraphs = unprocessedGraphs
    }
}

struct BatchGetMembershipDatasourcesOutputResponseBody: Swift.Equatable {
    let membershipDatasources: [DetectiveClientTypes.MembershipDatasources]?
    let unprocessedGraphs: [DetectiveClientTypes.UnprocessedGraph]?
}

extension BatchGetMembershipDatasourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipDatasources = "MembershipDatasources"
        case unprocessedGraphs = "UnprocessedGraphs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDatasourcesContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MembershipDatasources?].self, forKey: .membershipDatasources)
        var membershipDatasourcesDecoded0:[DetectiveClientTypes.MembershipDatasources]? = nil
        if let membershipDatasourcesContainer = membershipDatasourcesContainer {
            membershipDatasourcesDecoded0 = [DetectiveClientTypes.MembershipDatasources]()
            for structure0 in membershipDatasourcesContainer {
                if let structure0 = structure0 {
                    membershipDatasourcesDecoded0?.append(structure0)
                }
            }
        }
        membershipDatasources = membershipDatasourcesDecoded0
        let unprocessedGraphsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedGraph?].self, forKey: .unprocessedGraphs)
        var unprocessedGraphsDecoded0:[DetectiveClientTypes.UnprocessedGraph]? = nil
        if let unprocessedGraphsContainer = unprocessedGraphsContainer {
            unprocessedGraphsDecoded0 = [DetectiveClientTypes.UnprocessedGraph]()
            for structure0 in unprocessedGraphsContainer {
                if let structure0 = structure0 {
                    unprocessedGraphsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedGraphs = unprocessedGraphsDecoded0
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request attempted an invalid action.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph"
    }
}

public struct CreateGraphInput: Swift.Equatable {
    /// The tags to assign to the new behavior graph. You can add up to 50 tags. For each tag, you provide the tag key and the tag value. Each tag key can contain up to 128 characters. Each tag value can contain up to 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateGraphInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGraphOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGraphOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGraphOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGraphOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGraphOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphArn = output.graphArn
        } else {
            self.graphArn = nil
        }
    }
}

public struct CreateGraphOutputResponse: Swift.Equatable {
    /// The ARN of the new behavior graph.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct CreateGraphOutputResponseBody: Swift.Equatable {
    let graphArn: Swift.String?
}

extension CreateGraphOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension CreateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case disableEmailNotification = "DisableEmailNotification"
        case graphArn = "GraphArn"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for account0 in accounts {
                try accountsContainer.encode(account0)
            }
        }
        if disableEmailNotification != false {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

extension CreateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/members"
    }
}

public struct CreateMembersInput: Swift.Equatable {
    /// The list of Amazon Web Services accounts to invite or to enable. You can invite or enable up to 50 accounts at a time. For each invited account, the account list contains the account identifier and the Amazon Web Services account root user email address. For organization accounts in the organization behavior graph, the email address is not required.
    /// This member is required.
    public var accounts: [DetectiveClientTypes.Account]?
    /// if set to true, then the invited accounts do not receive email notifications. By default, this is set to false, and the invited accounts receive email notifications. Organization accounts in the organization behavior graph do not receive email notifications.
    public var disableEmailNotification: Swift.Bool
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?
    /// Customized message text to include in the invitation email message to the invited member accounts.
    public var message: Swift.String?

    public init (
        accounts: [DetectiveClientTypes.Account]? = nil,
        disableEmailNotification: Swift.Bool = false,
        graphArn: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.disableEmailNotification = disableEmailNotification
        self.graphArn = graphArn
        self.message = message
    }
}

struct CreateMembersInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let message: Swift.String?
    let disableEmailNotification: Swift.Bool
    let accounts: [DetectiveClientTypes.Account]?
}

extension CreateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case disableEmailNotification = "DisableEmailNotification"
        case graphArn = "GraphArn"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let disableEmailNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableEmailNotification) ?? false
        disableEmailNotification = disableEmailNotificationDecoded
        let accountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[DetectiveClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [DetectiveClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
    }
}

extension CreateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Swift.Equatable {
    /// The set of member account invitation or enablement requests that Detective was able to process. This includes accounts that are being verified, that failed verification, and that passed verification and are being sent an invitation or are being enabled.
    public var members: [DetectiveClientTypes.MemberDetail]?
    /// The list of accounts for which Detective was unable to process the invitation or enablement request. For each account, the list provides the reason why the request could not be processed. The list includes accounts that are already member accounts in the behavior graph.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        members: [DetectiveClientTypes.MemberDetail]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Swift.Equatable {
    let members: [DetectiveClientTypes.MemberDetail]?
    let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension CreateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .members)
        var membersDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DetectiveClientTypes {
    public enum DatasourcePackage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case detectiveCore
        case eksAudit
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasourcePackage] {
            return [
                .detectiveCore,
                .eksAudit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .detectiveCore: return "DETECTIVE_CORE"
            case .eksAudit: return "EKS_AUDIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasourcePackage(rawValue: rawValue) ?? DatasourcePackage.sdkUnknown(rawValue)
        }
    }
}

extension DetectiveClientTypes.DatasourcePackageIngestDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasourcePackageIngestState = "DatasourcePackageIngestState"
        case lastIngestStateChange = "LastIngestStateChange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasourcePackageIngestState = self.datasourcePackageIngestState {
            try encodeContainer.encode(datasourcePackageIngestState.rawValue, forKey: .datasourcePackageIngestState)
        }
        if let lastIngestStateChange = lastIngestStateChange {
            var lastIngestStateChangeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .lastIngestStateChange)
            for (dictKey0, lastIngestStateChangeDates0) in lastIngestStateChange {
                try lastIngestStateChangeContainer.encode(lastIngestStateChangeDates0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasourcePackageIngestStateDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.DatasourcePackageIngestState.self, forKey: .datasourcePackageIngestState)
        datasourcePackageIngestState = datasourcePackageIngestStateDecoded
        let lastIngestStateChangeContainer = try containerValues.decodeIfPresent([Swift.String: DetectiveClientTypes.TimestampForCollection?].self, forKey: .lastIngestStateChange)
        var lastIngestStateChangeDecoded0: [Swift.String:DetectiveClientTypes.TimestampForCollection]? = nil
        if let lastIngestStateChangeContainer = lastIngestStateChangeContainer {
            lastIngestStateChangeDecoded0 = [Swift.String:DetectiveClientTypes.TimestampForCollection]()
            for (key0, timestampforcollection0) in lastIngestStateChangeContainer {
                if let timestampforcollection0 = timestampforcollection0 {
                    lastIngestStateChangeDecoded0?[key0] = timestampforcollection0
                }
            }
        }
        lastIngestStateChange = lastIngestStateChangeDecoded0
    }
}

extension DetectiveClientTypes {
    /// Details about the data source packages ingested by your behavior graph.
    public struct DatasourcePackageIngestDetail: Swift.Equatable {
        /// Details on which data source packages are ingested for a member account.
        public var datasourcePackageIngestState: DetectiveClientTypes.DatasourcePackageIngestState?
        /// The date a data source package was enabled for this account
        public var lastIngestStateChange: [Swift.String:DetectiveClientTypes.TimestampForCollection]?

        public init (
            datasourcePackageIngestState: DetectiveClientTypes.DatasourcePackageIngestState? = nil,
            lastIngestStateChange: [Swift.String:DetectiveClientTypes.TimestampForCollection]? = nil
        )
        {
            self.datasourcePackageIngestState = datasourcePackageIngestState
            self.lastIngestStateChange = lastIngestStateChange
        }
    }

}

extension DetectiveClientTypes {
    public enum DatasourcePackageIngestState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasourcePackageIngestState] {
            return [
                .disabled,
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasourcePackageIngestState(rawValue: rawValue) ?? DatasourcePackageIngestState.sdkUnknown(rawValue)
        }
    }
}

extension DetectiveClientTypes.DatasourcePackageUsageInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeUsageInBytes = "VolumeUsageInBytes"
        case volumeUsageUpdateTime = "VolumeUsageUpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeUsageInBytes = self.volumeUsageInBytes {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
        if let volumeUsageUpdateTime = self.volumeUsageUpdateTime {
            try encodeContainer.encodeTimestamp(volumeUsageUpdateTime, format: .dateTime, forKey: .volumeUsageUpdateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeUsageInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsageInBytes)
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeUsageUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .volumeUsageUpdateTime)
        volumeUsageUpdateTime = volumeUsageUpdateTimeDecoded
    }
}

extension DetectiveClientTypes {
    /// Information on the usage of a data source package in the behavior graph.
    public struct DatasourcePackageUsageInfo: Swift.Equatable {
        /// Total volume of data in bytes per day ingested for a given data source package.
        public var volumeUsageInBytes: Swift.Int?
        /// The data and time when the member account data volume was last updated. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        public var volumeUsageUpdateTime: ClientRuntime.Date?

        public init (
            volumeUsageInBytes: Swift.Int? = nil,
            volumeUsageUpdateTime: ClientRuntime.Date? = nil
        )
        {
            self.volumeUsageInBytes = volumeUsageInBytes
            self.volumeUsageUpdateTime = volumeUsageUpdateTime
        }
    }

}

extension DeleteGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension DeleteGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/removal"
    }
}

public struct DeleteGraphInput: Swift.Equatable {
    /// The ARN of the behavior graph to disable.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DeleteGraphInputBody: Swift.Equatable {
    let graphArn: Swift.String?
}

extension DeleteGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DeleteGraphOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGraphOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGraphOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGraphOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGraphOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension DeleteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/members/removal"
    }
}

public struct DeleteMembersInput: Swift.Equatable {
    /// The list of Amazon Web Services account identifiers for the member accounts to remove from the behavior graph. You can remove up to 50 member accounts at a time.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The ARN of the behavior graph to remove members from.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct DeleteMembersInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let accountIds: [Swift.String]?
}

extension DeleteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.accountIds = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services account identifiers for the member accounts that Detective successfully removed from the behavior graph.
    public var accountIds: [Swift.String]?
    /// The list of member accounts that Detective was not able to remove from the behavior graph. For each member account, provides the reason that the deletion could not be processed.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        accountIds: [Swift.String]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.accountIds = accountIds
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension DeleteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DescribeOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/orgs/describeOrganizationConfiguration"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {
    /// The ARN of the organization behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
    let graphArn: Swift.String?
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
        } else {
            self.autoEnable = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Swift.Equatable {
    /// Indicates whether to automatically enable new organization accounts as member accounts in the organization behavior graph.
    public var autoEnable: Swift.Bool

    public init (
        autoEnable: Swift.Bool = false
    )
    {
        self.autoEnable = autoEnable
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Swift.Equatable {
    let autoEnable: Swift.Bool
}

extension DescribeOrganizationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "AutoEnable"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/orgs/disableAdminAccount"
    }
}

public struct DisableOrganizationAdminAccountInput: Swift.Equatable {

    public init () { }
}

struct DisableOrganizationAdminAccountInputBody: Swift.Equatable {
}

extension DisableOrganizationAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension DisassociateMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/membership/removal"
    }
}

public struct DisassociateMembershipInput: Swift.Equatable {
    /// The ARN of the behavior graph to remove the member account from. The member account's member status in the behavior graph must be ENABLED.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DisassociateMembershipInputBody: Swift.Equatable {
    let graphArn: Swift.String?
}

extension DisassociateMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DisassociateMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMembershipOutputResponse: Swift.Equatable {

    public init () { }
}

extension EnableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension EnableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/orgs/enableAdminAccount"
    }
}

public struct EnableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account identifier of the account to designate as the Detective administrator account for the organization.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension EnableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DetectiveClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalerror
        case invalidgrapharn
        case invalidrequestbody
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalerror,
                .invalidgrapharn,
                .invalidrequestbody,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalerror: return "INTERNAL_ERROR"
            case .invalidgrapharn: return "INVALID_GRAPH_ARN"
            case .invalidrequestbody: return "INVALID_REQUEST_BODY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension GetMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension GetMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/members/get"
    }
}

public struct GetMembersInput: Swift.Equatable {
    /// The list of Amazon Web Services account identifiers for the member account for which to return member details. You can request details for up to 50 member accounts at a time. You cannot use GetMembers to retrieve information about member accounts that were removed from the behavior graph.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The ARN of the behavior graph for which to request the member details.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct GetMembersInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let accountIds: [Swift.String]?
}

extension GetMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDetails = output.memberDetails
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDetails = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Swift.Equatable {
    /// The member account details that Detective is returning in response to the request.
    public var memberDetails: [DetectiveClientTypes.MemberDetail]?
    /// The requested member accounts for which Detective was unable to return member details. For each account, provides the reason why the request could not be processed.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        memberDetails: [DetectiveClientTypes.MemberDetail]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.memberDetails = memberDetails
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Swift.Equatable {
    let memberDetails: [DetectiveClientTypes.MemberDetail]?
    let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension GetMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDetails = "MemberDetails"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .memberDetails)
        var memberDetailsDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let memberDetailsContainer = memberDetailsContainer {
            memberDetailsDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in memberDetailsContainer {
                if let structure0 = structure0 {
                    memberDetailsDecoded0?.append(structure0)
                }
            }
        }
        memberDetails = memberDetailsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DetectiveClientTypes.Graph: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .dateTime, forKey: .createdTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension DetectiveClientTypes {
    /// A behavior graph in Detective.
    public struct Graph: Swift.Equatable {
        /// The ARN of the behavior graph.
        public var arn: Swift.String?
        /// The date and time that the behavior graph was created. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        public var createdTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was valid but failed because of a problem with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DetectiveClientTypes {
    public enum InvitationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invitation
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [InvitationType] {
            return [
                .invitation,
                .organization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invitation: return "INVITATION"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvitationType(rawValue: rawValue) ?? InvitationType.sdkUnknown(rawValue)
        }
    }
}

extension ListDatasourcePackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasourcePackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/datasources/list"
    }
}

public struct ListDatasourcePackagesInput: Swift.Equatable {
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// For requests to get the next page of results, the pagination token that was returned with the previous set of results. The initial request does not include a pagination token.
    public var nextToken: Swift.String?

    public init (
        graphArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasourcePackagesInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasourcePackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasourcePackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasourcePackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasourcePackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasourcePackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasourcePackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasourcePackages = output.datasourcePackages
            self.nextToken = output.nextToken
        } else {
            self.datasourcePackages = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasourcePackagesOutputResponse: Swift.Equatable {
    /// Details on the data source packages active in the behavior graph.
    public var datasourcePackages: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestDetail]?
    /// For requests to get the next page of results, the pagination token that was returned with the previous set of results. The initial request does not include a pagination token.
    public var nextToken: Swift.String?

    public init (
        datasourcePackages: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasourcePackages = datasourcePackages
        self.nextToken = nextToken
    }
}

struct ListDatasourcePackagesOutputResponseBody: Swift.Equatable {
    let datasourcePackages: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestDetail]?
    let nextToken: Swift.String?
}

extension ListDatasourcePackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasourcePackages = "DatasourcePackages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasourcePackagesContainer = try containerValues.decodeIfPresent([Swift.String: DetectiveClientTypes.DatasourcePackageIngestDetail?].self, forKey: .datasourcePackages)
        var datasourcePackagesDecoded0: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestDetail]? = nil
        if let datasourcePackagesContainer = datasourcePackagesContainer {
            datasourcePackagesDecoded0 = [Swift.String:DetectiveClientTypes.DatasourcePackageIngestDetail]()
            for (key0, datasourcepackageingestdetail0) in datasourcePackagesContainer {
                if let datasourcepackageingestdetail0 = datasourcepackageingestdetail0 {
                    datasourcePackagesDecoded0?[key0] = datasourcepackageingestdetail0
                }
            }
        }
        datasourcePackages = datasourcePackagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGraphsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGraphsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graphs/list"
    }
}

public struct ListGraphsInput: Swift.Equatable {
    /// The maximum number of graphs to return at a time. The total must be less than the overall limit on the number of results to return, which is currently 200.
    public var maxResults: Swift.Int?
    /// For requests to get the next page of results, the pagination token that was returned with the previous set of results. The initial request does not include a pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGraphsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGraphsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGraphsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGraphsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGraphsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGraphsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphList = output.graphList
            self.nextToken = output.nextToken
        } else {
            self.graphList = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphsOutputResponse: Swift.Equatable {
    /// A list of behavior graphs that the account is an administrator account for.
    public var graphList: [DetectiveClientTypes.Graph]?
    /// If there are more behavior graphs remaining in the results, then this is the pagination token to use to request the next page of behavior graphs.
    public var nextToken: Swift.String?

    public init (
        graphList: [DetectiveClientTypes.Graph]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphList = graphList
        self.nextToken = nextToken
    }
}

struct ListGraphsOutputResponseBody: Swift.Equatable {
    let graphList: [DetectiveClientTypes.Graph]?
    let nextToken: Swift.String?
}

extension ListGraphsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphList = "GraphList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphListContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.Graph?].self, forKey: .graphList)
        var graphListDecoded0:[DetectiveClientTypes.Graph]? = nil
        if let graphListContainer = graphListContainer {
            graphListDecoded0 = [DetectiveClientTypes.Graph]()
            for structure0 in graphListContainer {
                if let structure0 = structure0 {
                    graphListDecoded0?.append(structure0)
                }
            }
        }
        graphList = graphListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/list"
    }
}

public struct ListInvitationsInput: Swift.Equatable {
    /// The maximum number of behavior graph invitations to return in the response. The total must be less than the overall limit on the number of results to return, which is currently 200.
    public var maxResults: Swift.Int?
    /// For requests to retrieve the next page of results, the pagination token that was returned with the previous page of results. The initial request does not include a pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Swift.Equatable {
    /// The list of behavior graphs for which the member account has open or accepted invitations.
    public var invitations: [DetectiveClientTypes.MemberDetail]?
    /// If there are more behavior graphs remaining in the results, then this is the pagination token to use to request the next page of behavior graphs.
    public var nextToken: Swift.String?

    public init (
        invitations: [DetectiveClientTypes.MemberDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Swift.Equatable {
    let invitations: [DetectiveClientTypes.MemberDetail]?
    let nextToken: Swift.String?
}

extension ListInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "Invitations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .invitations)
        var invitationsDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/members/list"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The ARN of the behavior graph for which to retrieve the list of member accounts.
    /// This member is required.
    public var graphArn: Swift.String?
    /// The maximum number of member accounts to include in the response. The total must be less than the overall limit on the number of results to return, which is currently 200.
    public var maxResults: Swift.Int?
    /// For requests to retrieve the next page of member account results, the pagination token that was returned with the previous page of results. The initial request does not include a pagination token.
    public var nextToken: Swift.String?

    public init (
        graphArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMembersInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDetails = output.memberDetails
            self.nextToken = output.nextToken
        } else {
            self.memberDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Swift.Equatable {
    /// The list of member accounts in the behavior graph. For invited accounts, the results include member accounts that did not pass verification and member accounts that have not yet accepted the invitation to the behavior graph. The results do not include member accounts that were removed from the behavior graph. For the organization behavior graph, the results do not include organization accounts that the Detective administrator account has not enabled as member accounts.
    public var memberDetails: [DetectiveClientTypes.MemberDetail]?
    /// If there are more member accounts remaining in the results, then use this pagination token to request the next page of member accounts.
    public var nextToken: Swift.String?

    public init (
        memberDetails: [DetectiveClientTypes.MemberDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberDetails = memberDetails
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Swift.Equatable {
    let memberDetails: [DetectiveClientTypes.MemberDetail]?
    let nextToken: Swift.String?
}

extension ListMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDetails = "MemberDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .memberDetails)
        var memberDetailsDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let memberDetailsContainer = memberDetailsContainer {
            memberDetailsDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in memberDetailsContainer {
                if let structure0 = structure0 {
                    memberDetailsDecoded0?.append(structure0)
                }
            }
        }
        memberDetails = memberDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/orgs/adminAccountslist"
    }
}

public struct ListOrganizationAdminAccountsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// For requests to get the next page of results, the pagination token that was returned with the previous set of results. The initial request does not include a pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListOrganizationAdminAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOrganizationAdminAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.administrators = output.administrators
            self.nextToken = output.nextToken
        } else {
            self.administrators = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Swift.Equatable {
    /// The list of Detective administrator accounts.
    public var administrators: [DetectiveClientTypes.Administrator]?
    /// If there are more accounts remaining in the results, then this is the pagination token to use to request the next page of accounts.
    public var nextToken: Swift.String?

    public init (
        administrators: [DetectiveClientTypes.Administrator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.administrators = administrators
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Swift.Equatable {
    let administrators: [DetectiveClientTypes.Administrator]?
    let nextToken: Swift.String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrators = "Administrators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.Administrator?].self, forKey: .administrators)
        var administratorsDecoded0:[DetectiveClientTypes.Administrator]? = nil
        if let administratorsContainer = administratorsContainer {
            administratorsDecoded0 = [DetectiveClientTypes.Administrator]()
            for structure0 in administratorsContainer {
                if let structure0 = structure0 {
                    administratorsDecoded0?.append(structure0)
                }
            }
        }
        administrators = administratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the behavior graph for which to retrieve the tag values.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag values that are assigned to the behavior graph. The request returns up to 50 tag values.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DetectiveClientTypes.MemberDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case administratorId = "AdministratorId"
        case datasourcePackageIngestStates = "DatasourcePackageIngestStates"
        case disabledReason = "DisabledReason"
        case emailAddress = "EmailAddress"
        case graphArn = "GraphArn"
        case invitationType = "InvitationType"
        case invitedTime = "InvitedTime"
        case masterId = "MasterId"
        case percentOfGraphUtilization = "PercentOfGraphUtilization"
        case percentOfGraphUtilizationUpdatedTime = "PercentOfGraphUtilizationUpdatedTime"
        case status = "Status"
        case updatedTime = "UpdatedTime"
        case volumeUsageByDatasourcePackage = "VolumeUsageByDatasourcePackage"
        case volumeUsageInBytes = "VolumeUsageInBytes"
        case volumeUsageUpdatedTime = "VolumeUsageUpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let datasourcePackageIngestStates = datasourcePackageIngestStates {
            var datasourcePackageIngestStatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .datasourcePackageIngestStates)
            for (dictKey0, datasourcePackageIngestStates0) in datasourcePackageIngestStates {
                try datasourcePackageIngestStatesContainer.encode(datasourcePackageIngestStates0.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let disabledReason = self.disabledReason {
            try encodeContainer.encode(disabledReason.rawValue, forKey: .disabledReason)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let invitationType = self.invitationType {
            try encodeContainer.encode(invitationType.rawValue, forKey: .invitationType)
        }
        if let invitedTime = self.invitedTime {
            try encodeContainer.encodeTimestamp(invitedTime, format: .dateTime, forKey: .invitedTime)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let percentOfGraphUtilization = self.percentOfGraphUtilization {
            try encodeContainer.encode(percentOfGraphUtilization, forKey: .percentOfGraphUtilization)
        }
        if let percentOfGraphUtilizationUpdatedTime = self.percentOfGraphUtilizationUpdatedTime {
            try encodeContainer.encodeTimestamp(percentOfGraphUtilizationUpdatedTime, format: .dateTime, forKey: .percentOfGraphUtilizationUpdatedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = self.updatedTime {
            try encodeContainer.encodeTimestamp(updatedTime, format: .dateTime, forKey: .updatedTime)
        }
        if let volumeUsageByDatasourcePackage = volumeUsageByDatasourcePackage {
            var volumeUsageByDatasourcePackageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .volumeUsageByDatasourcePackage)
            for (dictKey0, volumeUsageByDatasourcePackage0) in volumeUsageByDatasourcePackage {
                try volumeUsageByDatasourcePackageContainer.encode(volumeUsageByDatasourcePackage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let volumeUsageInBytes = self.volumeUsageInBytes {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
        if let volumeUsageUpdatedTime = self.volumeUsageUpdatedTime {
            try encodeContainer.encodeTimestamp(volumeUsageUpdatedTime, format: .dateTime, forKey: .volumeUsageUpdatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.MemberStatus.self, forKey: .status)
        status = statusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.MemberDisabledReason.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
        let invitedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedTime)
        invitedTime = invitedTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let volumeUsageInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsageInBytes)
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeUsageUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .volumeUsageUpdatedTime)
        volumeUsageUpdatedTime = volumeUsageUpdatedTimeDecoded
        let percentOfGraphUtilizationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfGraphUtilization)
        percentOfGraphUtilization = percentOfGraphUtilizationDecoded
        let percentOfGraphUtilizationUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .percentOfGraphUtilizationUpdatedTime)
        percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTimeDecoded
        let invitationTypeDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.InvitationType.self, forKey: .invitationType)
        invitationType = invitationTypeDecoded
        let volumeUsageByDatasourcePackageContainer = try containerValues.decodeIfPresent([Swift.String: DetectiveClientTypes.DatasourcePackageUsageInfo?].self, forKey: .volumeUsageByDatasourcePackage)
        var volumeUsageByDatasourcePackageDecoded0: [Swift.String:DetectiveClientTypes.DatasourcePackageUsageInfo]? = nil
        if let volumeUsageByDatasourcePackageContainer = volumeUsageByDatasourcePackageContainer {
            volumeUsageByDatasourcePackageDecoded0 = [Swift.String:DetectiveClientTypes.DatasourcePackageUsageInfo]()
            for (key0, datasourcepackageusageinfo0) in volumeUsageByDatasourcePackageContainer {
                if let datasourcepackageusageinfo0 = datasourcepackageusageinfo0 {
                    volumeUsageByDatasourcePackageDecoded0?[key0] = datasourcepackageusageinfo0
                }
            }
        }
        volumeUsageByDatasourcePackage = volumeUsageByDatasourcePackageDecoded0
        let datasourcePackageIngestStatesContainer = try containerValues.decodeIfPresent([Swift.String: DetectiveClientTypes.DatasourcePackageIngestState?].self, forKey: .datasourcePackageIngestStates)
        var datasourcePackageIngestStatesDecoded0: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestState]? = nil
        if let datasourcePackageIngestStatesContainer = datasourcePackageIngestStatesContainer {
            datasourcePackageIngestStatesDecoded0 = [Swift.String:DetectiveClientTypes.DatasourcePackageIngestState]()
            for (key0, datasourcepackageingeststate0) in datasourcePackageIngestStatesContainer {
                if let datasourcepackageingeststate0 = datasourcepackageingeststate0 {
                    datasourcePackageIngestStatesDecoded0?[key0] = datasourcepackageingeststate0
                }
            }
        }
        datasourcePackageIngestStates = datasourcePackageIngestStatesDecoded0
    }
}

extension DetectiveClientTypes {
    /// Details about a member account in a behavior graph.
    public struct MemberDetail: Swift.Equatable {
        /// The Amazon Web Services account identifier for the member account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account identifier of the administrator account for the behavior graph.
        public var administratorId: Swift.String?
        /// The state of a data source package for the behavior graph.
        public var datasourcePackageIngestStates: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestState]?
        /// For member accounts with a status of ACCEPTED_BUT_DISABLED, the reason that the member account is not enabled. The reason can have one of the following values:
        ///
        /// * VOLUME_TOO_HIGH - Indicates that adding the member account would cause the data volume for the behavior graph to be too high.
        ///
        /// * VOLUME_UNKNOWN - Indicates that Detective is unable to verify the data volume for the member account. This is usually because the member account is not enrolled in Amazon GuardDuty.
        public var disabledReason: DetectiveClientTypes.MemberDisabledReason?
        /// The Amazon Web Services account root user email address for the member account.
        public var emailAddress: Swift.String?
        /// The ARN of the behavior graph.
        public var graphArn: Swift.String?
        /// The type of behavior graph membership. For an organization account in the organization behavior graph, the type is ORGANIZATION. For an account that was invited to a behavior graph, the type is INVITATION.
        public var invitationType: DetectiveClientTypes.InvitationType?
        /// For invited accounts, the date and time that Detective sent the invitation to the account. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        public var invitedTime: ClientRuntime.Date?
        /// The Amazon Web Services account identifier of the administrator account for the behavior graph.
        @available(*, deprecated, message: "This property is deprecated. Use AdministratorId instead.")
        public var masterId: Swift.String?
        /// The member account data volume as a percentage of the maximum allowed data volume. 0 indicates 0 percent, and 100 indicates 100 percent. Note that this is not the percentage of the behavior graph data volume. For example, the data volume for the behavior graph is 80 GB per day. The maximum data volume is 160 GB per day. If the data volume for the member account is 40 GB per day, then PercentOfGraphUtilization is 25. It represents 25% of the maximum allowed data volume.
        @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageByDatasourcePackage instead.")
        public var percentOfGraphUtilization: Swift.Double?
        /// The date and time when the graph utilization percentage was last updated. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageByDatasourcePackage instead.")
        public var percentOfGraphUtilizationUpdatedTime: ClientRuntime.Date?
        /// The current membership status of the member account. The status can have one of the following values:
        ///
        /// * INVITED - For invited accounts only. Indicates that the member was sent an invitation but has not yet responded.
        ///
        /// * VERIFICATION_IN_PROGRESS - For invited accounts only, indicates that Detective is verifying that the account identifier and email address provided for the member account match. If they do match, then Detective sends the invitation. If the email address and account identifier don't match, then the member cannot be added to the behavior graph. For organization accounts in the organization behavior graph, indicates that Detective is verifying that the account belongs to the organization.
        ///
        /// * VERIFICATION_FAILED - For invited accounts only. Indicates that the account and email address provided for the member account do not match, and Detective did not send an invitation to the account.
        ///
        /// * ENABLED - Indicates that the member account currently contributes data to the behavior graph. For invited accounts, the member account accepted the invitation. For organization accounts in the organization behavior graph, the Detective administrator account enabled the organization account as a member account.
        ///
        /// * ACCEPTED_BUT_DISABLED - The account accepted the invitation, or was enabled by the Detective administrator account, but is prevented from contributing data to the behavior graph. DisabledReason provides the reason why the member account is not enabled.
        ///
        ///
        /// Invited accounts that declined an invitation or that were removed from the behavior graph are not included. In the organization behavior graph, organization accounts that the Detective administrator account did not enable are not included.
        public var status: DetectiveClientTypes.MemberStatus?
        /// The date and time that the member account was last updated. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        public var updatedTime: ClientRuntime.Date?
        /// Details on the volume of usage for each data source package in a behavior graph.
        public var volumeUsageByDatasourcePackage: [Swift.String:DetectiveClientTypes.DatasourcePackageUsageInfo]?
        /// The data volume in bytes per day for the member account.
        @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageByDatasourcePackage instead.")
        public var volumeUsageInBytes: Swift.Int?
        /// The data and time when the member account data volume was last updated. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageByDatasourcePackage instead.")
        public var volumeUsageUpdatedTime: ClientRuntime.Date?

        public init (
            accountId: Swift.String? = nil,
            administratorId: Swift.String? = nil,
            datasourcePackageIngestStates: [Swift.String:DetectiveClientTypes.DatasourcePackageIngestState]? = nil,
            disabledReason: DetectiveClientTypes.MemberDisabledReason? = nil,
            emailAddress: Swift.String? = nil,
            graphArn: Swift.String? = nil,
            invitationType: DetectiveClientTypes.InvitationType? = nil,
            invitedTime: ClientRuntime.Date? = nil,
            masterId: Swift.String? = nil,
            percentOfGraphUtilization: Swift.Double? = nil,
            percentOfGraphUtilizationUpdatedTime: ClientRuntime.Date? = nil,
            status: DetectiveClientTypes.MemberStatus? = nil,
            updatedTime: ClientRuntime.Date? = nil,
            volumeUsageByDatasourcePackage: [Swift.String:DetectiveClientTypes.DatasourcePackageUsageInfo]? = nil,
            volumeUsageInBytes: Swift.Int? = nil,
            volumeUsageUpdatedTime: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.administratorId = administratorId
            self.datasourcePackageIngestStates = datasourcePackageIngestStates
            self.disabledReason = disabledReason
            self.emailAddress = emailAddress
            self.graphArn = graphArn
            self.invitationType = invitationType
            self.invitedTime = invitedTime
            self.masterId = masterId
            self.percentOfGraphUtilization = percentOfGraphUtilization
            self.percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTime
            self.status = status
            self.updatedTime = updatedTime
            self.volumeUsageByDatasourcePackage = volumeUsageByDatasourcePackage
            self.volumeUsageInBytes = volumeUsageInBytes
            self.volumeUsageUpdatedTime = volumeUsageUpdatedTime
        }
    }

}

extension DetectiveClientTypes {
    public enum MemberDisabledReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case volumeTooHigh
        case volumeUnknown
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberDisabledReason] {
            return [
                .volumeTooHigh,
                .volumeUnknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .volumeTooHigh: return "VOLUME_TOO_HIGH"
            case .volumeUnknown: return "VOLUME_UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberDisabledReason(rawValue: rawValue) ?? MemberDisabledReason.sdkUnknown(rawValue)
        }
    }
}

extension DetectiveClientTypes {
    public enum MemberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acceptedButDisabled
        case enabled
        case invited
        case verificationFailed
        case verificationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberStatus] {
            return [
                .acceptedButDisabled,
                .enabled,
                .invited,
                .verificationFailed,
                .verificationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acceptedButDisabled: return "ACCEPTED_BUT_DISABLED"
            case .enabled: return "ENABLED"
            case .invited: return "INVITED"
            case .verificationFailed: return "VERIFICATION_FAILED"
            case .verificationInProgress: return "VERIFICATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberStatus(rawValue: rawValue) ?? MemberStatus.sdkUnknown(rawValue)
        }
    }
}

extension DetectiveClientTypes.MembershipDatasources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case datasourcePackageIngestHistory = "DatasourcePackageIngestHistory"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let datasourcePackageIngestHistory = datasourcePackageIngestHistory {
            var datasourcePackageIngestHistoryContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .datasourcePackageIngestHistory)
            for (dictKey0, datasourcePackageIngestHistory0) in datasourcePackageIngestHistory {
                var datasourcePackageIngestHistory0Container = datasourcePackageIngestHistoryContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, lastIngestStateChangeDates1) in datasourcePackageIngestHistory0 {
                    try datasourcePackageIngestHistory0Container.encode(lastIngestStateChangeDates1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let datasourcePackageIngestHistoryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: DetectiveClientTypes.TimestampForCollection?]?].self, forKey: .datasourcePackageIngestHistory)
        var datasourcePackageIngestHistoryDecoded0: [Swift.String:[Swift.String:DetectiveClientTypes.TimestampForCollection]]? = nil
        if let datasourcePackageIngestHistoryContainer = datasourcePackageIngestHistoryContainer {
            datasourcePackageIngestHistoryDecoded0 = [Swift.String:[Swift.String:DetectiveClientTypes.TimestampForCollection]]()
            for (key0, lastingeststatechangedates0) in datasourcePackageIngestHistoryContainer {
                var lastingeststatechangedates0Decoded0: [Swift.String: DetectiveClientTypes.TimestampForCollection]? = nil
                if let lastingeststatechangedates0 = lastingeststatechangedates0 {
                    lastingeststatechangedates0Decoded0 = [Swift.String: DetectiveClientTypes.TimestampForCollection]()
                    for (key1, timestampforcollection1) in lastingeststatechangedates0 {
                        if let timestampforcollection1 = timestampforcollection1 {
                            lastingeststatechangedates0Decoded0?[key1] = timestampforcollection1
                        }
                    }
                }
                datasourcePackageIngestHistoryDecoded0?[key0] = lastingeststatechangedates0Decoded0
            }
        }
        datasourcePackageIngestHistory = datasourcePackageIngestHistoryDecoded0
    }
}

extension DetectiveClientTypes {
    /// Details on data source packages for members of the behavior graph.
    public struct MembershipDatasources: Swift.Equatable {
        /// The account identifier of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// Details on when a data source package was added to a behavior graph.
        public var datasourcePackageIngestHistory: [Swift.String:[Swift.String:DetectiveClientTypes.TimestampForCollection]]?
        /// The ARN of the organization behavior graph.
        public var graphArn: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            datasourcePackageIngestHistory: [Swift.String:[Swift.String:DetectiveClientTypes.TimestampForCollection]]? = nil,
            graphArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.datasourcePackageIngestHistory = datasourcePackageIngestHistory
            self.graphArn = graphArn
        }
    }

}

extension RejectInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension RejectInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/removal"
    }
}

public struct RejectInvitationInput: Swift.Equatable {
    /// The ARN of the behavior graph to reject the invitation to. The member account's current member status in the behavior graph must be INVITED.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct RejectInvitationInputBody: Swift.Equatable {
    let graphArn: Swift.String?
}

extension RejectInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension RejectInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RejectInvitationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RejectInvitationOutputResponse: Swift.Equatable {

    public init () { }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request refers to a nonexistent resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resources = output.resources
        } else {
            self.message = nil
            self.resources = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request cannot be completed for one of the following reasons.
///
/// * The request would cause the number of member accounts in the behavior graph to exceed the maximum allowed. A behavior graph cannot have more than 1200 member accounts.
///
/// * The request would cause the data rate for the behavior graph to exceed the maximum allowed.
///
/// * Detective is unable to verify the data rate for the member account. This is usually because the member account is not enrolled in Amazon GuardDuty.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The type of resource that has exceeded the service quota.
    public var resources: [Swift.String]?

    public init (
        message: Swift.String? = nil,
        resources: [Swift.String]? = nil
    )
    {
        self.message = message
        self.resources = resources
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resources: [Swift.String]?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resources = "Resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension StartMonitoringMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension StartMonitoringMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/member/monitoringstate"
    }
}

public struct StartMonitoringMemberInput: Swift.Equatable {
    /// The account ID of the member account to try to enable. The account must be an invited member account with a status of ACCEPTED_BUT_DISABLED.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.graphArn = graphArn
    }
}

struct StartMonitoringMemberInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let accountId: Swift.String?
}

extension StartMonitoringMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension StartMonitoringMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMonitoringMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartMonitoringMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMonitoringMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartMonitoringMemberOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the behavior graph to assign the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the behavior graph. You can add up to 50 tags. For each tag, you provide the tag key and the tag value. Each tag key can contain up to 128 characters. Each tag value can contain up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DetectiveClientTypes.TimestampForCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension DetectiveClientTypes {
    /// Details on when data collection began for a source package.
    public struct TimestampForCollection: Swift.Equatable {
        /// The data and time when data collection began for a source package. The value is an ISO8601 formatted string. For example, 2021-08-18T16:35:56.284Z.
        public var timestamp: ClientRuntime.Date?

        public init (
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.timestamp = timestamp
        }
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be completed because too many other requests are occurring at the same time.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DetectiveClientTypes.UnprocessedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DetectiveClientTypes {
    /// A member account that was included in a request but for which the request could not be processed.
    public struct UnprocessedAccount: Swift.Equatable {
        /// The Amazon Web Services account identifier of the member account that was not processed.
        public var accountId: Swift.String?
        /// The reason that the member account request could not be processed.
        public var reason: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.reason = reason
        }
    }

}

extension DetectiveClientTypes.UnprocessedGraph: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DetectiveClientTypes {
    /// Behavior graphs that could not be processed in the request.
    public struct UnprocessedGraph: Swift.Equatable {
        /// The ARN of the organization behavior graph.
        public var graphArn: Swift.String?
        /// The reason data source package information could not be processed for a behavior graph.
        public var reason: Swift.String?

        public init (
            graphArn: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.graphArn = graphArn
            self.reason = reason
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the behavior graph to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove from the behavior graph. You can remove up to 50 tags at a time.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDatasourcePackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasourcePackages = "DatasourcePackages"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasourcePackages = datasourcePackages {
            var datasourcePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasourcePackages)
            for datasourcepackage0 in datasourcePackages {
                try datasourcePackagesContainer.encode(datasourcepackage0.rawValue)
            }
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension UpdateDatasourcePackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/graph/datasources/update"
    }
}

public struct UpdateDatasourcePackagesInput: Swift.Equatable {
    /// The data source package start for the behavior graph.
    /// This member is required.
    public var datasourcePackages: [DetectiveClientTypes.DatasourcePackage]?
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        datasourcePackages: [DetectiveClientTypes.DatasourcePackage]? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.datasourcePackages = datasourcePackages
        self.graphArn = graphArn
    }
}

struct UpdateDatasourcePackagesInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let datasourcePackages: [DetectiveClientTypes.DatasourcePackage]?
}

extension UpdateDatasourcePackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasourcePackages = "DatasourcePackages"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let datasourcePackagesContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.DatasourcePackage?].self, forKey: .datasourcePackages)
        var datasourcePackagesDecoded0:[DetectiveClientTypes.DatasourcePackage]? = nil
        if let datasourcePackagesContainer = datasourcePackagesContainer {
            datasourcePackagesDecoded0 = [DetectiveClientTypes.DatasourcePackage]()
            for enum0 in datasourcePackagesContainer {
                if let enum0 = enum0 {
                    datasourcePackagesDecoded0?.append(enum0)
                }
            }
        }
        datasourcePackages = datasourcePackagesDecoded0
    }
}

extension UpdateDatasourcePackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasourcePackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatasourcePackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasourcePackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasourcePackagesOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "AutoEnable"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
        if let graphArn = self.graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/orgs/updateOrganizationConfiguration"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Indicates whether to automatically enable new organization accounts as member accounts in the organization behavior graph.
    public var autoEnable: Swift.Bool
    /// The ARN of the organization behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        autoEnable: Swift.Bool = false,
        graphArn: Swift.String? = nil
    )
    {
        self.autoEnable = autoEnable
        self.graphArn = graphArn
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let graphArn: Swift.String?
    let autoEnable: Swift.Bool
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "AutoEnable"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.errorCodeReason = output.errorCodeReason
            self.message = output.message
        } else {
            self.errorCode = nil
            self.errorCodeReason = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request parameters are invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code associated with the validation failure.
    public var errorCode: DetectiveClientTypes.ErrorCode?
    /// An explanation of why validation failed.
    public var errorCodeReason: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: DetectiveClientTypes.ErrorCode? = nil,
        errorCodeReason: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorCodeReason = errorCodeReason
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: DetectiveClientTypes.ErrorCode?
    let errorCodeReason: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorCodeReason = "ErrorCodeReason"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorCodeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCodeReason)
        errorCodeReason = errorCodeReasonDecoded
    }
}
