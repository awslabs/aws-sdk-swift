//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension MediaTailorClientTypes {

    /// For SCTE35_ENHANCED output, defines a key and corresponding value. MediaTailor generates these pairs within the EXT-X-ASSETtag.
    public struct KeyValuePair: Swift.Sendable {
        /// For SCTE35_ENHANCED output, defines a key. MediaTailor takes this key, and its associated value, and generates the key/value pair within the EXT-X-ASSETtag. If you specify a key, you must also specify a corresponding value.
        /// This member is required.
        public var key: Swift.String?
        /// For SCTE35_ENHANCED output, defines a value. MediaTailor; takes this value, and its associated key, and generates the key/value pair within the EXT-X-ASSETtag. If you specify a value, you must also specify a corresponding key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension MediaTailorClientTypes {

    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case spliceInsert
        case timeSignal
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .spliceInsert,
                .timeSignal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .spliceInsert: return "SPLICE_INSERT"
            case .timeSignal: return "TIME_SIGNAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// Slate VOD source configuration.
    public struct SlateSource: Swift.Sendable {
        /// The name of the source location where the slate VOD source is stored.
        public var sourceLocationName: Swift.String?
        /// The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.
        public var vodSourceName: Swift.String?

        public init(
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }
}

extension MediaTailorClientTypes {

    /// Splice insert message configuration.
    public struct SpliceInsertMessage: Swift.Sendable {
        /// This is written to splice_insert.avail_num, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var availNum: Swift.Int?
        /// This is written to splice_insert.avails_expected, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var availsExpected: Swift.Int?
        /// This is written to splice_insert.splice_event_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 1.
        public var spliceEventId: Swift.Int?
        /// This is written to splice_insert.unique_program_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var uniqueProgramId: Swift.Int?

        public init(
            availNum: Swift.Int? = nil,
            availsExpected: Swift.Int? = nil,
            spliceEventId: Swift.Int? = nil,
            uniqueProgramId: Swift.Int? = nil
        )
        {
            self.availNum = availNum
            self.availsExpected = availsExpected
            self.spliceEventId = spliceEventId
            self.uniqueProgramId = uniqueProgramId
        }
    }
}

extension MediaTailorClientTypes {

    /// The segmentation_descriptor message can contain advanced metadata fields, like content identifiers, to convey a wide range of information about the ad break. MediaTailor writes the ad metadata in the egress manifest as part of the EXT-X-DATERANGE or EventStream ad marker's SCTE-35 data. segmentation_descriptor messages must be sent with the time_signal message type. See the segmentation_descriptor() table of the 2022 SCTE-35 specification for more information.
    public struct SegmentationDescriptor: Swift.Sendable {
        /// The segment number to assign to the segmentation_descriptor.segment_num message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.
        public var segmentNum: Swift.Int?
        /// The Event Identifier to assign to the segmentation_descriptor.segmentation_event_id message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.
        public var segmentationEventId: Swift.Int?
        /// The Type Identifier to assign to the segmentation_descriptor.segmentation_type_id message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.
        public var segmentationTypeId: Swift.Int?
        /// The Upid to assign to the segmentation_descriptor.segmentation_upid message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).
        public var segmentationUpid: Swift.String?
        /// The Upid Type to assign to the segmentation_descriptor.segmentation_upid_type message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.
        public var segmentationUpidType: Swift.Int?
        /// The number of segments expected, which is assigned to the segmentation_descriptor.segments_expectedS message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.
        public var segmentsExpected: Swift.Int?
        /// The sub-segment number to assign to the segmentation_descriptor.sub_segment_num message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.
        public var subSegmentNum: Swift.Int?
        /// The number of sub-segments expected, which is assigned to the segmentation_descriptor.sub_segments_expected message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.
        public var subSegmentsExpected: Swift.Int?

        public init(
            segmentNum: Swift.Int? = nil,
            segmentationEventId: Swift.Int? = nil,
            segmentationTypeId: Swift.Int? = nil,
            segmentationUpid: Swift.String? = nil,
            segmentationUpidType: Swift.Int? = nil,
            segmentsExpected: Swift.Int? = nil,
            subSegmentNum: Swift.Int? = nil,
            subSegmentsExpected: Swift.Int? = nil
        )
        {
            self.segmentNum = segmentNum
            self.segmentationEventId = segmentationEventId
            self.segmentationTypeId = segmentationTypeId
            self.segmentationUpid = segmentationUpid
            self.segmentationUpidType = segmentationUpidType
            self.segmentsExpected = segmentsExpected
            self.subSegmentNum = subSegmentNum
            self.subSegmentsExpected = subSegmentsExpected
        }
    }
}

extension MediaTailorClientTypes {

    /// The SCTE-35 time_signal message can be sent with one or more segmentation_descriptor messages. A time_signal message can be sent only if a single segmentation_descriptor message is sent. The time_signal message contains only the splice_time field which is constructed using a given presentation timestamp. When sending a time_signal message, the splice_command_type field in the splice_info_section message is set to 6 (0x06). See the time_signal() table of the 2022 SCTE-35 specification for more information.
    public struct TimeSignalMessage: Swift.Sendable {
        /// The configurations for the SCTE-35 segmentation_descriptor message(s) sent with the time_signal message.
        public var segmentationDescriptors: [MediaTailorClientTypes.SegmentationDescriptor]?

        public init(
            segmentationDescriptors: [MediaTailorClientTypes.SegmentationDescriptor]? = nil
        )
        {
            self.segmentationDescriptors = segmentationDescriptors
        }
    }
}

extension MediaTailorClientTypes {

    /// Ad break configuration parameters.
    public struct AdBreak: Swift.Sendable {
        /// Defines a list of key/value pairs that MediaTailor generates within the EXT-X-ASSETtag for SCTE35_ENHANCED output.
        public var adBreakMetadata: [MediaTailorClientTypes.KeyValuePair]?
        /// The SCTE-35 ad insertion type. Accepted value: SPLICE_INSERT, TIME_SIGNAL.
        public var messageType: MediaTailorClientTypes.MessageType?
        /// How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.
        /// This member is required.
        public var offsetMillis: Swift.Int?
        /// Ad break slate configuration.
        public var slate: MediaTailorClientTypes.SlateSource?
        /// This defines the SCTE-35 splice_insert() message inserted around the ad. For information about using splice_insert(), see the SCTE-35 specficiaiton, section 9.7.3.1.
        public var spliceInsertMessage: MediaTailorClientTypes.SpliceInsertMessage?
        /// Defines the SCTE-35 time_signal message inserted around the ad. Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a splice_insert SCTE-35 message to the ad break. This message provides basic metadata about the ad break. See section 9.7.4 of the 2022 SCTE-35 specification for more information.
        public var timeSignalMessage: MediaTailorClientTypes.TimeSignalMessage?

        public init(
            adBreakMetadata: [MediaTailorClientTypes.KeyValuePair]? = nil,
            messageType: MediaTailorClientTypes.MessageType? = nil,
            offsetMillis: Swift.Int? = nil,
            slate: MediaTailorClientTypes.SlateSource? = nil,
            spliceInsertMessage: MediaTailorClientTypes.SpliceInsertMessage? = nil,
            timeSignalMessage: MediaTailorClientTypes.TimeSignalMessage? = nil
        )
        {
            self.adBreakMetadata = adBreakMetadata
            self.messageType = messageType
            self.offsetMillis = offsetMillis
            self.slate = slate
            self.spliceInsertMessage = spliceInsertMessage
            self.timeSignalMessage = timeSignalMessage
        }
    }
}

extension MediaTailorClientTypes {

    public enum AlertCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case info
        case playbackWarning
        case schedulingError
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertCategory] {
            return [
                .info,
                .playbackWarning,
                .schedulingError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .info: return "INFO"
            case .playbackWarning: return "PLAYBACK_WARNING"
            case .schedulingError: return "SCHEDULING_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// Alert configuration parameters.
    public struct Alert: Swift.Sendable {
        /// The code for the alert. For example, NOT_PROCESSED.
        /// This member is required.
        public var alertCode: Swift.String?
        /// If an alert is generated for a resource, an explanation of the reason for the alert.
        /// This member is required.
        public var alertMessage: Swift.String?
        /// The category that MediaTailor assigns to the alert.
        public var category: MediaTailorClientTypes.AlertCategory?
        /// The timestamp when the alert was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Names (ARNs) related to this alert.
        /// This member is required.
        public var relatedResourceArns: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            alertCode: Swift.String? = nil,
            alertMessage: Swift.String? = nil,
            category: MediaTailorClientTypes.AlertCategory? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            relatedResourceArns: [Swift.String]? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.alertCode = alertCode
            self.alertMessage = alertMessage
            self.category = category
            self.lastModifiedTime = lastModifiedTime
            self.relatedResourceArns = relatedResourceArns
            self.resourceArn = resourceArn
        }
    }
}

extension MediaTailorClientTypes {

    /// Clip range configuration for the VOD source associated with the program.
    public struct ClipRange: Swift.Sendable {
        /// The end offset of the clip range, in milliseconds, starting from the beginning of the VOD source associated with the program.
        public var endOffsetMillis: Swift.Int?
        /// The start offset of the clip range, in milliseconds. This offset truncates the start at the number of milliseconds into the duration of the VOD source.
        public var startOffsetMillis: Swift.Int?

        public init(
            endOffsetMillis: Swift.Int? = nil,
            startOffsetMillis: Swift.Int? = nil
        )
        {
            self.endOffsetMillis = endOffsetMillis
            self.startOffsetMillis = startOffsetMillis
        }
    }
}

extension MediaTailorClientTypes {

    /// A playlist of media (VOD and/or live) to be played instead of the default media on a particular program.
    public struct AlternateMedia: Swift.Sendable {
        /// Ad break configuration parameters defined in AlternateMedia.
        public var adBreaks: [MediaTailorClientTypes.AdBreak]?
        /// Clip range configuration for the VOD source associated with the program.
        public var clipRange: MediaTailorClientTypes.ClipRange?
        /// The duration of the alternateMedia in milliseconds.
        public var durationMillis: Swift.Int?
        /// The name of the live source for alternateMedia.
        public var liveSourceName: Swift.String?
        /// The date and time that the alternateMedia is scheduled to start, in epoch milliseconds.
        public var scheduledStartTimeMillis: Swift.Int?
        /// The name of the source location for alternateMedia.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source for alternateMedia.
        public var vodSourceName: Swift.String?

        public init(
            adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
            clipRange: MediaTailorClientTypes.ClipRange? = nil,
            durationMillis: Swift.Int? = nil,
            liveSourceName: Swift.String? = nil,
            scheduledStartTimeMillis: Swift.Int? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.adBreaks = adBreaks
            self.clipRange = clipRange
            self.durationMillis = durationMillis
            self.liveSourceName = liveSourceName
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }
}

extension MediaTailorClientTypes {

    /// An AudienceMedia object contains an Audience and a list of AlternateMedia.
    public struct AudienceMedia: Swift.Sendable {
        /// The list of AlternateMedia defined in AudienceMedia.
        public var alternateMedia: [MediaTailorClientTypes.AlternateMedia]?
        /// The Audience defined in AudienceMedia.
        public var audience: Swift.String?

        public init(
            alternateMedia: [MediaTailorClientTypes.AlternateMedia]? = nil,
            audience: Swift.String? = nil
        )
        {
            self.alternateMedia = alternateMedia
            self.audience = audience
        }
    }
}

extension MediaTailorClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// MediaTailor only places (consumes) prefetched ads if the ad break meets the criteria defined by the dynamic variables. This gives you granular control over which ad break to place the prefetched ads into. As an example, let's say that you set DynamicVariable to scte.event_id and Operator to EQUALS, and your playback configuration has an ADS URL of https://my.ads.server.com/path?&podId=[scte.avail_num]&event=[scte.event_id]&duration=[session.avail_duration_secs]. And the prefetch request to the ADS contains these values https://my.ads.server.com/path?&podId=3&event=my-awesome-event&duration=30. MediaTailor will only insert the prefetched ads into the ad break if has a SCTE marker with an event id of my-awesome-event, since it must match the event id that MediaTailor uses to query the ADS. You can specify up to five AvailMatchingCriteria. If you specify multiple AvailMatchingCriteria, MediaTailor combines them to match using a logical AND. You can model logical OR combinations by creating multiple prefetch schedules.
    public struct AvailMatchingCriteria: Swift.Sendable {
        /// The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see [Using dynamic ad variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html) in the MediaTailor User Guide. You can include up to 100 dynamic variables.
        /// This member is required.
        public var dynamicVariable: Swift.String?
        /// For the DynamicVariable specified in AvailMatchingCriteria, the Operator that is used for the comparison.
        /// This member is required.
        public var `operator`: MediaTailorClientTypes.Operator?

        public init(
            dynamicVariable: Swift.String? = nil,
            `operator`: MediaTailorClientTypes.Operator? = nil
        )
        {
            self.dynamicVariable = dynamicVariable
            self.`operator` = `operator`
        }
    }
}

extension MediaTailorClientTypes {

    public enum LogType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asRun
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .asRun
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asRun: return "AS_RUN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The log configuration for the channel.
    public struct LogConfigurationForChannel: Swift.Sendable {
        /// The log types.
        public var logTypes: [MediaTailorClientTypes.LogType]?

        public init(
            logTypes: [MediaTailorClientTypes.LogType]? = nil
        )
        {
            self.logTypes = logTypes
        }
    }
}

extension MediaTailorClientTypes {

    /// Dash manifest configuration parameters.
    public struct DashPlaylistSettings: Swift.Sendable {
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public var manifestWindowSeconds: Swift.Int?
        /// Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var minBufferTimeSeconds: Swift.Int?
        /// Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var minUpdatePeriodSeconds: Swift.Int?
        /// Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var suggestedPresentationDelaySeconds: Swift.Int?

        public init(
            manifestWindowSeconds: Swift.Int? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            minUpdatePeriodSeconds: Swift.Int? = nil,
            suggestedPresentationDelaySeconds: Swift.Int? = nil
        )
        {
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        }
    }
}

extension MediaTailorClientTypes {

    public enum AdMarkupType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daterange
        case scte35Enhanced
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkupType] {
            return [
                .daterange,
                .scte35Enhanced
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daterange: return "DATERANGE"
            case .scte35Enhanced: return "SCTE35_ENHANCED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// HLS playlist configuration parameters.
    public struct HlsPlaylistSettings: Swift.Sendable {
        /// Determines the type of SCTE 35 tags to use in ad markup. Specify DATERANGE to use DATERANGE tags (for live or VOD content). Specify SCTE35_ENHANCED to use EXT-X-CUE-OUT and EXT-X-CUE-IN tags (for VOD content only).
        public var adMarkupType: [MediaTailorClientTypes.AdMarkupType]?
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public var manifestWindowSeconds: Swift.Int?

        public init(
            adMarkupType: [MediaTailorClientTypes.AdMarkupType]? = nil,
            manifestWindowSeconds: Swift.Int? = nil
        )
        {
            self.adMarkupType = adMarkupType
            self.manifestWindowSeconds = manifestWindowSeconds
        }
    }
}

extension MediaTailorClientTypes {

    /// The output item response.
    public struct ResponseOutputItem: Swift.Sendable {
        /// DASH manifest configuration settings.
        public var dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings?
        /// HLS manifest configuration settings.
        public var hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings?
        /// The name of the manifest for the channel that will appear in the channel output's playback URL.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The URL used for playback by content players.
        /// This member is required.
        public var playbackUrl: Swift.String?
        /// A string used to associate a package configuration source group with a channel output.
        /// This member is required.
        public var sourceGroup: Swift.String?

        public init(
            dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings? = nil,
            hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings? = nil,
            manifestName: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            sourceGroup: Swift.String? = nil
        )
        {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.playbackUrl = playbackUrl
            self.sourceGroup = sourceGroup
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration parameters for a channel. For information about MediaTailor channels, see [Working with channels](https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html) in the MediaTailor User Guide.
    public struct Channel: Swift.Sendable {
        /// The ARN of the channel.
        /// This member is required.
        public var arn: Swift.String?
        /// The list of audiences defined in channel.
        public var audiences: [Swift.String]?
        /// The name of the channel.
        /// This member is required.
        public var channelName: Swift.String?
        /// Returns the state whether the channel is running or not.
        /// This member is required.
        public var channelState: Swift.String?
        /// The timestamp of when the channel was created.
        public var creationTime: Foundation.Date?
        /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
        public var fillerSlate: MediaTailorClientTypes.SlateSource?
        /// The timestamp of when the channel was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The log configuration.
        /// This member is required.
        public var logConfiguration: MediaTailorClientTypes.LogConfigurationForChannel?
        /// The channel's output properties.
        /// This member is required.
        public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
        /// The type of playback mode for this channel. LINEAR - Programs play back-to-back only once. LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
        /// This member is required.
        public var playbackMode: Swift.String?
        /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String: Swift.String]?
        /// The tier for this channel. STANDARD tier channels can contain live programs.
        /// This member is required.
        public var tier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            audiences: [Swift.String]? = nil,
            channelName: Swift.String? = nil,
            channelState: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            logConfiguration: MediaTailorClientTypes.LogConfigurationForChannel? = nil,
            outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
            playbackMode: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            tier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.logConfiguration = logConfiguration
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
        }
    }
}

extension MediaTailorClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dash
        case hls
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .dash,
                .hls
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .hls: return "HLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The HTTP package configuration properties for the requested VOD source.
    public struct HttpPackageConfiguration: Swift.Sendable {
        /// The relative path to the URL for this VOD source. This is combined with SourceLocation::HttpConfiguration::BaseUrl to form a valid URL.
        /// This member is required.
        public var path: Swift.String?
        /// The name of the source group. This has to match one of the Channel::Outputs::SourceGroup.
        /// This member is required.
        public var sourceGroup: Swift.String?
        /// The streaming protocol for this package configuration. Supported values are HLS and DASH.
        /// This member is required.
        public var type: MediaTailorClientTypes.ModelType?

        public init(
            path: Swift.String? = nil,
            sourceGroup: Swift.String? = nil,
            type: MediaTailorClientTypes.ModelType? = nil
        )
        {
            self.path = path
            self.sourceGroup = sourceGroup
            self.type = type
        }
    }
}

extension MediaTailorClientTypes {

    /// Live source configuration parameters.
    public struct LiveSource: Swift.Sendable {
        /// The ARN for the live source.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the live source was created.
        public var creationTime: Foundation.Date?
        /// The HTTP package configurations for the live source.
        /// This member is required.
        public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
        /// The timestamp that indicates when the live source was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name that's used to refer to a live source.
        /// This member is required.
        public var liveSourceName: Swift.String?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            liveSourceName: Swift.String? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }
    }
}

extension MediaTailorClientTypes {

    public enum FillPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullAvailOnly
        case partialAvail
        case sdkUnknown(Swift.String)

        public static var allCases: [FillPolicy] {
            return [
                .fullAvailOnly,
                .partialAvail
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullAvailOnly: return "FULL_AVAIL_ONLY"
            case .partialAvail: return "PARTIAL_AVAIL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    public enum Mode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterLiveEdge
        case behindLiveEdge
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .afterLiveEdge,
                .behindLiveEdge,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterLiveEdge: return "AFTER_LIVE_EDGE"
            case .behindLiveEdge: return "BEHIND_LIVE_EDGE"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public struct AvailSuppression: Swift.Sendable {
        /// Defines the policy to apply to the avail suppression mode. BEHIND_LIVE_EDGE will always use the full avail suppression policy. AFTER_LIVE_EDGE mode can be used to invoke partial ad break fills when a session starts mid-break.
        public var fillPolicy: MediaTailorClientTypes.FillPolicy?
        /// Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window. When Mode is set to AFTER_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks that are within the live edge plus the avail suppression value.
        public var mode: MediaTailorClientTypes.Mode?
        /// A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.
        public var value: Swift.String?

        public init(
            fillPolicy: MediaTailorClientTypes.FillPolicy? = nil,
            mode: MediaTailorClientTypes.Mode? = nil,
            value: Swift.String? = nil
        )
        {
            self.fillPolicy = fillPolicy
            self.mode = mode
            self.value = value
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public struct Bumper: Swift.Sendable {
        /// The URL for the end bumper asset.
        public var endUrl: Swift.String?
        /// The URL for the start bumper asset.
        public var startUrl: Swift.String?

        public init(
            endUrl: Swift.String? = nil,
            startUrl: Swift.String? = nil
        )
        {
            self.endUrl = endUrl
            self.startUrl = startUrl
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public struct CdnConfiguration: Swift.Sendable {
        /// A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.<region>.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.
        public var adSegmentUrlPrefix: Swift.String?
        /// A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.
        public var contentSegmentUrlPrefix: Swift.String?

        public init(
            adSegmentUrlPrefix: Swift.String? = nil,
            contentSegmentUrlPrefix: Swift.String? = nil
        )
        {
            self.adSegmentUrlPrefix = adSegmentUrlPrefix
            self.contentSegmentUrlPrefix = contentSegmentUrlPrefix
        }
    }
}

extension MediaTailorClientTypes {

    public enum OriginManifestType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiPeriod
        case singlePeriod
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginManifestType] {
            return [
                .multiPeriod,
                .singlePeriod
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiPeriod: return "MULTI_PERIOD"
            case .singlePeriod: return "SINGLE_PERIOD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for DASH content.
    public struct DashConfiguration: Swift.Sendable {
        /// The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.
        public var manifestEndpointPrefix: Swift.String?
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public var mpdLocation: Swift.String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public var originManifestType: MediaTailorClientTypes.OriginManifestType?

        public init(
            manifestEndpointPrefix: Swift.String? = nil,
            mpdLocation: Swift.String? = nil,
            originManifestType: MediaTailorClientTypes.OriginManifestType? = nil
        )
        {
            self.manifestEndpointPrefix = manifestEndpointPrefix
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for HLS content.
    public struct HlsConfiguration: Swift.Sendable {
        /// The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.
        public var manifestEndpointPrefix: Swift.String?

        public init(
            manifestEndpointPrefix: Swift.String? = nil
        )
        {
            self.manifestEndpointPrefix = manifestEndpointPrefix
        }
    }
}

extension MediaTailorClientTypes {

    /// Insertion Mode controls whether players can use stitched or guided ad insertion.
    public enum InsertionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case playerSelect
        case stitchedOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [InsertionMode] {
            return [
                .playerSelect,
                .stitchedOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .playerSelect: return "PLAYER_SELECT"
            case .stitchedOnly: return "STITCHED_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for pre-roll ad insertion.
    public struct LivePreRollConfiguration: Swift.Sendable {
        /// The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
        public var adDecisionServerUrl: Swift.String?
        /// The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
        public var maxDurationSeconds: Swift.Int?

        public init(
            adDecisionServerUrl: Swift.String? = nil,
            maxDurationSeconds: Swift.Int? = nil
        )
        {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.maxDurationSeconds = maxDurationSeconds
        }
    }
}

extension MediaTailorClientTypes {

    /// Returns Amazon CloudWatch log settings for a playback configuration.
    public struct LogConfiguration: Swift.Sendable {
        /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the [debug log mode](https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html). Valid values: 0 - 100
        /// This member is required.
        public var percentEnabled: Swift.Int?

        public init(
            percentEnabled: Swift.Int? = nil
        )
        {
            self.percentEnabled = percentEnabled
        }
    }
}

extension MediaTailorClientTypes {

    /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
    public struct AdMarkerPassthrough: Swift.Sendable {
        /// Enables ad marker passthrough for your configuration.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public struct ManifestProcessingRules: Swift.Sendable {
        /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
        public var adMarkerPassthrough: MediaTailorClientTypes.AdMarkerPassthrough?

        public init(
            adMarkerPassthrough: MediaTailorClientTypes.AdMarkerPassthrough? = nil
        )
        {
            self.adMarkerPassthrough = adMarkerPassthrough
        }
    }
}

extension MediaTailorClientTypes {

    /// A playback configuration. For information about MediaTailor configurations, see [Working with configurations in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html).
    public struct PlaybackConfiguration: Swift.Sendable {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
        public var adDecisionServerUrl: Swift.String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
        public var availSuppression: MediaTailorClientTypes.AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
        public var bumper: MediaTailorClientTypes.Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
        public var configurationAliases: [Swift.String: [Swift.String: Swift.String]]?
        /// The configuration for a DASH source.
        public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
        /// The configuration for HLS content.
        public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
        /// The setting that controls whether players can use stitched or guided ad insertion. The default, STITCHED_ONLY, forces all player sessions to use stitched (server-side) ad insertion. Choosing PLAYER_SELECT allows players to select either stitched or guided ad insertion at session-initialization time. The default for players that do not specify an insertion mode is stitched.
        public var insertionMode: MediaTailorClientTypes.InsertionMode?
        /// The configuration for pre-roll ad insertion.
        public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
        /// The Amazon CloudWatch log settings for a playback configuration.
        public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public var name: Swift.String?
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
        public var personalizationThresholdSeconds: Swift.Int?
        /// The Amazon Resource Name (ARN) for the playback configuration.
        public var playbackConfigurationArn: Swift.String?
        /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.
        public var playbackEndpointPrefix: Swift.String?
        /// The URL that the player uses to initialize a session that uses client-side reporting.
        public var sessionInitializationEndpointPrefix: Swift.String?
        /// The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public var slateAdUrl: Swift.String?
        /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String: Swift.String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public var transcodeProfileName: Swift.String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public var videoContentSourceUrl: Swift.String?

        public init(
            adDecisionServerUrl: Swift.String? = nil,
            availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
            bumper: MediaTailorClientTypes.Bumper? = nil,
            cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
            configurationAliases: [Swift.String: [Swift.String: Swift.String]]? = nil,
            dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
            hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
            insertionMode: MediaTailorClientTypes.InsertionMode? = nil,
            livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
            logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
            manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
            name: Swift.String? = nil,
            personalizationThresholdSeconds: Swift.Int? = nil,
            playbackConfigurationArn: Swift.String? = nil,
            playbackEndpointPrefix: Swift.String? = nil,
            sessionInitializationEndpointPrefix: Swift.String? = nil,
            slateAdUrl: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            transcodeProfileName: Swift.String? = nil,
            videoContentSourceUrl: Swift.String? = nil
        )
        {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.hlsConfiguration = hlsConfiguration
            self.insertionMode = insertionMode
            self.livePreRollConfiguration = livePreRollConfiguration
            self.logConfiguration = logConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.playbackConfigurationArn = playbackConfigurationArn
            self.playbackEndpointPrefix = playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }
    }
}

extension MediaTailorClientTypes {

    /// A complex type that contains settings that determine how and when that MediaTailor places prefetched ads into upcoming ad breaks.
    public struct PrefetchConsumption: Swift.Sendable {
        /// If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as scte.event_id, set the avail matching criteria.
        public var availMatchingCriteria: [MediaTailorClientTypes.AvailMatchingCriteria]?
        /// The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call DeletePrefetchSchedule.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The time when prefetched ads are considered for use in an ad break. If you don't specify StartTime, the prefetched ads are available after MediaTailor retrives them from the ad decision server.
        public var startTime: Foundation.Date?

        public init(
            availMatchingCriteria: [MediaTailorClientTypes.AvailMatchingCriteria]? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.availMatchingCriteria = availMatchingCriteria
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension MediaTailorClientTypes {

    /// A complex type that contains settings governing when MediaTailor prefetches ads, and which dynamic variables that MediaTailor includes in the request to the ad decision server.
    public struct PrefetchRetrieval: Swift.Sendable {
        /// The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS). You initially configure [dynamic variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html) for the ADS URL when you set up your playback configuration. When you specify DynamicVariables for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.
        public var dynamicVariables: [Swift.String: Swift.String]?
        /// The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.
        public var startTime: Foundation.Date?

        public init(
            dynamicVariables: [Swift.String: Swift.String]? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.dynamicVariables = dynamicVariables
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension MediaTailorClientTypes {

    /// A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see [Using ad prefetching](https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html) in the MediaTailor User Guide.
    public struct PrefetchSchedule: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the prefetch schedule.
        /// This member is required.
        public var arn: Swift.String?
        /// Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a consumption window. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.
        /// This member is required.
        public var consumption: MediaTailorClientTypes.PrefetchConsumption?
        /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the playback configuration to create the prefetch schedule for.
        /// This member is required.
        public var playbackConfigurationName: Swift.String?
        /// A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).
        /// This member is required.
        public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
        /// An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.
        public var streamId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
            name: Swift.String? = nil,
            playbackConfigurationName: Swift.String? = nil,
            retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.consumption = consumption
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
            self.retrieval = retrieval
            self.streamId = streamId
        }
    }
}

extension MediaTailorClientTypes {

    /// The schedule's ad break properties.
    public struct ScheduleAdBreak: Swift.Sendable {
        /// The approximate duration of the ad break, in seconds.
        public var approximateDurationSeconds: Swift.Int?
        /// The approximate time that the ad will start playing.
        public var approximateStartTime: Foundation.Date?
        /// The name of the source location containing the VOD source used for the ad break.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source used for the ad break.
        public var vodSourceName: Swift.String?

        public init(
            approximateDurationSeconds: Swift.Int? = nil,
            approximateStartTime: Foundation.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }
}

extension MediaTailorClientTypes {

    public enum ScheduleEntryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alternateMedia
        case fillerSlate
        case program
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleEntryType] {
            return [
                .alternateMedia,
                .fillerSlate,
                .program
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alternateMedia: return "ALTERNATE_MEDIA"
            case .fillerSlate: return "FILLER_SLATE"
            case .program: return "PROGRAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The properties for a schedule.
    public struct ScheduleEntry: Swift.Sendable {
        /// The approximate duration of this program, in seconds.
        public var approximateDurationSeconds: Swift.Int?
        /// The approximate time that the program will start playing.
        public var approximateStartTime: Foundation.Date?
        /// The ARN of the program.
        /// This member is required.
        public var arn: Swift.String?
        /// The list of audiences defined in ScheduleEntry.
        public var audiences: [Swift.String]?
        /// The name of the channel that uses this schedule.
        /// This member is required.
        public var channelName: Swift.String?
        /// The name of the live source used for the program.
        public var liveSourceName: Swift.String?
        /// The name of the program.
        /// This member is required.
        public var programName: Swift.String?
        /// The schedule's ad break properties.
        public var scheduleAdBreaks: [MediaTailorClientTypes.ScheduleAdBreak]?
        /// The type of schedule entry.
        public var scheduleEntryType: MediaTailorClientTypes.ScheduleEntryType?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source.
        public var vodSourceName: Swift.String?

        public init(
            approximateDurationSeconds: Swift.Int? = nil,
            approximateStartTime: Foundation.Date? = nil,
            arn: Swift.String? = nil,
            audiences: [Swift.String]? = nil,
            channelName: Swift.String? = nil,
            liveSourceName: Swift.String? = nil,
            programName: Swift.String? = nil,
            scheduleAdBreaks: [MediaTailorClientTypes.ScheduleAdBreak]? = nil,
            scheduleEntryType: MediaTailorClientTypes.ScheduleEntryType? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.arn = arn
            self.audiences = audiences
            self.channelName = channelName
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduleAdBreaks = scheduleAdBreaks
            self.scheduleEntryType = scheduleEntryType
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }
}

extension MediaTailorClientTypes {

    /// The segment delivery configuration settings.
    public struct SegmentDeliveryConfiguration: Swift.Sendable {
        /// The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as https://example.com/some/path. To use a relative URL specify the relative path, such as /some/path*.
        public var baseUrl: Swift.String?
        /// A unique identifier used to distinguish between multiple segment delivery configurations in a source location.
        public var name: Swift.String?

        public init(
            baseUrl: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
            self.name = name
        }
    }
}

extension MediaTailorClientTypes {

    public enum AccessType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autodetectSigv4
        case s3Sigv4
        case secretsManagerAccessToken
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessType] {
            return [
                .autodetectSigv4,
                .s3Sigv4,
                .secretsManagerAccessToken
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autodetectSigv4: return "AUTODETECT_SIGV4"
            case .s3Sigv4: return "S3_SIGV4"
            case .secretsManagerAccessToken: return "SECRETS_MANAGER_ACCESS_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see [Working with AWS Secrets Manager access token authentication](https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html).
    public struct SecretsManagerAccessTokenConfiguration: Swift.Sendable {
        /// The name of the HTTP header used to supply the access token in requests to the source location.
        public var headerName: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.
        public var secretArn: Swift.String?
        /// The AWS Secrets Manager [SecretString](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html) key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.
        public var secretStringKey: Swift.String?

        public init(
            headerName: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            secretStringKey: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.secretArn = secretArn
            self.secretStringKey = secretStringKey
        }
    }
}

extension MediaTailorClientTypes {

    /// Access configuration parameters.
    public struct AccessConfiguration: Swift.Sendable {
        /// The type of authentication used to access content from HttpConfiguration::BaseUrl on your source location. S3_SIGV4 - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name. Before you can use S3_SIGV4, you must meet these requirements: • You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide. • The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations. AUTODETECT_SIGV4 - AWS Signature Version 4 authentication for a set of supported services: MediaPackage Version 2 and Amazon S3 hosted virtual-style access. If your source location base URL is a MediaPackage Version 2 endpoint or an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the resource where your source content is stored. Before you can use AUTODETECT_SIGV4 with a MediaPackage Version 2 endpoint, you must meet these requirements: • You must grant MediaTailor access to your MediaPackage endpoint by granting mediatailor.amazonaws.com principal access in an Origin Access policy on the endpoint. • Your MediaTailor source location base URL must be a MediaPackage V2 endpoint. • The caller of the API must have mediapackagev2:GetObject IAM permissions to read all top level manifests referenced by the MediaTailor source packaging configurations. Before you can use AUTODETECT_SIGV4 with an Amazon S3 bucket, you must meet these requirements: • You must grant MediaTailor access to your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For more information about configuring access in IAM, see [Access management](https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html) in the IAM User Guide.. • The mediatailor.amazonaws.com service principal must have permissions to read all top-level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.
        public var accessType: MediaTailorClientTypes.AccessType?
        /// AWS Secrets Manager access token configuration parameters.
        public var secretsManagerAccessTokenConfiguration: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration?

        public init(
            accessType: MediaTailorClientTypes.AccessType? = nil,
            secretsManagerAccessTokenConfiguration: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration? = nil
        )
        {
            self.accessType = accessType
            self.secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfiguration
        }
    }
}

extension MediaTailorClientTypes {

    /// The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.
    public struct DefaultSegmentDeliveryConfiguration: Swift.Sendable {
        /// The hostname of the server that will be used to serve segments. This string must include the protocol, such as https://.
        public var baseUrl: Swift.String?

        public init(
            baseUrl: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
        }
    }
}

extension MediaTailorClientTypes {

    /// The HTTP configuration for the source location.
    public struct HttpConfiguration: Swift.Sendable {
        /// The base URL for the source location host server. This string must include the protocol, such as https://.
        /// This member is required.
        public var baseUrl: Swift.String?

        public init(
            baseUrl: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
        }
    }
}

extension MediaTailorClientTypes {

    /// A source location is a container for sources. For more information about source locations, see [Working with source locations](https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html) in the MediaTailor User Guide.
    public struct SourceLocation: Swift.Sendable {
        /// The access configuration for the source location.
        public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
        /// The ARN of the SourceLocation.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the source location was created.
        public var creationTime: Foundation.Date?
        /// The default segment delivery configuration.
        public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
        /// The HTTP configuration for the source location.
        /// This member is required.
        public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
        /// The timestamp that indicates when the source location was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The segment delivery configurations for the source location.
        public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String: Swift.String]?

        public init(
            accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
            httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }
    }
}

extension MediaTailorClientTypes {

    /// VOD source configuration parameters.
    public struct VodSource: Swift.Sendable {
        /// The ARN for the VOD source.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the VOD source was created.
        public var creationTime: Foundation.Date?
        /// The HTTP package configurations for the VOD source.
        /// This member is required.
        public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
        /// The timestamp that indicates when the VOD source was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the source location that the VOD source is associated with.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String: Swift.String]?
        /// The name of the VOD source.
        /// This member is required.
        public var vodSourceName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }
    }
}

extension MediaTailorClientTypes {

    /// A location at which a zero-duration ad marker was detected in a VOD source manifest.
    public struct AdBreakOpportunity: Swift.Sendable {
        /// The offset in milliseconds from the start of the VOD source at which an ad marker was detected.
        /// This member is required.
        public var offsetMillis: Swift.Int?

        public init(
            offsetMillis: Swift.Int? = nil
        )
        {
            self.offsetMillis = offsetMillis
        }
    }
}

/// A request contains unexpected data.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteChannelPolicyInput: Swift.Sendable {
    /// The name of the channel associated with this channel policy.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

public struct DeleteChannelPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct GetChannelPolicyInput: Swift.Sendable {
    /// The name of the channel associated with this Channel Policy.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

public struct GetChannelPolicyOutput: Swift.Sendable {
    /// The IAM policy for the channel. IAM policies are used to control access to your channel.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

public struct PutChannelPolicyInput: Swift.Sendable {
    /// The channel name associated with this Channel Policy.
    /// This member is required.
    public var channelName: Swift.String?
    /// Adds an IAM role that determines the permissions of your channel.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.policy = policy
    }
}

public struct PutChannelPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct ConfigureLogsForChannelInput: Swift.Sendable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The types of logs to collect.
    /// This member is required.
    public var logTypes: [MediaTailorClientTypes.LogType]?

    public init(
        channelName: Swift.String? = nil,
        logTypes: [MediaTailorClientTypes.LogType]? = nil
    )
    {
        self.channelName = channelName
        self.logTypes = logTypes
    }
}

public struct ConfigureLogsForChannelOutput: Swift.Sendable {
    /// The name of the channel.
    public var channelName: Swift.String?
    /// The types of logs collected.
    public var logTypes: [MediaTailorClientTypes.LogType]?

    public init(
        channelName: Swift.String? = nil,
        logTypes: [MediaTailorClientTypes.LogType]? = nil
    )
    {
        self.channelName = channelName
        self.logTypes = logTypes
    }
}

extension MediaTailorClientTypes {

    /// The output configuration for this channel.
    public struct RequestOutputItem: Swift.Sendable {
        /// DASH manifest configuration parameters.
        public var dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings?
        /// HLS playlist configuration parameters.
        public var hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings?
        /// The name of the manifest for the channel. The name appears in the PlaybackUrl.
        /// This member is required.
        public var manifestName: Swift.String?
        /// A string used to match which HttpPackageConfiguration is used for each VodSource.
        /// This member is required.
        public var sourceGroup: Swift.String?

        public init(
            dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings? = nil,
            hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings? = nil,
            manifestName: Swift.String? = nil,
            sourceGroup: Swift.String? = nil
        )
        {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.sourceGroup = sourceGroup
        }
    }
}

extension MediaTailorClientTypes {

    public enum PlaybackMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linear
        case loop
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaybackMode] {
            return [
                .linear,
                .loop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case .loop: return "LOOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    public enum Tier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Tier] {
            return [
                .basic,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// The configuration for time-shifted viewing.
    public struct TimeShiftConfiguration: Swift.Sendable {
        /// The maximum time delay for time-shifted viewing. The minimum allowed maximum time delay is 0 seconds, and the maximum allowed maximum time delay is 21600 seconds (6 hours).
        /// This member is required.
        public var maxTimeDelaySeconds: Swift.Int?

        public init(
            maxTimeDelaySeconds: Swift.Int? = nil
        )
        {
            self.maxTimeDelaySeconds = maxTimeDelaySeconds
        }
    }
}

public struct CreateChannelInput: Swift.Sendable {
    /// The list of audiences defined in channel.
    public var audiences: [Swift.String]?
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The channel's output properties.
    /// This member is required.
    public var outputs: [MediaTailorClientTypes.RequestOutputItem]?
    /// The type of playback mode to use for this channel. LINEAR - The programs in the schedule play once back-to-back in the schedule. LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.
    /// This member is required.
    public var playbackMode: MediaTailorClientTypes.PlaybackMode?
    /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The tier of the channel.
    public var tier: MediaTailorClientTypes.Tier?
    /// The time-shifted viewing configuration you want to associate to the channel.
    public var timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration?

    public init(
        audiences: [Swift.String]? = nil,
        channelName: Swift.String? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        outputs: [MediaTailorClientTypes.RequestOutputItem]? = nil,
        playbackMode: MediaTailorClientTypes.PlaybackMode? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tier: MediaTailorClientTypes.Tier? = nil,
        timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration? = nil
    )
    {
        self.audiences = audiences
        self.channelName = channelName
        self.fillerSlate = fillerSlate
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
        self.timeShiftConfiguration = timeShiftConfiguration
    }
}

extension MediaTailorClientTypes {

    public enum ChannelState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelState] {
            return [
                .running,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateChannelOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to assign to the channel.
    public var arn: Swift.String?
    /// The list of audiences defined in channel.
    public var audiences: [Swift.String]?
    /// The name to assign to the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: Foundation.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The output properties to assign to the channel.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The playback mode to assign to the channel.
    public var playbackMode: Swift.String?
    /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The tier of the channel.
    public var tier: Swift.String?
    /// The time-shifted viewing configuration assigned to the channel.
    public var timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration?

    public init(
        arn: Swift.String? = nil,
        audiences: [Swift.String]? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: Foundation.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tier: Swift.String? = nil,
        timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration? = nil
    )
    {
        self.arn = arn
        self.audiences = audiences
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
        self.timeShiftConfiguration = timeShiftConfiguration
    }
}

public struct DeleteChannelInput: Swift.Sendable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

public struct DeleteChannelOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeChannelInput: Swift.Sendable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

public struct DescribeChannelOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var arn: Swift.String?
    /// The list of audiences defined in channel.
    public var audiences: [Swift.String]?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: Foundation.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The log configuration for the channel.
    /// This member is required.
    public var logConfiguration: MediaTailorClientTypes.LogConfigurationForChannel?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The channel's playback mode.
    public var playbackMode: Swift.String?
    /// The tags assigned to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The channel's tier.
    public var tier: Swift.String?
    /// The time-shifted viewing configuration for the channel.
    public var timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration?

    public init(
        arn: Swift.String? = nil,
        audiences: [Swift.String]? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: Foundation.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfigurationForChannel? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tier: Swift.String? = nil,
        timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration? = nil
    )
    {
        self.arn = arn
        self.audiences = audiences
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.logConfiguration = logConfiguration
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
        self.timeShiftConfiguration = timeShiftConfiguration
    }
}

public struct GetChannelScheduleInput: Swift.Sendable {
    /// The single audience for GetChannelScheduleRequest.
    public var audience: Swift.String?
    /// The name of the channel associated with this Channel Schedule.
    /// This member is required.
    public var channelName: Swift.String?
    /// The duration in minutes of the channel schedule.
    public var durationMinutes: Swift.String?
    /// The maximum number of channel schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults channel schedules, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// (Optional) If the playback configuration has more than MaxResults channel schedules, use NextToken to get the second and subsequent pages of results. For the first GetChannelScheduleRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more channel schedules to get.
    public var nextToken: Swift.String?

    public init(
        audience: Swift.String? = nil,
        channelName: Swift.String? = nil,
        durationMinutes: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.audience = audience
        self.channelName = channelName
        self.durationMinutes = durationMinutes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetChannelScheduleOutput: Swift.Sendable {
    /// A list of schedule entries for the channel.
    public var items: [MediaTailorClientTypes.ScheduleEntry]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.ScheduleEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListChannelsInput: Swift.Sendable {
    /// The maximum number of channels that you want MediaTailor to return in response to the current request. If there are more than MaxResults channels, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListChannelsOutput: Swift.Sendable {
    /// A list of channels that are associated with this account.
    public var items: [MediaTailorClientTypes.Channel]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension MediaTailorClientTypes {

    public enum RelativePosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterProgram
        case beforeProgram
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativePosition] {
            return [
                .afterProgram,
                .beforeProgram
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterProgram: return "AFTER_PROGRAM"
            case .beforeProgram: return "BEFORE_PROGRAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaTailorClientTypes {

    /// Program transition configuration.
    public struct Transition: Swift.Sendable {
        /// The duration of the live program in seconds.
        public var durationMillis: Swift.Int?
        /// The position where this program will be inserted relative to the RelativePosition.
        /// This member is required.
        public var relativePosition: MediaTailorClientTypes.RelativePosition?
        /// The name of the program that this program will be inserted next to, as defined by RelativePosition.
        public var relativeProgram: Swift.String?
        /// The date and time that the program is scheduled to start, in epoch milliseconds.
        public var scheduledStartTimeMillis: Swift.Int?
        /// Defines when the program plays in the schedule. You can set the value to ABSOLUTE or RELATIVE. ABSOLUTE - The program plays at a specific wall clock time. This setting can only be used for channels using the LINEARPlaybackMode. Note the following considerations when using ABSOLUTE transitions: If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary. If there are gaps in playback, MediaTailor plays the FillerSlate you configured for your linear channel. RELATIVE - The program is inserted into the schedule either before or after a program that you specify via RelativePosition.
        /// This member is required.
        public var type: Swift.String?

        public init(
            durationMillis: Swift.Int? = nil,
            relativePosition: MediaTailorClientTypes.RelativePosition? = nil,
            relativeProgram: Swift.String? = nil,
            scheduledStartTimeMillis: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.durationMillis = durationMillis
            self.relativePosition = relativePosition
            self.relativeProgram = relativeProgram
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
            self.type = type
        }
    }
}

extension MediaTailorClientTypes {

    /// Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.
    public struct ScheduleConfiguration: Swift.Sendable {
        /// Program clip range configuration.
        public var clipRange: MediaTailorClientTypes.ClipRange?
        /// Program transition configurations.
        /// This member is required.
        public var transition: MediaTailorClientTypes.Transition?

        public init(
            clipRange: MediaTailorClientTypes.ClipRange? = nil,
            transition: MediaTailorClientTypes.Transition? = nil
        )
        {
            self.clipRange = clipRange
            self.transition = transition
        }
    }
}

public struct CreateProgramInput: Swift.Sendable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The list of AudienceMedia defined in program.
    public var audienceMedia: [MediaTailorClientTypes.AudienceMedia]?
    /// The name of the channel for this Program.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name of the Program.
    /// This member is required.
    public var programName: Swift.String?
    /// The schedule configuration settings.
    /// This member is required.
    public var scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init(
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        audienceMedia: [MediaTailorClientTypes.AudienceMedia]? = nil,
        channelName: Swift.String? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.audienceMedia = audienceMedia
        self.channelName = channelName
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

public struct CreateProgramOutput: Swift.Sendable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN to assign to the program.
    public var arn: Swift.String?
    /// The list of AudienceMedia defined in program.
    public var audienceMedia: [MediaTailorClientTypes.AudienceMedia]?
    /// The name to assign to the channel for this program.
    public var channelName: Swift.String?
    /// The clip range configuration settings.
    public var clipRange: MediaTailorClientTypes.ClipRange?
    /// The time the program was created.
    public var creationTime: Foundation.Date?
    /// The duration of the live program in milliseconds.
    public var durationMillis: Swift.Int?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name to assign to this program.
    public var programName: Swift.String?
    /// The scheduled start time for this Program.
    public var scheduledStartTime: Foundation.Date?
    /// The name to assign to the source location for this program.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init(
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        audienceMedia: [MediaTailorClientTypes.AudienceMedia]? = nil,
        channelName: Swift.String? = nil,
        clipRange: MediaTailorClientTypes.ClipRange? = nil,
        creationTime: Foundation.Date? = nil,
        durationMillis: Swift.Int? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: Foundation.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.audienceMedia = audienceMedia
        self.channelName = channelName
        self.clipRange = clipRange
        self.creationTime = creationTime
        self.durationMillis = durationMillis
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

public struct DeleteProgramInput: Swift.Sendable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the program.
    /// This member is required.
    public var programName: Swift.String?

    public init(
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

public struct DeleteProgramOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeProgramInput: Swift.Sendable {
    /// The name of the channel associated with this Program.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the program.
    /// This member is required.
    public var programName: Swift.String?

    public init(
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

public struct DescribeProgramOutput: Swift.Sendable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN of the program.
    public var arn: Swift.String?
    /// The list of AudienceMedia defined in program.
    public var audienceMedia: [MediaTailorClientTypes.AudienceMedia]?
    /// The name of the channel that the program belongs to.
    public var channelName: Swift.String?
    /// The clip range configuration settings.
    public var clipRange: MediaTailorClientTypes.ClipRange?
    /// The timestamp of when the program was created.
    public var creationTime: Foundation.Date?
    /// The duration of the live program in milliseconds.
    public var durationMillis: Swift.Int?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name of the program.
    public var programName: Swift.String?
    /// The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.
    public var scheduledStartTime: Foundation.Date?
    /// The source location name.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init(
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        audienceMedia: [MediaTailorClientTypes.AudienceMedia]? = nil,
        channelName: Swift.String? = nil,
        clipRange: MediaTailorClientTypes.ClipRange? = nil,
        creationTime: Foundation.Date? = nil,
        durationMillis: Swift.Int? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: Foundation.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.audienceMedia = audienceMedia
        self.channelName = channelName
        self.clipRange = clipRange
        self.creationTime = creationTime
        self.durationMillis = durationMillis
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

extension MediaTailorClientTypes {

    /// Program transition configuration.
    public struct UpdateProgramTransition: Swift.Sendable {
        /// The duration of the live program in seconds.
        public var durationMillis: Swift.Int?
        /// The date and time that the program is scheduled to start, in epoch milliseconds.
        public var scheduledStartTimeMillis: Swift.Int?

        public init(
            durationMillis: Swift.Int? = nil,
            scheduledStartTimeMillis: Swift.Int? = nil
        )
        {
            self.durationMillis = durationMillis
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
        }
    }
}

extension MediaTailorClientTypes {

    /// Schedule configuration parameters.
    public struct UpdateProgramScheduleConfiguration: Swift.Sendable {
        /// Program clip range configuration.
        public var clipRange: MediaTailorClientTypes.ClipRange?
        /// Program transition configuration.
        public var transition: MediaTailorClientTypes.UpdateProgramTransition?

        public init(
            clipRange: MediaTailorClientTypes.ClipRange? = nil,
            transition: MediaTailorClientTypes.UpdateProgramTransition? = nil
        )
        {
            self.clipRange = clipRange
            self.transition = transition
        }
    }
}

public struct UpdateProgramInput: Swift.Sendable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The list of AudienceMedia defined in program.
    public var audienceMedia: [MediaTailorClientTypes.AudienceMedia]?
    /// The name of the channel for this Program.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the Program.
    /// This member is required.
    public var programName: Swift.String?
    /// The schedule configuration settings.
    /// This member is required.
    public var scheduleConfiguration: MediaTailorClientTypes.UpdateProgramScheduleConfiguration?

    public init(
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        audienceMedia: [MediaTailorClientTypes.AudienceMedia]? = nil,
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduleConfiguration: MediaTailorClientTypes.UpdateProgramScheduleConfiguration? = nil
    )
    {
        self.adBreaks = adBreaks
        self.audienceMedia = audienceMedia
        self.channelName = channelName
        self.programName = programName
        self.scheduleConfiguration = scheduleConfiguration
    }
}

public struct UpdateProgramOutput: Swift.Sendable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN to assign to the program.
    public var arn: Swift.String?
    /// The list of AudienceMedia defined in program.
    public var audienceMedia: [MediaTailorClientTypes.AudienceMedia]?
    /// The name to assign to the channel for this program.
    public var channelName: Swift.String?
    /// The clip range configuration settings.
    public var clipRange: MediaTailorClientTypes.ClipRange?
    /// The time the program was created.
    public var creationTime: Foundation.Date?
    /// The duration of the live program in milliseconds.
    public var durationMillis: Swift.Int?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name to assign to this program.
    public var programName: Swift.String?
    /// The scheduled start time for this Program.
    public var scheduledStartTime: Foundation.Date?
    /// The name to assign to the source location for this program.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init(
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        audienceMedia: [MediaTailorClientTypes.AudienceMedia]? = nil,
        channelName: Swift.String? = nil,
        clipRange: MediaTailorClientTypes.ClipRange? = nil,
        creationTime: Foundation.Date? = nil,
        durationMillis: Swift.Int? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: Foundation.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.audienceMedia = audienceMedia
        self.channelName = channelName
        self.clipRange = clipRange
        self.creationTime = creationTime
        self.durationMillis = durationMillis
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

public struct StartChannelInput: Swift.Sendable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

public struct StartChannelOutput: Swift.Sendable {

    public init() { }
}

public struct StopChannelInput: Swift.Sendable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init(
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

public struct StopChannelOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateChannelInput: Swift.Sendable {
    /// The list of audiences defined in channel.
    public var audiences: [Swift.String]?
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The channel's output properties.
    /// This member is required.
    public var outputs: [MediaTailorClientTypes.RequestOutputItem]?
    /// The time-shifted viewing configuration you want to associate to the channel.
    public var timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration?

    public init(
        audiences: [Swift.String]? = nil,
        channelName: Swift.String? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        outputs: [MediaTailorClientTypes.RequestOutputItem]? = nil,
        timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration? = nil
    )
    {
        self.audiences = audiences
        self.channelName = channelName
        self.fillerSlate = fillerSlate
        self.outputs = outputs
        self.timeShiftConfiguration = timeShiftConfiguration
    }
}

public struct UpdateChannelOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the channel.
    public var arn: Swift.String?
    /// The list of audiences defined in channel.
    public var audiences: [Swift.String]?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Returns the state whether the channel is running or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: Foundation.Date?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp that indicates when the channel was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The type of playback mode for this channel. LINEAR - Programs play back-to-back only once. LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
    public var playbackMode: Swift.String?
    /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The tier associated with this Channel.
    public var tier: Swift.String?
    /// The time-shifted viewing configuration for the channel.
    public var timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration?

    public init(
        arn: Swift.String? = nil,
        audiences: [Swift.String]? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: Foundation.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tier: Swift.String? = nil,
        timeShiftConfiguration: MediaTailorClientTypes.TimeShiftConfiguration? = nil
    )
    {
        self.arn = arn
        self.audiences = audiences
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
        self.timeShiftConfiguration = timeShiftConfiguration
    }
}

/// Configures Amazon CloudWatch log settings for a playback configuration.
public struct ConfigureLogsForPlaybackConfigurationInput: Swift.Sendable {
    /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the [debug log mode](https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html). Valid values: 0 - 100
    /// This member is required.
    public var percentEnabled: Swift.Int?
    /// The name of the playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init(
        percentEnabled: Swift.Int? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.percentEnabled = percentEnabled
        self.playbackConfigurationName = playbackConfigurationName
    }
}

public struct ConfigureLogsForPlaybackConfigurationOutput: Swift.Sendable {
    /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.
    /// This member is required.
    public var percentEnabled: Swift.Int?
    /// The name of the playback configuration.
    public var playbackConfigurationName: Swift.String?

    public init(
        percentEnabled: Swift.Int? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.percentEnabled = percentEnabled
        self.playbackConfigurationName = playbackConfigurationName
    }
}

public struct CreateLiveSourceInput: Swift.Sendable {
    /// A list of HTTP package configuration parameters for this live source.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct CreateLiveSourceOutput: Swift.Sendable {
    /// The ARN to assign to the live source.
    public var arn: Swift.String?
    /// The time the live source was created.
    public var creationTime: Foundation.Date?
    /// A list of HTTP package configuration parameters for this live source.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The time the live source was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name to assign to the live source.
    public var liveSourceName: Swift.String?
    /// The name to assign to the source location of the live source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct CreatePrefetchScheduleInput: Swift.Sendable {
    /// The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
    /// This member is required.
    public var consumption: MediaTailorClientTypes.PrefetchConsumption?
    /// The name to assign to the schedule request.
    /// This member is required.
    public var name: Swift.String?
    /// The name to assign to the playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?
    /// The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
    /// This member is required.
    public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    /// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
    public var streamId: Swift.String?

    public init(
        consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.consumption = consumption
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
        self.retrieval = retrieval
        self.streamId = streamId
    }
}

public struct CreatePrefetchScheduleOutput: Swift.Sendable {
    /// The ARN to assign to the prefetch schedule.
    public var arn: Swift.String?
    /// The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
    public var consumption: MediaTailorClientTypes.PrefetchConsumption?
    /// The name to assign to the prefetch schedule.
    public var name: Swift.String?
    /// The name to assign to the playback configuration.
    public var playbackConfigurationName: Swift.String?
    /// The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
    public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    /// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
    public var streamId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.consumption = consumption
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
        self.retrieval = retrieval
        self.streamId = streamId
    }
}

public struct CreateSourceLocationInput: Swift.Sendable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The optional configuration for the server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The source's HTTP package configurations.
    /// This member is required.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// A list of the segment delivery configurations associated with this resource.
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name associated with the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct CreateSourceLocationOutput: Swift.Sendable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN to assign to the source location.
    public var arn: Swift.String?
    /// The time the source location was created.
    public var creationTime: Foundation.Date?
    /// The optional configuration for the server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The source's HTTP package configurations.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The time the source location was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The segment delivery configurations for the source location. For information about MediaTailor configurations, see [Working with configurations in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html).
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name to assign to the source location.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct CreateVodSourceInput: Swift.Sendable {
    /// A list of HTTP package configuration parameters for this VOD source.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the source location for this VOD source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name associated with the VOD source.>
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init(
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

public struct CreateVodSourceOutput: Swift.Sendable {
    /// The ARN to assign to this VOD source.
    public var arn: Swift.String?
    /// The time the VOD source was created.
    public var creationTime: Foundation.Date?
    /// A list of HTTP package configuration parameters for this VOD source.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The time the VOD source was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name to assign to the source location for this VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name to assign to the VOD source.
    public var vodSourceName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

extension MediaTailorClientTypes {

    /// The configuration for DASH PUT operations.
    public struct DashConfigurationForPut: Swift.Sendable {
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public var mpdLocation: Swift.String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public var originManifestType: MediaTailorClientTypes.OriginManifestType?

        public init(
            mpdLocation: Swift.String? = nil,
            originManifestType: MediaTailorClientTypes.OriginManifestType? = nil
        )
        {
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }
    }
}

public struct DeleteLiveSourceInput: Swift.Sendable {
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with this Live Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
    }
}

public struct DeleteLiveSourceOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePlaybackConfigurationInput: Swift.Sendable {
    /// The name of the playback configuration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeletePlaybackConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePrefetchScheduleInput: Swift.Sendable {
    /// The name of the prefetch schedule. If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the playback configuration for this prefetch schedule.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init(
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
    }
}

public struct DeletePrefetchScheduleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSourceLocationInput: Swift.Sendable {
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        sourceLocationName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

public struct DeleteSourceLocationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteVodSourceInput: Swift.Sendable {
    /// The name of the source location associated with this VOD Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name of the VOD source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init(
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

public struct DeleteVodSourceOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeLiveSourceInput: Swift.Sendable {
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with this Live Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
    }
}

public struct DescribeLiveSourceOutput: Swift.Sendable {
    /// The ARN of the live source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the live source was created.
    public var creationTime: Foundation.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The timestamp that indicates when the live source was modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the live source.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with the live source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct DescribeSourceLocationInput: Swift.Sendable {
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        sourceLocationName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

public struct DescribeSourceLocationOutput: Swift.Sendable {
    /// The access configuration for the source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN of the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: Foundation.Date?
    /// The default segment delivery configuration settings.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP package configuration settings for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// A list of the segment delivery configurations associated with this resource.
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct DescribeVodSourceInput: Swift.Sendable {
    /// The name of the source location associated with this VOD Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name of the VOD Source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init(
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

public struct DescribeVodSourceOutput: Swift.Sendable {
    /// The ad break opportunities within the VOD source.
    public var adBreakOpportunities: [MediaTailorClientTypes.AdBreakOpportunity]?
    /// The ARN of the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: Foundation.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The last modified time of the VOD source.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init(
        adBreakOpportunities: [MediaTailorClientTypes.AdBreakOpportunity]? = nil,
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreakOpportunities = adBreakOpportunities
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

public struct GetPlaybackConfigurationInput: Swift.Sendable {
    /// The identifier for the playback configuration.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetPlaybackConfigurationOutput: Swift.Sendable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
    public var configurationAliases: [Swift.String: [Swift.String: Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    /// The configuration for HLS content.
    public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    /// The setting that controls whether players can use stitched or guided ad insertion. The default, STITCHED_ONLY, forces all player sessions to use stitched (server-side) ad insertion. Choosing PLAYER_SELECT allows players to select either stitched or guided ad insertion at session-initialization time. The default for players that do not specify an insertion mode is stitched.
    public var insertionMode: MediaTailorClientTypes.InsertionMode?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The Amazon CloudWatch log settings for a playback configuration.
    public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var personalizationThresholdSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) for the playback configuration.
    public var playbackConfigurationArn: Swift.String?
    /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.
    public var playbackEndpointPrefix: Swift.String?
    /// The URL that the player uses to initialize a session that uses client-side reporting.
    public var sessionInitializationEndpointPrefix: Swift.String?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags assigned to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init(
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String: [Swift.String: Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
        hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
        insertionMode: MediaTailorClientTypes.InsertionMode? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        playbackConfigurationArn: Swift.String? = nil,
        playbackEndpointPrefix: Swift.String? = nil,
        sessionInitializationEndpointPrefix: Swift.String? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.insertionMode = insertionMode
        self.livePreRollConfiguration = livePreRollConfiguration
        self.logConfiguration = logConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

public struct GetPrefetchScheduleInput: Swift.Sendable {
    /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Returns information about the prefetch schedule for a specific playback configuration. If you call GetPrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init(
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
    }
}

public struct GetPrefetchScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the prefetch schedule.
    public var arn: Swift.String?
    /// Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a consumption window. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.
    public var consumption: MediaTailorClientTypes.PrefetchConsumption?
    /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
    public var name: Swift.String?
    /// The name of the playback configuration to create the prefetch schedule for.
    public var playbackConfigurationName: Swift.String?
    /// A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).
    public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    /// An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.
    public var streamId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.consumption = consumption
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
        self.retrieval = retrieval
        self.streamId = streamId
    }
}

public struct ListAlertsInput: Swift.Sendable {
    /// The maximum number of alerts that you want MediaTailor to return in response to the current request. If there are more than MaxResults alerts, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListAlertsOutput: Swift.Sendable {
    /// A list of alerts that are associated with this resource.
    public var items: [MediaTailorClientTypes.Alert]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.Alert]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListLiveSourcesInput: Swift.Sendable {
    /// The maximum number of live sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults live sources, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The name of the source location associated with this Live Sources list.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceLocationName = sourceLocationName
    }
}

public struct ListLiveSourcesOutput: Swift.Sendable {
    /// Lists the live sources.
    public var items: [MediaTailorClientTypes.LiveSource]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.LiveSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListPlaybackConfigurationsInput: Swift.Sendable {
    /// The maximum number of playback configurations that you want MediaTailor to return in response to the current request. If there are more than MaxResults playback configurations, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPlaybackConfigurationsOutput: Swift.Sendable {
    /// Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.
    public var items: [MediaTailorClientTypes.PlaybackConfiguration]?
    /// Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.PlaybackConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListPrefetchSchedulesInput: Swift.Sendable {
    /// The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// (Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results. For the first ListPrefetchSchedulesRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.
    public var nextToken: Swift.String?
    /// Retrieves the prefetch schedule(s) for a specific playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?
    /// An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.
    public var streamId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.playbackConfigurationName = playbackConfigurationName
        self.streamId = streamId
    }
}

public struct ListPrefetchSchedulesOutput: Swift.Sendable {
    /// Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.
    public var items: [MediaTailorClientTypes.PrefetchSchedule]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.PrefetchSchedule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListSourceLocationsInput: Swift.Sendable {
    /// The maximum number of source locations that you want MediaTailor to return in response to the current request. If there are more than MaxResults source locations, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSourceLocationsOutput: Swift.Sendable {
    /// A list of source locations.
    public var items: [MediaTailorClientTypes.SourceLocation]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.SourceLocation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with this resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags associated with this resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListVodSourcesInput: Swift.Sendable {
    /// The maximum number of VOD sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults VOD sources, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The name of the source location associated with this VOD Source list.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceLocationName = sourceLocationName
    }
}

public struct ListVodSourcesOutput: Swift.Sendable {
    /// Lists the VOD sources.
    public var items: [MediaTailorClientTypes.VodSource]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [MediaTailorClientTypes.VodSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateLiveSourceInput: Swift.Sendable {
    /// A list of HTTP package configurations for the live source on this account.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with this Live Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
    }
}

public struct UpdateLiveSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with this live source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the live source was created.
    public var creationTime: Foundation.Date?
    /// A list of HTTP package configurations for the live source on this account.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The timestamp that indicates when the live source was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the live source.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with the live source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct PutPlaybackConfigurationInput: Swift.Sendable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
    public var configurationAliases: [Swift.String: [Swift.String: Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut?
    /// The setting that controls whether players can use stitched or guided ad insertion. The default, STITCHED_ONLY, forces all player sessions to use stitched (server-side) ad insertion. Choosing PLAYER_SELECT allows players to select either stitched or guided ad insertion at session-initialization time. The default for players that do not specify an insertion mode is stitched.
    public var insertionMode: MediaTailorClientTypes.InsertionMode?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var personalizationThresholdSeconds: Swift.Int?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init(
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String: [Swift.String: Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut? = nil,
        insertionMode: MediaTailorClientTypes.InsertionMode? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.insertionMode = insertionMode
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

public struct PutPlaybackConfigurationOutput: Swift.Sendable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
    public var configurationAliases: [Swift.String: [Swift.String: Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    /// The configuration for HLS content.
    public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    /// The setting that controls whether players can use stitched or guided ad insertion. The default, STITCHED_ONLY, forces all player sessions to use stitched (server-side) ad insertion. Choosing PLAYER_SELECT allows players to select either stitched or guided ad insertion at session-initialization time. The default for players that do not specify an insertion mode is stitched.
    public var insertionMode: MediaTailorClientTypes.InsertionMode?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The Amazon CloudWatch log settings for a playback configuration.
    public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var personalizationThresholdSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) associated with the playback configuration.
    public var playbackConfigurationArn: Swift.String?
    /// The playback endpoint prefix associated with the playback configuration.
    public var playbackEndpointPrefix: Swift.String?
    /// The session initialization endpoint prefix associated with the playback configuration.
    public var sessionInitializationEndpointPrefix: Swift.String?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init(
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String: [Swift.String: Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
        hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
        insertionMode: MediaTailorClientTypes.InsertionMode? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        playbackConfigurationArn: Swift.String? = nil,
        playbackEndpointPrefix: Swift.String? = nil,
        sessionInitializationEndpointPrefix: Swift.String? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.insertionMode = insertionMode
        self.livePreRollConfiguration = livePreRollConfiguration
        self.logConfiguration = logConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

public struct UpdateSourceLocationInput: Swift.Sendable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The optional configuration for the host server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP configuration for the source location.
    /// This member is required.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// A list of the segment delivery configurations associated with this resource.
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init(
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
    }
}

public struct UpdateSourceLocationOutput: Swift.Sendable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The Amazon Resource Name (ARN) associated with the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: Foundation.Date?
    /// The optional configuration for the host server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP configuration for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The segment delivery configurations for the source location. For information about MediaTailor configurations, see [Working with configurations in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html).
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UpdateVodSourceInput: Swift.Sendable {
    /// A list of HTTP package configurations for the VOD source on this account.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the source location associated with this VOD Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name of the VOD source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init(
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

public struct UpdateVodSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: Foundation.Date?
    /// A list of HTTP package configurations for the VOD source on this account.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The timestamp that indicates when the VOD source was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

extension ConfigureLogsForChannelInput {

    static func urlPathProvider(_ value: ConfigureLogsForChannelInput) -> Swift.String? {
        return "/configureLogs/channel"
    }
}

extension ConfigureLogsForPlaybackConfigurationInput {

    static func urlPathProvider(_ value: ConfigureLogsForPlaybackConfigurationInput) -> Swift.String? {
        return "/configureLogs/playbackConfiguration"
    }
}

extension CreateChannelInput {

    static func urlPathProvider(_ value: CreateChannelInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

extension CreateLiveSourceInput {

    static func urlPathProvider(_ value: CreateLiveSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let liveSourceName = value.liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

extension CreatePrefetchScheduleInput {

    static func urlPathProvider(_ value: CreatePrefetchScheduleInput) -> Swift.String? {
        guard let playbackConfigurationName = value.playbackConfigurationName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension CreateProgramInput {

    static func urlPathProvider(_ value: CreateProgramInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        guard let programName = value.programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

extension CreateSourceLocationInput {

    static func urlPathProvider(_ value: CreateSourceLocationInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

extension CreateVodSourceInput {

    static func urlPathProvider(_ value: CreateVodSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let vodSourceName = value.vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

extension DeleteChannelInput {

    static func urlPathProvider(_ value: DeleteChannelInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

extension DeleteChannelPolicyInput {

    static func urlPathProvider(_ value: DeleteChannelPolicyInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

extension DeleteLiveSourceInput {

    static func urlPathProvider(_ value: DeleteLiveSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let liveSourceName = value.liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

extension DeletePlaybackConfigurationInput {

    static func urlPathProvider(_ value: DeletePlaybackConfigurationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/playbackConfiguration/\(name.urlPercentEncoding())"
    }
}

extension DeletePrefetchScheduleInput {

    static func urlPathProvider(_ value: DeletePrefetchScheduleInput) -> Swift.String? {
        guard let playbackConfigurationName = value.playbackConfigurationName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension DeleteProgramInput {

    static func urlPathProvider(_ value: DeleteProgramInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        guard let programName = value.programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

extension DeleteSourceLocationInput {

    static func urlPathProvider(_ value: DeleteSourceLocationInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

extension DeleteVodSourceInput {

    static func urlPathProvider(_ value: DeleteVodSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let vodSourceName = value.vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

extension DescribeChannelInput {

    static func urlPathProvider(_ value: DescribeChannelInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

extension DescribeLiveSourceInput {

    static func urlPathProvider(_ value: DescribeLiveSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let liveSourceName = value.liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

extension DescribeProgramInput {

    static func urlPathProvider(_ value: DescribeProgramInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        guard let programName = value.programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

extension DescribeSourceLocationInput {

    static func urlPathProvider(_ value: DescribeSourceLocationInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

extension DescribeVodSourceInput {

    static func urlPathProvider(_ value: DescribeVodSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let vodSourceName = value.vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

extension GetChannelPolicyInput {

    static func urlPathProvider(_ value: GetChannelPolicyInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

extension GetChannelScheduleInput {

    static func urlPathProvider(_ value: GetChannelScheduleInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/schedule"
    }
}

extension GetChannelScheduleInput {

    static func queryItemProvider(_ value: GetChannelScheduleInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let audience = value.audience {
            let audienceQueryItem = Smithy.URIQueryItem(name: "audience".urlPercentEncoding(), value: Swift.String(audience).urlPercentEncoding())
            items.append(audienceQueryItem)
        }
        if let durationMinutes = value.durationMinutes {
            let durationMinutesQueryItem = Smithy.URIQueryItem(name: "durationMinutes".urlPercentEncoding(), value: Swift.String(durationMinutes).urlPercentEncoding())
            items.append(durationMinutesQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetPlaybackConfigurationInput {

    static func urlPathProvider(_ value: GetPlaybackConfigurationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/playbackConfiguration/\(name.urlPercentEncoding())"
    }
}

extension GetPrefetchScheduleInput {

    static func urlPathProvider(_ value: GetPrefetchScheduleInput) -> Swift.String? {
        guard let playbackConfigurationName = value.playbackConfigurationName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension ListAlertsInput {

    static func urlPathProvider(_ value: ListAlertsInput) -> Swift.String? {
        return "/alerts"
    }
}

extension ListAlertsInput {

    static func queryItemProvider(_ value: ListAlertsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsInput {

    static func queryItemProvider(_ value: ListChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLiveSourcesInput {

    static func urlPathProvider(_ value: ListLiveSourcesInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSources"
    }
}

extension ListLiveSourcesInput {

    static func queryItemProvider(_ value: ListLiveSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPlaybackConfigurationsInput {

    static func urlPathProvider(_ value: ListPlaybackConfigurationsInput) -> Swift.String? {
        return "/playbackConfigurations"
    }
}

extension ListPlaybackConfigurationsInput {

    static func queryItemProvider(_ value: ListPlaybackConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPrefetchSchedulesInput {

    static func urlPathProvider(_ value: ListPrefetchSchedulesInput) -> Swift.String? {
        guard let playbackConfigurationName = value.playbackConfigurationName else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())"
    }
}

extension ListSourceLocationsInput {

    static func urlPathProvider(_ value: ListSourceLocationsInput) -> Swift.String? {
        return "/sourceLocations"
    }
}

extension ListSourceLocationsInput {

    static func queryItemProvider(_ value: ListSourceLocationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListVodSourcesInput {

    static func urlPathProvider(_ value: ListVodSourcesInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSources"
    }
}

extension ListVodSourcesInput {

    static func queryItemProvider(_ value: ListVodSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PutChannelPolicyInput {

    static func urlPathProvider(_ value: PutChannelPolicyInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

extension PutPlaybackConfigurationInput {

    static func urlPathProvider(_ value: PutPlaybackConfigurationInput) -> Swift.String? {
        return "/playbackConfiguration"
    }
}

extension StartChannelInput {

    static func urlPathProvider(_ value: StartChannelInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/start"
    }
}

extension StopChannelInput {

    static func urlPathProvider(_ value: StopChannelInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateChannelInput {

    static func urlPathProvider(_ value: UpdateChannelInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

extension UpdateLiveSourceInput {

    static func urlPathProvider(_ value: UpdateLiveSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let liveSourceName = value.liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

extension UpdateProgramInput {

    static func urlPathProvider(_ value: UpdateProgramInput) -> Swift.String? {
        guard let channelName = value.channelName else {
            return nil
        }
        guard let programName = value.programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

extension UpdateSourceLocationInput {

    static func urlPathProvider(_ value: UpdateSourceLocationInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

extension UpdateVodSourceInput {

    static func urlPathProvider(_ value: UpdateVodSourceInput) -> Swift.String? {
        guard let sourceLocationName = value.sourceLocationName else {
            return nil
        }
        guard let vodSourceName = value.vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

extension ConfigureLogsForChannelInput {

    static func write(value: ConfigureLogsForChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelName"].write(value.channelName)
        try writer["LogTypes"].writeList(value.logTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaTailorClientTypes.LogType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConfigureLogsForPlaybackConfigurationInput {

    static func write(value: ConfigureLogsForPlaybackConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PercentEnabled"].write(value.percentEnabled)
        try writer["PlaybackConfigurationName"].write(value.playbackConfigurationName)
    }
}

extension CreateChannelInput {

    static func write(value: CreateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audiences"].writeList(value.audiences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FillerSlate"].write(value.fillerSlate, with: MediaTailorClientTypes.SlateSource.write(value:to:))
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: MediaTailorClientTypes.RequestOutputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PlaybackMode"].write(value.playbackMode)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Tier"].write(value.tier)
        try writer["TimeShiftConfiguration"].write(value.timeShiftConfiguration, with: MediaTailorClientTypes.TimeShiftConfiguration.write(value:to:))
    }
}

extension CreateLiveSourceInput {

    static func write(value: CreateLiveSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpPackageConfigurations"].writeList(value.httpPackageConfigurations, memberWritingClosure: MediaTailorClientTypes.HttpPackageConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePrefetchScheduleInput {

    static func write(value: CreatePrefetchScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Consumption"].write(value.consumption, with: MediaTailorClientTypes.PrefetchConsumption.write(value:to:))
        try writer["Retrieval"].write(value.retrieval, with: MediaTailorClientTypes.PrefetchRetrieval.write(value:to:))
        try writer["StreamId"].write(value.streamId)
    }
}

extension CreateProgramInput {

    static func write(value: CreateProgramInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdBreaks"].writeList(value.adBreaks, memberWritingClosure: MediaTailorClientTypes.AdBreak.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AudienceMedia"].writeList(value.audienceMedia, memberWritingClosure: MediaTailorClientTypes.AudienceMedia.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LiveSourceName"].write(value.liveSourceName)
        try writer["ScheduleConfiguration"].write(value.scheduleConfiguration, with: MediaTailorClientTypes.ScheduleConfiguration.write(value:to:))
        try writer["SourceLocationName"].write(value.sourceLocationName)
        try writer["VodSourceName"].write(value.vodSourceName)
    }
}

extension CreateSourceLocationInput {

    static func write(value: CreateSourceLocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessConfiguration"].write(value.accessConfiguration, with: MediaTailorClientTypes.AccessConfiguration.write(value:to:))
        try writer["DefaultSegmentDeliveryConfiguration"].write(value.defaultSegmentDeliveryConfiguration, with: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.write(value:to:))
        try writer["HttpConfiguration"].write(value.httpConfiguration, with: MediaTailorClientTypes.HttpConfiguration.write(value:to:))
        try writer["SegmentDeliveryConfigurations"].writeList(value.segmentDeliveryConfigurations, memberWritingClosure: MediaTailorClientTypes.SegmentDeliveryConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateVodSourceInput {

    static func write(value: CreateVodSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpPackageConfigurations"].writeList(value.httpPackageConfigurations, memberWritingClosure: MediaTailorClientTypes.HttpPackageConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListPrefetchSchedulesInput {

    static func write(value: ListPrefetchSchedulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StreamId"].write(value.streamId)
    }
}

extension PutChannelPolicyInput {

    static func write(value: PutChannelPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
    }
}

extension PutPlaybackConfigurationInput {

    static func write(value: PutPlaybackConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdDecisionServerUrl"].write(value.adDecisionServerUrl)
        try writer["AvailSuppression"].write(value.availSuppression, with: MediaTailorClientTypes.AvailSuppression.write(value:to:))
        try writer["Bumper"].write(value.bumper, with: MediaTailorClientTypes.Bumper.write(value:to:))
        try writer["CdnConfiguration"].write(value.cdnConfiguration, with: MediaTailorClientTypes.CdnConfiguration.write(value:to:))
        try writer["ConfigurationAliases"].writeMap(value.configurationAliases, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DashConfiguration"].write(value.dashConfiguration, with: MediaTailorClientTypes.DashConfigurationForPut.write(value:to:))
        try writer["InsertionMode"].write(value.insertionMode)
        try writer["LivePreRollConfiguration"].write(value.livePreRollConfiguration, with: MediaTailorClientTypes.LivePreRollConfiguration.write(value:to:))
        try writer["ManifestProcessingRules"].write(value.manifestProcessingRules, with: MediaTailorClientTypes.ManifestProcessingRules.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["PersonalizationThresholdSeconds"].write(value.personalizationThresholdSeconds)
        try writer["SlateAdUrl"].write(value.slateAdUrl)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TranscodeProfileName"].write(value.transcodeProfileName)
        try writer["VideoContentSourceUrl"].write(value.videoContentSourceUrl)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateChannelInput {

    static func write(value: UpdateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audiences"].writeList(value.audiences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FillerSlate"].write(value.fillerSlate, with: MediaTailorClientTypes.SlateSource.write(value:to:))
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: MediaTailorClientTypes.RequestOutputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeShiftConfiguration"].write(value.timeShiftConfiguration, with: MediaTailorClientTypes.TimeShiftConfiguration.write(value:to:))
    }
}

extension UpdateLiveSourceInput {

    static func write(value: UpdateLiveSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpPackageConfigurations"].writeList(value.httpPackageConfigurations, memberWritingClosure: MediaTailorClientTypes.HttpPackageConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateProgramInput {

    static func write(value: UpdateProgramInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdBreaks"].writeList(value.adBreaks, memberWritingClosure: MediaTailorClientTypes.AdBreak.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AudienceMedia"].writeList(value.audienceMedia, memberWritingClosure: MediaTailorClientTypes.AudienceMedia.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScheduleConfiguration"].write(value.scheduleConfiguration, with: MediaTailorClientTypes.UpdateProgramScheduleConfiguration.write(value:to:))
    }
}

extension UpdateSourceLocationInput {

    static func write(value: UpdateSourceLocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessConfiguration"].write(value.accessConfiguration, with: MediaTailorClientTypes.AccessConfiguration.write(value:to:))
        try writer["DefaultSegmentDeliveryConfiguration"].write(value.defaultSegmentDeliveryConfiguration, with: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.write(value:to:))
        try writer["HttpConfiguration"].write(value.httpConfiguration, with: MediaTailorClientTypes.HttpConfiguration.write(value:to:))
        try writer["SegmentDeliveryConfigurations"].writeList(value.segmentDeliveryConfigurations, memberWritingClosure: MediaTailorClientTypes.SegmentDeliveryConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateVodSourceInput {

    static func write(value: UpdateVodSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpPackageConfigurations"].writeList(value.httpPackageConfigurations, memberWritingClosure: MediaTailorClientTypes.HttpPackageConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConfigureLogsForChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfigureLogsForChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfigureLogsForChannelOutput()
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.logTypes = try reader["LogTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaTailorClientTypes.LogType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigureLogsForPlaybackConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfigureLogsForPlaybackConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfigureLogsForPlaybackConfigurationOutput()
        value.percentEnabled = try reader["PercentEnabled"].readIfPresent() ?? 0
        value.playbackConfigurationName = try reader["PlaybackConfigurationName"].readIfPresent()
        return value
    }
}

extension CreateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.audiences = try reader["Audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.channelState = try reader["ChannelState"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fillerSlate = try reader["FillerSlate"].readIfPresent(with: MediaTailorClientTypes.SlateSource.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.ResponseOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.playbackMode = try reader["PlaybackMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tier = try reader["Tier"].readIfPresent()
        value.timeShiftConfiguration = try reader["TimeShiftConfiguration"].readIfPresent(with: MediaTailorClientTypes.TimeShiftConfiguration.read(from:))
        return value
    }
}

extension CreateLiveSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLiveSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLiveSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreatePrefetchScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePrefetchScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePrefetchScheduleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.consumption = try reader["Consumption"].readIfPresent(with: MediaTailorClientTypes.PrefetchConsumption.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.playbackConfigurationName = try reader["PlaybackConfigurationName"].readIfPresent()
        value.retrieval = try reader["Retrieval"].readIfPresent(with: MediaTailorClientTypes.PrefetchRetrieval.read(from:))
        value.streamId = try reader["StreamId"].readIfPresent()
        return value
    }
}

extension CreateProgramOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProgramOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProgramOutput()
        value.adBreaks = try reader["AdBreaks"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AdBreak.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.audienceMedia = try reader["AudienceMedia"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AudienceMedia.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.clipRange = try reader["ClipRange"].readIfPresent(with: MediaTailorClientTypes.ClipRange.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.durationMillis = try reader["DurationMillis"].readIfPresent()
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.programName = try reader["ProgramName"].readIfPresent()
        value.scheduledStartTime = try reader["ScheduledStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension CreateSourceLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSourceLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSourceLocationOutput()
        value.accessConfiguration = try reader["AccessConfiguration"].readIfPresent(with: MediaTailorClientTypes.AccessConfiguration.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultSegmentDeliveryConfiguration = try reader["DefaultSegmentDeliveryConfiguration"].readIfPresent(with: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.read(from:))
        value.httpConfiguration = try reader["HttpConfiguration"].readIfPresent(with: MediaTailorClientTypes.HttpConfiguration.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.segmentDeliveryConfigurations = try reader["SegmentDeliveryConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.SegmentDeliveryConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateVodSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVodSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVodSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension DeleteChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelOutput {
        return DeleteChannelOutput()
    }
}

extension DeleteChannelPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelPolicyOutput {
        return DeleteChannelPolicyOutput()
    }
}

extension DeleteLiveSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLiveSourceOutput {
        return DeleteLiveSourceOutput()
    }
}

extension DeletePlaybackConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePlaybackConfigurationOutput {
        return DeletePlaybackConfigurationOutput()
    }
}

extension DeletePrefetchScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePrefetchScheduleOutput {
        return DeletePrefetchScheduleOutput()
    }
}

extension DeleteProgramOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProgramOutput {
        return DeleteProgramOutput()
    }
}

extension DeleteSourceLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSourceLocationOutput {
        return DeleteSourceLocationOutput()
    }
}

extension DeleteVodSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVodSourceOutput {
        return DeleteVodSourceOutput()
    }
}

extension DescribeChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.audiences = try reader["Audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.channelState = try reader["ChannelState"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fillerSlate = try reader["FillerSlate"].readIfPresent(with: MediaTailorClientTypes.SlateSource.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: MediaTailorClientTypes.LogConfigurationForChannel.read(from:))
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.ResponseOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.playbackMode = try reader["PlaybackMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tier = try reader["Tier"].readIfPresent()
        value.timeShiftConfiguration = try reader["TimeShiftConfiguration"].readIfPresent(with: MediaTailorClientTypes.TimeShiftConfiguration.read(from:))
        return value
    }
}

extension DescribeLiveSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLiveSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLiveSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeProgramOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProgramOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProgramOutput()
        value.adBreaks = try reader["AdBreaks"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AdBreak.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.audienceMedia = try reader["AudienceMedia"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AudienceMedia.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.clipRange = try reader["ClipRange"].readIfPresent(with: MediaTailorClientTypes.ClipRange.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.durationMillis = try reader["DurationMillis"].readIfPresent()
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.programName = try reader["ProgramName"].readIfPresent()
        value.scheduledStartTime = try reader["ScheduledStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension DescribeSourceLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSourceLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSourceLocationOutput()
        value.accessConfiguration = try reader["AccessConfiguration"].readIfPresent(with: MediaTailorClientTypes.AccessConfiguration.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultSegmentDeliveryConfiguration = try reader["DefaultSegmentDeliveryConfiguration"].readIfPresent(with: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.read(from:))
        value.httpConfiguration = try reader["HttpConfiguration"].readIfPresent(with: MediaTailorClientTypes.HttpConfiguration.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.segmentDeliveryConfigurations = try reader["SegmentDeliveryConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.SegmentDeliveryConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeVodSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVodSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVodSourceOutput()
        value.adBreakOpportunities = try reader["AdBreakOpportunities"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AdBreakOpportunity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension GetChannelPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension GetChannelScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelScheduleOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.ScheduleEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetPlaybackConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlaybackConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlaybackConfigurationOutput()
        value.adDecisionServerUrl = try reader["AdDecisionServerUrl"].readIfPresent()
        value.availSuppression = try reader["AvailSuppression"].readIfPresent(with: MediaTailorClientTypes.AvailSuppression.read(from:))
        value.bumper = try reader["Bumper"].readIfPresent(with: MediaTailorClientTypes.Bumper.read(from:))
        value.cdnConfiguration = try reader["CdnConfiguration"].readIfPresent(with: MediaTailorClientTypes.CdnConfiguration.read(from:))
        value.configurationAliases = try reader["ConfigurationAliases"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dashConfiguration = try reader["DashConfiguration"].readIfPresent(with: MediaTailorClientTypes.DashConfiguration.read(from:))
        value.hlsConfiguration = try reader["HlsConfiguration"].readIfPresent(with: MediaTailorClientTypes.HlsConfiguration.read(from:))
        value.insertionMode = try reader["InsertionMode"].readIfPresent() ?? .stitchedOnly
        value.livePreRollConfiguration = try reader["LivePreRollConfiguration"].readIfPresent(with: MediaTailorClientTypes.LivePreRollConfiguration.read(from:))
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: MediaTailorClientTypes.LogConfiguration.read(from:))
        value.manifestProcessingRules = try reader["ManifestProcessingRules"].readIfPresent(with: MediaTailorClientTypes.ManifestProcessingRules.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.personalizationThresholdSeconds = try reader["PersonalizationThresholdSeconds"].readIfPresent()
        value.playbackConfigurationArn = try reader["PlaybackConfigurationArn"].readIfPresent()
        value.playbackEndpointPrefix = try reader["PlaybackEndpointPrefix"].readIfPresent()
        value.sessionInitializationEndpointPrefix = try reader["SessionInitializationEndpointPrefix"].readIfPresent()
        value.slateAdUrl = try reader["SlateAdUrl"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.transcodeProfileName = try reader["TranscodeProfileName"].readIfPresent()
        value.videoContentSourceUrl = try reader["VideoContentSourceUrl"].readIfPresent()
        return value
    }
}

extension GetPrefetchScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPrefetchScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPrefetchScheduleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.consumption = try reader["Consumption"].readIfPresent(with: MediaTailorClientTypes.PrefetchConsumption.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.playbackConfigurationName = try reader["PlaybackConfigurationName"].readIfPresent()
        value.retrieval = try reader["Retrieval"].readIfPresent(with: MediaTailorClientTypes.PrefetchRetrieval.read(from:))
        value.streamId = try reader["StreamId"].readIfPresent()
        return value
    }
}

extension ListAlertsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAlertsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAlertsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.Alert.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.Channel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLiveSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLiveSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLiveSourcesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.LiveSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPlaybackConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlaybackConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlaybackConfigurationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.PlaybackConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPrefetchSchedulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrefetchSchedulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrefetchSchedulesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.PrefetchSchedule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSourceLocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSourceLocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSourceLocationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.SourceLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListVodSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVodSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVodSourcesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.VodSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PutChannelPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutChannelPolicyOutput {
        return PutChannelPolicyOutput()
    }
}

extension PutPlaybackConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPlaybackConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutPlaybackConfigurationOutput()
        value.adDecisionServerUrl = try reader["AdDecisionServerUrl"].readIfPresent()
        value.availSuppression = try reader["AvailSuppression"].readIfPresent(with: MediaTailorClientTypes.AvailSuppression.read(from:))
        value.bumper = try reader["Bumper"].readIfPresent(with: MediaTailorClientTypes.Bumper.read(from:))
        value.cdnConfiguration = try reader["CdnConfiguration"].readIfPresent(with: MediaTailorClientTypes.CdnConfiguration.read(from:))
        value.configurationAliases = try reader["ConfigurationAliases"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dashConfiguration = try reader["DashConfiguration"].readIfPresent(with: MediaTailorClientTypes.DashConfiguration.read(from:))
        value.hlsConfiguration = try reader["HlsConfiguration"].readIfPresent(with: MediaTailorClientTypes.HlsConfiguration.read(from:))
        value.insertionMode = try reader["InsertionMode"].readIfPresent() ?? .stitchedOnly
        value.livePreRollConfiguration = try reader["LivePreRollConfiguration"].readIfPresent(with: MediaTailorClientTypes.LivePreRollConfiguration.read(from:))
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: MediaTailorClientTypes.LogConfiguration.read(from:))
        value.manifestProcessingRules = try reader["ManifestProcessingRules"].readIfPresent(with: MediaTailorClientTypes.ManifestProcessingRules.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.personalizationThresholdSeconds = try reader["PersonalizationThresholdSeconds"].readIfPresent()
        value.playbackConfigurationArn = try reader["PlaybackConfigurationArn"].readIfPresent()
        value.playbackEndpointPrefix = try reader["PlaybackEndpointPrefix"].readIfPresent()
        value.sessionInitializationEndpointPrefix = try reader["SessionInitializationEndpointPrefix"].readIfPresent()
        value.slateAdUrl = try reader["SlateAdUrl"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.transcodeProfileName = try reader["TranscodeProfileName"].readIfPresent()
        value.videoContentSourceUrl = try reader["VideoContentSourceUrl"].readIfPresent()
        return value
    }
}

extension StartChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartChannelOutput {
        return StartChannelOutput()
    }
}

extension StopChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopChannelOutput {
        return StopChannelOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.audiences = try reader["Audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.channelState = try reader["ChannelState"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fillerSlate = try reader["FillerSlate"].readIfPresent(with: MediaTailorClientTypes.SlateSource.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.ResponseOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.playbackMode = try reader["PlaybackMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tier = try reader["Tier"].readIfPresent()
        value.timeShiftConfiguration = try reader["TimeShiftConfiguration"].readIfPresent(with: MediaTailorClientTypes.TimeShiftConfiguration.read(from:))
        return value
    }
}

extension UpdateLiveSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLiveSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLiveSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateProgramOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProgramOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProgramOutput()
        value.adBreaks = try reader["AdBreaks"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AdBreak.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.audienceMedia = try reader["AudienceMedia"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AudienceMedia.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.clipRange = try reader["ClipRange"].readIfPresent(with: MediaTailorClientTypes.ClipRange.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.durationMillis = try reader["DurationMillis"].readIfPresent()
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.programName = try reader["ProgramName"].readIfPresent()
        value.scheduledStartTime = try reader["ScheduledStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension UpdateSourceLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSourceLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSourceLocationOutput()
        value.accessConfiguration = try reader["AccessConfiguration"].readIfPresent(with: MediaTailorClientTypes.AccessConfiguration.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultSegmentDeliveryConfiguration = try reader["DefaultSegmentDeliveryConfiguration"].readIfPresent(with: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.read(from:))
        value.httpConfiguration = try reader["HttpConfiguration"].readIfPresent(with: MediaTailorClientTypes.HttpConfiguration.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.segmentDeliveryConfigurations = try reader["SegmentDeliveryConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.SegmentDeliveryConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateVodSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVodSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVodSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

enum ConfigureLogsForChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfigureLogsForPlaybackConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLiveSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePrefetchScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProgramOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSourceLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVodSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLiveSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePlaybackConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePrefetchScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProgramOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSourceLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVodSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLiveSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProgramOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSourceLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVodSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlaybackConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPrefetchScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAlertsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLiveSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlaybackConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrefetchSchedulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSourceLocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVodSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutChannelPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPlaybackConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLiveSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProgramOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSourceLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVodSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MediaTailorClientTypes.SlateSource {

    static func write(value: MediaTailorClientTypes.SlateSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourceLocationName"].write(value.sourceLocationName)
        try writer["VodSourceName"].write(value.vodSourceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.SlateSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.SlateSource()
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.ResponseOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.ResponseOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.ResponseOutputItem()
        value.dashPlaylistSettings = try reader["DashPlaylistSettings"].readIfPresent(with: MediaTailorClientTypes.DashPlaylistSettings.read(from:))
        value.hlsPlaylistSettings = try reader["HlsPlaylistSettings"].readIfPresent(with: MediaTailorClientTypes.HlsPlaylistSettings.read(from:))
        value.manifestName = try reader["ManifestName"].readIfPresent() ?? ""
        value.playbackUrl = try reader["PlaybackUrl"].readIfPresent() ?? ""
        value.sourceGroup = try reader["SourceGroup"].readIfPresent() ?? ""
        return value
    }
}

extension MediaTailorClientTypes.HlsPlaylistSettings {

    static func write(value: MediaTailorClientTypes.HlsPlaylistSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdMarkupType"].writeList(value.adMarkupType, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaTailorClientTypes.AdMarkupType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ManifestWindowSeconds"].write(value.manifestWindowSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.HlsPlaylistSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.HlsPlaylistSettings()
        value.manifestWindowSeconds = try reader["ManifestWindowSeconds"].readIfPresent()
        value.adMarkupType = try reader["AdMarkupType"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaTailorClientTypes.AdMarkupType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.DashPlaylistSettings {

    static func write(value: MediaTailorClientTypes.DashPlaylistSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ManifestWindowSeconds"].write(value.manifestWindowSeconds)
        try writer["MinBufferTimeSeconds"].write(value.minBufferTimeSeconds)
        try writer["MinUpdatePeriodSeconds"].write(value.minUpdatePeriodSeconds)
        try writer["SuggestedPresentationDelaySeconds"].write(value.suggestedPresentationDelaySeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.DashPlaylistSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.DashPlaylistSettings()
        value.manifestWindowSeconds = try reader["ManifestWindowSeconds"].readIfPresent()
        value.minBufferTimeSeconds = try reader["MinBufferTimeSeconds"].readIfPresent()
        value.minUpdatePeriodSeconds = try reader["MinUpdatePeriodSeconds"].readIfPresent()
        value.suggestedPresentationDelaySeconds = try reader["SuggestedPresentationDelaySeconds"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.TimeShiftConfiguration {

    static func write(value: MediaTailorClientTypes.TimeShiftConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxTimeDelaySeconds"].write(value.maxTimeDelaySeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.TimeShiftConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.TimeShiftConfiguration()
        value.maxTimeDelaySeconds = try reader["MaxTimeDelaySeconds"].readIfPresent() ?? 0
        return value
    }
}

extension MediaTailorClientTypes.HttpPackageConfiguration {

    static func write(value: MediaTailorClientTypes.HttpPackageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Path"].write(value.path)
        try writer["SourceGroup"].write(value.sourceGroup)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.HttpPackageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.HttpPackageConfiguration()
        value.path = try reader["Path"].readIfPresent() ?? ""
        value.sourceGroup = try reader["SourceGroup"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaTailorClientTypes.PrefetchConsumption {

    static func write(value: MediaTailorClientTypes.PrefetchConsumption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailMatchingCriteria"].writeList(value.availMatchingCriteria, memberWritingClosure: MediaTailorClientTypes.AvailMatchingCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.PrefetchConsumption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.PrefetchConsumption()
        value.availMatchingCriteria = try reader["AvailMatchingCriteria"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AvailMatchingCriteria.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MediaTailorClientTypes.AvailMatchingCriteria {

    static func write(value: MediaTailorClientTypes.AvailMatchingCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicVariable"].write(value.dynamicVariable)
        try writer["Operator"].write(value.`operator`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AvailMatchingCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AvailMatchingCriteria()
        value.dynamicVariable = try reader["DynamicVariable"].readIfPresent() ?? ""
        value.`operator` = try reader["Operator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaTailorClientTypes.PrefetchRetrieval {

    static func write(value: MediaTailorClientTypes.PrefetchRetrieval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicVariables"].writeMap(value.dynamicVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.PrefetchRetrieval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.PrefetchRetrieval()
        value.dynamicVariables = try reader["DynamicVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension MediaTailorClientTypes.AdBreak {

    static func write(value: MediaTailorClientTypes.AdBreak?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdBreakMetadata"].writeList(value.adBreakMetadata, memberWritingClosure: MediaTailorClientTypes.KeyValuePair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MessageType"].write(value.messageType)
        try writer["OffsetMillis"].write(value.offsetMillis)
        try writer["Slate"].write(value.slate, with: MediaTailorClientTypes.SlateSource.write(value:to:))
        try writer["SpliceInsertMessage"].write(value.spliceInsertMessage, with: MediaTailorClientTypes.SpliceInsertMessage.write(value:to:))
        try writer["TimeSignalMessage"].write(value.timeSignalMessage, with: MediaTailorClientTypes.TimeSignalMessage.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AdBreak {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AdBreak()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.offsetMillis = try reader["OffsetMillis"].readIfPresent() ?? 0
        value.slate = try reader["Slate"].readIfPresent(with: MediaTailorClientTypes.SlateSource.read(from:))
        value.spliceInsertMessage = try reader["SpliceInsertMessage"].readIfPresent(with: MediaTailorClientTypes.SpliceInsertMessage.read(from:))
        value.timeSignalMessage = try reader["TimeSignalMessage"].readIfPresent(with: MediaTailorClientTypes.TimeSignalMessage.read(from:))
        value.adBreakMetadata = try reader["AdBreakMetadata"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.KeyValuePair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.KeyValuePair {

    static func write(value: MediaTailorClientTypes.KeyValuePair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.KeyValuePair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.KeyValuePair()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension MediaTailorClientTypes.TimeSignalMessage {

    static func write(value: MediaTailorClientTypes.TimeSignalMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SegmentationDescriptors"].writeList(value.segmentationDescriptors, memberWritingClosure: MediaTailorClientTypes.SegmentationDescriptor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.TimeSignalMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.TimeSignalMessage()
        value.segmentationDescriptors = try reader["SegmentationDescriptors"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.SegmentationDescriptor.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.SegmentationDescriptor {

    static func write(value: MediaTailorClientTypes.SegmentationDescriptor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SegmentNum"].write(value.segmentNum)
        try writer["SegmentationEventId"].write(value.segmentationEventId)
        try writer["SegmentationTypeId"].write(value.segmentationTypeId)
        try writer["SegmentationUpid"].write(value.segmentationUpid)
        try writer["SegmentationUpidType"].write(value.segmentationUpidType)
        try writer["SegmentsExpected"].write(value.segmentsExpected)
        try writer["SubSegmentNum"].write(value.subSegmentNum)
        try writer["SubSegmentsExpected"].write(value.subSegmentsExpected)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.SegmentationDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.SegmentationDescriptor()
        value.segmentationEventId = try reader["SegmentationEventId"].readIfPresent()
        value.segmentationUpidType = try reader["SegmentationUpidType"].readIfPresent()
        value.segmentationUpid = try reader["SegmentationUpid"].readIfPresent()
        value.segmentationTypeId = try reader["SegmentationTypeId"].readIfPresent()
        value.segmentNum = try reader["SegmentNum"].readIfPresent()
        value.segmentsExpected = try reader["SegmentsExpected"].readIfPresent()
        value.subSegmentNum = try reader["SubSegmentNum"].readIfPresent()
        value.subSegmentsExpected = try reader["SubSegmentsExpected"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.SpliceInsertMessage {

    static func write(value: MediaTailorClientTypes.SpliceInsertMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailNum"].write(value.availNum)
        try writer["AvailsExpected"].write(value.availsExpected)
        try writer["SpliceEventId"].write(value.spliceEventId)
        try writer["UniqueProgramId"].write(value.uniqueProgramId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.SpliceInsertMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.SpliceInsertMessage()
        value.availNum = try reader["AvailNum"].readIfPresent()
        value.availsExpected = try reader["AvailsExpected"].readIfPresent()
        value.spliceEventId = try reader["SpliceEventId"].readIfPresent()
        value.uniqueProgramId = try reader["UniqueProgramId"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.ClipRange {

    static func write(value: MediaTailorClientTypes.ClipRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndOffsetMillis"].write(value.endOffsetMillis)
        try writer["StartOffsetMillis"].write(value.startOffsetMillis)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.ClipRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.ClipRange()
        value.endOffsetMillis = try reader["EndOffsetMillis"].readIfPresent() ?? 0
        value.startOffsetMillis = try reader["StartOffsetMillis"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.AudienceMedia {

    static func write(value: MediaTailorClientTypes.AudienceMedia?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlternateMedia"].writeList(value.alternateMedia, memberWritingClosure: MediaTailorClientTypes.AlternateMedia.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Audience"].write(value.audience)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AudienceMedia {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AudienceMedia()
        value.audience = try reader["Audience"].readIfPresent()
        value.alternateMedia = try reader["AlternateMedia"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AlternateMedia.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.AlternateMedia {

    static func write(value: MediaTailorClientTypes.AlternateMedia?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdBreaks"].writeList(value.adBreaks, memberWritingClosure: MediaTailorClientTypes.AdBreak.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClipRange"].write(value.clipRange, with: MediaTailorClientTypes.ClipRange.write(value:to:))
        try writer["DurationMillis"].write(value.durationMillis)
        try writer["LiveSourceName"].write(value.liveSourceName)
        try writer["ScheduledStartTimeMillis"].write(value.scheduledStartTimeMillis)
        try writer["SourceLocationName"].write(value.sourceLocationName)
        try writer["VodSourceName"].write(value.vodSourceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AlternateMedia {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AlternateMedia()
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        value.clipRange = try reader["ClipRange"].readIfPresent(with: MediaTailorClientTypes.ClipRange.read(from:))
        value.scheduledStartTimeMillis = try reader["ScheduledStartTimeMillis"].readIfPresent()
        value.adBreaks = try reader["AdBreaks"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.AdBreak.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.durationMillis = try reader["DurationMillis"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.AccessConfiguration {

    static func write(value: MediaTailorClientTypes.AccessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessType"].write(value.accessType)
        try writer["SecretsManagerAccessTokenConfiguration"].write(value.secretsManagerAccessTokenConfiguration, with: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AccessConfiguration()
        value.accessType = try reader["AccessType"].readIfPresent()
        value.secretsManagerAccessTokenConfiguration = try reader["SecretsManagerAccessTokenConfiguration"].readIfPresent(with: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration.read(from:))
        return value
    }
}

extension MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration {

    static func write(value: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HeaderName"].write(value.headerName)
        try writer["SecretArn"].write(value.secretArn)
        try writer["SecretStringKey"].write(value.secretStringKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration()
        value.headerName = try reader["HeaderName"].readIfPresent()
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.secretStringKey = try reader["SecretStringKey"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration {

    static func write(value: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseUrl"].write(value.baseUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration()
        value.baseUrl = try reader["BaseUrl"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.HttpConfiguration {

    static func write(value: MediaTailorClientTypes.HttpConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseUrl"].write(value.baseUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.HttpConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.HttpConfiguration()
        value.baseUrl = try reader["BaseUrl"].readIfPresent() ?? ""
        return value
    }
}

extension MediaTailorClientTypes.SegmentDeliveryConfiguration {

    static func write(value: MediaTailorClientTypes.SegmentDeliveryConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseUrl"].write(value.baseUrl)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.SegmentDeliveryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.SegmentDeliveryConfiguration()
        value.baseUrl = try reader["BaseUrl"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.LogConfigurationForChannel {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.LogConfigurationForChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.LogConfigurationForChannel()
        value.logTypes = try reader["LogTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaTailorClientTypes.LogType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.AdBreakOpportunity {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AdBreakOpportunity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AdBreakOpportunity()
        value.offsetMillis = try reader["OffsetMillis"].readIfPresent() ?? 0
        return value
    }
}

extension MediaTailorClientTypes.ScheduleEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.ScheduleEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.ScheduleEntry()
        value.approximateDurationSeconds = try reader["ApproximateDurationSeconds"].readIfPresent()
        value.approximateStartTime = try reader["ApproximateStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.channelName = try reader["ChannelName"].readIfPresent() ?? ""
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent()
        value.programName = try reader["ProgramName"].readIfPresent() ?? ""
        value.scheduleAdBreaks = try reader["ScheduleAdBreaks"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.ScheduleAdBreak.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleEntryType = try reader["ScheduleEntryType"].readIfPresent()
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent() ?? ""
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        value.audiences = try reader["Audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.ScheduleAdBreak {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.ScheduleAdBreak {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.ScheduleAdBreak()
        value.approximateDurationSeconds = try reader["ApproximateDurationSeconds"].readIfPresent()
        value.approximateStartTime = try reader["ApproximateStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent()
        value.vodSourceName = try reader["VodSourceName"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.AvailSuppression {

    static func write(value: MediaTailorClientTypes.AvailSuppression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FillPolicy"].write(value.fillPolicy)
        try writer["Mode"].write(value.mode)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AvailSuppression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AvailSuppression()
        value.mode = try reader["Mode"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.fillPolicy = try reader["FillPolicy"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.Bumper {

    static func write(value: MediaTailorClientTypes.Bumper?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndUrl"].write(value.endUrl)
        try writer["StartUrl"].write(value.startUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.Bumper {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.Bumper()
        value.endUrl = try reader["EndUrl"].readIfPresent()
        value.startUrl = try reader["StartUrl"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.CdnConfiguration {

    static func write(value: MediaTailorClientTypes.CdnConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdSegmentUrlPrefix"].write(value.adSegmentUrlPrefix)
        try writer["ContentSegmentUrlPrefix"].write(value.contentSegmentUrlPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.CdnConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.CdnConfiguration()
        value.adSegmentUrlPrefix = try reader["AdSegmentUrlPrefix"].readIfPresent()
        value.contentSegmentUrlPrefix = try reader["ContentSegmentUrlPrefix"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.DashConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.DashConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.DashConfiguration()
        value.manifestEndpointPrefix = try reader["ManifestEndpointPrefix"].readIfPresent()
        value.mpdLocation = try reader["MpdLocation"].readIfPresent()
        value.originManifestType = try reader["OriginManifestType"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.HlsConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.HlsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.HlsConfiguration()
        value.manifestEndpointPrefix = try reader["ManifestEndpointPrefix"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.LivePreRollConfiguration {

    static func write(value: MediaTailorClientTypes.LivePreRollConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdDecisionServerUrl"].write(value.adDecisionServerUrl)
        try writer["MaxDurationSeconds"].write(value.maxDurationSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.LivePreRollConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.LivePreRollConfiguration()
        value.adDecisionServerUrl = try reader["AdDecisionServerUrl"].readIfPresent()
        value.maxDurationSeconds = try reader["MaxDurationSeconds"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.LogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.LogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.LogConfiguration()
        value.percentEnabled = try reader["PercentEnabled"].readIfPresent() ?? 0
        return value
    }
}

extension MediaTailorClientTypes.ManifestProcessingRules {

    static func write(value: MediaTailorClientTypes.ManifestProcessingRules?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdMarkerPassthrough"].write(value.adMarkerPassthrough, with: MediaTailorClientTypes.AdMarkerPassthrough.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.ManifestProcessingRules {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.ManifestProcessingRules()
        value.adMarkerPassthrough = try reader["AdMarkerPassthrough"].readIfPresent(with: MediaTailorClientTypes.AdMarkerPassthrough.read(from:))
        return value
    }
}

extension MediaTailorClientTypes.AdMarkerPassthrough {

    static func write(value: MediaTailorClientTypes.AdMarkerPassthrough?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.AdMarkerPassthrough {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.AdMarkerPassthrough()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension MediaTailorClientTypes.Alert {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.Alert {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.Alert()
        value.alertCode = try reader["AlertCode"].readIfPresent() ?? ""
        value.alertMessage = try reader["AlertMessage"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.relatedResourceArns = try reader["RelatedResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        value.category = try reader["Category"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.Channel {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.Channel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.Channel()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.channelName = try reader["ChannelName"].readIfPresent() ?? ""
        value.channelState = try reader["ChannelState"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fillerSlate = try reader["FillerSlate"].readIfPresent(with: MediaTailorClientTypes.SlateSource.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.ResponseOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.playbackMode = try reader["PlaybackMode"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tier = try reader["Tier"].readIfPresent() ?? ""
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: MediaTailorClientTypes.LogConfigurationForChannel.read(from:))
        value.audiences = try reader["Audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.LiveSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.LiveSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.LiveSource()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.liveSourceName = try reader["LiveSourceName"].readIfPresent() ?? ""
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.PlaybackConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.PlaybackConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.PlaybackConfiguration()
        value.adDecisionServerUrl = try reader["AdDecisionServerUrl"].readIfPresent()
        value.availSuppression = try reader["AvailSuppression"].readIfPresent(with: MediaTailorClientTypes.AvailSuppression.read(from:))
        value.bumper = try reader["Bumper"].readIfPresent(with: MediaTailorClientTypes.Bumper.read(from:))
        value.cdnConfiguration = try reader["CdnConfiguration"].readIfPresent(with: MediaTailorClientTypes.CdnConfiguration.read(from:))
        value.configurationAliases = try reader["ConfigurationAliases"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dashConfiguration = try reader["DashConfiguration"].readIfPresent(with: MediaTailorClientTypes.DashConfiguration.read(from:))
        value.hlsConfiguration = try reader["HlsConfiguration"].readIfPresent(with: MediaTailorClientTypes.HlsConfiguration.read(from:))
        value.insertionMode = try reader["InsertionMode"].readIfPresent() ?? .stitchedOnly
        value.livePreRollConfiguration = try reader["LivePreRollConfiguration"].readIfPresent(with: MediaTailorClientTypes.LivePreRollConfiguration.read(from:))
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: MediaTailorClientTypes.LogConfiguration.read(from:))
        value.manifestProcessingRules = try reader["ManifestProcessingRules"].readIfPresent(with: MediaTailorClientTypes.ManifestProcessingRules.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.personalizationThresholdSeconds = try reader["PersonalizationThresholdSeconds"].readIfPresent()
        value.playbackConfigurationArn = try reader["PlaybackConfigurationArn"].readIfPresent()
        value.playbackEndpointPrefix = try reader["PlaybackEndpointPrefix"].readIfPresent()
        value.sessionInitializationEndpointPrefix = try reader["SessionInitializationEndpointPrefix"].readIfPresent()
        value.slateAdUrl = try reader["SlateAdUrl"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.transcodeProfileName = try reader["TranscodeProfileName"].readIfPresent()
        value.videoContentSourceUrl = try reader["VideoContentSourceUrl"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.PrefetchSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.PrefetchSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.PrefetchSchedule()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.consumption = try reader["Consumption"].readIfPresent(with: MediaTailorClientTypes.PrefetchConsumption.read(from:))
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.playbackConfigurationName = try reader["PlaybackConfigurationName"].readIfPresent() ?? ""
        value.retrieval = try reader["Retrieval"].readIfPresent(with: MediaTailorClientTypes.PrefetchRetrieval.read(from:))
        value.streamId = try reader["StreamId"].readIfPresent()
        return value
    }
}

extension MediaTailorClientTypes.SourceLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.SourceLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.SourceLocation()
        value.accessConfiguration = try reader["AccessConfiguration"].readIfPresent(with: MediaTailorClientTypes.AccessConfiguration.read(from:))
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultSegmentDeliveryConfiguration = try reader["DefaultSegmentDeliveryConfiguration"].readIfPresent(with: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.read(from:))
        value.httpConfiguration = try reader["HttpConfiguration"].readIfPresent(with: MediaTailorClientTypes.HttpConfiguration.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.segmentDeliveryConfigurations = try reader["SegmentDeliveryConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.SegmentDeliveryConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MediaTailorClientTypes.VodSource {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaTailorClientTypes.VodSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaTailorClientTypes.VodSource()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.httpPackageConfigurations = try reader["HttpPackageConfigurations"].readListIfPresent(memberReadingClosure: MediaTailorClientTypes.HttpPackageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceLocationName = try reader["SourceLocationName"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vodSourceName = try reader["VodSourceName"].readIfPresent() ?? ""
        return value
    }
}

extension MediaTailorClientTypes.RequestOutputItem {

    static func write(value: MediaTailorClientTypes.RequestOutputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashPlaylistSettings"].write(value.dashPlaylistSettings, with: MediaTailorClientTypes.DashPlaylistSettings.write(value:to:))
        try writer["HlsPlaylistSettings"].write(value.hlsPlaylistSettings, with: MediaTailorClientTypes.HlsPlaylistSettings.write(value:to:))
        try writer["ManifestName"].write(value.manifestName)
        try writer["SourceGroup"].write(value.sourceGroup)
    }
}

extension MediaTailorClientTypes.ScheduleConfiguration {

    static func write(value: MediaTailorClientTypes.ScheduleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClipRange"].write(value.clipRange, with: MediaTailorClientTypes.ClipRange.write(value:to:))
        try writer["Transition"].write(value.transition, with: MediaTailorClientTypes.Transition.write(value:to:))
    }
}

extension MediaTailorClientTypes.Transition {

    static func write(value: MediaTailorClientTypes.Transition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationMillis"].write(value.durationMillis)
        try writer["RelativePosition"].write(value.relativePosition)
        try writer["RelativeProgram"].write(value.relativeProgram)
        try writer["ScheduledStartTimeMillis"].write(value.scheduledStartTimeMillis)
        try writer["Type"].write(value.type)
    }
}

extension MediaTailorClientTypes.DashConfigurationForPut {

    static func write(value: MediaTailorClientTypes.DashConfigurationForPut?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MpdLocation"].write(value.mpdLocation)
        try writer["OriginManifestType"].write(value.originManifestType)
    }
}

extension MediaTailorClientTypes.UpdateProgramScheduleConfiguration {

    static func write(value: MediaTailorClientTypes.UpdateProgramScheduleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClipRange"].write(value.clipRange, with: MediaTailorClientTypes.ClipRange.write(value:to:))
        try writer["Transition"].write(value.transition, with: MediaTailorClientTypes.UpdateProgramTransition.write(value:to:))
    }
}

extension MediaTailorClientTypes.UpdateProgramTransition {

    static func write(value: MediaTailorClientTypes.UpdateProgramTransition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationMillis"].write(value.durationMillis)
        try writer["ScheduledStartTimeMillis"].write(value.scheduledStartTimeMillis)
    }
}

public enum MediaTailorClientTypes {}
